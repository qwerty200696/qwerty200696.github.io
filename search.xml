<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[判断int是否为3的幂—— Leetcode(326)]]></title>
      <url>/2018/01/13/leetcode_326_power_of_3/</url>
      <content type="html"><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></p>
<blockquote>
<p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Follow up:<br>Could you do it without using any loop / recursion?</p>
</blockquote>
<a id="more"></a>
<p>一般的通用解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        while (n &gt;= 3 )&#123;</div><div class="line">            if(n % 3 != 0)</div><div class="line">                return false;</div><div class="line">            n /= 3;   </div><div class="line">        &#125;</div><div class="line">        return n&gt;0 &amp;&amp; n != 2;     </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述可以通过，但是题目说最好尝试一下非循环或者递归的解法。</p>
<p>我感觉此类方法就是有点取巧了。如，找出<code>int</code>范围内最大的3的倍数，所以任何3的倍数<code>n</code>都可以被其整除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        //方法2</div><div class="line">        const int maxint = 0x7fffffff;</div><div class="line">        //假设3^k 是int范围内最大的3的幂</div><div class="line">        int k = int(log(maxint) / log(3));</div><div class="line">        int max_power_3 = pow(3,k);</div><div class="line">        return n&gt;0 &amp;&amp; max_power_3 % n ==0;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>或者将上述代码压缩到一行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">3</span>,<span class="keyword">int</span>(<span class="built_in">log</span>(<span class="number">0x7fffffff</span>) / <span class="built_in">log</span>(<span class="number">3</span>)))) % n == <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>pow</code>函数在头文件<code>math.h</code>中。</p>
</blockquote>
<p>同类题：</p>
<ol>
<li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li>
<li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li>
<li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[判断int是否为4的幂—— Leetcode(342)]]></title>
      <url>/2018/01/13/leetcode_342_power_of_4/</url>
      <content type="html"><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></p>
<blockquote>
<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>Example:<br>Given num = 16, return true. Given num = 5, return false.</p>
<p>Follow up: Could you solve it without loops/recursion?</p>
</blockquote>
<p>判断一个数是不是4的幂。还是使用二进制。<br>在判断2的幂的基础上添加条件。<br>如：<code>16(10000)</code>是，<code>8(1000)</code>不是；可以与<code>0x55(01010101)</code>取并集即可。(即判断1的位数是不是在奇数位)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfFour(int n) &#123;</div><div class="line">        return n&gt;0 &amp;&amp; ((n &amp; (n-1)) == 0) &amp;&amp; (n &amp; 0x55555555);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>另一种思路的解法为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; ((n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>) &amp;&amp; (（(n<span class="number">-1</span>) %<span class="number">3</span> == <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>先直觉上检验一下，发现的确是这样：$4 -1 = 3,16 - 1 = 15, 64 -1 = 63$，都是3的倍数。因此$(4^n - 1) % 3 == 0$是成立的。</p>
<p>下面给出简短证明：<br>$$4^n -1 = 2^{2n}-1 = (2^n+1)(2^n-1)$$<br>我们知道：$2^n+1$、$2^n$与$2^n-1$是三个连续数，其中必有一个为3的倍数，而且$2^n$必然不是3的倍数，因此，$2^n+1$与$2^n-1$中必有一个为3的倍数。也就是$4^n -1$必为3的倍数。</p>
<p>同类题：</p>
<ol>
<li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li>
<li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li>
<li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[判断int是否为2的幂—— Leetcode(231)]]></title>
      <url>/2018/01/13/leetcode_231_power_of_2/</url>
      <content type="html"><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></p>
<p>Given an integer, write a function to determine if it is a power of two.</p>
<a id="more"></a>
<p>出错样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input: -16 Expected: false // 就是没有考虑负数。</div></pre></td></tr></table></figure></p>
<p>C++实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span>(n != <span class="number">2</span> &amp;&amp; n &gt; <span class="number">2</span>)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                n /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上述一个常规的做法：连续除。</p>
<p>此外，我们考虑到2的幂的二进制只有最高位为1，其余都为0，此时利用这个特点可以写出如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfTwo(int n) &#123;</div><div class="line">        if(n &lt;= 0)</div><div class="line">             return false;</div><div class="line">        return (n &amp;(n-1) )== 0;</div><div class="line">        //或者一句话表示，如下：</div><div class="line">        //return n&gt;0 &amp;&amp; (n &amp;(n-1) )== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>n &amp; (n-1)==0</code> 会被当作：<code>n &amp; ((n-1)==0)</code>，故需要加上括号写为：<code>(n &amp;(n-1) )== 0</code>。</p>
</blockquote>
<p>例如：8的二进制<code>1000</code>,7的二进制<code>0111</code>，取并集为0。</p>
<p>同类题：</p>
<ol>
<li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li>
<li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li>
<li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git入门使用指南]]></title>
      <url>/2018/01/13/Git_usage/</url>
      <content type="html"><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>下面是摘自官网的一段话：</p>
<blockquote>
<p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p>
</blockquote>
<p>简而言之，Git是一个优秀的分布式版本管理软件。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开Git官网：<a href="https://git-scm.com/" target="_blank" rel="external">git-scm.com</a>，下载并安装。<br>Debian或<code>Ubuntu Linux</code>，通过一条<code>sudo apt-get install git</code>就可以直接完成<code>Git</code>的安装。</p>
<p>安装完成后，windows打开<code>git-bash</code>，linux直接打开<code>terminal</code>。</p>
<h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>配置用户信息（和Github上一致）：用户名和邮箱地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name "qwerty200696"</div><div class="line">git config --global user.email "wang@126.com"</div></pre></td></tr></table></figure></p>
<p>如果之前已经配置好了，可以使用如下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config user.name</div><div class="line">git config user.email</div></pre></td></tr></table></figure>
<p>还可以配置颜色和行尾。不同平台的行尾是有显著区别的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git config --global core.autocrlf true</div><div class="line">git config --global core.autocrlf input</div><div class="line"></div><div class="line">git config --global color.ui auto</div></pre></td></tr></table></figure>
<p>其他配置：<br>配置的级别分为：<code>global</code> 、<code>local</code>与<code>system</code>三种级别，<code>local</code>会覆盖<code>global</code>。就像面向对象的继承那样，最近的是最有效的，也就是<code>local</code>。</p>
<h2 id="init-amp-add——开始与添加"><a href="#init-amp-add——开始与添加" class="headerlink" title="init&amp;add——开始与添加"></a>init&amp;add——开始与添加</h2><p>选择需要版本控制的文件夹，打开终端(linux)或者Git Bash(windows)。</p>
<p>初始化Git：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p>
<blockquote>
<p>最好的方法是在开始一个项目之前，通过<code>git init xxx</code>来新建一个项目目录<code>xxx</code>。git会自动创建该<code>xxx</code>目录。</p>
</blockquote>
<p>假设文件夹下存在需要版本管理的文件，使用如下命令查看是否已经被管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure>
<p>添加需要管理的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add 1.py # 某个具体的文件</div><div class="line">git add .  # 添加文件夹下所有的文件</div></pre></td></tr></table></figure></p>
<p>可以在目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件。</p>
<h2 id="commit——提交修改"><a href="#commit——提交修改" class="headerlink" title="commit——提交修改"></a>commit——提交修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;first commit&quot;</div></pre></td></tr></table></figure>
<p>修改内容之后，使用<code>commit</code>提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
<p><code>log</code>命令可以查看每次的更改。</p>
<p>目前都是在本地化的版本管理。</p>
<h2 id="diff——显示不同"><a href="#diff——显示不同" class="headerlink" title="diff——显示不同"></a>diff——显示不同</h2><p>现在假设你修改了一个文件，但是过去了一段时间后忘记修改在什么地方了，此时你需要“diff”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git diff  # 文件的最新改动</div><div class="line">git diff --staged  # 已经暂存的和最近历史的改动。</div><div class="line">git diff HEAD # HEAD提交历史中，最近一次的别名，最新的修改与最近历史的改动。跳过了暂存的修改，直接与最近一次提交的比较。</div><div class="line"></div><div class="line">git diff --color-words  # 只对修改的地方用不同颜色标记，而不是整行。</div><div class="line">git diff --word-diff # 对长行的小改动更加清晰明了。</div><div class="line">git diff --stat  # 极简输出，只输出改动的文件，阻止其他输出。</div></pre></td></tr></table></figure></p>
<h2 id="log——查看修改"><a href="#log——查看修改" class="headerlink" title="log——查看修改"></a>log——查看修改</h2><p>log是一个非常强大的明了，不仅可以查看提交的历史记录，而且是了解仓库的进展、提交的内容以及文件的好帮手。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">git log --oneline  # 更常用！</div><div class="line">git log --stat #可以查看修改的文件。</div><div class="line">git log --patch # 可以查看文件中具体的修改内容。</div><div class="line"></div><div class="line">git log --graph --all --decorate --oneline  # z展示每次提交的一行概括。</div></pre></td></tr></table></figure></p>
<h2 id="remove——删除文件"><a href="#remove——删除文件" class="headerlink" title="remove——删除文件"></a>remove——删除文件</h2><p>删除文件。两种方式，一种是<code>git rm</code>，一种是<code>git add</code></p>
<p><code>git rm</code> 用来删除一个文件；并且会自动暂存修改。</p>
<p>此外，如果用<code>rm</code>删除了一个文件，可以使用<code>git rm</code>再次暂存修改。</p>
<p>现实情况中，往往会有很多文件被删除了，不可能通过命令行一个个修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Git add -u .  # 注意，最后的dot不能省略哦，表示当前目录</div></pre></td></tr></table></figure></p>
<p>改命令会遍历文件夹，并且查找出所有删除的文件，并且暂存。</p>
<p>有时候只是想要从git中删除，但是本地文件不删除，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm --cached xxx_file</div></pre></td></tr></table></figure></p>
<p>你是真的想在所有历史记录中删除这个文件的记录吗？这是另一个主题中会讲。或者你是不想要某个文件被追踪，之后也是这样，那么可以使用<code>git ignore</code>文件，在之后也会介绍。</p>
<h2 id="move——移动文件"><a href="#move——移动文件" class="headerlink" title="move——移动文件"></a>move——移动文件</h2><p> 移动文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git mv xxx_file otherPath/xxx.file</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add -A .</div></pre></td></tr></table></figure>
<p>找出所有的移动过的文件。（包括修改之后移动的文件）</p>
<p>追踪移动过的文件的历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log -- path/file # 只会追踪到该目录下的历史，历史会终止在移动的时候。</div><div class="line"></div><div class="line">git log --stat -M --follow -- path/file # 跨目录追踪历史，文件在移动过程中也追踪。</div></pre></td></tr></table></figure></p>
<p>在移动文件之后，commit给我们一个数字来告诉我们文件在移动前后的相似度。Git提供的默认阈值是50%的相似度，超过50%，在移动前后就会继续追踪该文件。</p>
<h2 id="ignore——忽略文件"><a href="#ignore——忽略文件" class="headerlink" title="ignore——忽略文件"></a>ignore——忽略文件</h2><p>可以在目录/子目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件/文件夹。</p>
<p>只能对当前目录的文件/文件夹进行忽略。 可以使用匹配符，在当前目录/子目录都有效。</p>
<p><del>子目录中，需要路径优先级？？</del><br>也可以使用“！”反忽略某一个特定的文件。<br>注释行用“#”号开头。</p>
<p>查看忽略了的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git ls-files --others --ignored --exclude-standard  ## 查看忽略的文件</div><div class="line"></div><div class="line">git ls-files  --ignored --exclude-standard</div></pre></td></tr></table></figure></p>
<p><del>为什么我感觉不需要加上 <code>--others</code>也可以。而且第二个命令更靠谱。</del></p>
<p>以上述的第一个命令为主。<br>如果你感觉第一个命令不行的话，那是因为在某些文件先前已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。git清除本地缓存命令如下：【参考资料二】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m &apos;update .gitignore&apos;</div></pre></td></tr></table></figure></p>
<p>关于ignore规则的详细介绍，可参考<a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="external">这篇博文</a>，写得很详细。</p>
<h2 id="branch——开始新分支"><a href="#branch——开始新分支" class="headerlink" title="branch——开始新分支"></a>branch——开始新分支</h2><h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch newBranchName  ## 创键分支</div><div class="line">git branch -d existedBranchname  ## 删除分支，没有合并的话会出错</div><div class="line">git branch -D existedBranchname  ## 删除分支，强制删除</div></pre></td></tr></table></figure>
<h3 id="switch——切换分支"><a href="#switch——切换分支" class="headerlink" title="switch——切换分支"></a>switch——切换分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout existedBranchname</div></pre></td></tr></table></figure>
<h2 id="checkout的其他用法"><a href="#checkout的其他用法" class="headerlink" title="checkout的其他用法"></a>checkout的其他用法</h2><p>最主要的作用就是切换分支，上面已经讲过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">git status</div></pre></td></tr></table></figure></p>
<p>都可以查看目前处于那个分支上面。</p>
<p>撤销内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- filename.txt</div></pre></td></tr></table></figure></p>
<p>会清理掉最后一次commit的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b newBranchName</div></pre></td></tr></table></figure>
<p>一步到位，既创建了一个新的branch，也转移到了新的branch。</p>
<p>如果在使用<code>checkout</code>命令的时候，不小心将头指针分离了，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wangwlj@myUbuntu:~/文档/py_prog/py3_prog$ git branch -a</div><div class="line">* （头指针分离于 ee74fc7）</div><div class="line">  master</div><div class="line">  program</div></pre></td></tr></table></figure></p>
<p>当我们发现头指针游离于分支之外的时候，不要惊慌，再次<code>git checkout program</code>切换到已经存在的分支即可。</p>
<h2 id="merge——分支合并"><a href="#merge——分支合并" class="headerlink" title="merge——分支合并"></a>merge——分支合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master  ## 切换到主分支</div><div class="line">git merge branchNeedToMerge ## 将分支branchNeedToMerge的修改合并到master</div></pre></td></tr></table></figure>
<h3 id="merge冲突的解决"><a href="#merge冲突的解决" class="headerlink" title="merge冲突的解决"></a>merge冲突的解决</h3><p>merge冲突：两个文件都有变化，Git无法确定该怎么合并。该如何解决呢？</p>
<p>先用<code>git status</code>查看是哪个文件冲突 ，然后用编辑器打开，进行修改。</p>
<p>先查找<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>标志，表明是当前branch上的内容，直到<code>=======</code>标志结束。<br>在<code>=======</code>标志的下方，直到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchNeedToMerge</code>标志结束，是另一个分支的内容。</p>
<p>找到位置后，需要手动地解决冲突：编辑文件，删去冲突的标签，决定该删去或保留哪些内容，保存即可。最后重新add、commit提交。</p>
<h3 id="abort——放弃冲突"><a href="#abort——放弃冲突" class="headerlink" title="abort——放弃冲突"></a>abort——放弃冲突</h3><p>放弃这个冲突（不重要），从上次commit开始，并且清除暂存区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --abort</div></pre></td></tr></table></figure></p>
<h3 id="squash压缩"><a href="#squash压缩" class="headerlink" title="squash压缩"></a>squash压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git merge --squash branchNeedToMerge</div><div class="line">git commit -m &quot;some message&quot;</div></pre></td></tr></table></figure>
<p>意思是 你在分支<code>branchNeedToMerge</code>里面做了很多次commit修改，但是修改很零碎；在master分支里只想要一次commit就更新到<code>branchNeedToMerge</code>分支的进度。此时就可以使用<code>--squash</code>参数。</p>
<blockquote>
<p>判断是否使用<code>--squash</code>选项最根本的标准是，待合并分支上的历史是否有意义。</p>
</blockquote>
<p>关于<code>--squash</code> 参数的举例可参考<a href="http://blog.csdn.net/rockrockwu/article/details/33740711" target="_blank" rel="external">这篇文章</a>。</p>
<h3 id="d-删除分支"><a href="#d-删除分支" class="headerlink" title="-d 删除分支"></a>-d 删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d branchNeedToMerge</div></pre></td></tr></table></figure>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin &lt;server&gt;</div></pre></td></tr></table></figure>
<p><code>&lt;server&gt;</code>是远程服务器的地址、目的地的url。<br>如果输错了或者忘记了也不要紧，可以输入如下命令重新设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin &lt;new-server&gt;</div></pre></td></tr></table></figure></p>
<p>查看远程的地址有哪些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure></p>
<p>最后删除远端地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div></pre></td></tr></table></figure></p>
<h3 id="fetch-pull-push"><a href="#fetch-pull-push" class="headerlink" title="fetch/pull/push"></a>fetch/pull/push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git pull origin</div><div class="line">git push origin</div></pre></td></tr></table></figure>
<p>fetch:去github.com上面下载信息，放在远程追踪分支。，<br>pull：与fetch非常像，下载下来放到远程，并且合并到本地。<br>push：电脑上完成了工作，发送到github上面。</p>
<h2 id="fork-pull-requests"><a href="#fork-pull-requests" class="headerlink" title="fork/pull requests"></a>fork/pull requests</h2><p>fork:拷贝到自己的仓库进行修改，最好新建分支。<br>pull requests:对他人的代码进行修改，提意见</p>
<h2 id="reset——重置"><a href="#reset——重置" class="headerlink" title="reset——重置"></a>reset——重置</h2><p>reset有三个等级，默认的是<code>mixed</code>，除此之外还有<code>soft</code>与<code>hard</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~5  # 选择需要重置commit的次数</div><div class="line">git status</div><div class="line">git commit -m&quot;new message&quot;  # 重新提交</div></pre></td></tr></table></figure>
<p>reset在对仓库历史提交的处理上比较有用，当然也是一个危险的命令啦。</p>
<p>checkout可以做类似的事情，<code>checkout</code>更加关注的是一个目录或者文件级别的精度。也就是说，可以把某个文件拉回到几次提交之前的状态。</p>
<h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><p>包括<code>reset</code>做的那些不可恢复的操作，<code>reflog</code>都有记录。<br>但默认提供的是30天的保存时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure>
<p>也可以图形化查看历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitk --all `git reflog | cut c1-7`&amp;</div></pre></td></tr></table></figure></p>
<p><code>reflog</code>让我们有动力地去多做commit，commit了就有保障了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000" target="_blank" rel="external">忽略特殊文件</a></li>
<li><a href="https://www.cnblogs.com/zzcc/p/5695883.html" target="_blank" rel="external">Git中.gitignore文件不起作用的解决</a></li>
<li><a href="https://www.nowcoder.com/courses/2" target="_blank" rel="external">GitHub&amp;Git入门基础</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下必备软件及安装总结]]></title>
      <url>/2018/01/13/ubuntu_software_summary/</url>
      <content type="html"><![CDATA[<h2 id="安装ubuntu"><a href="#安装ubuntu" class="headerlink" title="安装ubuntu"></a>安装ubuntu</h2><p>本文以<code>Ubuntu 16.04</code>为例。</p>
<p>制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。</p>
<p>安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将<code>/home</code>分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。</p>
<a id="more"></a>
<p>给出几个参考链接：</p>
<ul>
<li><a href="http://blog.csdn.net/yaoyut/article/details/78003061" target="_blank" rel="external">用UltraISO制作Ubuntu16.04 U盘启动盘</a></li>
<li><a href="https://www.zhihu.com/question/19867618" target="_blank" rel="external">怎样安装 Windows 7 与 Linux 的双系统？</a><br>双系统是比较特殊的，双系统可以，单系统也没问题。</li>
</ul>
<h2 id="软件安装前的设置"><a href="#软件安装前的设置" class="headerlink" title="软件安装前的设置"></a>软件安装前的设置</h2><p>假设现在已经有了一个全新的<code>Ubuntu</code>系统，此时你需要先换源。</p>
<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>系统自带的源速度不快，因此考虑换成国内源。笔者采用的是阿里云的源，还是不错的。</p>
<ul>
<li><p><a href="http://blog.csdn.net/happywho250/article/details/52506321" target="_blank" rel="external">ubuntu16.04换源</a></p>
</li>
<li><p><a href="http://blog.csdn.net/u011557212/article/details/53233944" target="_blank" rel="external">Ubuntu16.04常用源</a></p>
</li>
</ul>
<h3 id="主文件夹下的中文目录改为英文目录"><a href="#主文件夹下的中文目录改为英文目录" class="headerlink" title="主文件夹下的中文目录改为英文目录"></a>主文件夹下的中文目录改为英文目录</h3><blockquote>
<p>可选项。主文件夹下的中文目录名其实也不错。</p>
</blockquote>
<p>Linux下使用命令行是很正常的事情，<code>cd ~/桌面</code> 需要切换输入法，可能会显得不那么流畅，因此，可以考虑将主文件夹下的中文目录设置为英文。</p>
<p>参考这篇文章：<br><a href="http://blog.csdn.net/l0605020112/article/details/20285239" target="_blank" rel="external">将Ubuntu主文件夹里的中文文件夹名称改成英文</a></p>
<p>我采用的是第一种方法。换了之后建议重启一下。</p>
<p>笔者不是一开始就改的，所以导致换目录名后出现了一系列问题。一开始就换会比较好。</p>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><h2 id="安装必备软件"><a href="#安装必备软件" class="headerlink" title="安装必备软件"></a>安装必备软件</h2><p>在对Ubuntu换源之后，就可以开始安装一些必备而的软件了。Ubuntu下软件的安装都不难，可以根据需求选择安装相应的软件。</p>
<h3 id="1-搜狗输入法"><a href="#1-搜狗输入法" class="headerlink" title="1. 搜狗输入法"></a>1. 搜狗输入法</h3><p>输入法必备，放在第一个吧。</p>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>官网下载linux版本的dev包：<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="external">pinyin.sogou.com/linux</a><br>进入下载目录，在终端执行安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> sudo dpkg  -i   sogoupinyin_2.2.0.0102_amd64.deb</div></pre></td></tr></table></figure></p>
<p>安装过程会出现 依赖关系问题（未安装成功，依赖库不全），不要担心，接着执行下面的命令就可以了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>sudo apt-get install -f</div></pre></td></tr></table></figure>
<p>等待完成后，搜狗拼音输入法就安装好了。</p>
<blockquote>
<p>上述两条命令都是常用命令，需要记住。</p>
</blockquote>
<h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p> 下面对输入法进行系统配置，具体流程如下：</p>
<ul>
<li>桌面右上角面板的<code>开关机的按钮</code>，选择<code>系统设置</code>；</li>
<li>进入系统设置后，点击<code>语言支持</code>，键盘输入方式系统中选择 <code>fcitx</code>；</li>
<li>注销系统用户，重新登陆进入桌面后看看，熟悉的搜狗输入法出现了吧。</li>
</ul>
<p>参考自：<a href="https://jingyan.baidu.com/article/a3aad71aa1abe7b1fa009641.html" target="_blank" rel="external">ubuntu安装配置搜狗拼音输入法</a></p>
<h3 id="2-网易云音乐"><a href="#2-网易云音乐" class="headerlink" title="2. 网易云音乐"></a>2. 网易云音乐</h3><p>网易云音乐，大家都知道的，无需过多介绍，虽然现在由于版权问题好多歌曲都下架了，不过<code>Linux</code>下的网易云做得非常好。</p>
<p>只需要简单地下载、安装即可。具体请参考：<a href="http://blog.csdn.net/u011557212/article/details/53234134" target="_blank" rel="external">ubuntu16.04安装网易云音乐</a></p>
<blockquote>
<p>别人写得很详细的教程，我就只放链接了。</p>
</blockquote>
<h3 id="3-chrome浏览器"><a href="#3-chrome浏览器" class="headerlink" title="3. chrome浏览器"></a>3. chrome浏览器</h3><p>Linux下谷歌浏览器是必备的。</p>
<p>安装谷歌浏览器，只需要三行代码：<br>打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /tmp</div></pre></td></tr></table></figure></p>
<p>对于谷歌Chrome32位版本，使用如下链接：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb</div></pre></td></tr></table></figure></p>
<p>对于64位版本可以使用如下链接下载：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</div></pre></td></tr></table></figure></p>
<p>下载完后，运行如下命令安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dpkg -i google-chrome*; sudo apt-get -f install</div></pre></td></tr></table></figure></p>
<p>然后，就可以去搜索使用了。<br>是不是很方便？</p>
<p>参考自：<a href="http://www.linuxidc.com/Linux/2013-10/91857.htm" target="_blank" rel="external">安装谷歌Chrome浏览器</a></p>
<h3 id="4-Guake-Terminal-optional"><a href="#4-Guake-Terminal-optional" class="headerlink" title="4. Guake Terminal (optional)"></a>4. Guake Terminal (optional)</h3><h4 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h4><p><code>Guake Terminal</code>顾名思义，是一个终端。功能只有一个, 按 <code>F12</code> 时从屏幕顶部 嗖! 地下来一个。</p>
<p>可到官网：<a href="http://guake-project.org/" target="_blank" rel="external">guake-project.org</a> 查看详细说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/Guake/guake.git</div><div class="line">$ cd guake</div><div class="line"></div><div class="line"># For Ubuntu user, we have a script that does all these steps for you. Use:</div><div class="line">$ ./dev.sh</div></pre></td></tr></table></figure>
<p>如果上述第三条命令出错的话，请尝试以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./dev.sh --install</div></pre></td></tr></table></figure></p>
<p>期间，会自动安装一些库，如<code>git</code>之类的。</p>
<h4 id="设置与自启动"><a href="#设置与自启动" class="headerlink" title="设置与自启动"></a>设置与自启动</h4><p>安装完成后，可以在终端输入<code>guake</code>查看效果，输入<code>guake --preferences</code>进行相关的配置。<br><code>guake</code>启动后，按下<code>F12</code>显示终端，再按<code>F12</code>消失。可以设置焦点失去时隐藏，这样就不用反复点<code>F12</code>了。</p>
<p>自启动设置：</p>
<p>点击最左上角的<code>Dash</code>图标(用于查找文件与程序的nage)，输入<code>启动</code>二字查看搜索结果，点击“启动应用程序”，按下图设置：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fneyjbeucgj20gn0daabi.jpg" alt=""></p>
<h3 id="5-思维导图xmind"><a href="#5-思维导图xmind" class="headerlink" title="5. 思维导图xmind"></a>5. 思维导图xmind</h3><p><code>xmind</code>和<code>MindManager</code>都是优秀的思维导图软件，linux下只有<code>xmind</code>。</p>
<p>具体的安装步骤：</p>
<p>1、去官网下载<a href="http://www.xmind.net/download/linux/" target="_blank" rel="external">http://www.xmind.net/download/linux/</a></p>
<p>2、下载完后解压，进入解压后目录，在命令行输入<code>sudo ./setup</code>，这个是用来安装软件相关的依赖；然后进入<code>xmind_amd64</code>（64位系统）或者<code>xmind_i386</code>(32位系统)</p>
<p>3、在目录中直接双击<code>XMind</code>文件，或者在命令行中输入 <code>sudo ./XMind</code>。这样XMind就可以直接运行。由于XMInd8的ubuntu版本是用JAVA来开发的，所以可以直接打开，无需安装。</p>
<p>参考自：<a href="http://blog.csdn.net/faryang/article/details/70238326" target="_blank" rel="external">ubuntu16.04安装xmind8</a></p>
<h3 id="6-pycharm"><a href="#6-pycharm" class="headerlink" title="6. pycharm"></a>6. pycharm</h3><p>需要使用Python的话可以考虑安装Pycharm。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>打开<a href="https://www.jetbrains.com/pycharm/download/#section=linux" target="_blank" rel="external">pycharm官网</a></p>
<p>下载linux版本的pycharm。</p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>打开刚才下载的目录。右击文件，点击提取到此处（这与Windows的解压是一个意思）</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>解压完成后，打开刚才解压好的文件夹，然后再打开bin目录。</p>
<p>在文件夹空白处右击，在此处打开终端然后输入：<code>sh ./pycharm.sh</code> 回车</p>
<p>接着就打开了pycharm。</p>
<p>如果你需要导入之前安装版本的设置的话，可以选择第一个选项；如果没有的话，默认不导入设置就可以了。</p>
<p>点击同意，然后激活<code>pycharm</code>就可以使用了。</p>
<p>详情可参考：<br><a href="https://jingyan.baidu.com/article/60ccbceb4e3b0e64cab19733.html" target="_blank" rel="external">Ubuntu系统安装PyCharm教程（详细图文）</a></p>
<p>另附：学生可以免费注册pycharm，学生版也可以使用专业版的pycharm，没有什么区别。</p>
<h3 id="7-WPS"><a href="#7-WPS" class="headerlink" title="7. WPS"></a>7. WPS</h3><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>进入WPS官网下载deb包：<a href="http://linux.wps.cn/" target="_blank" rel="external">http://linux.wps.cn/</a></p>
<p>安装，打开终端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 下载</div><div class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</div></pre></td></tr></table></figure>
<h4 id="解决打开WPS时出现的系统缺失字体问题"><a href="#解决打开WPS时出现的系统缺失字体问题" class="headerlink" title="解决打开WPS时出现的系统缺失字体问题"></a>解决打开WPS时出现的系统缺失字体问题</h4><p>下载wps_symbol_fonts.zip: <a href="https://pan.baidu.com/s/1eS6xIzo" target="_blank" rel="external">https://pan.baidu.com/s/1eS6xIzo</a></p>
<p>将<code>wps_symbol_fonts.zip</code>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd wps_symbol_fontsls</div></pre></td></tr></table></figure></p>
<p>将目录中所有文件复制到<code>/usr/share/fonts</code>下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</div></pre></td></tr></table></figure>
<p>重新打开WPS，问题解决。</p>
<h4 id="删除libreOffice-optional"><a href="#删除libreOffice-optional" class="headerlink" title="删除libreOffice (optional)"></a>删除libreOffice (optional)</h4><p>另外，安装完WPS后就没有必要保留<code>libreOffice</code></p>
<p>卸载<code>libreOffice</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove libreoffice-common</div></pre></td></tr></table></figure></p>
<p>顺便把Amazon链接删除了吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    sudo apt-get remove unity-webapps-common</div><div class="line">    sudo apt autoremove</div><div class="line">```       </div><div class="line">参考自：[Ubuntu16.04安装wps并解决系统缺失字体问题](https://www.cnblogs.com/liutongqing/p/6388160.html)</div><div class="line"></div><div class="line">### 8. 图片编辑工具GIMP</div><div class="line"></div><div class="line">`GIMP`虽然不能完全替代`PS`，但是也能弥补一下。系统默认源中已经包含了GIMP，不需要使用PPA这些。</div><div class="line"></div><div class="line">安装：</div></pre></td></tr></table></figure></p>
<pre><code>sudo apt-get install gimp
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">启动：</div><div class="line"></div><div class="line">通过Dash搜索`GIMP`即可。或者命令行输入GIMP也行。</div><div class="line"></div><div class="line">参考：</div><div class="line"></div><div class="line">- https://www.gimp.org/downloads/</div><div class="line">- https://www.cnblogs.com/EasonJim/p/7121885.html</div><div class="line"></div><div class="line"></div><div class="line">### 9. indicator-sysmonitor</div><div class="line"></div><div class="line">先看一下效果图：</div><div class="line">![1](http://ww1.sinaimg.cn/large/c38a0784ly1fndxu83315j20fr02zglt.jpg)</div><div class="line"></div><div class="line">图中的“CPU，温度，内存”部分就是该软件的作用了。</div><div class="line"></div><div class="line">想要安装可参考：[Ubuntu 16.04安装indicator-sysmonitor实现导航条显示上下行网速/CPU/内存使用率](http://www.cnblogs.com/EasonJim/p/7130171.html)</div><div class="line"></div><div class="line">### 10. 主题管理工具unity tweak tool</div><div class="line"></div><div class="line">主题管理工具`unity tweak tool`</div><div class="line"></div><div class="line">1,    添加源</div></pre></td></tr></table></figure>
<p>sudo add-apt-repository ppa:freyja-dev/unity-tweak-tool-daily<br>sudo apt-get update<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2,安装</div></pre></td></tr></table></figure></p>
<p>　　sudo apt-get install unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,卸载</div></pre></td></tr></table></figure></p>
<p>　　sudo apt-get remove unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">4,搜索`unity tweak tool`运行</div><div class="line"></div><div class="line">5,若出现以下问题，终端输入`sudo apt-get install unity-webapps-service `即可</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne74thxbkj20j006ojrk.jpg)</div><div class="line"></div><div class="line"></div><div class="line">### 11. docky</div><div class="line"></div><div class="line">经常使用Mac者的福音。实现效果如下图：</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne792nqnfj20jj032mzj.jpg)</div><div class="line"></div><div class="line">一句话安装：</div></pre></td></tr></table></figure></p>
<p>sudo apt install ducky<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用方法：</div><div class="line"></div><div class="line">- 删除图标：拖到回收站上面就可以。</div><div class="line">- 添加图标：打开程序的时候会自动加载到docky中，此时右键选择锁定。</div><div class="line"></div><div class="line">图标模糊：下载高清图标，替换掉。具体可查看知乎问题“Docky中程序的图标太模糊，如何替换Docky中程序的图标？”的[回答](https://www.zhihu.com/question/22892627/answer/64026877)。</div><div class="line"></div><div class="line">### 12. teamviewer</div><div class="line"></div><div class="line">`teamviewer`的作用：与其他主机互传文件或者控制远程主机。</div><div class="line"></div><div class="line">安装过程如下：</div><div class="line"></div><div class="line">1、下载安装程序(32位和64位Ubuntu通用)</div><div class="line">https://www.teamviewer.com/zhcn/download/linux/</div><div class="line"></div><div class="line">选择下载对应版本。</div><div class="line"></div><div class="line">2、在终端中执行如下命令进行安装</div></pre></td></tr></table></figure></p>
<pre><code>sudo dpkg -i teamviewer_i386.deb
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3、使用如下命令处理依赖问题</div></pre></td></tr></table></figure>
<pre><code>sudo apt-get install –f 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">参考链接：[Ubuntu 16中如何安装TeamViewer 12](http://blog.csdn.net/zuochao_2013/article/details/53671245)</div><div class="line"></div><div class="line">使用部分不难，简单易上手。可以注册一个`teamview`账号，还是很方便的。</div><div class="line"></div><div class="line"></div><div class="line">### 13. 截图工具shutter</div><div class="line"></div><div class="line">`shutter`安装可参考：[ubuntu 安装截图工具 Shutter，并设置快捷键 Ctrl+Alt+A](http://blog.csdn.net/hanshileiai/article/details/46843713)</div><div class="line"></div><div class="line">其实`ubuntu`有自带的截图工具，不支持修改文件而已。</div></pre></td></tr></table></figure>
<pre><code>printscreen -- 全屏
alt + printscreen -- 当前活动截图
shift + printscreen -- 自选矩形截图
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">自带的截图工具配合第八个软件GIMP一起使用，也还是不错的。</div><div class="line"></div><div class="line">### 14. Markdown编辑器 </div><div class="line"></div><div class="line">我选择的是[Moeditor](https://github.com/Moeditor/Moeditor)。</div><div class="line"></div><div class="line">类似的`markdown`编辑器还有：[Atom](https://atom.io/) (Github出品)，Vim+Markdown，[Remarkable - Linux](https://remarkableapp.github.io/linux.html) （据说有点小bug），[Haroopad - The Next Document processor based on Markdown](http://pad.haroopress.com/user.html) ，[typora.io](https://www.typora.io/#linux) ， SublimeText3+插件，[StackEdit](https://stackedit.io/)  (网页版)，[小书匠markdown编辑器](http://markdown.xiaoshujiang.com/) ，马克飞象，VS Code，reText等等。</div><div class="line"></div><div class="line"></div><div class="line">`Moeditor`下载地址：https://github.com/Moeditor/Moeditor/releases</div><div class="line"></div><div class="line">安装： `sudo dpkg -i xxxx.deb`</div><div class="line"></div><div class="line">使用： 简单易上手。简洁。右上角分别为：最小化和全屏。菜单在左下角（新建，保存，另存为之类的）和右下角（切换编辑模式）。</div><div class="line"></div><div class="line">### 15. shadowsocks</div><div class="line"></div><div class="line">算是必备的吧。科研(?)利器。</div><div class="line">#### 安装软件</div><div class="line"></div><div class="line">ubuntu16.04 直接一句话安装：</div></pre></td></tr></table></figure>
<p>sudo apt install shadowsocks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">提示需要安装一些依赖库，选择`yes`即可。</div><div class="line"></div><div class="line">我们可以在`/home/wangwlj/` 下新建个文件`shadowsocks.json`  (`wangwlj`是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：</div></pre></td></tr></table></figure></p>
<p>{<br>    “server”:”11.22.33.44”,<br>    “server_port”:50003,<br>    “local_port”:1080,<br>    “password”:”123456”,<br>    “timeout”:600,<br>    “method”:”aes-256-cfb”<br>}</p>
<p>上面的各项参数含义如下：<br>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样<br>```</p>
<p>确定上面的配置文件没有问题，然后我们就可以在终端输入<code>sslocal -c /home/wangwlj/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p>
<h4 id="chrome插件SwithyOmega配置"><a href="#chrome插件SwithyOmega配置" class="headerlink" title="chrome插件SwithyOmega配置"></a>chrome插件SwithyOmega配置</h4><p>这里就不详写了，看这篇，写的很详细：<a href="http://www.sundabao.com/ubuntu%E4%BD%BF%E7%94%A8shadowsocks/" target="_blank" rel="external">ubuntu使用shadowsocks</a></p>
<p>还是简要附上几点吧。</p>
<p>新建一个模式，代理服务器，代理协议<code>SOCKS5</code>，代理服务器<code>127.0.0.1</code>，端口<code>1080</code></p>
<p><code>auto switch</code>中，上述模式对应的是：(按照规则列表匹配请求)使用shadowsocks访问的规则列表：<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a><br>，其余情况为直接访问。</p>
<blockquote>
<p>PS：windows下的chrome插件SwithyOmega的配置与Ubuntu一样。</p>
</blockquote>
<h3 id="Updating-1"><a href="#Updating-1" class="headerlink" title="Updating"></a>Updating</h3><p>将在个人博客中持续更新……</p>
<p>为了查找安装方便，所有参考链接均在对应位置处，就不放在最后了。</p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法导论详解(6) 第七章快速排序]]></title>
      <url>/2018/01/11/algorithm_tutorial_charpter_7/</url>
      <content type="html"><![CDATA[<h2 id="快速排序简介"><a href="#快速排序简介" class="headerlink" title="快速排序简介"></a>快速排序简介</h2><p>快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子很小，快排可以说是最快的排序算法，并非浪得虚名。另外它还是原址排序。</p>
<p>快速排序是基于分治模式的：</p>
<ul>
<li>分解：数组A【p..r】被划分成两个（可能空）子数组A【p..q-1】和A【q+1..r】，使得A【p..q-1】中的每个元素都小于等于A(q)，而且，小于等于A【q+1..r】中的元素。计算下标q也是划分过程中的一部分。</li>
<li>解决：通过递归调用快速排序，对子数组A【p..q-1】和A【q+1..r】排序。</li>
<li>合并：因为两个子数组是原址排序的，将它们的合并不需要操作：整个数组A【p..r】已排序。</li>
</ul>
<p>快排的伪码：<br><img src="https://images2.imgbox.com/e6/39/ffgJfqit_o.jpg" alt=""></p>
<p>其中对数组的划分：<code>Partition</code>是快排算法的关键，，它对子数组A【p..r】进行原址重排）。<br><img src="https://images2.imgbox.com/7e/a5/T2zKB1UV_o.jpg" alt=""></p>
<h2 id="快速排序Python实现"><a href="#快速排序Python实现" class="headerlink" title="快速排序Python实现"></a>快速排序Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = PARTITION(A, p, r)</div><div class="line">        QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure>
<h2 id="快速排序性能分析"><a href="#快速排序性能分析" class="headerlink" title="快速排序性能分析"></a>快速排序性能分析</h2><p>当数据量很小的时候，大概就十来个元素的小型序列，快排的优势并不明显，甚至比插入排序慢。但是一旦数据多，它的优势就充分发挥出来了。</p>
<p>举一个例子，<code>C++ STL</code> 中的<code>sort</code>函数，就充分发挥了快排的优势，并且取长补短，在数据量大时采用<code>QuickSort</code>，分段递归排序。一旦分段后的数据量小于某个门槛，为避免<code>QuickSort</code>递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，还会改用<code>HeapSort</code>(堆排序，第六章刚讲)。所以说，C++的“混合兵种”sort的性能肯定会比C的qsort好。</p>
<p>快排的运行时间与Partition的划分有关：</p>
<ul>
<li><strong>最坏情况</strong>是输入的数组已经完全排好序，那么每次划分的左、右两个区域分别为n-1和0，效率为$O( n^2 )$.</li>
<li>而对于其他<strong>常数比例划分</strong>，哪怕是左右按9:1的比例划分，效果都是和在正中间划分一样快的（算法导论上有详细分析）</li>
<li>即，<strong>任何一种按照常数比例进行划分，总运行时间都是$\text{O}(n \text{lg} n)$</strong>。</li>
</ul>
<h2 id="快速排序的随机化版本"><a href="#快速排序的随机化版本" class="headerlink" title="快速排序的随机化版本"></a>快速排序的随机化版本</h2><p>随机抽样(random sampling):从$A[p..r]$中随机选一个元素作为主元，而不是始终采用$A[r]$作为主元。</p>
<p>随机化的快排的伪码如下：</p>
<p><img src="https://images2.imgbox.com/53/ea/JY82TS9f_o.jpg" alt="快速排序的随机化版本"></p>
<p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    rand_i = random.random()</div><div class="line">    <span class="comment"># print(round(a *(r - p)) + p)</span></div><div class="line">    rand_i = round(rand_i * (r - p) + p)  <span class="comment"># 区间的计算需要注意，否则不对</span></div><div class="line">    A[rand_i], A[r] = A[r], A[rand_i]</div><div class="line">    <span class="keyword">return</span> PARTITION(A, p, r)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = RANDOMIZED_PARTITION(A, p, r)</div><div class="line">        RANDOMIZED_QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        RANDOMIZED_QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    RANDOMIZED_QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>算法导论 中文 第三版</li>
<li><a href="http://blog.csdn.net/shuangde800/article/details/7599509" target="_blank" rel="external">【算法导论】排序 （三）：快速排序 深入分析</a></li>
<li><a href="http://www.runoob.com/python/func-number-random.html" target="_blank" rel="external">Python random() 函数</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法导论 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> quicksort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法导论详解(5) 第六章堆排序]]></title>
      <url>/2018/01/09/algorithm_tutorial_charpter_6/</url>
      <content type="html"><![CDATA[<p>在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p>
<a id="more"></a>
<p>空间原址性(in place)：仅有常数个元素需要在排序过程中存储在数组之外。</p>
<h2 id="堆-6-1-P84"><a href="#堆-6-1-P84" class="headerlink" title="堆(6.1, P84)"></a>堆(6.1, P84)</h2><p>堆，也叫 二叉堆，是一个数组，可以看作近似的完全二叉树，树的每个节点对应数组一个元素。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p>
<p>表示堆的数组<code>A</code>包括两个属性：<code>A.length</code>给出数组元素的个数；<code>A.heap-size</code>给出有多少个元素存储在该数组中。即heap-size是数组的有效元素。</p>
<p>给定下标<code>i</code>，很容易计算其父节点、左节点和右节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>这三个函数通常以宏或者内联函数的方式实现。</p>
</blockquote>
<p>二叉堆分为两种形式：最大堆和最小堆。<br>最大堆满足：A[PARENT(i)] ≥ A[i] ，即：某个节点的值最多与其父节点一样大；最小堆满足：A[PARENT(i)] ≤ A[i]。</p>
<p>堆排序算法采用的是最大堆。最小堆通常用于构造优先队列。</p>
<p>堆的高度为：$Θ(lgn)$</p>
<h2 id="维持堆的性质（6-2，P86）"><a href="#维持堆的性质（6-2，P86）" class="headerlink" title="维持堆的性质（6.2，P86）"></a>维持堆的性质（6.2，P86）</h2><p><code>MAX-HEAPIFY</code>：输入为一个数组A和一个下标i，A[i]有可能小于其孩子，通过让A[i]在数组中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质。</p>
<p>该函数伪码表示为：<br><img src="https://images2.imgbox.com/54/2c/3rWF8zSL_o.png" alt="MAX-HEAPIFY伪码"></p>
<p>算法图示：<br><img src="https://images2.imgbox.com/71/85/6tJrJVIS_o.png" alt=""></p>
<p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= len(A) <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= len(A) <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p>
<p>每个孩子的子树最多为2n/3（不太理解这句话？？）。<br>所以，在最差情况下（最底层恰好半满）运行时间为：<br>$$T(n) = T(2n/3)+ \Theta(1)$$<br>上述递归式的解为：$T(n) = \text{O} (\text{lg}n)$</p>
<h2 id="建堆-6-3-P87"><a href="#建堆-6-3-P87" class="headerlink" title="建堆(6.3, P87)"></a>建堆(6.3, P87)</h2><p>子数组元素$A[ (\lfloor n/2\rfloor +1),\cdots,n]$是树中的所有叶节点。<br><code>BUILD_MAX_HEAP</code>从非叶节点开始一直循环到根节点。</p>
<p><img src="https://images2.imgbox.com/02/43/BH6sysvA_o.png" alt=""></p>
<p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i)</div></pre></td></tr></table></figure></p>
<p><code>BUILD_MAX_HEAP</code> 的时间复杂度为$T(n) = \text{O}(n)$</p>
<h2 id="堆排序算法-6-4，P89"><a href="#堆排序算法-6-4，P89" class="headerlink" title="堆排序算法(6.4，P89)"></a>堆排序算法(6.4，P89)</h2><p>伪代码：<br><img src="https://images2.imgbox.com/5d/94/xcT4QVgb_o.png" alt=""></p>
<p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div></pre></td></tr></table></figure></p>
<p><code>HEAPSORT</code>过程的时间复杂度为：$\text{O}(n\text{lg}n)$，因为<code>BUILD_MAX_HEAP</code>的时间复杂度为$\text{O}(n)$，n-1次调用<code>MAX_HEAPIFY</code>，每次时间为$\text{O}(\text{lg}n)$。</p>
<h2 id="堆排序的Python完整实现"><a href="#堆排序的Python完整实现" class="headerlink" title="堆排序的Python完整实现"></a>堆排序的Python完整实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i, heap_size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># A = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]</span></div><div class="line">    <span class="comment"># MAX_HEAPIFY(A, 2)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    <span class="comment"># A = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]</span></div><div class="line">    <span class="comment"># BUILD_MAX_HEAP(A)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    A = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</div><div class="line">    HEAPSORT(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure>
<h2 id="优先队列-6-5，P90"><a href="#优先队列-6-5，P90" class="headerlink" title="优先队列(6.5，P90)"></a>优先队列(6.5，P90)</h2><p>优先队列：是一种用来维护由一组元素构成的集合S的数据结果，其中的每个元素都有一个相关的值，称为关键字。优先队列也有两种形式：最大优先队列和最小优先队列。</p>
<p>最大优先队列的应用：共享计算机系统的作业调度。<br>最小优先队列被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生事件作为关键词。</p>
<p>优先队列可以用堆来实现。优先队列的元素对应应用程序的对象，堆中每个元素存储对象的句柄(handle)。</p>
<p>最大优先队列支持：</p>
<ul>
<li>对最大优先队列进行插入，<code>MaxHeapInsert</code>；</li>
<li>返回最大优先队列的最大值，<code>HeapMax</code>；</li>
<li>去掉最大值并且返回该值，<code>HeapExtractMax</code>；</li>
<li>将第x个元素的值改为k，其中k&gt;=x的原来的值，<code>HeapIncreaseKey</code>；</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div></pre></td></tr></table></figure>
<p><code>HeapExtractMax</code>的操作复杂度为$\text{O}(\text{lg}n)$（也就是<code>MAX_HEAPIFY</code>的复杂度）。</p>
<h2 id="最大优先队列的Python完整实现："><a href="#最大优先队列的Python完整实现：" class="headerlink" title="最大优先队列的Python完整实现："></a>最大优先队列的Python完整实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, heap_size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= heap_size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= heap_size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, heap_size)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_INCREASE_KEY</span><span class="params">(A, i, key)</span>:</span></div><div class="line">    <span class="keyword">if</span> key &lt; A[i - <span class="number">1</span>]:</div><div class="line">        print(<span class="string">"ERROR!! New key is smaller than current key!!!"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    A[i - <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> A[int(PARENT(i) - <span class="number">1</span>)] &lt; A[int(i - <span class="number">1</span>)]:</div><div class="line">        A[int(PARENT(i) - <span class="number">1</span>)], A[int(i - <span class="number">1</span>)] = A[int(i - <span class="number">1</span>)], A[int(PARENT(i) - <span class="number">1</span>)]</div><div class="line">        i = PARENT(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAP_INSERT</span><span class="params">(A, key)</span>:</span></div><div class="line">    MAX_INT = <span class="number">0x7fffffff</span></div><div class="line">    heap_size = len(A) + <span class="number">1</span></div><div class="line">    A.append(- MAX_INT)  <span class="comment"># 尾部追加元素</span></div><div class="line">    HEAP_INCREASE_KEY(A, heap_size, key)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line">    MAX_HEAP_INSERT(A, <span class="number">9</span>)  <span class="comment"># 调用的数值都是从1开始。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure>
<p>算法基本思想：在末尾新插入一个元素，按照最大堆的要求排列好就行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>算法导论 中文 第三版</li>
<li><a href="http://blog.csdn.net/u010183397/article/details/46882099" target="_blank" rel="external">算法导论 第六章：堆排序</a></li>
<li><a href="http://blog.csdn.net/xjm199/article/details/18039023" target="_blank" rel="external">最大优先队列–【算法导论】</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法导论 </tag>
            
            <tag> 堆排序 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动手实现atoi函数—— Leetcode(8)]]></title>
      <url>/2018/01/09/leetcode_8/</url>
      <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/string-to-integer-atoi/description/" target="_blank" rel="external">8. String to Integer (atoi)</a></p>
<p>Implement atoi to convert a string to an integer.</p>
<p><strong>Hint</strong>: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<a id="more"></a>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现将<code>string</code>转化为<code>int</code>的<code>atoi</code>函数。这题需要充分考虑各种不规范输入的情况，主要有以下几种情况：</p>
<ol>
<li>忽略前面的所有空格直到非空格出现。从该字符开始，有可能是正负号，然后紧跟着一系列数字。</li>
<li>在数字的尾部有可能有一些无关的附加字符，也需要忽略它们。</li>
<li>如果第一个非空格字符不是有效数（即不是+-或者数字），则返回0。</li>
<li>如果string为空，或者仅有空格，则返回0。</li>
<li>如果最终结果超过int的范围，则返回int的最大/最小值。</li>
</ol>
<p>提供几个测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Input:&quot;2147483648&quot;     Expected:2147483647  //溢出的情况</div><div class="line">//Input:&quot;+&quot;              Expected:0 //不合法的情况 </div><div class="line">//Input:&quot;+-2&quot;            Expected:0 //不合法的情况 </div><div class="line">// Input: &quot;  123&quot; //有空格的情况</div><div class="line">// Input:&quot;-123&quot;   //有负数的情况</div><div class="line">// Input:&quot;+123&quot;   //有+号的情况</div></pre></td></tr></table></figure></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>先给出我自己折腾的一个解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = <span class="number">0x7fffffff</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MIN = <span class="number">0x80000000</span>;</div><div class="line">    <span class="keyword">int</span> len = str.size();</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(str[index] == <span class="string">' '</span> &amp;&amp; index &lt; len)&#123;</div><div class="line">        index ++; <span class="comment">// 跳过空格</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>; <span class="comment">//符号位</span></div><div class="line">    <span class="keyword">long</span> l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt; len; ++i)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i+<span class="number">1</span>] &amp;&amp; str[i+<span class="number">1</span>] &lt;= <span class="string">'9'</span>)</div><div class="line">                sign = (str[i] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            l = l * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>); <span class="comment">// 字符0对应的10进制为48，可以直接减去48</span></div><div class="line">            <span class="keyword">if</span>(l * sign &gt; INT_MAX)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MAX;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l * sign &lt; INT_MIN)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MIN;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l  * sign;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要思路就是：从左向右，先忽略空格；然后空格之后第一位有三种可能：</p>
<ul>
<li>如果是“+-”号，则第二位必须是数字才记上正负号，否则返回0；</li>
<li>如果是数字，直到遇到非数字结束；</li>
<li>如果不是上述情况，则返回0。</li>
</ul>
<p>这边再给出一个<a href="https://leetcode.com/problems/string-to-integer-atoi/discuss/4642" target="_blank" rel="external">简洁的写法</a>，具体思路类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> indicator = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=str.size();)</div><div class="line">    &#123;</div><div class="line">        i = str.find_first_not_of(<span class="string">' '</span>);</div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            indicator = (str[i++] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            result = result*<span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</div><div class="line">            <span class="keyword">if</span>(result*indicator &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</div><div class="line">            <span class="keyword">if</span>(result*indicator &lt;= INT_MIN) <span class="keyword">return</span> INT_MIN;                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result*indicator;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：原先<code>for(int i = 0; i&lt;=str.size();)</code>中并不包含等号，会导致空串时无返回值的错误。因此加上等于号。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> atoi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客彻底解决置顶问题]]></title>
      <url>/2018/01/09/blog_pin_post/</url>
      <content type="html"><![CDATA[<p><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""><br><a id="more"></a></p>
<h2 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h2><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">这篇文章</a>。</p>
<p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="external">仓库</a>，可以直接用以下命令安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> npm uninstall hexo-generator-index --save</div><div class="line"><span class="meta">$</span> npm install hexo-generator-index-pin-top --save</div></pre></td></tr></table></figure>
<p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">title:</span> <span class="string">hexo+GitHub博客搭建实战</span></div><div class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-09</span><span class="bullet">-08</span> <span class="number">12</span><span class="string">:00:25</span></div><div class="line"><span class="attr">categories:</span> <span class="string">博客搭建系列</span></div><div class="line"><span class="attr">top:</span> <span class="literal">true</span></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure>
<p>到目前为止，置顶功能已经可以实现了。所有相关博文到这边就结束了。</p>
<p>不过置顶的文章显示在最上面之后，如果没有明确的置顶标志，是不是感觉有点怪怪的呢？</p>
<h2 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h2><p>打开：<code>/blog/themes/next/layout/_macro</code> 目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% if post.top %&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-thumb-tack"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<p>效果展示：<br><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">解决Hexo博客文章置顶问题</a></li>
<li><a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决Hexo置顶问题</a></li>
<li><a href="http://jinfang.life/posts/e0bb97e1/" target="_blank" rel="external">Hexo主题的数据封装，样式渲染和扩展实例</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 置顶 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法导论详解(3) 第四章分治策略]]></title>
      <url>/2018/01/08/algorithm_tutorial_chapter_4/</url>
      <content type="html"><![CDATA[<p>本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法，最后介绍了主方法。</p>
<a id="more"></a>
<h2 id="分治策略简介"><a href="#分治策略简介" class="headerlink" title="分治策略简介"></a>分治策略简介</h2><p>分治策略在每层递归时都有三个步骤：</p>
<ul>
<li>分解原问题为若干子问题；子问题的形式与原问题一样，只是规模更小。</li>
<li>解决这些子问题，递归地求解各子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>
<li>合并这些子问题的解成原问题的解。</li>
</ul>
<p>递归情况(recursive case)<br>基本情况(base case)：子问题足够小的时候，递归已经“触底”时。</p>
<p>递归式：我们用递归式描述了MERGE-SORT过程的最坏情况运行时间$T(n)$：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+f(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>$$<br>求解递归式的方法：代入法（猜测）；递归树法；主方法。本书使用主方法。</p>
<p>主方法可求解形如下面公式的递归式的界：<br>$$T(n) = aT(n/b)+f(n)$$<br>其中，$a\geqslant 1,b&gt;1,f(n)$是一个给定的函数。</p>
<p>递归式的技术细节</p>
<ul>
<li>忽略递归式声明和求解的一些细节，如MERGE-SORT的最坏情况运行时间准确的递归式为：</li>
</ul>
<p>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> T(\lceil n/2\rceil )+T(\lfloor n/2\rfloor )+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>$$</p>
<ul>
<li>边界条件是我们通常忽略的细节。</li>
<li>当声明、求解递归式时，我们常常忽略向下取整、向上取整及边界条件。</li>
</ul>
<p>本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法。</p>
<h2 id="最大子数组问题-4-1，P38"><a href="#最大子数组问题-4-1，P38" class="headerlink" title="最大子数组问题(4.1，P38)"></a>最大子数组问题(4.1，P38)</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>买股票（低价买入，高价卖出）。给定一段时间，选取最大收益。</p>
<h3 id="问题变换"><a href="#问题变换" class="headerlink" title="问题变换"></a>问题变换</h3><p>不关注每天的价格，而是关注每日价格变化。<br>那么问题就转化为寻求价格变化数组A的最大非空连续子数组。<br>称这样的连续子数组为<strong>最大子数组</strong>。</p>
<h3 id="使用分治策略的求解方法"><a href="#使用分治策略的求解方法" class="headerlink" title="使用分治策略的求解方法"></a>使用分治策略的求解方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># MAX = 1 &lt;&lt; 31</span></div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(A, low, mid, high)</span>:</span></div><div class="line">    max_left = mid</div><div class="line">    max_right = mid</div><div class="line">    left_sum = <span class="number">0</span>  <span class="comment"># original version init with -max, now is zero,because minimum is zero</span></div><div class="line">    all_sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid - <span class="number">1</span>, low - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 左边不经过mid</span></div><div class="line">        all_sum += A[i]</div><div class="line">        <span class="keyword">if</span> all_sum &gt; left_sum:</div><div class="line">            left_sum = all_sum</div><div class="line">            max_left = i</div><div class="line">    right_sum = A[mid]  <span class="comment"># original version init with -max, now is A[mid],because A[mid] must be included.</span></div><div class="line">    all_sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid, high + <span class="number">1</span>):</div><div class="line">        all_sum += A[i]</div><div class="line">        <span class="keyword">if</span> all_sum &gt; right_sum:</div><div class="line">            right_sum = all_sum</div><div class="line">            max_right = i</div><div class="line">    <span class="comment"># print([low, mid, high], [max_left, max_right, left_sum + right_sum])</span></div><div class="line">    <span class="keyword">return</span> [max_left, max_right, left_sum + right_sum]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A, low, high)</span>:</span></div><div class="line">    <span class="keyword">if</span> high == low:</div><div class="line">        <span class="keyword">return</span> [low, high, A[low]]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        mid = math.floor((low + high) / <span class="number">2</span>)</div><div class="line">        left_low, left_high, left_sum = find_maximum_subarray(A, low, mid)</div><div class="line">        right_low, right_high, right_sum = find_maximum_subarray(A, mid + <span class="number">1</span>, high)</div><div class="line">        cross_low, cross_high, cross_sum = find_max_crossing_subarray(A, low, mid, high)</div><div class="line">        <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</div><div class="line">            <span class="keyword">return</span> [left_low, left_high, left_sum]</div><div class="line">        <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</div><div class="line">            <span class="keyword">return</span> [right_low, right_high, right_sum]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> [cross_low, cross_high, cross_sum]</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">1</span>, <span class="number">-3</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">-5</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">9</span>]</div><div class="line">    <span class="comment"># A = [1, -3, 7, -5, -4, -1, -9, -3, 1, -3, -5, -9]</span></div><div class="line">    <span class="comment"># print(find_max_crossing_subarray(A, 0, 6, len(A) - 1))</span></div><div class="line">    print(find_maximum_subarray(A, <span class="number">0</span>, len(A) - <span class="number">1</span>))</div></pre></td></tr></table></figure>
<h3 id="分治算法的分析"><a href="#分治算法的分析" class="headerlink" title="分治算法的分析"></a>分治算法的分析</h3><p>假设问题规模为2的幂，这样所有问题的规模都是整数。</p>
<p>在<code>find_maximum_subarray</code>函数中，需要求解两个子问题——左数组和右数组(分别为5/6行)，每个子问题的运行时间为$T(n/2)$，两个子问题加起来就是$2T(n/2)$。<br>第7行，<code>find_max_crossing_subarray</code>函数求解跨越中点的子数组，花费线性的时间，为$\Theta (n)$。</p>
<p>总的运行时间递归式为：<br>$$T(n) = \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>2T(n/2)+\Theta (n) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$<br>与鬼归并排序的递归式相同。在4.5节用主方法求解该递归式，其解为$T(n) =\Theta (n\ \text{lg}n) $。</p>
<h3 id="线性复杂度的解法–习题4-1-5-P42"><a href="#线性复杂度的解法–习题4-1-5-P42" class="headerlink" title="线性复杂度的解法–习题4.1-5(P42)"></a>线性复杂度的解法–习题4.1-5(P42)</h3><p>主要思想：从左到右处理，记录目前为止已经处理的最大子数组。非递归、线性复杂度。</p>
<p>从左到右累加，如果当前子数组的累加和小于零，则意味着最大子数组(maximun subarray)肯定不包括该子数组，所以果断舍弃，重新开始累加。</p>
<p>该解法的python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A)</span>:</span></div><div class="line">   j = <span class="number">0</span></div><div class="line">   max_sum = <span class="number">0</span></div><div class="line">   left = <span class="number">-1</span></div><div class="line">   cur_left = <span class="number">0</span></div><div class="line">   right = <span class="number">-1</span></div><div class="line">   sum = <span class="number">0</span></div><div class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">       sum = sum + A[j]</div><div class="line">       <span class="keyword">if</span> sum &gt; max_sum:</div><div class="line">           max_sum = sum</div><div class="line">           left = cur_left</div><div class="line">           right = j</div><div class="line">       <span class="keyword">elif</span> sum &lt; <span class="number">0</span>:</div><div class="line">           sum = <span class="number">0</span></div><div class="line">           cur_left = j + <span class="number">1</span></div><div class="line">   <span class="keyword">if</span> max_sum &gt; <span class="number">0</span>:</div><div class="line">       <span class="keyword">return</span> left, right, max_sum</div><div class="line">   <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<h2 id="矩阵乘法的Strassen算法-4-2，P43"><a href="#矩阵乘法的Strassen算法-4-2，P43" class="headerlink" title="矩阵乘法的Strassen算法(4.2，P43)"></a>矩阵乘法的Strassen算法(4.2，P43)</h2><p>若$A=(a_{ij}),B=(b_{ij})$是$nxn$的方阵，则对$i,j=1,2,\cdots ,n$,定义矩阵乘积$C=A\cdot B$中的$c_{ij}$为：<br>$$c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}$$</p>
<p>写成程序，是一个三重循环，因此，复杂度为$\Theta (n^3)$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">SQUARE_MATRIX_MULTIPLY</span><span class="params">(A, B)</span>:</span>  </div><div class="line">    <span class="keyword">assert</span>(len(A) == len(B))  </div><div class="line">    n = len(A)  </div><div class="line">    C = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(n)] <span class="keyword">for</span> row <span class="keyword">in</span> range(n)]  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">                C[i][j]= C[i][j] + A[i][k]*B[k][j]  </div><div class="line">    <span class="keyword">return</span> C</div></pre></td></tr></table></figure>
<h3 id="一个简单的分治算法-4-2，P43"><a href="#一个简单的分治算法-4-2，P43" class="headerlink" title="一个简单的分治算法(4.2，P43)"></a>一个简单的分治算法(4.2，P43)</h3><p>假定三个矩阵均为$n\times n$矩阵，其中n为2的幂。在每个分解步骤中，$n\times n$矩阵都被划分为4个$n/2 \times n/2$的子矩阵，如下：<br>$$A = \begin{bmatrix}<br>A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}<br>\end{bmatrix},<br>B = \begin{bmatrix}<br>B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}<br>\end{bmatrix},<br>C = \begin{bmatrix}<br>C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}<br>\end{bmatrix}<br>$$<br>因此，公式$C=A\cdot B$改写成：<br>$$\begin{bmatrix}<br>C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}<br>\end{bmatrix}= \begin{bmatrix}<br>A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}<br>\end{bmatrix} \cdot<br>\begin{bmatrix}<br>B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}<br>\end{bmatrix}<br>$$<br>等价于：<br>$$\begin{matrix}<br>C_{11} = A_{11}\cdot B_{11} + A_{12}\cdot B_{21} \\<br>C_{12} = A_{11}\cdot B_{12} + A_{12}\cdot B_{22} \\<br>C_{21} = A_{21}\cdot B_{11} + A_{22}\cdot B_{21} \\<br>C_{22} = A_{21}\cdot B_{12} + A_{22}\cdot B_{22}<br>\end{matrix}$$</p>
<p>该简单分治算法的总运行时间递归式为：<br>$$T(n) = \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>8T(n/2)+\Theta (n^2) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$</p>
<h3 id="Strassen-方法-4-2，P45"><a href="#Strassen-方法-4-2，P45" class="headerlink" title="Strassen 方法(4.2，P45)"></a>Strassen 方法(4.2，P45)</h3><p>为减小时间复杂度，采用Strassen 法，其原理仍将讲矩阵A,B,C划分成n/2 x n/2 ,然后按如下计算：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn945rgi23j20bx08575e.jpg" alt=""></p>
<p>即：先创建10个矩阵$S_1,\cdots,S_{10} $，由于进行了10次$n/2\times n/2$矩阵的加减法，所以该步骤花费$\Theta(n^2)$时间。</p>
<p>接着，递归地计算七次$n/2\times n/2$矩阵的乘法，即计算$P_1,\cdots,P_{7}$矩阵。</p>
<p>最后计算结果矩阵C的子矩阵$C_{11},C_{12},C_{21},C_{22}$。</p>
<p>其时间复杂度为：</p>
<p>$$T(n)= \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>7T(n/2)+\Theta (n^2) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$</p>
<p>利用4.5节的主方法，可以求出上述的解为：<br>$$T(n)= \Theta(n^{\text{lg}7}) $$</p>
<h2 id="用主方法求解递归式-4-5，P53"><a href="#用主方法求解递归式-4-5，P53" class="headerlink" title="用主方法求解递归式(4.5，P53)"></a>用主方法求解递归式(4.5，P53)</h2><p>主方法依赖于主定理。</p>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>令$a\geqslant 1$和$b&gt;1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：<br>$$T(n)= aT(n/b)+f(n)$$</p>
<p>其中，我们将$n/b$解释为$\lfloor n/b \rfloor$或$\lceil n/b \rceil$。那么$T(n)$有如下的渐近界：</p>
<ol>
<li><p>若对某个常数$\epsilon &gt; 0$有$f(n) = \text{O}(n^{\text{log}_ba - \epsilon})$，则$T(n)=\Theta(n^{\text{log}_ba} )$</p>
</li>
<li><p>若$f(n) = \Theta(n^{\text{log}_ba})$，则$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$</p>
</li>
<li>若对某个常数$\epsilon &gt; 0$有$f(n) = \Omega(n^{\text{log}_ba + \epsilon})$，且对某个常数$c&lt;1$和所有足够大的n有$aT(n/b)\leqslant cf(n)$，则$T(n)=\Theta(f(n) )$</li>
</ol>
<p>以上就是主定理的完整叙述。</p>
<p>解释：我们将函数$f(n)$和$n^{\text{log}_ba}$进行比较。直觉上，两个函数较大者决定了递归式的解。<br>情况1表示：函数$n^{log_ba}$更大，则解为$T(n)=\Theta(n^{\text{log}_ba} )$；<br>情况3表示：函数$f(n)$更大，则解为$T(n)=\Theta(f(n) )$。<br>情况2表示：当两个函数大小相当，则乘上一个对数因子，解为$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$。</p>
<blockquote>
<p>上述的大于/小于都是多项式意义上的，也就是渐近小于(大于)。每种情况之间都有一定的间隙。若$f(n)$落在间隙中，就不能使用主方法。</p>
</blockquote>
<h3 id="使用主方法"><a href="#使用主方法" class="headerlink" title="使用主方法"></a>使用主方法</h3><p>使用主方法，只需要确定主定理的哪种情况成立，即可以得到解。</p>
<p>下面举几个例子。</p>
<p>$$T(n)= 9T(n/3)+n$$<br>上式中，$a=9,b=3,f(n) = n$，因此，$n^{\text{log}_ba} =n^{\text{log}_39} = \Theta(n^2) $。由于$f(n) = \text{O}(n^{\text{log}_39 - \epsilon})$，其中$\epsilon = 1$，所以应用主定理的情况1，从而得到$T(n) = \Theta(n^2) $</p>
<p>$$T(n)= T(2n/3)+1$$<br>上式中，$a=1,b=3/2,f(n) = 1$，因此，$n^{\text{log}_ba} =n^{\text{log}_{3/2}1} =n^0 = 1 $，由于$f(n) = \Theta(n^{\text{log}_ba}) = \Theta (1)$，所以，适用于情况二，从而得到最终解为$T(n) = \Theta(\text{lg} n ) $</p>
<p>归并排序和最大子数组方法的运行时间的递归式：<br>$$ T(n)= 2T(n/2)+\Theta(n)$$<br>同理，$n^{\text{log}_ba} =n^{\text{log}_{2}2} =n $， 由于$f(n) = \Theta(n)$，所以应用情况2，得到解$T(n) = \Theta(n\text{lg} n ) $</p>
<p>矩阵乘法的第一个分治算法的运行时间：<br>$$ T(n)= 8T(n/2)+\Theta(n^2)$$<br>上式，有：$n^{\text{log}_ba} =n^{\text{log}_{2}8} =n^3 $，$n^3$多项式意义上大于$f(n)$，因此应用情况1，解为$T(n) = \Theta(n^3) $</p>
<p>矩阵乘法的Strassen算法运行时间：<br>$$ T(n)= 7T(n/2)+\Theta(n^2)$$<br>上式中，有$n^{\text{log}_ba} =n^{\text{log}_{2}7} = n^{\text{lg}7}$，由于$2.80&lt;lg7&lt;2.81$，对$\epsilon = 0.8$，有$f(n) = \text{O}(n^{\text{lg}7-\epsilon})$，故应用情况1，得到：$T(n) = \Theta(n^{\text{lg}7}) $</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>算法导论 中文版 原书第三版</li>
<li><a href="http://blog.csdn.net/u010183397/article/details/46866577" target="_blank" rel="external">算法导论 第四章：分治法(二)</a></li>
<li><a href="http://blog.csdn.net/sushauai/article/details/50491477" target="_blank" rel="external">算法导论课后习题解析 第四章 上</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法导论 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 最大子数组 </tag>
            
            <tag> 矩阵乘法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[判断回文数（三种解法）—— Leetcode(9)]]></title>
      <url>/2018/01/08/Leetcode_9/</url>
      <content type="html"><![CDATA[<p>Leetcode链接：<a href="https://leetcode.com/problems/palindrome-number" target="_blank" rel="external">9. Palindrome Number</a></p>
<a id="more"></a>
<p>Palindrome Number，即判断是否为回文数，并且题目要求不能使用额外的空间。<br>即，不能使用回文串的方法。</p>
<p>在本题中，负数不作为回文数考虑范围之内，但是输入依然可能为负，此时直接返回false即可。</p>
<p>首先，一种容易想到的方法是：将整个数取反后看和原来的数是否相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum =<span class="number">0</span>;  </div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> origin = x;  </div><div class="line">        <span class="keyword">while</span>(x)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">int</span> num = x %<span class="number">10</span>;  </div><div class="line">            sum = sum*<span class="number">10</span> + num;  </div><div class="line">            x/=<span class="number">10</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(sum == origin)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我采用另外一种方法：根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="comment">// 负数肯定不是，以及首尾不对称的非0数</span></div><div class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> ( x &gt; rev)&#123;</div><div class="line">            rev = rev * <span class="number">10</span> + x % <span class="number">10</span>; <span class="comment">//将低位一半的数取反。</span></div><div class="line">            x = <span class="keyword">int</span> (x / <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//有rev &gt;= x， 奇数情况下需要除去10</span></div><div class="line">        <span class="keyword">return</span> x == rev || x == <span class="keyword">int</span>(rev/<span class="number">10</span>); </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>还有另外一种解法：<br>类似与采用两个指针。<br>在循环体中，不断地比较第i位和倒数第i位，直到遇到最中间的1个数字(输入为奇数个数字)或者遇到最中间的2个数字(输入为偶数个数字)时结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">  <span class="keyword">int</span> div = <span class="number">1</span>;  </div><div class="line">  <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) &#123;  </div><div class="line">    div *= <span class="number">10</span>;  </div><div class="line">  &#125;          </div><div class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;  </div><div class="line">    <span class="keyword">int</span> l = x / div;  </div><div class="line">    <span class="keyword">int</span> r = x % <span class="number">10</span>;  </div><div class="line">    <span class="keyword">if</span> (l != r) <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    x = (x % div) / <span class="number">10</span>;  <span class="comment">//去掉两边的数</span></div><div class="line">    div /= <span class="number">100</span>;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考链接：</p>
<ul>
<li><a href="http://blog.csdn.net/feliciafay/article/details/17134663" target="_blank" rel="external">LeetCode(9)PalindromeNumber</a></li>
<li><a href="http://blog.csdn.net/zhangxiao93/article/details/48751493" target="_blank" rel="external">leetcode9</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> 回文数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Primer学习笔记：(六)函数]]></title>
      <url>/2018/01/06/CPP_06/</url>
      <content type="html"><![CDATA[<p>第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。<br>本章内容包括：</p>
<ol>
<li>函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。</li>
<li>函数重载,重载可以使函数接受不同种类或者数量不同的参数。</li>
<li>函数指针，指向函数的一类特殊指针。</li>
</ol>
<a id="more"></a>
<h2 id="函数基础（P182，6-1）"><a href="#函数基础（P182，6-1）" class="headerlink" title="函数基础（P182，6.1）"></a>函数基础（P182，6.1）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span> <span class="comment">// 形参  </span></span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    func(<span class="number">1</span>, <span class="string">'a'</span>); <span class="comment">// 实参，与形参的类型、数量相匹配  </span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用函数时，第一步编译器会隐式的定义并初始化它的形参。比如一个函数<code>void f(int a);</code>，形参<code>int a</code>会被用户传入的实参初始化，此时形参是实参的一个副本。当有多个形参时，形参对应的实参的求值顺序是不一定的。实参的类型必须和形参的类型一致或能转化为形参声明的类型。</p>
<p>函数可以返回空值。返回函数指针和数组的特殊函数类型将在之后提到。</p>
<h3 id="局部静态对象（P185，6-1-1）"><a href="#局部静态对象（P185，6-1-1）" class="headerlink" title="局部静态对象（P185，6.1.1）"></a>局部静态对象（P185，6.1.1）</h3><p>一个对象的名字有作用域，对象本身也有生命周期。名字的作用域是我们可以通过名字访问对象的的区间。相对的，生命周期是指对象的产生和销毁的过程。</p>
<p>定义在所有函数外部的变量叫做<strong>全局变量</strong>，在整个程序的执行过程中一直存在。这种对象在程序启动时被创建，直到程序结束才会被销毁。</p>
<p>定义在函数体内的对象或者函数的形参都是<strong>局部变量</strong>。当函数执行路径经过该对象的定义语句时才会自动开始创建该对象，在对应的块结束时，这个对象会被销毁。</p>
<p>有时候我们有必要使局部变量的生命周期贯穿函数调用及之后的时间，所以我们可以将局部对象定义成<code>static</code>对象，定义语句形如<code>static int a=1;</code>，这样我们就可以在程序的别的地方（只要是在这个static对象的作用域内访问它）操作这个局部静态对象。</p>
<p>在一个程序中多次定义局部静态对象仍然是不被允许的。但是当一个函数里的对象被定义为局部静态对象，<font color="00A00A">多次调用这个函数并不会重置这个局部静态对象的值</font>。它自己会记得上一次被函数调用之后的值并继承这个值，不被第二次函数调用的变量定义初始化，这就是它静态的特性。</p>
<blockquote>
<p>局部静态变量若没有显式的初始化，则执行值初始化，内置类型的局部静态变量初始化为0。</p>
</blockquote>
<h3 id="函数声明（P186，6-1-2）"><a href="#函数声明（P186，6-1-2）" class="headerlink" title="函数声明（P186，6.1.2）"></a>函数声明（P186，6.1.2）</h3><p>函数声明要在使用这个函数之前。规范的形式是通常放在头文件里。函数声明可以不写形参的名字，只写形参的类型。</p>
<p>函数声明也称作函数原型(function prototype)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数的声明，必须要写在函数第一次被调用之前。  </span></div><div class="line"> <span class="comment">// 这部分的代码可放到头文件中，用的时候include进来就可以了(分离式编译)  </span></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;  </div><div class="line">  </div><div class="line"> <span class="comment">// 只要函数在被调用前声明了，那函数的定义可以写在声明之后的任意的位置，  </span></div><div class="line"> <span class="comment">// 如这里的func就可以在声明之后、main函数之前定义；  </span></div><div class="line"> <span class="comment">// 如果func没有在调用前声明，则必须要在被调用前定义(相当于把main函数后面的func那段代码放在这里实现)  </span></div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">return</span> func(<span class="string">'a'</span>, <span class="string">'1'</span>); <span class="comment">// 函数的调用，虽然func在main后定义，但是因为之前对func进行了声明，所以编译器知道这个函数的三要素是啥  </span></div><div class="line"> &#125;  </div><div class="line">  </div><div class="line"> <span class="comment">/* </span></div><div class="line"><span class="comment">  * 函数的定义的参数列表中各参数的类型、数量以及位置等需要和声明时的相匹配 </span></div><div class="line"><span class="comment">  */</span>  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> i)</span>  </span></div><div class="line"><span class="function"> </span>&#123;  </div><div class="line">     <span class="comment">// do something  </span></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="传引用调用（P189，6-2-2）"><a href="#传引用调用（P189，6-2-2）" class="headerlink" title="传引用调用（P189，6.2.2）"></a>传引用调用（P189，6.2.2）</h3><p>当函数的形参是一个引用类型的时候，在使用函数时，这个函数的引用形参就绑定在了传入的实参上，这种函数调用就叫做<strong>传引用调用</strong>。在函数涉及到一些比较大的类型对象作为参数的时候，通常地我们使用传引用调用，这样就可以避免实参初始化形参带来的拷贝。在C语言里经常传入指针避免拷贝，在C++里，一般使用引用。</p>
<p>大多数情况下函数只能有一个返回值，因此在我们需要的时候，我们可以<strong>传一个额外的引用的参数在函数里面。这样函数体内就可以改变引用的值进而改变函数外部被引用连接的对象的值，从而返回多个数值</strong>。</p>
<h3 id="const形参和实参（-P190，6-2-2）"><a href="#const形参和实参（-P190，6-2-2）" class="headerlink" title="const形参和实参（ P190，6.2.2）"></a>const形参和实参（ P190，6.2.2）</h3><p>函数形参的类型也可以是带const的类型。</p>
<blockquote>
<p>顶层const作用于对象本身（离对象最近的const），实参初始化形参的时候会忽略掉顶层const。即<strong>形参的顶层const被忽略掉了</strong>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>; <span class="comment">//fcn 能读取i，但不能向i写值。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//错误，重复定义了fcn(int)。</span></div></pre></td></tr></table></figure>
<p>因为顶层const被忽略掉了，所以第二个fcn是错误的。</p>
<p>形参的初始化方式与变量的初始化方式一样。先回顾一下变量的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int i  = 42;</div><div class="line">const int *cp = &amp;i; //正确，但是cp不能改变i</div><div class="line">const int &amp;r = i;   //正确，但是r不能改变i</div><div class="line">const int &amp;r2 = 42; //正确，参见P55。</div><div class="line"></div><div class="line">int *p = cp;        //错误，p的类型和cp的类型不匹配</div><div class="line">int &amp;r3 = r;        //r3的类型和r的类型不匹配</div><div class="line">int &amp;4 = 42;        //错误，不能用字面值常量初始化一个非常量引用（参见P45）</div></pre></td></tr></table></figure></p>
<p>将同样的初始化规则应用到参数传递上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</div><div class="line"><span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</div><div class="line">reset(&amp;i);  <span class="comment">//调用形参类型是int *的函数</span></div><div class="line">reset(&amp;ci);  <span class="comment">//错误：不能用指向const int对象的指针初始化int *</span></div><div class="line"></div><div class="line">reset(i);  <span class="comment">//调用形参类型是int &amp;的函数</span></div><div class="line">reset(ci);  <span class="comment">//错误：不能把普通引用绑定到const对象ci上</span></div><div class="line">reset(<span class="number">42</span>);  <span class="comment">//错误：不能把普通引用绑定到字面值上</span></div><div class="line">reset(ctr);  <span class="comment">//错误：类型不匹配，ctr是无符号类型</span></div></pre></td></tr></table></figure></p>
<p><strong><font color="00A00A">我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</font></strong></p>
<hr>
<p><strong>当我们接受函数的参数是为了完成比较或者判断等操作，而不需要改变参数的值，我们应该使用带const的参数来确保参数不会被更改</strong>。另外，const类型的形参能比普通类型的形参接受更多种类的参数。比如<code>void fn(const string&amp;);</code>这个函数，字符串字面值是<code>const char [ ]</code>类型，因此fn这个函数接受字符串字面值。但是如果声明成了<code>void fn(string&amp;);</code>，那么这个函数就没有办法接受字符串字面值（类似：<code>“string”</code>这样的值就是字符串字面值）。另外，带const的形参也接受带底层const的对象。</p>
<h3 id="传递数组作为参数（P193，6-2-4）"><a href="#传递数组作为参数（P193，6-2-4）" class="headerlink" title="传递数组作为参数（P193，6.2.4）"></a>传递数组作为参数（P193，6.2.4）</h3><p>又是我们想要向函数传递一个数组，但是数组是不可拷贝的，因此我们不能够通过值传递的方式传递一个数组到函数里，另外，如果数组的内容很大，传递数组的每个元素会带来不必要的拷贝。</p>
<p>以下的方法都基于或类似<strong><font color="00A00A">传递数组的指针</font></strong>。一维数组的指针指向数组的第一个元素。我们可以声明类似如下的形式传递一个数组指针到函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure></p>
<p>这三者是等价的。传递之后形参的类型都是<code>int *</code>类型。</p>
<p>但是正因为数组的信息是以指针的形式传递给函数的，所以函数只得到一个地址，并不知道数组的大小，因此也就很容易访问到未定义的内存区域，因此在传递数组指针的基础上，我们可以通过手动标志数组大小等方法保证函数访问的内存是合法的不越界的。因此衍生出以下几种方法。</p>
<ol>
<li>第一种方法：<strong>在数组的末尾加标记。</strong>这种方法类似于C风格字符串，末尾会自动加’\0’来告诉大家这个字符串结束了。在数组末尾加特殊的标记来使数组不越界是简单易用的方法。</li>
<li>第二种方法：<strong>使用标准库规范中的begin和end函数。</strong>头文件<code>iterator</code>里有针对数组的begin和end函数，返回数组的首指针和尾后指针，指针指向数组元素的类型，这种方法也可以检测越界。</li>
<li>第三种方法：<strong>传递一个表示数组大小的参数。</strong>这样构建函数时就知道数组有多大了。如<code>print(j, end(j)-begin(j));</code></li>
<li>第四种方法：<strong>传递数组的引用。</strong>除了使用指针，我们还可以使用引用来得到一个完整数组的引用（别名）。声明格式类似下面这种：<code>void fx(int (&amp;arr)[10]);</code>，这里形参的名字是<code>arr</code>，<code>arr</code>前面的<code>&amp;</code>符号代表它是引用类型，引用了一个实参数组，这个数组必须只有10个元素（因为arr后面的[10]也是构成引用声明的必要部分。）</li>
</ol>
<blockquote>
<p>注意<code>void fx(int &amp;arr[10]);</code>这个去掉括号的写法是错误的，不存在引用的数组。</p>
</blockquote>
<hr>
<p><strong>传递多维数组</strong>：有时我们也需要向一个函数传递多维数组。多维数组的实质是数组的数组，一维数组的名是指向数组元素的指针，二维数组是指向数组元素的指针的指针。因此想要一个函数传递多维数组的形参声明如下：<code>void fx(int (*arr)[10]);</code>这时arr指向有10个int型元素的数组。当我们把arr+1，它就又指向了新的10个元素，因此arr相当于二维数组的数组名（两者都是指向包含的一维数组首元素的指针）。</p>
<p>也可以用<code>int arr[][10]</code>代替<code>int (*arr)[10]</code>，因为它们是等价的，都是二维数组名。用<code>int arr[][10]</code>这种方式定义形参时，要标出除了第一个维度以外的每个维度。（假设有一个数组<code>int b[2][3]</code>，就说明b有两列，每列3个元素，这里的2就是第一个维度。指向一维数组的指针不关心在这个维度上有几个元素，因此忽略）。</p>
<h3 id="main函数的命令行选项（P196，6-2-5）"><a href="#main函数的命令行选项（P196，6-2-5）" class="headerlink" title="main函数的命令行选项（P196，6.2.5）"></a>main函数的命令行选项（P196，6.2.5）</h3><p>最开始我们使用<code>UNIX</code>或<code>LINUX</code>系统编程时经常使用没有图形界面的编译器来把写好的代码编译成obj文件，这时候我们使用命令行来编译一份源代码文件，我们需要在终端里输入类似“<code>prog -d -o oflie data0</code>”的命令行来进行命令行控制。</p>
<p>现在我们看到的main函数一般都是<code>int main()</code>，括号里面什么也不写，我们也可以给main传递上述的那个命令行参数。形如：<code>int main(int argc,char *argv[])</code>。 main可以什么参数也不接受，也可以接受一个int和一个指向字符串的指针这两个参数。main没有第三种形式了。</p>
<p><code>int argc</code>是表示后面的argv一共指向几个字符串用的。<code>char *argv[]</code>里面的每一个字符串都顺序对应着命令行的参数。这些参数的字符串数组的第一个元素应该是可执行文件的名字或者空参数，最后一个字符串的值必须为<code>0</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于命令”prog -d -o oflie data0“：</span></div><div class="line">argc = <span class="number">5</span>;</div><div class="line">argv[<span class="number">0</span>] = <span class="string">"prog"</span>;</div><div class="line">argv[<span class="number">1</span>] = <span class="string">"-d"</span>;</div><div class="line">argv[<span class="number">2</span>] = <span class="string">"-o"</span>;</div><div class="line">argv[<span class="number">3</span>] = <span class="string">"0file"</span>;</div><div class="line">argv[<span class="number">4</span>] = <span class="string">"data0"</span>;</div><div class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>有关命令行的更多选项和argv参数的具体用法，可以参照对应的编译器文档。</p>
<h3 id="含有可变形参的函数（P197，6-2-6）"><a href="#含有可变形参的函数（P197，6-2-6）" class="headerlink" title="含有可变形参的函数（P197，6.2.6）"></a>含有可变形参的函数（P197，6.2.6）</h3><p>到现在我们定义的函数都是固定参数的，但是有时候我们无法预知向函数传递几个参数，又想使用一个函数接受这种变化，我们就可以使用C++指定的两种方法来定义含有可变形参的函数。</p>
<ul>
<li>第一种方法是当参数个数不一定，但是<strong>参数类型都相同</strong>时，我们可以<strong>传递一个initializer_list参数</strong>。这是标准库设施中的一部分。</li>
<li>第二种方法在当我们想传递不确定个数的<strong>不同类型的实参</strong>时要使用的技术：<strong>可变参数模板。</strong>这个16章才介绍。</li>
</ul>
<p>其实还有一种方法使函数接受多种形参，不过这种方法多用于和C语言旧代码对接时使用。<strong>这个方法用省略符来传递可变数量的形参</strong>。</p>
<blockquote>
<p>常见的应用场景：日志的打印</p>
</blockquote>
<h3 id="initializer-list（P197，6-2-6）"><a href="#initializer-list（P197，6-2-6）" class="headerlink" title="initializer_list（P197，6.2.6）"></a>initializer_list（P197，6.2.6）</h3><p>下面是关于定义可变形参函数的第一种方法——<code>initializer_list</code>参数的介绍：</p>
<p><code>initializer_list</code>类似<code>vector</code>，是一种容器，接纳一种同样类型的元素。initializer_list定义在同名的<code>&lt;initializer_list &gt;</code>中，我们可以把任意数量，同样类型的参数传递给这个容器使函数能够处理多个元素。</p>
<p>initializer_list支持的操作包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名 //默认初始化一个 initializer_list空容器</div><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名&#123;元素值1，元素值2，元素值2...&#125; //大括号初始化</div><div class="line">initializer_list 容器名1（已被定义的initializer_list 容器的容器名2 ）//使容器1的内容和容器二一致，两个容器共享容器二里面的元素。不会形成拷贝，（也可以用initializer_list 容器名1=initializer_list 容器名2）</div><div class="line">initializer_list 容器名.size() //元素数量</div><div class="line">initializer_list 容器名.begin() //指向首元素的迭代器</div><div class="line">initializer_list 容器名.end() //尾后迭代器</div></pre></td></tr></table></figure></p>
<p>initializer_list里面元素的值永远是常量不能被更改，如果里面的元素是指针或引用，这个元素的属性将被自动加上底层const。<br>当我们声明一个接受 <code>initializer_list</code>类型的函数 <code>void fa(initializer_list&lt;int&gt; list1);</code>的时候，我们需要使用大括号来调用这个函数，形如fa({2,3,4});这样我们就向initializer_list传递了一个值的序列。<br>我们也可以声明<code>void fa(string b,initializer_list&lt;int&gt; list1);</code>这种函数。</p>
<h3 id="省略符形参（P199，6-2-6）"><a href="#省略符形参（P199，6-2-6）" class="headerlink" title="省略符形参（P199，6.2.6）"></a>省略符形参（P199，6.2.6）</h3><p>下面是关于定义可变形参函数的第三种方法——省略符形参的介绍。</p>
<p>省略符形参有下列两种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( parm_list , ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( ... )</span></span>;</div></pre></td></tr></table></figure></p>
<p>第一种形式为特定数目的形参提供了声明。在这种情况下，当函数被调用时，对于与显示声明的形参相对应的实参进行类型检查，而对于与省略符对应的实参则暂停类型检查。在第一种形式中，形参声明后面的逗号是可选的。如果没有逗号，相应地，就变成了第二种情况。</p>
<blockquote>
<p>省略符形参应该仅仅用于C和C++通用的类型。<br>特别注意的是，大多数类型的对象在传递给省略符形参时都无法正确拷贝。<br>（感慨：所以说有什么用？还是用<code>intializer_list</code>吧？）</p>
</blockquote>
<p>你可以传递任意数量的参数给省略符形参。要注意省略号的优先级别最低，所以在函数解析时，只有当其它所有的函数都无法调用时，编译器才会考虑调用省略号函数的。<br>(optional)首先，如果要用省略符的方式处理不定参数的函数要包含头文件：<code>#include &lt;stdarg.h&gt;</code> （C语言中）或者<code>#include &lt;cstdarg&gt;</code>（C++中）。 然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。<br>用省略符处理不定参数的函数基于C语言的方法，在C++中不建议使用。（使用了C语言标准库功能varargs）。</p>
<h2 id="返回值（P202，6-3）"><a href="#返回值（P202，6-3）" class="headerlink" title="返回值（P202，6.3）"></a>返回值（P202，6.3）</h2><p>在void返回值的语句最后会隐式地有<code>return;</code>语句，这时函数什么也不返回。</p>
<blockquote>
<p>不要返回局部对象的引用或指针。</p>
</blockquote>
<p>函数可以返回一个<strong>非常量引用</strong>作为左值。也可以返回一个花括号括起来的列表，来初始化vector等类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; test()  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>main函数的return语句可以不写，编译器会带为隐式补充。</p>
<blockquote>
<p>main 函数不能调用自己。</p>
</blockquote>
<h3 id="返回数组指针（P205，6-3-3）"><a href="#返回数组指针（P205，6-3-3）" class="headerlink" title="返回数组指针（P205，6.3.3）"></a>返回数组指针（P205，6.3.3）</h3><p>虽然我们不能直接让函数返回一个数组，但是我们可以设定函数返回一个指针的类型。函数会返回数组的指针。返回数组指针的函数定义语句如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数组元素类型 （*函数名 （参数列表））[ 数组大小 ]</div></pre></td></tr></table></figure></p>
<p>当然，返回一个临时量或者局部对象的引用/指针都是错误的行为，如果你在函数里普通地定义了一个数组，那么这个数组的生命周期在函数返回时就结束了，会被内存中释放，因此可能需要用static使这个数组静态。静态对象只是延长了对象的生命周期，但是无论如何在函数内部定义的对象在外部都无法访问，除非使用返回指针的方法。</p>
<p>一条<code>double (*func(int a))[10]</code>这种语句来说明函数接受一个<code>int a</code>形参并且返回一个带有10个元素的double数组，这种语句在写法上比较乱，因此<code>C++11</code>提供了<strong><font color="00A00A">尾置返回</font></strong>的方法让程序员不必要非要迁就编译器的理解能力，上一条语句等价于这样：<code>auto func(int a)-&gt;double(*)[10]</code>我们使用<code>-&gt;</code>符号把返回值类型的描述放在了参数列表后面并和函数声明分离开让函数看起来不那么乱。</p>
<p>我们也可以使用<code>decltype</code>语句返回数组指针。<code>decltype</code>后面的括号可以括起一个现有的数组推导数组类型。我们再手动加<code>*</code>得到数组指针类型的返回值。在已有<code>int a[10];</code>的情况下，我们可以使用<code>decltype(a) *fn(int b)</code>这种形式定义一个返回指向数组的指针的返回值类型。</p>
<h2 id="函数重载（P207，6-4）"><a href="#函数重载（P207，6-4）" class="headerlink" title="函数重载（P207，6.4）"></a>函数重载（P207，6.4）</h2><p>我们可以定义一组功能类似，函数名一致，但是接受的参数类型或数量不同的函数。定义多个这种函数就叫做<strong>函数重载</strong>。函数重载可以提供给我们用一个函数名处理多种参数形式的情况。</p>
<p>定义重载函数要能重传入的参数里区别出实质不同的重载函数，如函数A的定义为<code>int fa(const int a);</code>和函数<code>B int fa(int b);</code>这两个函数函数名一样，形参类型不同，但仍然无法作为重载函数。因为我们传入一个int值时，fa不知道应该执行第一种还是第二种。所以<strong>只有参数顶层const属性不同的几个函数不是重载函数。</strong></p>
<blockquote>
<p>形参相同，但返回类型不同的函数也不能构成重载。</p>
</blockquote>
<p>当然，对于底层const，比如参数列表为<code>const int *a</code>的函数和参数列表为int a的函数能被看出不同，因为对于一个传入的const常量指针，这个实参只能初始化<code>const int *a</code>，不能被初始化<code>int a</code>。当同时有这两种形式的重载函数时，当传入一个非常量，IDE会优先选择为它匹配形参为<code>int a</code>版本的普通变量形参函数。</p>
<blockquote>
<p>形参是某种类型的引用或指针，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载。（此时的const是底层的）</p>
</blockquote>
<h3 id="const-cast和函数（P209，6-4）"><a href="#const-cast和函数（P209，6-4）" class="headerlink" title="const_cast和函数（P209，6.4）"></a>const_cast和函数（P209，6.4）</h3><p>这里主要介绍<code>const_cast</code>类型强制转换是如何在函数中被使用的。在第四章(4.11.3, P145)第一次接触<code>const_cast</code>的时候我们提到过这个常被用于函数里。这里我们就看看怎么使用。</p>
<p>之前说过，向函数传递参数时最好传递<code>const</code>型参数使其能够接受多种参数，这里我们可以在函数体内使用<code>const</code>再把参数变回普通的变量，这样就可以返回一个<code>非const</code>值了。</p>
<h3 id="重载和作用域（P210，6-4）"><a href="#重载和作用域（P210，6-4）" class="headerlink" title="重载和作用域（P210，6.4）"></a>重载和作用域（P210，6.4）</h3><p>声明变量时，变量的作用域就在块里，声明函数也一样，而且里层的作用域会隐藏外部的作用域。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	int a=0; //这里是a的外层作用域</div><div class="line">    &#123;</div><div class="line">    	double a=1.2; //外边已经有a了，这里又声明了一个a，因此这个a的作用域覆盖了前面的int a；</div><div class="line">    	cout&lt;&lt;a&lt;&lt;endl; //输出的会是1.2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数声明也一样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    int fa(int b); //这里是函数fa的外层作用域</div><div class="line">    double fa(double b); //重载了函数fa使它能够接受double</div><div class="line">    &#123;</div><div class="line">        double fa(string &amp; c); //外边已经有fa了，这里又声明了一个fa，因此这个fa的作用域覆盖了前面的;</div><div class="line">        fa(2.3); //错误，原型为double fa(double b)的函数声明作用域被double fa(string &amp; c);覆盖，匹配不到函数</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>C++中，名字查找发生在类型检查之前。</p>
</blockquote>
<h2 id="特殊用途语言特性（6-5）"><a href="#特殊用途语言特性（6-5）" class="headerlink" title="特殊用途语言特性（6.5）"></a>特殊用途语言特性（6.5）</h2><h3 id="默认实参（P211，6-5-1）"><a href="#默认实参（P211，6-5-1）" class="headerlink" title="默认实参（P211，6.5.1）"></a>默认实参（P211，6.5.1）</h3><p>有时候一些函数我们每次调用它总会向它传递一些特殊的值。我们可以声明带有默认实参的函数。默认实参如果没有明确说明，默认实参会被自动当做函数的初始值传递进去。<br>形如<code>int fn(int a,int b=2,double c=3.3)</code>这样定义函数头的方式就给了b和c默认的实参，注意，<strong>当一个形参被给了默认实参，它后面的所有参数都要有默认实参才行。</strong></p>
<p>当我们想使用默认实参的时候，只要调用函数的时候使用这种对应的实参就行了，默认实参会用来填补缺少的尾部实参，上面的定义的函数如果这么调用：<code>fn(1,2);</code>，<code>double c</code>的值会被自动设为3.3。书写这种函数时要尽量保证要经常用到的默认实参放在参数列表的更后面一点，这样才合理。</p>
<p>可以只在函数声明里标注默认实参不在函数定义里这样写，结果仍然将是正确的。<code>void fn(int = 1, int = 2, int =3);</code>这种函数声明语句省略了形参的名字，不过也是可以的。</p>
<blockquote>
<p>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p>
</blockquote>
<p>局部变量不能做默认实参，默认实参的定义在函数体之外。另外，<strong>默认实参是可以在名字的作用域内通过名字更改的</strong>。</p>
<h3 id="内联函数（P213，6-5-2）"><a href="#内联函数（P213，6-5-2）" class="headerlink" title="内联函数（P213，6.5.2）"></a>内联函数（P213，6.5.2）</h3><p>有时我们要频繁调用一个优化规模小，流程直接，频繁被调用的函数，定义函数时我们可以在返回值类型前面加上关键字<code>inline</code>使它成为内联函数，减少运行时的开销。</p>
<blockquote>
<p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p>
</blockquote>
<h3 id="constexpr函数（P214，6-5-2）"><a href="#constexpr函数（P214，6-5-2）" class="headerlink" title="constexpr函数（P214，6.5.2）"></a>constexpr函数（P214，6.5.2）</h3><p>这是一种能够被用在常量表达式的函数，但是函数的返回值类型和形参类型必须都是字面值。<strong>函数体中必须有且只有一条<code>return</code>语句，<code>constexpr</code>函数被隐式的指定为内联函数。</strong>const函数中也可以有类型别名，使用作用域声明等不执行操作的其他语句。这里没有赋值，没有构建对象。同时<code>constexpr</code>可以返回计算后的结果。如<code>constexpr int fn(int a){return a+22;}</code>，这条定义是正确的，前提是调用函数这个函数fn时，传入的实参是一个常量。比如<code>fn(3);</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> new_sz() * cnt; &#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> a2[scale(i)]; <span class="comment">//错误，scale(i)不是常量表达式</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>内联函数和constexpr函数通常定义在头文件中。</p>
</blockquote>
<h3 id="调试帮助（P215，6-5-3）"><a href="#调试帮助（P215，6-5-3）" class="headerlink" title="调试帮助（P215，6.5.3）"></a>调试帮助（P215，6.5.3）</h3><p>程序员在写程序时可能涉及到一些调试中的代码，这些代码只在开发程序时使用，当即将发布程序的时候，要暂时屏蔽掉正在调试中的代码。C++提供了<code>assert</code>和<code>NDEBUG</code>两个预处理功能屏蔽测试代码。</p>
<h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><p>assert这个宏定义在<code>cassert</code>头文件中，assert使用一个表达式作为它的条件，形如<code>assert(expr);</code>首先对expr或者表达式求值，如果结果为真（非0），那么assert什么都不做。如果结果为假(表达式值为0)，那么assert输出信息并且终止程序的执行。</p>
<p>assert经常用于处理不能发生的条件，如果你写了一段代码，代码没测试越界，你就可以用assert，当它越界了我们就结束程序的执行。</p>
<h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><p><code>NDEBUG</code>宏定义可以影响assert的行为，这个默认是没被定义的。当我们宏定义了<code>NDEBUG</code>，就屏蔽掉了assert的功能。</p>
<p>可以使用<code>NDEBUG</code>编写自己的调试代码。</p>
<p>此外，IDE还提供了<code>__FILE__</code>(这里是两个英文下划线，这个存放文件名) 、<code>__func__</code>（这个存放所在的函数名) 、 <code>__LINE__</code>（这个存放所在的行数) 、<code>__TIME__</code>（这个存放调试的时间) 、 <code>__DATE__</code>（这个存放调试的日期) 这五种静态数组来提供错误信息。</p>
<h2 id="函数匹配（P217，6-6）"><a href="#函数匹配（P217，6-6）" class="headerlink" title="函数匹配（P217，6.6）"></a>函数匹配（P217，6.6）</h2><p>程序员定义重载函数之后就可以使用它们了，挑选到底使用哪个版本的函数是一个过程，这个过程叫做函数匹配。</p>
<ol>
<li>函数匹配的第一步是在调用时先找与与调用函数同名的函数名。且调用点在函数作用域内。这一步筛选出的函数叫做<strong>候选函数</strong>。</li>
<li>函数匹配的第二步是从候选函数中选择出能够被本次函数调用的实参传入的函数，函数名一致的前提下还要求函数的形参个数和实参一致，实参能够转化成（或者就是）形参规定的类型。这一步筛选出的函数叫做<strong>可行函数</strong>。</li>
<li><strong>寻找最佳匹配。</strong>当<code>有int fn(int a);</code>和<code>int fn(double a,double b=1.0)</code>时，我们调用函数fn形如<code>fn(3.4);</code>显然这两种函数都是可行函数，这是我们再寻找最佳的匹配，因为<code>fn(3.4);</code>对应<code>fn(double,double=1.0);</code>的话无需转化，因此是最佳匹配。当有多个最佳匹配的时候函数将停止调用。</li>
</ol>
<p>为了划分最佳匹配的各种情况，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示：</p>
<ol>
<li>精确匹配：<br>精确匹配可以包含以下情况：数组名转化成数组指针的匹配，函数类型转换成函数指针的匹配，实参类型与形参类型相同。另外，像实参添加顶层const或者忽略实参赋值给形参的顶层const也属于精确匹配。</li>
<li>通过指针的转换把非常量指针转换成常量指针。</li>
<li>通过类型提升实现的匹配。</li>
<li>通过算数类型转换或指针转换实现的匹配</li>
<li>通过类类型转换实现匹配（类类型转换还没有讲）</li>
</ol>
<p>要注意小整数字面值会被自动转换成int，而带小数点的字面值会被默认转换成doube。</p>
<h2 id="函数指针（P221，6-7）"><a href="#函数指针（P221，6-7）" class="headerlink" title="函数指针（P221，6.7）"></a>函数指针（P221，6.7）</h2><p>声明一条函数指针的语句如下: <code>int (*PtrOfFunc)(参数列表)</code>，其中<code>PtrOfFunc</code>就是<strong><font color="00A00A">指向函数的指针</font></strong>。我们可以把函数名赋值给定义的函数指针的名字。</p>
<blockquote>
<p><code>*PtrOfFunc</code>两端 的括号不能少。</p>
</blockquote>
<p>返回函数指针的形参定义为<code>double(*fn(int a)) (int d,char b);</code>这里声明的函数是fn，函数的形参是<code>int a</code>，返回值是函数指针类型的，返回的函数指针对应的函数的返回类型是double，参数是int d,char b。</p>
<p>和处理数组一样，我们也可以<strong>使用尾置</strong>返回来返回一个函数指针，尾置返回函数指针的声明是<code>auto fn(int a)-&gt;double (*)(int d,char b);</code>尾置返回适合用来返回复杂的类型比如数组，函数指针等等。</p>
<p>遇到<code>double(*fn(int a)) (int d,char b);</code>这种复杂的表达式，应该以定义的变量名为中心，从里往外一层层往外扩展。这个函数的定义语句里面，fn就是其中的变量名，看它右侧，有<code>（int a）</code>,这（<code>int a）</code>是一个形参列表。因此得出结论fn的本质是一个函数，再看左侧，<code>*</code>代表这个函数返回一个指针，这个指针的类型在更外层<code>（double (*) (int d,char b)）</code>型。</p>
<p>当然这种声明/定义容易让人心累，所以这种情况下使用<code>auto fn(int a)-&gt;double (*)(int d,char b)</code>是不错的选择。如果这样还是觉得太长了，可以使用typdef，USING等重命名语句加上decltype推导。比如<code>tpyedef double func (int d,char b);</code>这样的语句之后，func就是一个函数类型。</p>
<p>也可以使用<code>tpyedef decltype(fn) func2;</code>这条语句等价于上面的语句。<br>对于using语句，<code>using Func2 = double (int d,char b);</code>即可。<br>可见typedef和using的替换原则是不同的，在涉及到复杂类型的时候，类似数组，函数指针，tpyedef的替换名要和被替换的类型一起被声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//F是函数类型，不是指针</span></div><div class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*) (<span class="keyword">int</span> *, <span class="keyword">int</span>); <span class="comment">// PF是指针类型</span></div><div class="line"></div><div class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针。</span></div><div class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//错误，F是函数类型，f1不能返回一个函数</span></div><div class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//正确，显式地指定返回类型是指向函数的指针。</span></div><div class="line"></div><div class="line"><span class="comment">// 当然也可以使用下面的形式直接声明f1</span></div><div class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span> *, <span class="keyword">int</span>);</div></pre></td></tr></table></figure>
<h2 id="术语表-P225"><a href="#术语表-P225" class="headerlink" title="术语表(P225)"></a>术语表(P225)</h2><p>1.函数 function<br>2.形参 parameter<br>3.调用运算符（一个动作） call operator<br>4.实参 argument<br>5.主调函数 calling function<br>6.被调函数 called function<br>7.生命周期 lifetime<br>8.局部变量 local variable<br>9.自动对象 automatic object<br>10.局部静态对象 local static object<br>11.函数原型 function prototype<br>12.分离式编译 separate compilation<br>13.可执行文件 executable file<br>14.引用传递 passed by reference<br>15.传引用调用 called by reference<br>16.值传递 passed by value<br>17.传值调用 called by value<br>18.重载 overloaded<br>19.函数匹配 function matching<br>20.重载确定 overloaded resolution<br>21.最佳匹配 best match<br>22.二义性调用 ambiguous call<br>23.默认实参 default argument<br>24.预处理宏 preprocessor marco<br>25.候选函数 candidate function<br>26.可行函数 viable function<br>27.递归循环 recursion loop<br>28.递归函数 recursive function<br>29.尾置返回类型 trailing return type</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>C++ Primer 中文版 第5版</li>
<li><a href="http://blog.csdn.net/sunhero2010/article/details/49760521" target="_blank" rel="external">C++primer第五版第六章学习笔记</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23536587" target="_blank" rel="external">C++Primer第5版学习笔记（六）</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++ Primer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Primer学习笔记：(四/五)表达式和语句]]></title>
      <url>/2018/01/05/CPP_04_05/</url>
      <content type="html"><![CDATA[<p>第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成：</p>
<ol>
<li>表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。</li>
<li>各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。</li>
<li>类型转换，包括隐式和显式两种转换的规则。</li>
</ol>
<a id="more"></a>
<h2 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h2><h3 id="表达式的基本概念-P120，4-1-1"><a href="#表达式的基本概念-P120，4-1-1" class="headerlink" title="表达式的基本概念(P120，4.1.1)"></a>表达式的基本概念(P120，4.1.1)</h3><p>表达式由一个或者多个运算对象组成，多个对象组成表达式时，对象之间用运算符连接形成复杂表达式。</p>
<p>运算符中，需要两个对象和运算符连接形成表达式的这种运算符叫做二元（双目，二目）运算符。</p>
<p>分析一个表达式，必须先了解运算对象的含义、运算符的优先级(precedence)、结合律(associativity)和运算符的求值顺序(order of evaluation)。</p>
<ol>
<li>对于含有子表达式的复杂表达式，应该按照求值顺序，看看应该先求哪一个子表达式的值。</li>
<li>对于不那么复杂的子表达式，应该按照优先级，查看表达式中的每个操作数（对象）应该先跟那一个运算符在一起运算。</li>
<li>如果有优先级相同的运算符同时在同一个运算对象左右，应该按照结合律选定结合顺序是从右向左还是从左向右计算表达式的值。</li>
</ol>
<h3 id="左值和右值-P121，4-1-1"><a href="#左值和右值-P121，4-1-1" class="headerlink" title="左值和右值(P121，4.1.1)"></a>左值和右值(P121，4.1.1)</h3><p><strong>起源</strong>：左值和右值原来是C语言中的概念，特指赋值运算符左右两段的表达式。C语言中，能放在赋值运算符左侧被赋值的对象就是左值，反过来在赋值运算符右侧的对象就是右值。C++中的这两个概念的词义发生了改变。</p>
<p><strong>概述</strong>：可以暂时概述一下C++中左值和右值的概念。从性质上来看，当一个对象做右值时，我们使用的是这个对象的内容（值）；当一个对象做左值时，我们使用的是它对象的身份（在内存中的位置）。</p>
<p><strong>应用</strong>：表达式中有的位置需要的是左值，有的位置需要的是右值。表达式的值本身也有左右的分别。<br><strong>赋值运算符</strong>中左侧操作数和表达式结果都是左值。<br><strong>取地址符</strong>的操作对象是左值，得到的是右值。<br><strong>解引用、下标运算符</strong>的求值结果是左值。<br><strong>decltype</strong>作用于表达式时，如果表达式的结果是一个左值，decltype会返回一个引用类型。</p>
<h3 id="优先级和结合律（P122，4-1-2）"><a href="#优先级和结合律（P122，4-1-2）" class="headerlink" title="优先级和结合律（P122，4.1.2）"></a>优先级和结合律（P122，4.1.2）</h3><p>1.<font color="AA0AA0">优先级</font> 复杂表达式中一个运算对象连接多个不同运算符时，哪个运算符优先级高，就先计算哪个运算符和对象作用后的值。</p>
<p>2.<font color="AA0AA0">结合律</font> 复杂表达式中一个运算对象连接多个优先级相同的运算符时，根据这一优先级对应的结合律，按从右至左或者从左至右的顺序计算表达式的值。</p>
<p>如<code>3+2*4-7；</code>这个表达式是一个复杂表达式，因为表达式里<code>*</code>号优先级比较高，所以先计算<code>2*4</code>，得到<code>3+8-7</code>；得到的新表达式更简洁了，只剩下+-两个符号，这两个符号优先级相同，因此查看这个优先级对应的结合律可知这一级别的符号满足左结合性。因此从左向右计算，得到<code>11-7</code>；进一步得到结果<code>4</code>。</p>
<blockquote>
<p>括号无视优先级和结合律，可以考虑多使用括号。</p>
</blockquote>
<h3 id="求值顺序（P123，4-1-3）"><a href="#求值顺序（P123，4-1-3）" class="headerlink" title="求值顺序（P123，4.1.3）"></a>求值顺序（P123，4.1.3）</h3><p>一个表达式里如果运算对象都是函数返回的，都需要计算求值才知道对象的状态，函数调用符号优先级一致，中间隔着几个优先级低的其他符号连接操作对象，比如<code>int a=f()+g();</code>，这时候是函数f()先被调用还是g()先被调用呢？<font color="AA0AA0">答案是未定义。</font>C++语法没有规定这种情况应该谁先谁后。</p>
<p>就像下面的表达式<code>++i+i++</code>这个表达式中，优先级最高的表达式<code>++i</code>和<code>i++</code>中间隔着优先级低的运算符<code>+</code>，关于<code>++i</code>先计算还是<code>i++</code>先计算，这是<strong>未定义</strong>的，而因为这个表达式先计算<code>++i</code>或先计算<code>i++</code>的结果不同，<strong>所以这条表达式是错误的</strong>。<font color="AA0AA0">一个变量如果在同一个表达式里被多次改变，这个表达式的求值顺序又不一定，就会出现二义性。应该避免这样的写法。</font></p>
<p>目前只有四种运算符明确规定了求值顺序。</p>
<ol>
<li>逻辑运算符<code>&amp;&amp;</code>和<code>||</code>(P126)：这两个运算符先计算左边操作数的值。</li>
<li>条件运算符<code>?:</code>(P137)：条件运算符先计算？前的表达式，并求值，之后对视情况对：左右侧的表达式求值。</li>
<li>逗号运算符<code>，</code>(P140) ：这个运算符的求值顺序是从左至右。</li>
</ol>
<blockquote>
<p>处理复合表达式的两点建议：<br>①拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求；<br>②如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。</p>
</blockquote>
<h3 id="关于运算符，左值和右值的归纳"><a href="#关于运算符，左值和右值的归纳" class="headerlink" title="关于运算符，左值和右值的归纳"></a>关于运算符，左值和右值的归纳</h3><p>本章各种运算符形成的表达式所返回的值的属性和运算符需要的操作数的属性如下：</p>
<ul>
<li>算数/逻辑/位运算符： 操作对象和结果都是右值 </li>
<li>赋值运算符：左侧的操作对象必须是可以修改的左值，右侧的操作对象是右值，返回一个左值。 </li>
<li>递增/递减运算符： 前置版本的++/–返回左值，后置版本的++/–返回右值。操作对象都必须是左值。</li>
<li>箭头成员访问运算符： 作用于指针，表达式结果是一个左值。</li>
<li>点成员访问运算符: 这个成员所属的对象是左值，结果就是左值；这个成员所属的对象是右值，结果就是右值。 </li>
<li>条件运算符： 条件运算符的三个表达式都是左值或者都能转化成左值类型时，结果为左值；否则是右值。</li>
</ul>
<h2 id="算术运算符-P124-4-2"><a href="#算术运算符-P124-4-2" class="headerlink" title="算术运算符(P124, 4.2)"></a>算术运算符(P124, 4.2)</h2><h3 id="除法和取模的结果-（P125，4-2）"><a href="#除法和取模的结果-（P125，4-2）" class="headerlink" title="除法和取模的结果 （P125，4.2）"></a>除法和取模的结果 （P125，4.2）</h3><p>两个非浮点型变量/字面值相除，结果还是原来的类型，不会有原来操作数是整数，运算之后结果是小数的情况。<br>C++11中， 对于<strong>除运算符，结果向零取整（直接切掉小数部分，得到的数就是结果）</strong>。对于<strong>取模运算符，结果的符号和被除数的符号一致</strong>。（之前的语法标准里除法的结果可以选择是否向零取整，求模（模就是余数）运算可选符号）</p>
<blockquote>
<p>(-m)/n = -(m/n); m/(-n) = -(m/n);<br>m%(-n) = m%n; (-m)%n = -(m%n);</p>
</blockquote>
<h2 id="成员访问运算符-P133-4-6"><a href="#成员访问运算符-P133-4-6" class="headerlink" title="成员访问运算符(P133, 4.6)"></a>成员访问运算符(P133, 4.6)</h2><p>点运算符和箭头运算符都可以获取类对象的一个成员，<code>ptr-&gt;mem</code> 等价于 <code>(*ptr).mem</code>。</p>
<p>解引用运算符的优先级低于点运算符，所以<code>(*ptr).mem</code>中的括号不能省略，否则出错。</p>
<h2 id="条件运算符-P134-4-7"><a href="#条件运算符-P134-4-7" class="headerlink" title="条件运算符(P134, 4.7)"></a>条件运算符(P134, 4.7)</h2><p>条件运算符的格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2</div></pre></td></tr></table></figure></p>
<p>条件运算符允许嵌套。</p>
<h2 id="位运算符（P136，4-8）"><a href="#位运算符（P136，4-8）" class="headerlink" title="位运算符（P136，4.8）"></a>位运算符（P136，4.8）</h2><p><code>bitset</code>的标准库类型可以表示任意大小的二进制位集合。</p>
<blockquote>
<p>关于符号位没有明确的规定，因此强烈建议仅将位运算符用于处理无符号类型。</p>
</blockquote>
<p>左移运算符移动二进制数后会在右侧插入零，右移运算符在处理有符号类型的操作数（尤其是带负号的）时具体行为由环境决定。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">～</td>
<td>位求反</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td>右移</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td>位与</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td>位异或</td>
</tr>
<tr>
<td style="text-align:center">&#124;</td>
<td>位或</td>
</tr>
</tbody>
</table>
<blockquote>
<p>【写博客相关】表格中竖号的打法：<code>&amp;#124;</code>，或者中文格式的<code>丨</code>（输入法输入“shu”查找）</p>
</blockquote>
<p>移位运算符（也叫IO运算符）满足左结合律。</p>
<h2 id="sizeof运算符（P139，4-9）"><a href="#sizeof运算符（P139，4-9）" class="headerlink" title="sizeof运算符（P139，4.9）"></a>sizeof运算符（P139，4.9）</h2><p>sizeof运算符有两种用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p>
<p>第一种是sizeof后面直接加一条表达式语句；第二种形如<code>sizeof (类型名)；</code>第二种形式后会得到该类对象所占空间的大小。<br>第一种形式中，如果表达式是指针类型，sizeof运算符会返回指针本身的大小。当有一个类名叫data，类中有一个成员叫做student时，可以使用作用域标识符和sizeof联动，使用<code>sizeof(data::student);</code>就可以计算出student占字节数。</p>
<h3 id="隐式类型转换（P141，4-11）"><a href="#隐式类型转换（P141，4-11）" class="headerlink" title="隐式类型转换（P141，4.11）"></a>隐式类型转换（P141，4.11）</h3><p>概述：在C++中，一些类型可以按照一定规则互相转换，很多时候语境中需要使用两个或多个相同的类型才能继续运算。因此这时一种类型的值会被自动转换成另一个类型的值。这个过程就是隐式转换，其中算术隐式转换较为常见。</p>
<p>主要的隐式转换发生的情况：</p>
<ol>
<li>大多数表达式中，比int小的类型会被提升为int型。</li>
<li>在条件中，非布尔值要转化成布尔值。</li>
<li>在初始化和赋值语句中，赋值符号的右侧对象的类型转换成左侧对象的类型进行运算。</li>
<li>算术/关系运算中对象有有多种类型的，转化成同一类型。</li>
<li>形参转化为实参的类型（第六章）。</li>
<li>数组名会被转换为指针。</li>
<li>0，nullptr会转为任何类型的指针。任何类型的指针都可以转化为（const）void *类型。</li>
</ol>
<p>算数转换时发生隐式转换的补充：<br>在算术运算符的作用下，不同的操作数要转换成同一个类型才能够进行计算。以<code>i+a；</code>这个表达式举例，了解算术转换的方式。</p>
<ol>
<li>首先，当i和a的类型占字节比int小，如<code>char、short</code>，把他们转换为int型。如果他们原来类型的最大值在当前系统里大于int型最大值，则转化成<code>unsigned int</code>型。</li>
<li>之后，如果i和a的类型相同，结束算数隐式转换，若i和a的类型不同，把占字节少的类型的对象转成占字节多的类型的对象。</li>
<li>如果占字节多的带符号类型的最大值小于占字节少的带转换对象的最大值，带符号类型将被转换为无符号类型。</li>
</ol>
<h3 id="显式转换（P144，4-11-3）"><a href="#显式转换（P144，4-11-3）" class="headerlink" title="显式转换（P144，4.11.3）"></a>显式转换（P144，4.11.3）</h3><p>显式转换就是强制类型转换(cast)。</p>
<p>一个命名的强制类型转换具有以下形式：<code>cast-name&lt;要转换成的类型&gt; （被转换的值）；</code>其中，cast-name是四种强制类型转换：<code>static_cast、dynamic_cast、const_cast</code>和<code>reinterpret_cast</code>之中的一种。</p>
<ul>
<li><code>static_cast</code>用于常见的强制类型转换。只要两个类型有关联，比如浮点数类型和整数类型，整数类型和布尔值类型，布尔值类型和指针类型，就可以使用static_cast。只是不能转换常量const到变量。</li>
<li><code>const_cast</code>用于去掉（或者加上）对象的底层const，要转换的类型和转换的类型都必须是指针或者引用类型。常用于将在第六章介绍的函数重载。当然，这个重载只能针对指针或者引用类型。</li>
<li><code>reinterpret_cast</code>依赖机器，是强行改变一个类型到另外一个不相干的类型。</li>
<li><code>dynamic_cast</code>支持运行时类型识别，在19章(P730)将会提到。</li>
</ul>
<blockquote>
<p>建议：避免强制类型转换。</p>
</blockquote>
<h2 id="运算符优先级列表的规律（P147-4-12）"><a href="#运算符优先级列表的规律（P147-4-12）" class="headerlink" title="运算符优先级列表的规律（P147,4.12）"></a>运算符优先级列表的规律（P147,4.12）</h2><p>优先级和结合性是第四章的重要内容，因此第四章之后给出了完整的优先级和结合性的参考表。这里是有一定的规律的。</p>
<ol>
<li>首先优先级最高的运算符都有这样的属性：单独拿出这个运算符左面的操作数和右面的操作数都没有意义。即运算符本身是连接两个名字组合一个概念的连接器。比如优先级最高的运算符::（作用域运算符），优先级比较高的点运算符（成员选择）下标运算符[]。</li>
<li>比连接不同名字形成概念的这种运算符稍微低一级别的就是计算对象本身的运算符，比如++，–，类型转换，位求反，逻辑非，解引用，取地址，求类型占的字节数这些运算符大多都是单目元素符，他们的运算目的一般是根据操作数本身的属性进行计算或者改变操作数本身。</li>
<li>算术运算符。</li>
<li>逻辑运算符。</li>
<li>条件运算符。</li>
<li>赋值运算符 。</li>
<li>复合赋值，抛出异常，逗号运算符等。</li>
</ol>
<h2 id="术语表-P149"><a href="#术语表-P149" class="headerlink" title="术语表(P149)"></a>术语表(P149)</h2><p>1.运算对象 operand<br>2.结果 result<br>3.一元运算符 unary operator<br>4.二元运算符 binary operator<br>5.优先级 precedence<br>6.结合律 associativity<br>7.求值顺序 order of evaluation<br>8.提升 promoted<br>9.重载运算符 overloaded operator<br>10.右值 rvalue<br>11.左值 lvalue<br>12.复合表达式 compound expression<br>13.短路求值 short-circuit evaluation<br>14.高位 high order position<br>15.逗号运算符 comma operator<br>16.相互转换 conversion<br>17.隐式转换 implicit conversion<br>18.算术转换 arithmetic conversion<br>19.整型提升 intergral promotion<br>20.运算对象 operand</p>
<h2 id="语句简介"><a href="#语句简介" class="headerlink" title="语句简介"></a>语句简介</h2><p>第五章是和语句有关的知识，语句也是C++的重要组分，本章由三部分组成：</p>
<ol>
<li>语句的概念，包括简单语句和语句作用域的概念。</li>
<li>条件/循环/跳转语句,条件语句主要包括if/else语句、switc语句和？：表达式条件语句；循环语句则是for语句和while语句；跳转语句包括continue、break和goto语句。</li>
<li>try/throw和异常处理，包括异常处理的使用方法。</li>
</ol>
<h2 id="语句作用域（P155，5-2）"><a href="#语句作用域（P155，5-2）" class="headerlink" title="语句作用域（P155，5.2）"></a>语句作用域（P155，5.2）</h2><p>用花括号括起来的块就是作用域的标志。在作用域中定义的对象只在作用域中起作用。块之外是没法访问和控制块内部的变量的。</p>
<p>尤其是在switch语句中，switch的执行过程可能跨过一些标签，当标签里声明并定义了一个对象，这个对象的作用域就延伸到了所有case标签里，如果case 1定义了int a；switch执行了case2，这时这个我们不想执行的语句却产生了自己的作用域，这显然是不行的。因此可以在case标签后使用大括号形成块，这样就不会出现作用域的问题。</p>
<p>goto也一样不能向前（代码的后几行）跳过对象的定义。不允许跨过变量的定义到达变量的作用域内。但是goto语句可以向后（代码的前几行）跳过定义。</p>
<blockquote>
<p>不要在程序中使用goto语句，它会使得程序既难理解又难修改。</p>
</blockquote>
<h2 id="try语句块和异常处理（P172，5-6）"><a href="#try语句块和异常处理（P172，5-6）" class="headerlink" title="try语句块和异常处理（P172，5.6）"></a>try语句块和异常处理（P172，5.6）</h2><p>可以用try\throw和catch联动进行异常处理，形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;待检测块&#125; <span class="comment">//待检测块里面包括throw语句来抛出异常</span></div><div class="line"><span class="keyword">catch</span> (异常类型 异常对象的对象名)</div><div class="line">&#123;异常处理语句 &#125;</div><div class="line"><span class="keyword">catch</span> （同上，可以写很多<span class="keyword">catch</span>）</div><div class="line">&#123;另一组异常处理语句&#125;</div></pre></td></tr></table></figure></p>
<p>throw抛出异常和catch处理异常的头文件都在<code>stdexcept</code>里定义。抛出异常的语句形如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> 异常类型（<span class="string">"异常文本"</span>）；</div></pre></td></tr></table></figure></p>
<p>异常类型一般只支持赋值，初始化，调用成员函数.what之类的几种操作。</p>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.控制流 flow-of-control<br>2.表达式语句 expression statement<br>3.空语句 null statement<br>4.复合语句 compound statement<br>5.悬垂else dangling else<br>6.case标签 case label<br>7.引发（异常） raise<br>8.catch子句 catch clause<br>9.异常处理代码 exception handler<br>10.异常安全（这不是特别安全的意思，而是在异常情况下也能保证程序执行预期的正确行为） exception safe</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>C++ Primer 中文版 第5版</li>
<li><a href="https://zhuanlan.zhihu.com/p/23535827" target="_blank" rel="external">C++Primer第5版学习笔记（四、五）</a></li>
<li><a href="https://www.zhihu.com/question/37542455" target="_blank" rel="external">用Markdown写Hexo博客时如何转义竖杠 | ？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++ Primer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Primer学习笔记：(三)字符串、向量和数组]]></title>
      <url>/2018/01/04/CPP_03/</url>
      <content type="html"><![CDATA[<p>第三章主要讲这么五个概念：</p>
<p>1.<strong>using声明</strong>，我知道挺多同学写代码练手都要在源文件前几句直接加using namespace std;然而using语句并不是什么情况都这么使用的，稍后我们将会看到详细的用法。</p>
<p>2.<strong>标准库类型string</strong>,和C的字符数组有区别的string，到底是怎么个构造，这章将会讲述。</p>
<p>3.<strong>标准库类型vector</strong>，vector和数组区别很大，这里将会提到，并引入一个“容器”的重要概念。</p>
<p>4.<strong>迭代器</strong>，迭代器用来代替下标这种传统方式访问容器或一些支持迭代器的类型。</p>
<p>5.<strong>数组和多维数组</strong>，经典概念。</p>
<a id="more"></a>
<h2 id="命名空间的using声明-P75-3-1"><a href="#命名空间的using声明-P75-3-1" class="headerlink" title="命名空间的using声明(P75,3.1)"></a>命名空间的using声明(P75,3.1)</h2><p>尽管我们可以在各种文件里都使用<code>using namespace std;</code>或者<code>using std::endl;</code>这种语句，但是，在头文件包含命名空间可能产生各种意外。因此，头文件不应包含using声明。</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>本节介绍最常用的操作，<em>9.5</em>节将介绍另外的。</p>
<h3 id="定义和初始化string对象-P76-3-2-1"><a href="#定义和初始化string对象-P76-3-2-1" class="headerlink" title="定义和初始化string对象(P76,3.2.1)"></a>定义和初始化string对象(P76,3.2.1)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div></pre></td></tr></table></figure>
<p>以下几种初始化语句被string支持：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s1;<span class="comment">//创建了一个空的字符串，对象名为s1，类型为string类型。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//是s2的值与s1的值相等。</span></div><div class="line"><span class="built_in">string</span> s2=s1;<span class="comment">//同上一句，拷贝初始化。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;<span class="comment">//直接用字符串字面值初始化string类型的对象。</span></div><div class="line"><span class="built_in">string</span> s3=<span class="string">"value"</span>;<span class="comment">//字符串字面值转化为string类型变量并赋值给string。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//直接初始化string，操作后s4拥有10个字符，每个字符的值都是'c'。</span></div></pre></td></tr></table></figure>
<p>最后，其实<code>string s5={&quot;value&quot;}</code>和<code>string s3=&quot;value&quot;</code>一样，也是合法的。不过<strong>大括号初始化是严格检测匹配的</strong>，比如<code>int a={3.5};</code>就是错误的。</p>
<h3 id="string支持的操作-P77-3-2-2"><a href="#string支持的操作-P77-3-2-2" class="headerlink" title="string支持的操作(P77,3.2.2)"></a>string支持的操作(P77,3.2.2)</h3><h4 id="1-输入流中获取字符串"><a href="#1-输入流中获取字符串" class="headerlink" title="1.输入流中获取字符串"></a>1.输入流中获取字符串</h4><p>首先要强调是<code>cin&gt;&gt;string</code>的操作，这种操作就是从输入流中读字符串，值得注意的是这个过程会忽略掉开头输入的各种空白（我们说空白时是在说 <font color="00aa00"> <strong>空格，换行符，制表符</strong></font>）,读取输入流直到遇到字符后的第一个空白为止。</p>
<p>另一种<code>getline（cin,string）;</code>的操作(P78) 则可以读一行，也就是读入输入流的数据（包括空格，制表符），直到遇到<font color="00aa00"><strong>换行符</strong></font>为止，这里输入流中的换行符本身已经被读过了，但是字符串里不保存这个换行符。下次再从输入流里读什么数据至少也要从这个换行符后面对输入流进行操作了。</p>
<h4 id="2-string-type-size-P79"><a href="#2-string-type-size-P79" class="headerlink" title="2.string::type_size (P79)"></a>2.string::type_size (P79)</h4><p>为了更抽象，脱离机器特性，调用每个string对象的<strong>size成员函数</strong>，返回值都是一个<strong><code>string::type_size</code></strong>类型，这个类型拥有无符号整形数的一些性质。在string对下标的支持中，[ ]中的数字也会被转换为<code>string::type_size</code>类型。这里要强调的是<code>string::type_size</code>是一个<font color="00aa00"><strong>无符号类型</strong></font>。使用这个类型和int型这种有符号的类型一起进行计算可能出现一些错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> len = line.size(); <span class="comment">//len的类型是string::size_type</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果一个表达式中已经有了<code>size()</code>函数，就不要再使用<code>int</code>了，这样可以避免混用<code>int</code>和<code>unsigned</code>可能带来的问题。</p>
</blockquote>
<h4 id="3-string对象与字符串字面值相加-P80"><a href="#3-string对象与字符串字面值相加-P80" class="headerlink" title="3.string对象与字符串字面值相加 (P80)"></a>3.string对象与字符串字面值相加 (P80)</h4><p>字符串字面值是字符数组类型，字符串字面值和string类型的对象在一起计算时会被自动转换为string类型。</p>
<h4 id="4-其他支持的操作"><a href="#4-其他支持的操作" class="headerlink" title="4.其他支持的操作"></a>4.其他支持的操作</h4><p>包括下标运算符[ ]、重载的+、==、！=、&lt;、&gt;、&lt;=、&gt;=。</p>
<h3 id="处理每个字符的头文件cctype（P82-3-2-3）"><a href="#处理每个字符的头文件cctype（P82-3-2-3）" class="headerlink" title="处理每个字符的头文件cctype（P82, 3.2.3）"></a>处理每个字符的头文件cctype（P82, 3.2.3）</h3><p>我们可以通过引用头文件<code>&lt;cctype&gt;</code>的形式处理每一个字符。这个头文件包含很多方便处理字符的函数。列举如下：</p>
<ul>
<li>isalnum(c); //当c是字母或者数字时为真 </li>
<li>isalpha(c); //当c是字母时为真</li>
<li>iscntrl(c); //当c是控制字符时为真</li>
<li>isdigit(c); //当c是数字时为真</li>
<li>isgraph(c); //当c不是空格但是可打印时为真</li>
<li>islower(c); //当c是小写字母为真</li>
<li>isprint(c); //当c可打印时为真 </li>
<li>isupper(c); //当c是大写字符时为真</li>
<li>isxdigit(c); //当c是16位数字时为真</li>
<li>ispunct(c); //当c是标点符号时为真（一个字符除了控制字符，字母，数字，可打印空白就是标点符号）</li>
<li>isspace(c); //当c是空白时为真（空白包括空格，横向/纵向制表符，回车符，换行符，进纸符）</li>
<li>tolower(c); //把大写字符转换为小写字符，本来就是小写字符的不变，返回转换后的字符</li>
<li>toupper(c); //把小写字符转换为大写字符，本来就是大写字符的不变，返回转换后的字符</li>
</ul>
<blockquote>
<p>建议：使用C++版本的C标准库头文件。<br>C++标准库兼容了C语言的标准库。C语言的头文件形如<code>name.h</code>，C++则会将这些文件命名为<code>cname</code>。也就是去掉了<code>.h</code>后缀，在文件名前添加了字母c。</p>
</blockquote>
<h3 id="范围for（range-for）语句-P82，3-2-3"><a href="#范围for（range-for）语句-P82，3-2-3" class="headerlink" title="范围for（range for）语句(P82，3.2.3)"></a>范围for（range for）语句(P82，3.2.3)</h3><p><strong>范围for语句用于遍历元素</strong>。形如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(一个用于访问序列中基础元素的变量a : 被访问的序列对象b)&#123;</div><div class="line">    statement..... blabla;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首次初始化，变量a的值会被初始化为对象b序列中的第一个元素，迭代之后每次访问下一个元素，直到序列被完全访问结束。</p>
<p>可以使用<code>auto &amp;a</code>的方式声明变量a,使变量绑定到具体的序列元素上，从而进行更改。如在<code>for(auto a : str){}</code>中，每次把a初始化的行为实质上是使a获得str每个元素的副本（拷贝），而<code>for(auto &amp;a ： str){}</code>这样的语句则使a成为了str对应的每个元素的”别名”,从而可以修改str。</p>
<p>使用范围for循环遍历多维数组，为了不手动打类名，也为了防止外层数组的名被auto类型转化成指针，要在对外层数组的访问上都加上&amp;绑定。</p>
<blockquote>
<p>范围for有空补，未详看。</p>
</blockquote>
<h2 id="标准库类型vector-P86-3-3"><a href="#标准库类型vector-P86-3-3" class="headerlink" title="标准库类型vector(P86, 3.3)"></a>标准库类型vector(P86, 3.3)</h2><h3 id="类模板、容器和实例化-P87-3-3"><a href="#类模板、容器和实例化-P87-3-3" class="headerlink" title="类模板、容器和实例化(P87, 3.3)"></a>类模板、容器和实例化(P87, 3.3)</h3><p>当我们在C++里面谈论容器这个概念时，我们应该知道容器是用来存储和组织一类特定对象的集合。下面提到的标准库类型<code>vector</code>，就是一个容器。</p>
<p>类模板一般用于按照模板规定好的规则生成不同的类。我们无需很麻烦的一个一个写类的定义，只需使用模板，给出指定的少量信息，类模板就会帮助我们自动生成一个我们可以直接使用的类。vector也是一个类模板。</p>
<p>通过类模板创建类的过程，或者通过类型创建对象的过程，就叫做<strong>实例化</strong>。</p>
<h3 id="定义和初始化vector对象-P87-3-3-1"><a href="#定义和初始化vector对象-P87-3-3-1" class="headerlink" title="定义和初始化vector对象(P87,3.3.1)"></a>定义和初始化vector对象(P87,3.3.1)</h3><p>与string的定义和初始化一样，我们也可以使用多种方式定义和初始化一个vector对象。</p>
<p>以下几种初始化语句被vector支持：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v1;<span class="comment">//创建了一个空的vector容器，这个容器是Type类型对象的集合，这个集合名字叫做为v1，执行默认初始化。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v2(v1);<span class="comment">//创建了一个叫做v2的vector容器，这个容器的内容和v1相同。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v2=v1;<span class="comment">//同上一句，拷贝初始化。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v3&#123;a,b,c,...&#125;;<span class="comment">//v3包含了初始值个数的元素。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v4=&#123;a,b,c,...&#125;;<span class="comment">//同上。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v5(n,val);<span class="comment">//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都是val。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v5(n);<span class="comment">//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都被默认初始化。</span></div></pre></td></tr></table></figure>
<p>当我们使用圆括号<code>（）</code>初始化对象时，IDE会认为我们在通过语句<code>“构建”</code>(constract)这个对象 ；当我们使用花括号<code>{ }</code>初始化对象时，IDE会认为我们在列表初始化(list initialize)对象。</p>
<p>当我们使用等号=初始化对象时，我们就执行了“拷贝初始化”；当我们不使用=初始化对象时，我们就执行了“直接初始化”。</p>
<p>但是当我们在花括号里面给一个不符合对象类型的值，IDE就会认为我们正在<strong>构建而非初始化对象</strong>，一个体现就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>这个语句中，10不能转换为string，因此被系统理解为“这个string容器里有10个元素”。<br>当然，像<code>vector &lt;string&gt;s1={10};</code>这样的语句是错误的，因为=就应该是拷贝初始化了，然而10并不能够被转化为string因此也无法赋值。</p>
<h3 id="向vector对象添加元素-P90-3-3-2"><a href="#向vector对象添加元素-P90-3-3-2" class="headerlink" title="向vector对象添加元素(P90, 3.3.2)"></a>向vector对象添加元素(P90, 3.3.2)</h3><font color="000aa0"><br>向vector对象添加元素：<strong>push_back</strong>。<br></font>

<blockquote>
<p>循环体内部包含向vector对象添加元素时，则不能使用<strong>范围for循环</strong>。</p>
</blockquote>
<h3 id="vector支持的操作-P91-3-3-3"><a href="#vector支持的操作-P91-3-3-3" class="headerlink" title="vector支持的操作(P91, 3.3.3)"></a>vector支持的操作(P91, 3.3.3)</h3><ol>
<li><p>向容器的后面添加元素：已存在<code>vector&lt;T&gt; v;</code>，可以使用 <code>v.push_back(vector&lt;T&gt; a)</code>的方式在集合v的尾部添加元素。</p>
</li>
<li><p><code>empty</code>和<code>size</code>函数成员：已存在<code>vector&lt;T&gt; v;</code>，可以使用 <code>v.empty()</code>的方式判断v是否为空，可以使用<code>v.size()</code>的方式返回v的大小。</p>
</li>
<li><p>重载的运算符：vector支持的运算符包括下标运算符<code>[ ]</code>、重载的+、<code>==、！=、&lt;、&gt;、&lt;=、&gt;=</code>。这一点和<code>string</code>类似。</p>
</li>
</ol>
<blockquote>
<p>不能用下标形式添加元素。<br>只能对确知已存在的元素执行下标操作！</p>
</blockquote>
<h2 id="迭代器介绍-3-4"><a href="#迭代器介绍-3-4" class="headerlink" title="迭代器介绍(3.4)"></a>迭代器介绍(3.4)</h2><p>为了访问容器的元素（有些容器可能不支持下标运算符），因此C++提供了迭代器(iterator)这个概念来访问容器中的指定元素。</p>
<p>支持迭代器的类都会提供名为begin和end的函数成员来供我们获取迭代器。如已定义<code>vector&lt;int&gt; i1(10);</code>，这时使用<code>auto ben=i1.begin();</code>这个语句获取指向第一个字符的迭代器，使用<code>auto end=i1.end();</code>获取指向i1容器最后一个元素的下一个元素的迭代器，术语“尾后迭代器”。两个迭代器可以相减，但是两个迭代器相加后的行为是未定义的。</p>
<p>当使用<code>vector &lt;int&gt;</code>创建类时，这个类的命名空间就是<code>vector &lt;int&gt;</code>，命名空间中的迭代器类型写作<code>vector&lt;int&gt;::iterator</code>。因为这个叫做<code>&quot;vector&lt;int&gt;::iterator&quot;</code>的迭代器类型名太长了也不好记，这里我们使用<code>auto</code>推导这个类型。用成员函数<code>cbegin</code>和<code>cend</code>可以推导出底层const迭代器，就是这个迭代器对迭代器指向的内容只读不写。第6章会详细说明。</p>
<p>迭代器 对 迭代器指向的容器内容 可以像 指针 对 指针指向的数组元素一样使用。</p>
<p>虽然数组不是直接支持迭代器的类型，但是可以引入<code>&lt;iterator&gt;</code>头文件，使用<code>begin(数组名)</code>和<code>end(数组名)</code>的方式获得指向数组第一个元素和尾后第一个元素的指针。因为大多数容器不支持下标运算符，所以使用迭代器访问容器等结构中的元素是最好的方法。</p>
<h2 id="数组-3-5-P101"><a href="#数组-3-5-P101" class="headerlink" title="数组(3.5, P101)"></a>数组(3.5, P101)</h2><h3 id="一维数组的定义和初始化-3-5-1-P102"><a href="#一维数组的定义和初始化-3-5-1-P102" class="headerlink" title="一维数组的定义和初始化(3.5.1,P102)"></a>一维数组的定义和初始化(3.5.1,P102)</h3><p>一维数组声明形式：<code>类型名 数组名[一个常量]</code>。比如<code>int a[15];</code>这里这个数组的名字是a，有15个元素，每个元素都是int型的。再比如<strong><code>int *a[15];</code></strong>这里<strong>a数组的15个元素都是<code>int *</code>型的，即指向int的指针</strong>，这样的指针有15个，构成了一个数组。虽然有指针数组，但是不存在元素都是引用类型的数组。</p>
<p>一维数组的初始化方式就是花括号初始化，形如<code>int a[n]={1,2,3};</code>，大括号里面的内容就是初始化列表，n为数组大小，可以缺省，缺省时数组长度由初始化列表的元素个数决定。当初始化列表的值的个数比数组长度小，数组剩下的元素被初始化为默认的值，比如对于有10个元素的int型数组，如果只给出第一个元素的值，后几个元素将被初始化为0。</p>
<p>当我们声明<code>int a[]</code>的时候代表通过数组名a访问这个数组。<br>我们也可以定义指向数组的指针和指向数组的引用来间接访问这个数组。<br>已有<code>int arr[10];</code>的情况下，<code>int (*ptr) [10]=&amp;arr;</code>这条语句可以使指针ptr指向arr这整个数组。<code>int (&amp;ref)[10]=arr;</code>则会使ref作为整个arr数组的引用。<code>int *(&amp;ref)[10]=arr;</code>这个语句则是说ref是arr的引用，这个被引用的数组的类型是指针数组。</p>
<p><code>auto a=一个数组名</code>，a的类型将会是这个指针，指针指向的类型就是数组元素的类型。<br>用<code>decltype(一个数组名) a;</code>这样的形式，a将会是和数组名属性一致的数组。<br>在大部分运算中，数组名都会被转化成相应的指针类型。如<code>*(ai+4)</code>中，数组名ai是指向整个数组首元素的指针，这个指针＋4就是向右侧移动4位，指针原来指向第一个元素，移动4位就指向了数组中的第五个元素。然后指向的值就是ai数组第五个元素的值，相当于ai[4]。</p>
<h3 id="用数组初始化vector对象和用string对象赋值字符数组-3-5-5-P111"><a href="#用数组初始化vector对象和用string对象赋值字符数组-3-5-5-P111" class="headerlink" title="用数组初始化vector对象和用string对象赋值字符数组(3.5.5, P111)"></a>用数组初始化vector对象和用string对象赋值字符数组(3.5.5, P111)</h3><p>作为与旧代码的接口，C++提供了方便的把数组转化为vector对象的方法。在声明vector对象时，我们可以通过迭代器用一个数组初始化vector。<br>在已经存在<code>int oldarray[10];</code>的情况下，声明的语句形如：<code>vector&lt;int&gt; arr( begin(oldarray) , end(oldarray) );</code>可以把arr初始化为oldarray。begin和end这两个函数在<code>&lt;iterator&gt;</code>头文件里，作用是返回数组的首元素/尾后指针。这种初始化接受两个参数：拷贝开始部分指针和结束部分的指针。<br>我们也可以写形如<code>int arr[10]={0}; vector &lt;int&gt; newarr( arr+1 , arr+6 );</code>这种方式拷贝数组arr的第2~第5号元素，并用它们初始化newarr。</p>
<p>类似地，我们可以通过<code>string a(&quot;23333333\n&quot;); const char *b=a.c_str();</code>这样的语句使string型的a被赋值给字符数组指针b。返回结果是const是为了确保我们不会通过这个指针改动返回的字符数组的值。</p>
<blockquote>
<p>建议： 尽量使用标准库类型而非数组</p>
<p>使用指针和数组容易出错。现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</p>
</blockquote>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.拷贝初始化 copy initialization<br>2.直接初始化 direct initialization<br>3.范围for range for<br>4.容器 container<br>5.类模板 class template<br>6.实例化 instantiation<br>7.值初始化 value-initialized<br>8.构造 construct<br>9.列表初始化 list initialize<br>10.迭代器 iterator<br>11.迭代器运算 iterator arithmetic<br>12.C风格字符串 C-style character string<br>13.空字符 null terminated<br>14.缓冲区溢出 buffer overflow<br>15.编译器扩展 complier extension</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>C++ Primer 中文版 第5版</li>
<li><a href="https://zhuanlan.zhihu.com/p/23503699" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23503699</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> C++ Primer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> string </tag>
            
            <tag> vector </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[西瓜书《机器学习》学习笔记(2)：比较检验与偏差方差]]></title>
      <url>/2018/01/04/ML_chap2_02/</url>
      <content type="html"><![CDATA[<p>本篇主要介绍比较检验、偏差与方差。<br>其中，比较检验分为如下四类：</p>
<ul>
<li>假设检验</li>
<li>交差验证t检验</li>
<li>McNeMar检验</li>
<li>FriedMan检验与Nemenyi后续检验</li>
</ul>
<a id="more"></a>
<h2 id="比较检验-2-4-P37"><a href="#比较检验-2-4-P37" class="headerlink" title="比较检验(2.4, P37)"></a>比较检验(2.4, P37)</h2><p>在比较学习器泛化性能的过程中，<strong>统计假设检验（hypothesis test）</strong>为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。</p>
<h3 id="假设检验-2-4-1-P38"><a href="#假设检验-2-4-1-P38" class="headerlink" title="假设检验(2.4.1, P38)"></a>假设检验(2.4.1, P38)</h3><p>假设检验(Hypothesis Testing)是数理统计学中根据一定假设条件<strong>由样本推断总体</strong>的一种方法。</p>
<p>“假设”指的是对学习器泛化错误率分布的某种判断或猜想，如“$\epsilon = \epsilon_0 $”，现实任务中，我们并不知道学习器的泛化错误率$\epsilon$，但是可以通过测试错误率$\hat \epsilon$推算。</p>
<p>在包含了 m 个样本的测试集上，【泛化错误率为 $\epsilon$ 的学习器】被测得测试错误率为$ \hat \epsilon $的概率为：<br>$$P(\hat\epsilon;\epsilon) = \begin{pmatrix} m \\ \hat\epsilon\times m  \end{pmatrix} \epsilon^{\hat\epsilon\times m}(1-\epsilon)^{m-\hat\epsilon\times m}$$</p>
<blockquote>
<p>上式中的$\begin{pmatrix} m \\ \hat\epsilon\times m  \end{pmatrix} $表示$C_m^{m’}$，即从m个数中任取m’个数。</p>
</blockquote>
<p>这个概率，表达了【泛化错误率为 $\epsilon$ 的学习器】被测得【测试错误率】为 $\hat{\epsilon}$ 的可能性。 $\hat{\epsilon} $取0~100%。若以这个【可以测得的测试错误率$ \hat{\epsilon} $】作为自变量，以概率 $P(\hat{\epsilon};\epsilon) $为因变量，建立平面坐标图，则对于不同的测试错误率，有不同的可能性。在某点可能性越高，这个未知的【泛化错误率$ \epsilon $】和这个点代表的测试错误率的关系就越密切。</p>
<p>现在要找其可能性最高的点，就要对概率$ P(\hat{\epsilon};\epsilon)$ 求 $\epsilon$ 的导数，导数为0时，存在极值。</p>
<p>而对此概率函数求导并解出导函数等于0的式子之后，发现存在一个值 $\epsilon_0$ ，使得$P(\hat{\epsilon};\epsilon)$在$\epsilon=\epsilon_0$时最大，$|\epsilon-\epsilon_0|$ 增大时减小。整个图像其实是个山峰形状，符合二项分布。</p>
<p>那么此时也可以反过来讲，如果这个泛化错误率 $\epsilon$ 已知为 $\epsilon_0$ ，则理论上，横坐标为 $\epsilon_0$的概率值$P(\hat{\epsilon};\epsilon)$是最大的。</p>
<p>即：<strong>若泛化错误率为$ \epsilon_0$ ，则测试错误率也为 $\epsilon_0$ 的概率最大（可能性最高）</strong>。</p>
<p>此时，我们得到了泛化错误率为$ \epsilon_0$，我们可以用这个数值来进行假设，假设这个学习器的泛化错误率不会超过 $\epsilon_0$。</p>
<p>即假设：“$ H_0:\epsilon≤\epsilon_0$ ”。</p>
<p>到底要不要接受这个假设呢？</p>
<p>我们需要检验一下。</p>
<blockquote>
<p>显著度（显著性水平）是估计总体参数落在某一区间内，可能犯错误的概率，用$\alpha$表示。$\alpha$的常用取值很小，如0.05，0.1等。<br>$1-\alpha$则表示置信度(confidence)。</p>
</blockquote>
<p>通过二项检验(binomial test)，我们得到结论：在$\alpha$的显著度下，假设$ H_0:\epsilon≤\epsilon_0$ 不能被拒绝，能<strong>以$1-\alpha$的置信度认为，学习器的泛化错误率不大于$\epsilon_0$</strong>；否则假设被拒绝，即在$\alpha$的显著度下可认为该学习器的泛化错误率大于$\epsilon_0$。</p>
<hr>
<p>现实中我们并非仅作出一次留出法估计，而是做多次，所以会得到不同的多个测试错误率，假定为k个测试错误率： $\hat \epsilon_1$、$\hat \epsilon_2、\cdots 、\hat \epsilon_k$，则平均错误率$ \mu  $和方差$ \sigma^{2}$为：<br>$$\mu = \frac 1k \sum_{i=1}^k\hat \epsilon_i $$<br>$$ \sigma^2 = \frac{1}{k-1} \sum_{i=1}^k (\hat \epsilon_i - \mu)^2$$</p>
<blockquote>
<p>假设X服从标准正态分布N（0,1），Y服从$ \chi^2$分布，那么$ T=X/\sqrt{Y/n}$  的分布称为自由度为n的t分布,记为$T \sim t(n)$。</p>
<p>t分布这边需要一定的数学基础。默默记住吧。</p>
</blockquote>
<p>T 为自由度为 n 的 t 分布，变量 $\tau_{t}=(\sqrt{k}(\mu-\epsilon_0))/\sigma $服从自由度为 k-1 的 t 分布。（ $\mu-\epsilon_{0} $服从正态分布， $\sigma^{2} $服从自由度为 k-1 的$ \chi^2 $分布）</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3pvrkvwjj20em09pjrr.jpg" alt=""></p>
<p>由此图和 t 分布图的性质可知，最高点处就是测试错误率的最大值$\epsilon_0$ 。</p>
<p>现在要重新假设了，“ $H_1:\mu=\epsilon_0 $”。</p>
<p>接下来就是继续确定显著度 $\alpha$ ，确定门槛值（此处用双边假设），最后进行在置信度为 $1-\alpha$ 下的判断了。</p>
<h3 id="交叉验证-t-检验-2-4-2-P40"><a href="#交叉验证-t-检验-2-4-2-P40" class="headerlink" title="交叉验证 t 检验(2.4.2, P40)"></a>交叉验证 t 检验(2.4.2, P40)</h3><p>回顾一下上一篇中的<strong>k折交叉验证</strong>：</p>
<blockquote>
<p>“k折交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$</p>
</blockquote>
<p>如果说前一种的<strong>假设检验是得到单个学习器的泛化错误率的大致范围假设</strong>，那么<strong>“交叉验证t检验”方法就是在比较A、B两学习器性能的优劣</strong>了（不过偏向于验证A、B性能是否相同）。</p>
<p>现在有两个学习器A和B，使用 k 折交叉验证法得到测试错误率分别为 $\epsilon_{1}^{A},\epsilon_{2}^{A},\epsilon_{3}^{A},…\epsilon_{k}^{A}$ 和$\epsilon_{1}^{B},\epsilon_{2}^{B},\epsilon_{2}^{B},…\epsilon_{k}^{B} $。其中$ \epsilon_{i}^{A} $和 $\epsilon_{i}^{B} $是在相同的第 i 折训练/测试集上得到的结果。</p>
<blockquote>
<p>注意，此时的测试错误率和之前的假设检验那一节的测试错误率采用了不同的符号，此时由于没有提到泛化错误率，测试错误率被标记为$ \epsilon $，只不过增加了上下角标，请各位不要将其与上一节的泛化错误率混淆。</p>
</blockquote>
<p>基本思想：若两个学习器的性能相同，则它们使用的训练/测试集得到的测试错误率应相同，即 $\epsilon_{i}^{A}=\epsilon_{i}^{B} $。</p>
<p>实际上却不会像理想状态一样，两个学习器的测试错误率并不完全相同，而是存在一定的微小差值。我们想要判断两个学习器的性能是否有显著差别，就要利用这个差值进行假设检验。</p>
<p>若两个学习器性能相同，这个差值均值应该为0。因此可对这k个差值对“学习器A和B性能相同”这个假设做 t 检验。</p>
<p>1、先对每一对结果求差，$ \Delta_i=\epsilon_{i}^{A}-\epsilon_{i}^{B}$</p>
<p>2、计算出这$k$个差值的均值$ \mu $和方差 $\sigma^2$</p>
<p>3、根据 t 检验的公式$ T=X/\sqrt{Y/n} $，得 $\tau_t=|\frac{\sqrt{k}\mu}{\sigma}|$ ，满足自由度为 k-1 的 t 分布，故在显著度$ \alpha $，若其小于临界值 $t_{\alpha/2,k-1} $，则假设不能被拒绝，即认为两个学习器性能没有显著的差别。反之则认为平均错误率小的性能更优。</p>
<p>这里$t_{\alpha/2,k-1}$ 是分布上尾部累积分布为$\alpha/2$ 的临界值。</p>
<p>但是这样使用 k 折交叉验证法，通常情况下会因为样本有限，使得不同轮次的训练集产生一定程度的重叠。这样训练出来的学习器，会让得出的这组测试错误率无法做到彼此完全独立。</p>
<p>而进行有效的假设检验的一个重要的前提就是：测试错误率均为泛化错误率的独立采样。（例如 t 分布就需要随机变量X和Y相互独立。）</p>
<p>所以为了缓解这个问题，可采用“5×2交叉验证”法。</p>
<h4 id="5×2交叉验证-2-4-2-P41"><a href="#5×2交叉验证-2-4-2-P41" class="headerlink" title="5×2交叉验证(2.4.2, P41)"></a>5×2交叉验证(2.4.2, P41)</h4><p>待补。</p>
<h3 id="McNemar检验-2-4-3-P41"><a href="#McNemar检验-2-4-3-P41" class="headerlink" title="McNemar检验(2.4.3, P41)"></a>McNemar检验(2.4.3, P41)</h3><p>McNemar检验适用于二分类问题，与成对t检验一样也是用于比较两个学习器的性能大小。通过联列，可以获得学习器A和B的分类结果的差别。下表即为两分类器分类差别列联表， e 为样本数。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4g3oembgj20es08474e.jpg" alt="列联表"></p>
<p>主要思想是：若两学习器的性能相同，则A预测正确B预测错误数应等于B预测错误A预测正确数，即$e_{01}=e_{10}$，且$|e_{01}-e_{10}|$符合正态分布。</p>
<blockquote>
<p>$| e_{01}-e_{10}|$为什么符合正态分布？</p>
<p>按理说，实际生活中，凡自然状态下的整体数据分布几乎都符合<strong>正态分布</strong>，那么当假设两学习器性能相同的时候，如果用大量不同的测试集进行测试，这个差值应该就可能符合正态分布。</p>
</blockquote>
<p>McNemar检验考虑变量：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4gg36qwrj209902j3yb.jpg" alt="McNemar检验变量"></p>
<blockquote>
<p>但上式中的“-1”并非因为$ |e_{01}-e_{10}| $的均值 $\mu$ 为1，实际上均值$ \mu $应近似为0，这里的“-1”，是为了<strong>连续性校正</strong>。</p>
<p>什么是连续性校正？$2*2$列联表资料是分类资料,所以样本量较小时要进行连续性校正。。卡方检验要求：最好是大样本数据。一般每个个案最好出现一次，四分之一的个案至少出现五次。如果数据不符合要求，就要应用校正卡方。参见<a href="https://en.wikipedia.org/wiki/McNemar%27s_test#cite_note-Edwards1948-3" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>上述变量$\tau_{\chi^2}$ 符合自由度为1 的$ \chi^2 $分布。</p>
<blockquote>
<p>$ \chi^2 $分布的定义：若k个独立的随机变量$Z_1,Z_2,⋯,Z_k$，且符合标准正态分布$N(0,1)$，则这k个随机变量的平方和 $X=∑_{i=1}^kZ^2_i$为服从自由度为k的卡方分布，记为： $X\sim \chi^2(k)$。<br>卡方分布的期望与方差分为为：<br>$E(\chi^2)=k，D(\chi^2)=2k$，其中k为卡方分布的自由度。</p>
</blockquote>
<p>给定显著度$\alpha $，当上述变量小于临界变量值的时候，不能拒绝假设，即认为两学习器的性能没有显著差别；否则拒绝假设，即认为两者性能有显著差别，平均错误率较小的学习器性能较好。这个过程也是自由度为1 的卡方检验。</p>
<blockquote>
<p>$\chi^2 $检验，中文名为<strong>卡方检验</strong>。卡方检验是一种用途很广的计数资料的假设检验方法。它属于非参数检验的范畴，主要是比较两个及两个以上样本率( 构成比）以及<strong>两个分类变量的关联性分析</strong>。其根本思想就是在于比较理论频数和实际频数的吻合程度或拟合优度问题。</p>
</blockquote>
<h3 id="Friedman检验与Nemenyi后续检验-2-4-4-P42"><a href="#Friedman检验与Nemenyi后续检验-2-4-4-P42" class="headerlink" title="Friedman检验与Nemenyi后续检验(2.4.4, P42)"></a>Friedman检验与Nemenyi后续检验(2.4.4, P42)</h3><p>上述的三种检验（假设检验、交叉验证t检验，McNemar检验）都只能在一组数据集上，Friedman检验则可以在多组数据集进行多个学习器性能的比较，基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予<strong>序值1,2,3…</strong>，相同则平分序值，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4o1uvti5j20h005yglo.jpg" alt=""></p>
<blockquote>
<p>比如：D1数据集上，算法A的性能最好，其次算法B的性能，最差的是算法C的性能。<br>数字越小，代表该算法在该数据集上的表现越好。</p>
</blockquote>
<p><font color="000AA0">Friedman检验</font>：判断算法是否性能都相同。 检验变量$\tau_{\chi^2}$与F检验的临界值进行比较。</p>
<p>若<strong>“H0：所有算法的性能相同”</strong>这个假设被拒绝，则需要进行后续检验(post-hoc test)，来得到具体的算法之间的差异。常用的就是<strong>Nemenyi后续检验</strong>。</p>
<p>Nemenyi检验计算出平均序值差别的<strong>临界值域</strong>，<strong>若两个算法的平均序值差超出了临界值域CD，则相应的置信度1-α拒绝“两个算法性能相同”的假设</strong>。</p>
<p>总结一下多学习器的比较：</p>
<ul>
<li>Friedman + Nemenyi</li>
<li>Friedman 检验(基于序值，F检测，判断“是否都相同”)</li>
<li>Nemenyi 后续检验 (基于序值，进一步判断两两差别)</li>
</ul>
<blockquote>
<p>关于读音：（音译，仅供参考）<br>McNemar：mac呢嘛儿（mac:[mæk]，中文名：麦克尼马尔）<br>Friedman：free的们（free:[fri]，中文名：弗里德曼）<br>Nemenyi：呢曼里(y貌似不发音)</p>
</blockquote>
<h2 id="偏差与方差-2-5-P44"><a href="#偏差与方差-2-5-P44" class="headerlink" title="偏差与方差(2.5, P44)"></a>偏差与方差(2.5, P44)</h2><p>“偏差-方差分解”(bias-variance decomposition)是解释学习算法泛化性能的重要工具。</p>
<ul>
<li>测试样本：x</li>
<li>测试样本x在数据集中的标记： $y_D$</li>
<li>测试样本x的真实标记： y</li>
<li>训练集： D</li>
<li>从训练集 D 上学得的模型f</li>
<li>模型 f 在测试样本x上的预测输出$f(x;D) $</li>
</ul>
<p>根据上述变量，推导出学习算法的期望预测：<br>$$\bar f(x) = \mathbb{E}_D [f(x;D)] $$<br>使用样本数相同的不同训练集产生的<font color="00AA00"><strong>方差</strong></font>为：度量了同样大小的训练集的变动所导致的学习性能的变化，也就是<strong>数据扰动所造成的影响</strong>。<br>$$var(x) = \mathbb{E}_D [(f(x;D)- \bar f (x) )^2] $$</p>
<p><font color="00AA00"><strong>噪声</strong></font>(数据集标记和真实标记的方差)为：当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了<strong>学习问题本身的难度</strong>。<br>$$ \varepsilon^2 =  \mathbb{E}_D [(y_D - y)^2]$$</p>
<p><font color="00AA00"> <strong>Bias（偏差）</strong></font>：期望输出与真实标记的偏离程度，刻画了<strong>学习算法本身的拟合能力</strong>。<br>$$bias^2(x) = (\bar f (x) - y)^2 $$</p>
<p>对回归任务，泛化误差可通过“偏差-方差分解”拆解为：<br>$$E(f;D) = bias^2(x) + var(x) + \varepsilon^2 $$</p>
<p>也就是说，<strong>泛化误差可分解为 偏差、方差与噪声之和</strong>。<br>偏差-方差分解说明，<strong>泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的</strong>。</p>
<p>一般来说，偏差与方差是由冲突的，这称为“偏差-方差窘境”。<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4m77isg5j20k00fvt8z.jpg" alt="偏差-方差窘境"></p>
<p>随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。换句话说：<strong>在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差</strong>。因此训练也不要贪杯，适度辄止。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>周志华《机器学习》</li>
<li><a href="https://zhuanlan.zhihu.com/p/29248751" target="_blank" rel="external">《机器学习》学习笔记与习题探讨（二）④</a></li>
<li><a href="http://blog.csdn.net/bitcarmanlee/article/details/52279907" target="_blank" rel="external">卡方分布与卡方检验</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4a0824490102v8tz.html" target="_blank" rel="external">卡方检验（Chi-square test）和费舍尔精确检验（Fisher exact test）</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Machine Learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[西瓜书《机器学习》学习笔记(1)：评估方法与度量指标]]></title>
      <url>/2018/01/03/ML_chap2_01/</url>
      <content type="html"><![CDATA[<p>笔记直接跳过了第一章，从第二章开始。</p>
<p>本次笔记主要回顾评估方法与性能度量指标。<br><a id="more"></a></p>
<h2 id="经验误差与过拟合-2-1-P23"><a href="#经验误差与过拟合-2-1-P23" class="headerlink" title="经验误差与过拟合(2.1, P23)"></a>经验误差与过拟合(2.1, P23)</h2><p>学习器在训练集上的误差称为<strong>训练误差</strong>(training error)或<strong>经验误差</strong>(empirical error)，在新样本上的误差称为<strong>泛化误差</strong>(generalization error)，我们希望得到泛化误差小的学习器。</p>
<p>过拟合(overfitting)，欠拟合(underfitting)。</p>
<p>多种因素导致过拟合，最常见的就是由于学习能力过于强大，以至于把训练样本不太一般的特性都学到了。欠拟合相反。</p>
<p>欠拟合比较容易克服，如在决策树学习中学习扩展分支，在神经网络学习中增加训练轮数等。</p>
<p>过拟合无法彻底避免。只能“缓解”，减小风险。</p>
<h2 id="评估方法-2-2-P24"><a href="#评估方法-2-2-P24" class="headerlink" title="评估方法(2.2, P24)"></a>评估方法(2.2, P24)</h2><p>测试集(testing set)上的测试误差(testing error) 作为泛化误差的近似。</p>
<h3 id="留出法-2-2-1-P25"><a href="#留出法-2-2-1-P25" class="headerlink" title="留出法(2.2.1, P25)"></a>留出法(2.2.1, P25)</h3><p>“留出法”(hold-out) 将数据集D划分为两个<strong>互斥</strong>的集合，其中一个集合作为训练集S，另一个作为测试集T，即$D=S\cup T,S\cap T=\oslash $。</p>
<p>常见的划分为：大约2/3-4/5的样本用作训练，剩下的用作测试。</p>
<p>注意：</p>
<ul>
<li>训练/测试集的划分需要尽可能保持<strong>数据分布的一致性</strong>。</li>
<li>由于划分的随机性，单次留出法得到的评估结果往往不够稳定可靠，一般采用<strong>若干次随机划分、重复进行实验评估后取平均值</strong>。</li>
</ul>
<h3 id="交叉验证法-2-2-2-P26"><a href="#交叉验证法-2-2-2-P26" class="headerlink" title="交叉验证法(2.2.2, P26)"></a>交叉验证法(2.2.2, P26)</h3><p>“交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$</p>
<p>每次用k-1个子集作为训练集，余下的那个子集作为测试集；这样就可以得到k组训练/测试集。从而可进行k次训练和测试，最终返回k次测试结果的均值。</p>
<p>故通常把交叉验证法称为“k折交叉验证”(k-fold cross validation)。<br>10折交叉验证示意图：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3il11kesj20d706bdgd.jpg" alt="10折交叉验证示意图"></p>
<p>与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为<strong>p次k折交叉验证</strong>，常见的是10次10折交叉验证，即进行了100次训练/测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p>
<h3 id="自助法-2-2-3-P27"><a href="#自助法-2-2-3-P27" class="headerlink" title="自助法(2.2.3, P27)"></a>自助法(2.2.3, P27)</h3><p>“自助法”(bootstrapping)以自助采样法(bootstrapping sampling)为基础。<br>每次随机从包含m个样本的数据集D中挑选一个样本，将其拷贝到$D’$，然后再将该样本放回D中，使得该样本下次采样时仍有可能被采到。<br>重复执行m次后，就得到包含m个样本的数据集$D’$。</p>
<p>我们将$D’$用作训练集，$D-D’$(D中除了$D’$以外的样本)用作测试集。</p>
<p>在m次采样中，样本始终不被采到的概率取极限为：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3iphjqzuj206w01fdfm.jpg" alt=""></p>
<p>自助法在数据集较小、难以有效划分训练/测试集时很有用。</p>
<h3 id="调参与最终模型-2-2-4-P28"><a href="#调参与最终模型-2-2-4-P28" class="headerlink" title="调参与最终模型(2.2.4, P28)"></a>调参与最终模型(2.2.4, P28)</h3><p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。</p>
<p>当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。</p>
<p>学得模型(训练后的模型)实际使用中遇到的数据称为测试数据，在模型评估选择中用于评估测试的数据集称为“验证集”(calidation set)。【和吴恩达讲得差不多(略有区别？)。吴恩达说，通常将数据分为三类：训练集，验证集与测试集。】</p>
<h2 id="性能度量performance-measure-2-3-P28"><a href="#性能度量performance-measure-2-3-P28" class="headerlink" title="性能度量performance measure(2.3, P28)"></a>性能度量performance measure(2.3, P28)</h2><p>分类和回归属于监督学习。</p>
<ul>
<li><p>【分类】：对是离散值的结果进行预测。</p>
</li>
<li><p>【回归】：对是连续值的结果进行预测。</p>
</li>
</ul>
<p>回归任务和分类任务的常用性能度量如下图所示。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3mv5tkf5j20dw04zq3a.jpg" alt=""></p>
<p><del>预测任务：学习器预测结果$f(x)$与真实标记$y$进行比较。</del></p>
<p>回归任务：“均方误差”(mean squared error)<br>$$E(f;D) = \frac 1m \sum_{i=1}^m (f(x_i)-y_i)^2 $$</p>
<p>下面将依次介绍上图中分类任务的四类性能度量。</p>
<h3 id="错误率与精度-2-3-1-P29"><a href="#错误率与精度-2-3-1-P29" class="headerlink" title="错误率与精度(2.3.1, P29)"></a>错误率与精度(2.3.1, P29)</h3><p>错误率：分类错误的样本占样本总数的比例：<br>$$E(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)\neq y_i) $$<br>精度：分类正确的样本占样本总数的比例：<br>$$acc(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)= y_i) = 1-E(f;D)  $$</p>
<p>错误率+精度=1。</p>
<h3 id="查准率、查全率与F1-2-3-2-P30"><a href="#查准率、查全率与F1-2-3-2-P30" class="headerlink" title="查准率、查全率与F1(2.3.2, P30)"></a>查准率、查全率与F1(2.3.2, P30)</h3><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3j33r8v2j20c006v74f.jpg" alt=""></p>
<p>查准率就是准确率，查全率就是召回率。</p>
<p>更具体的，可参考我的这篇文章：<a href="http://wangwlj.com/2017/10/08/DL_Precision_and_Recall/">准确率、召回率与F1值</a><br>【重点，单独列出】</p>
<h3 id="ROC-与AUC-2-3-3-P33"><a href="#ROC-与AUC-2-3-3-P33" class="headerlink" title="ROC 与AUC(2.3.3, P33)"></a>ROC 与AUC(2.3.3, P33)</h3><p><strong>ROC：受试者工作特性(Receiver Operating Characteristic)。</strong><br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4csetqxzj20k009l0t5.jpg" alt=""><br>ROC图的纵坐标为“真正例率”，横坐标为“假正例率”。</p>
<blockquote>
<p>真正例率（TPR）：【真正例样本数】与【真实情况是正例的样本数】的比值。（查全率）</p>
<p>假正例率（FPR）：【假正例样本数】与【真实情况是反例的样本数】的比值。</p>
</blockquote>
<p>如图，理想模型是真正例率为100%，假正例率为0%的一点。随机猜测模型则是真正例率与假正例率持平的直线。由此可知，在随机猜测模型左上方的曲线和在其右下方的曲线都代表了什么。（右下方的模型，还不如随机猜测准。）</p>
<p>现实中通常是有限个测试样例来绘制ROC图。无法产生光滑的ROC曲线图。</p>
<p>同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则不太好判断。此时，AUC应运而生。</p>
<p>AUC(Area Under ROC Curve)：判断两个ROC曲线的性能，AUC计算的是ROC曲线下的面积。面积越大，性能越好。</p>
<h3 id="代价敏感错误率与代价曲线-2-3-4-P35"><a href="#代价敏感错误率与代价曲线-2-3-4-P35" class="headerlink" title="代价敏感错误率与代价曲线(2.3.4, P35)"></a>代价敏感错误率与代价曲线(2.3.4, P35)</h3><p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4d0hvlu2j20ak06w0sq.jpg" alt="二分类代价矩阵"></p>
<p>在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”(cost sensitive)的错误率为：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3ji8c6pjj20jh02baa9.jpg" alt=""></p>
<p>同样对于ROC曲线，在非均等错误代价下，性能度量的方法演变成了<strong>“代价曲线”</strong>，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3lfih9eaj20cs0260sl.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3m2chlkwj20fo028glj.jpg" alt=""><br>代价曲线的绘制：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC曲线上的每个点转化为代价平面上的一条线段，然后取<strong>所有线段的下界</strong>，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3jugpwecj20fc09jaak.jpg" alt="代价曲线"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>周志华《机器学习》</li>
<li><a href="http://blog.csdn.net/u011826404/article/details/53229609" target="_blank" rel="external">http://blog.csdn.net/u011826404/article/details/53229609</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28482121" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28482121</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Machine Learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows下的部分小技巧整理]]></title>
      <url>/2017/12/29/practical_tricks/</url>
      <content type="html"><![CDATA[<p>本文主要是电脑使用中的一些小技巧的整理。<br>主要包括：</p>
<ul>
<li>电脑常用的部分快捷键</li>
<li>批处理乱码问题</li>
<li>Photoshop文字添加、删除与旋转</li>
<li>VMbox虚拟机问题</li>
</ul>
<a id="more"></a>
<h1 id="电脑操作"><a href="#电脑操作" class="headerlink" title="电脑操作"></a>电脑操作</h1><h2 id="打开“我的电脑”的快捷键"><a href="#打开“我的电脑”的快捷键" class="headerlink" title="打开“我的电脑”的快捷键"></a>打开“我的电脑”的快捷键</h2><p><code>winkey +E</code> :<br>打开我的电脑（资源管理器）。winkey指的是键盘上刻有windows徽标的键，就是左边ctrl 和alt中间那个(window标志)。</p>
<p>其他常用键组合：</p>
<p><code>winkey + d</code> :<br>这是高手最常用的第一快捷组合键。这个快捷键组合可以将桌面上的所有<strong>窗口瞬间最小化</strong>，无论是聊天的窗口还是游戏的窗口……只要<strong>再次按下这个组合键，刚才的所有窗口都回来了</strong>，而且激活的也正是你最小化之前在使用的窗口！ </p>
<p><code>winkey + r</code> :<br>在我们的文章中，你经常会看到这样的操作提示:“点击‘开始→运行’，打开‘运行’对话框……”。其实，还有一个更简单的办法，就是按winkey + r！ </p>
<p><code>alt + tab</code> 或者 <code>winkey + tab</code>:<br>如果打开的窗口太多，这个组合键就非常有用了，它可以在<strong>一个窗口中显示当前打开的所有窗口的名称和图标</strong>，选中自己希望要打开的窗口，松开这个组合键就可以了。而alt+tab+shift键则可以反向显示当前打开的窗口。 </p>
<p><code>ALT + F4</code> ：<br>关闭当前应用程序 </p>
<p><code>PRINT SCREEN</code> :<br>将当前屏幕以图象方式拷贝到剪贴板 </p>
<p>更多快捷键可参考：<a href="https://zhidao.baidu.com/question/100107981.html" target="_blank" rel="external">https://zhidao.baidu.com/question/100107981.html</a></p>
<h2 id="复制一个当前文件夹窗口的快捷键"><a href="#复制一个当前文件夹窗口的快捷键" class="headerlink" title="复制一个当前文件夹窗口的快捷键"></a>复制一个当前文件夹窗口的快捷键</h2><p><code>Ctrl + N</code></p>
<h2 id="批量查看照片尺寸"><a href="#批量查看照片尺寸" class="headerlink" title="批量查看照片尺寸"></a>批量查看照片尺寸</h2><p>在空白的地方右击，选择<strong>查看——详细信息</strong>;</p>
<p>照片就以列表的形式摆放了，但没有尺寸大小的信息~</p>
<p>再次在空白处右击，选择<strong>排列方式——更多</strong>，</p>
<p>将滑块往下滑动，<strong>找到尺寸，打上勾</strong>，按确定~</p>
<p>照片的尺寸信息就出现了~</p>
<p>若没有理解清楚，详细图文教程可参考：<a href="https://jingyan.baidu.com/article/67508eb4d4d3ff9ccb1ce459.html" target="_blank" rel="external">如何批量查看照片的尺寸</a></p>
<h2 id="awesomiumProcess是什么进程"><a href="#awesomiumProcess是什么进程" class="headerlink" title="awesomiumProcess是什么进程"></a>awesomiumProcess是什么进程</h2><p>在Windows任务管理器中的相应进程上右键–打开文件位置，发现是MarkDownPad2自带的程序。</p>
<p>推广一下，就是手动查看进程中是否存在可疑程序。。。</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="批处理脚本bat中文乱码"><a href="#批处理脚本bat中文乱码" class="headerlink" title="批处理脚本bat中文乱码"></a>批处理脚本bat中文乱码</h2><p>面对这个情况是编码不同问题，所以在最开始就应该把编码修正，支持中文的编码是<code>ANSI</code>。</p>
<p>我们第一步是<strong>新建一个txt文件</strong>。用记事本打开，将原来的bat文件内容拷贝过来，然后选择“<strong>文件”=&gt;“另存为”</strong>。</p>
<p>cmd中的编码方式为ANSI，若中文不是此编码方式则会出现乱码。所以我们<strong>在编码的时候选择“ANSI”</strong>。</p>
<h1 id="photoshop"><a href="#photoshop" class="headerlink" title="photoshop"></a>photoshop</h1><h2 id="ps修改图片上的文字"><a href="#ps修改图片上的文字" class="headerlink" title="ps修改图片上的文字"></a>ps修改图片上的文字</h2><h3 id="删去文字"><a href="#删去文字" class="headerlink" title="删去文字"></a>删去文字</h3><p>先选择图层，再选择一个区域后，按delete删除。</p>
<p>取消当前图层的选区： <code>ctrl + D</code><br>参考自：<a href="https://jingyan.baidu.com/article/456c463b6e5e3a0a5831440e.html" target="_blank" rel="external">ps取消选区快捷键</a></p>
<h3 id="添加横的文字"><a href="#添加横的文字" class="headerlink" title="添加横的文字"></a>添加横的文字</h3><p>选择添加文本的按钮输入文字，但是不可以旋转（我要变成竖直的文字）。</p>
<p>按组合键<code>Ctrl + T</code>或者点击编辑菜单下的【自由变换】，进入文字调整。<br>具体参考：<a href="https://zhidao.baidu.com/question/227531179.html" target="_blank" rel="external">ps怎么旋转一个字体</a></p>
<h1 id="vbox虚拟机"><a href="#vbox虚拟机" class="headerlink" title="vbox虚拟机"></a>vbox虚拟机</h1><h2 id="无法启动E-FAIL-0x80004005"><a href="#无法启动E-FAIL-0x80004005" class="headerlink" title="无法启动E_FAIL (0x80004005)"></a>无法启动E_FAIL (0x80004005)</h2><p>版本问题。回退到4.3.12之前。新版本问题多多。<br>具体参考：<a href="https://bbs.kafan.cn/thread-1798795-1-1.html" target="_blank" rel="external">Oracle VM VirtualBox 虚拟机 启动报错代码:E_FAIL (0x80004005)</a></p>
<h2 id="VirtualBox显示模式切换热键"><a href="#VirtualBox显示模式切换热键" class="headerlink" title="VirtualBox显示模式切换热键"></a>VirtualBox显示模式切换热键</h2><p>初用VirtualBox, 几个显示切换快捷键还是要记一下的:</p>
<p>Right Ctrl + F        – 切换到全屏模式<br>Right Ctrl + L        – 切换到无缝模式<br>Right Ctrl + C        – 切换到比例模式<br>Right Ctrl + Home – 显示控制菜单</p>
<h2 id="无缝模式是灰色的，怎么办"><a href="#无缝模式是灰色的，怎么办" class="headerlink" title="无缝模式是灰色的，怎么办"></a>无缝模式是灰色的，怎么办</h2><p>安装增强模式。相当于VMware里面的”VMware Tools”。</p>
]]></content>
      
        <categories>
            
            <category> Photoshop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Photoshop </tag>
            
            <tag> VMbox </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中的部分tricks整理]]></title>
      <url>/2017/12/29/python_tricks/</url>
      <content type="html"><![CDATA[<p>本文整理了本人遇到的一些tricks。主要包括：</p>
<ul>
<li>pycharm快捷键整理</li>
<li>爬虫中的日志记录(logging)、取消SSL警告、字符过滤(re.sub)与查找(find)、文件删除(os)与文件保存(pickle)、词云(wordcloud)的使用</li>
<li>图像处理的部分基本操作(PIL,numpy)。</li>
</ul>
<a id="more"></a>
<h2 id="0-pycharm-快捷键"><a href="#0-pycharm-快捷键" class="headerlink" title="0 pycharm 快捷键"></a>0 pycharm 快捷键</h2><h3 id="注释-反注释"><a href="#注释-反注释" class="headerlink" title="注释/反注释"></a>注释/反注释</h3><p> <code>Ctrl+斜杠</code>，也就是 <code>Ctrl + /</code> 注释与反注释都是这个组合键。</p>
<h3 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h3><p><code>Ctrl+Shift+斜杠</code></p>
<h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p><code>ctrl + alt + F</code>: 格式化代码(用了JetBrains的IDE之后就习惯性地格式化一下)，代码规范化。</p>
<h3 id="复制当前行"><a href="#复制当前行" class="headerlink" title="复制当前行"></a>复制当前行</h3><p><code>Ctrl + D</code>复制当前行</p>
<h3 id="另起一行"><a href="#另起一行" class="headerlink" title="另起一行"></a>另起一行</h3><p><code>shift + enter</code> : 向下另起一行，光标在行内任意位置都能另起一行，且不破坏当行结构<br><code>ctrl + alt + enter</code> : 向上另起一行</p>
<h3 id="查看注释"><a href="#查看注释" class="headerlink" title="查看注释"></a>查看注释</h3><p><code>Ctrl + q</code>: help 查注释，查询documentation</p>
<h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p><code>ctrl + shift + a</code> : 搜索功能: 搜索IDE功能，比如想看看这个文件的历史，就键入history 可以找到 Local history</p>
<h3 id="万能提示键"><a href="#万能提示键" class="headerlink" title="万能提示键"></a>万能提示键</h3><p><code>ctrl + alt + space</code>: 万能提示键(在Keymap中搜索basic可以找到并修改它)PyCharm的会根据上下文提供补全。</p>
<h3 id="run相关的快捷键"><a href="#run相关的快捷键" class="headerlink" title="run相关的快捷键"></a>run相关的快捷键</h3><p>根据具体设置可能略有差异，笔者采用的是<br>VS风格（可在<code>File-&gt;Settings-&gt;Keymap</code>中设置）的快捷键。<br><code>ctrl + F9</code> : run the current file （跑当前页面的程序）<br><code>F9</code> :　resume the program (中断后)重新开始程序<br><code>ctrl + F5</code>: run the specific program(直接跑上一个程序)<br><code>F5</code>： debug（弹出debug目录，自行选择运行的文件）<br><code>alt + shift + F10</code> : 运行程序（弹出run目录）</p>
<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p><code>ctrl + shift + 数字键</code> 与 <code>ctrl + 数字键</code> : 书签功能<br><code>Ctrl + 鼠标点击</code>  ： 查看内置函数啥的<br><code>alt + 上下箭头</code> : <code>preview/next method (def/class)</code><br>debug的时候可以在断点打开Python console然后改变量值<br><code>Ctrl+ B</code>和<code>shift + →</code>，查看源码时很方便，至少在vim下看库的源码没那么容易。对Python程序员而言，看源码很重要<br><code>shift + F6</code> : 重命名，这太重要了，vim没有吧。即使有，那它也没法重构Flask和Django的template下的指令吧。</p>
<h2 id="1-python信息同时输出到控制台与文件"><a href="#1-python信息同时输出到控制台与文件" class="headerlink" title="1 python信息同时输出到控制台与文件"></a>1 python信息同时输出到控制台与文件</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><p>python编程中，往往需要将结果用print等输出，如果希望输出既可以显示到IDE的屏幕上，也能存到文件中（如txt）中，该怎么办呢？</p>
<h3 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h3><p>可通过日志<code>logging</code>模块输出信息到文件或屏幕。但可能要设置log的level或输出端，对于同时需要记录<code>debug error</code>等信息的较为合适，官方教程推荐学习用更规范的logger来操作。<br>例如,可参考来自官网的这段代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line">	logging.basicConfig(filename=<span class="string">'log_examp.log'</span>,level=logging.DEBUG)</div><div class="line">	logging.debug(<span class="string">'This message should go to the log file'</span>)</div><div class="line">	logging.info(<span class="string">'So should this'</span>)</div><div class="line">	logging.warning(<span class="string">'And this, too'</span>)</div></pre></td></tr></table></figure></p>
<p>其中的<code>level=logging.DEBUG</code>会显示Debug调试信息，若想显示普通的输出信息，可以换成<code>level=logging.INFO</code>。</p>
<table class="table table-bordered table-striped table-condensed"><br>    <tr><br>        <th>程度</th><br>        <th>使用场景</th><br>    </tr><br>    <tr><br>        <td>DEBUG</td><br>        <td>获得诊断问题是具体的信息</td><br>    </tr><br>    <tr><br>        <td>INFO</td><br>        <td>确认程序是否按正常工作</td><br>    </tr><br>    <tr><br>        <td>WARNING</td><br>        <td>在程序还正常运行时获取发生的意外的信息，这可能会在之后引发异常（例如磁盘空间不足）</td><br>    </tr><br>    <tr><br>        <td>ERROR</td><br>        <td>获取程序某些功能无法正常调用这类严重异常的信息</td><br>    </tr><br>    <tr><br>        <td>CRITICAL</td><br>        <td>获取程序无法继续运行的这类最严重异常信息</td><br>    </tr><br></table> 

<h3 id="1-3-改变默认输出信息的格式"><a href="#1-3-改变默认输出信息的格式" class="headerlink" title="1.3 改变默认输出信息的格式"></a>1.3 改变默认输出信息的格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="comment"># output format: output time - logging level - log messages</span></div><div class="line">logging.basicConfig(format=<span class="string">'%(asctime)s - %(levelname)s - %(message)s'</span>)</div><div class="line">logging.warning(<span class="string">'This message will appear in python console.'</span>)</div></pre></td></tr></table></figure>
<p>在<code>python console</code>中直接打印以下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-8-2 2:59:11, 510 - WARNING - This message will appear in python console</div></pre></td></tr></table></figure>
<h2 id="2-Python中将打印输出导向日志文件"><a href="#2-Python中将打印输出导向日志文件" class="headerlink" title="2 Python中将打印输出导向日志文件"></a>2 Python中将打印输出导向日志文件</h2><p>利用<code>sys.stdout</code>将print行导向到你定义的日志文件中，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="comment"># make a copy of original stdout route</span></div><div class="line">stdout_backup = sys.stdout</div><div class="line"><span class="comment"># define the log file that receives your log info</span></div><div class="line">log_file = open(<span class="string">"message.log"</span>, <span class="string">"w"</span>)</div><div class="line"><span class="comment"># redirect print output to log file</span></div><div class="line">sys.stdout = log_file</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Now all print info will be written to message.log"</span></div><div class="line"><span class="comment"># any command line that you will execute</span></div><div class="line">...</div><div class="line"></div><div class="line">log_file.close()</div><div class="line"><span class="comment"># restore the output to initial pattern</span></div><div class="line">sys.stdout = stdout_backup</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Now this will be presented on screen"</span></div></pre></td></tr></table></figure>
<p>这样子只会打印到日志文件，而控制台没有输出了，笔者一般不采用这种方法。</p>
<h2 id="3-python3使用requests请求HTTPS取消SSL验证警告"><a href="#3-python3使用requests请求HTTPS取消SSL验证警告" class="headerlink" title="3 python3使用requests请求HTTPS取消SSL验证警告"></a>3 python3使用requests请求HTTPS取消SSL验证警告</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h3><p>使用<code>requests</code>库请求<code>HTTPS</code>时,因为忽略证书验证,导致每次运行时都会报错（警告）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\python\Python35\lib\site-packages\urllib3\connectionpool.py:858: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings</div><div class="line"> 	InsecureRequestWarning)</div></pre></td></tr></table></figure></p>
<h3 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法"></a>3.2 解决方法</h3><blockquote>
<p>虽然这并不影响结果的正确，但是这个提示一直存在，看着是真的别扭，尤其需要输出到报告或者是日志的时候。代码加入下面两行，取消这个警告。</p>
</blockquote>
<p>添加如下的这两行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning </div><div class="line"></div><div class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</div></pre></td></tr></table></figure>
<blockquote>
<p>python3也可以的。我的pycharm中会显示找不到该库，不过没问题，依旧可以跑，应该是pycharm本身的问题。</p>
</blockquote>
<h2 id="4-python过滤中文、英文标点特殊符号"><a href="#4-python过滤中文、英文标点特殊符号" class="headerlink" title="4. python过滤中文、英文标点特殊符号"></a>4. python过滤中文、英文标点特殊符号</h2><h3 id="4-1-垃圾邮件过滤实例"><a href="#4-1-垃圾邮件过滤实例" class="headerlink" title="4.1 垃圾邮件过滤实例"></a>4.1 垃圾邮件过滤实例</h3><p>下面是一封垃圾邮件的过滤实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;想做/ 兼_职/学生_/ 的 、加,我Q：  1 5.  8 0. ！！？？  8 6 。0.  2。 3     有,惊,喜,哦&quot;</div></pre></td></tr></table></figure>
<p>邮件中的“<code>！？。、</code>”都是中文的，而“/.”是英文的</p>
<p>下面是采用re正则项过滤方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">temp = <span class="string">"想做/ 兼_职/学生_/ 的 、加,我Q：  1 5.  8 0. ！！？？  8 6 。0.  2。 3     有,惊,喜,哦"</span></div><div class="line">temp = temp.decode(<span class="string">"utf8"</span>) </div><div class="line">string = re.sub(<span class="string">"[\s+\.\!\/_,$%^*(+\"\']+|[+——！，。？、~@#￥%……&amp;*（）]+"</span>, <span class="string">""</span>, temp) <span class="comment"># 将temp中若存在的前面的这一长串替换为空的。</span></div><div class="line">print(string)</div></pre></td></tr></table></figure>
<h3 id="4-2-目录名称过滤实例"><a href="#4-2-目录名称过滤实例" class="headerlink" title="4.2 目录名称过滤实例"></a>4.2 目录名称过滤实例</h3><p>此外，比如说目录命名时，也需要过滤掉<code>/|</code>等，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dirName = re.sub(<span class="string">"[\s+\.\!\/_,$%^*(+\"\'?]+|[+——！，。？、~@#￥%……&amp;*（）]+"</span>, <span class="string">""</span>, dirName)</div><div class="line">os.mkdir(dirName)</div></pre></td></tr></table></figure></p>
<h2 id="5-Markdown之表格table的处理"><a href="#5-Markdown之表格table的处理" class="headerlink" title="5. Markdown之表格table的处理"></a>5. Markdown之表格table的处理</h2><p>插入表格代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered table-striped table-condensed"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>雾霾<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>暴雨<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>发现table加了个class属性，如果只是table标签 将不起作用。</p>
<pre><code>table-bordered：带圆角边框和竖线
table-striped：奇偶行颜色不同
table-condensed：压缩行距
</code></pre><p>除了以上另外还有其他可供选择：</p>
<p>1、如果需要表头跟内容不一样，可以将<code>&lt;td&gt;</code>表头内容<code>&lt;/td&gt;</code>换成<code>&lt;th&gt;</code>表头内容<code>&lt;/th&gt;</code>。</p>
<p>2、如果表格内文需要换行，可以在要换行的内容后加入<code>&lt;br&gt;</code>，后面的内容就会跑到下一行。</p>
<p>3、如果内文中有代码，需要特别显示，可使用：<code>&lt;code&gt;代码&lt;/code&gt;</code>。</p>
<p>4、如果表格中有需要设为斜体的内容，可使用：<code>&lt;I&gt;要设为斜体的内容&lt;/I&gt;</code>。</p>
<p>5、如果有跨行或者跨列的单元格，可用<code>&lt;th colspan=&quot;跨列数&quot;&gt;内容&lt;/th&gt;</code>或<code>rowspan</code>。</p>
<p>6、如果要调整某一列的宽度，可使用：<code>&lt;th width=&quot;宽度值或百分比&quot;&gt;表头内容&lt;/th&gt;</code>。</p>
<h2 id="6-用numpy打开图像和保存图像"><a href="#6-用numpy打开图像和保存图像" class="headerlink" title="6. 用numpy打开图像和保存图像"></a>6. 用numpy打开图像和保存图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-    </span></div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image    </div><div class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *    </div><div class="line"><span class="keyword">from</span> PCV.tools <span class="keyword">import</span> imtools    </div><div class="line"><span class="keyword">import</span> numpy  </div><div class="line"></div><div class="line">im = array(Image.open(<span class="string">'C:/pic/train2/1.jpg'</span>).convert(<span class="string">'L'</span>))  <span class="comment"># 打开图像，并转成灰度图像    </span></div><div class="line">img11=Image.fromarray(uint8(im))  </div><div class="line">img11.save(<span class="string">"C:/pic/train2/10.jpg"</span>)<span class="comment"># 保存灰度图像</span></div></pre></td></tr></table></figure>
<p>补充用opencv打开和保存图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8    </span></div><div class="line"><span class="keyword">import</span> cv2    </div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">"C:/pic/train1/2.jpg"</span>, <span class="number">0</span>)     </div><div class="line">cv2.imwrite(<span class="string">'C:/pic/1/5.jpg'</span>,img)</div></pre></td></tr></table></figure>
<h2 id="7-PIL-Image转换为OpenCV支持的Image格式"><a href="#7-PIL-Image转换为OpenCV支持的Image格式" class="headerlink" title="7. PIL.Image转换为OpenCV支持的Image格式"></a>7. PIL.Image转换为OpenCV支持的Image格式</h2><p>可参考：<a href="http://www.mobibrw.com/2017/7381" target="_blank" rel="external">http://www.mobibrw.com/2017/7381</a></p>
<p>后来放弃了。不太方便。</p>
<h2 id="8-使用pickle把数据保存到文件"><a href="#8-使用pickle把数据保存到文件" class="headerlink" title="8. 使用pickle把数据保存到文件"></a>8. 使用pickle把数据保存到文件</h2><h3 id="8-1-实例一"><a href="#8-1-实例一" class="headerlink" title="8.1 实例一"></a>8.1 实例一</h3><p>使用pickle模块从文件中重构python对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pprint, pickle</div><div class="line"></div><div class="line">pkl_file = open(<span class="string">'data.pkl'</span>, <span class="string">'rb'</span>)</div><div class="line"></div><div class="line">data1 = pickle.load(pkl_file)</div><div class="line">pprint.pprint(data1)</div><div class="line"></div><div class="line">data2 = pickle.load(pkl_file)</div><div class="line">pprint.pprint(data2)</div><div class="line"></div><div class="line">pkl_file.close()</div></pre></td></tr></table></figure></p>
<h3 id="8-2-实例二"><a href="#8-2-实例二" class="headerlink" title="8.2 实例二"></a>8.2 实例二</h3><p>其中，friend是从网页获得的数据，先保存下来，以备后续处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取好友列表</span></div><div class="line">friends = itchat.get_friends(update=<span class="keyword">True</span>)[<span class="number">0</span>:]</div><div class="line"></div><div class="line">output = open(<span class="string">'data.pkl'</span>, <span class="string">'wb'</span>)</div><div class="line"><span class="comment"># Pickle dictionary using protocol 0.</span></div><div class="line">pickle.dump(friends, output)</div><div class="line">output.close()</div></pre></td></tr></table></figure></p>
<p>读取保存的文件，用于后续处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pickle, re</div><div class="line"></div><div class="line">pkl_file = open(<span class="string">'data.pkl'</span>, <span class="string">'rb'</span>)</div><div class="line">friends = pickle.load(pkl_file)</div></pre></td></tr></table></figure>
<h2 id="9-解决Python词云库wordcloud不显示中文的问题"><a href="#9-解决Python词云库wordcloud不显示中文的问题" class="headerlink" title="9. 解决Python词云库wordcloud不显示中文的问题"></a>9. 解决Python词云库wordcloud不显示中文的问题</h2><h3 id="9-1-安装"><a href="#9-1-安装" class="headerlink" title="9.1 安装"></a>9.1 安装</h3><p>安装命令：</p>
<blockquote>
<p>pip install wordcloud</p>
</blockquote>
<h3 id="9-2-解决方案"><a href="#9-2-解决方案" class="headerlink" title="9.2 解决方案"></a>9.2 解决方案</h3><p>实例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">text = <span class="string">'''文案 文案</span></div><div class="line"><span class="string">The  抱抱 Zen of LOVE 抱抱 Python, 快乐 by Tim Peters</span></div><div class="line"><span class="string">公众号 公众号 Python 最好的 语言 语言</span></div><div class="line"><span class="string">一辈子 is better LOVE than 一辈子.</span></div><div class="line"><span class="string">喵小姐 is 爱你 than  implicit.爱你 喵小姐</span></div><div class="line"><span class="string">蟹先生 is 爱你 than complex.</span></div><div class="line"><span class="string">一辈子 is 蟹先生  than complicated.</span></div><div class="line"><span class="string">二中 is 喵小姐 我想你了 than nested. 二中 蟹先生</span></div><div class="line"><span class="string">清湖 is 胜于 than 清湖.</span></div><div class="line"><span class="string">思旺 counts. 想你</span></div><div class="line"><span class="string">Special 喵小姐 我想你了 aren't special enough 思旺 break 思旺 rules.</span></div><div class="line"><span class="string">别生气 practicality beats 厨艺好.</span></div><div class="line"><span class="string">Errors should 我想你了 never pass 小龙虾 silently. 运营</span></div><div class="line"><span class="string">别生气 explicitly 好不好. LOVE</span></div><div class="line"><span class="string">In the face of ambiguity, 程序员 the 厨艺好 to guess.龙华 龙华</span></div><div class="line"><span class="string">There 快乐 should be one-- 我想你了 and preferably 红烧肉 only one 小龙虾--obvious way to do it.运营</span></div><div class="line"><span class="string">Although 共享单车 way may not 我想你了 be obvious at first unless you're Dutch. 新媒体 地铁</span></div><div class="line"><span class="string">Now is better 红烧肉 than never.</span></div><div class="line"><span class="string">程序员 Although 共享单车 is often 高铁 than 东莞 now. 高铁 地铁</span></div><div class="line"><span class="string">If the implementation 想你 is hard to explain, it's a bad idea. 想你了</span></div><div class="line"><span class="string">If 成都 implementation is 想你 easy to explain, it may be a good idea.</span></div><div class="line"><span class="string">Namespaces are 端午one 端午 honking great idea -- 成都 do more of those! 想你了</span></div><div class="line"><span class="string">深圳 晚安 深圳 新媒体</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="comment"># the font from github: https://github.com/adobe-fonts</span></div><div class="line">font = <span class="string">r'C:\Windows\Fonts\simfang.ttf'</span></div><div class="line">wc = WordCloud(collocations=<span class="keyword">False</span>, font_path=font, width=<span class="number">1400</span>, height=<span class="number">1400</span>, margin=<span class="number">2</span>).generate(text.lower())</div><div class="line"></div><div class="line">plt.imshow(wc)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line">wc.to_file(<span class="string">'show_Chinese.png'</span>)  <span class="comment"># 把词云保存下来</span></div></pre></td></tr></table></figure></p>
<h2 id="10-PIL库图片基本操作"><a href="#10-PIL库图片基本操作" class="headerlink" title="10. PIL库图片基本操作"></a>10. PIL库图片基本操作</h2><p>1.打开图片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Image</div><div class="line">img=Image.open(<span class="string">"code.jpg"</span>)</div></pre></td></tr></table></figure></p>
<p>注：有些图片名称是包含中文的，就需要在“”前加上u，例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img=Image.open(<span class="string">u"阿布.jpg"</span>)</div></pre></td></tr></table></figure></p>
<p>2.展示图片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img.show()</div></pre></td></tr></table></figure>
<p>3.保存图片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img.save(<span class="string">"img1.png"</span>,<span class="string">"png"</span>)</div></pre></td></tr></table></figure></p>
<p>说明：img为一个图片，存为一个名叫img1的图片，格式为png。后面的png不写也可以，直接按照文件名的后缀.png存为相应格式了。</p>
<p>4.旋转图片rotate</p>
<pre><code>fixedIm=img.rotate(90)
fixedIm.save(&quot;fixedIm.png&quot;,&quot;png&quot;)
</code></pre><p>说明：<code>fixedIm=img.rotate(90)</code>，将图片img逆时针旋转90度，存到fixedIm中。</p>
<p>更多操作可参考:<br><a href="http://www.cnblogs.com/meitian/p/3699223.html" target="_blank" rel="external">http://www.cnblogs.com/meitian/p/3699223.html</a></p>
<h2 id="python删除文件"><a href="#python删除文件" class="headerlink" title="python删除文件"></a>python删除文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">   <span class="comment"># 删除文件： </span></div><div class="line">os.remove()</div><div class="line"><span class="comment">#删除空目录： </span></div><div class="line">os.rmdir()</div><div class="line">   <span class="comment"># 递归删除空目录： </span></div><div class="line">os.removedirs()</div></pre></td></tr></table></figure>
<p>递归删除目录和文件（类似DOS命令DeleteTree）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Delete everything reachable from the directory named in 'top',</span></div><div class="line"><span class="comment"># assuming there are no symbolic links.</span></div><div class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></div><div class="line"><span class="comment"># could delete all your disk files.</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(top, topdown=<span class="keyword">False</span>):</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</div><div class="line">        os.remove(os.path.join(root, name))</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</div><div class="line">        os.rmdir(os.path.join(root, name))</div></pre></td></tr></table></figure></p>
<p>参考自：<a href="http://www.cnblogs.com/SophiaTang/archive/2012/01/16/2323467.html" target="_blank" rel="external">python 删除文件</a></p>
<h2 id="Python3-find-方法"><a href="#Python3-find-方法" class="headerlink" title="Python3 find()方法"></a>Python3 find()方法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>find()</code>方法检测字符串中是否包含子字符串str，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>find()方法语法：</p>
<blockquote>
<p>str.find(str, beg=0, end=len(string))</p>
</blockquote>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>str：指定检索的字符串<br>beg：开始索引，默认为0。<br>end：结束索引，默认为字符串的长度。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果包含子字符串返回开始的索引值，否则返回-1。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例展示了find()方法的实例(Python 3.0+)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"> </div><div class="line">str1 = <span class="string">"Runoob example....wow!!!"</span></div><div class="line">str2 = <span class="string">"exam"</span>;</div><div class="line"> </div><div class="line"><span class="keyword">print</span> (str1.find(str2))</div><div class="line"><span class="keyword">print</span> (str1.find(str2, <span class="number">5</span>))</div><div class="line"><span class="keyword">print</span> (str1.find(str2, <span class="number">10</span>))</div></pre></td></tr></table></figure>
<p>以上实例输出结果如下：</p>
<blockquote>
<p>7</p>
<p>7</p>
<p>-1</p>
</blockquote>
<p>实例(Python 3.0+)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;info = <span class="string">'abca'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(info.find(<span class="string">'a'</span>))      <span class="comment"># 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(info.find(<span class="string">'a'</span>, <span class="number">1</span>))   <span class="comment"># 从下标1开始，查找在字符串里第一个出现的子串：返回结果3</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(info.find(<span class="string">'3'</span>))      <span class="comment"># 查找不到返回-1</span></div><div class="line"><span class="number">-1</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/woaik110/article/details/52444427" target="_blank" rel="external">python 信息同时输出到控制台与文件</a></li>
<li><a href="http://www.cnblogs.com/arkenstone/p/5727883.html" target="_blank" rel="external">Python中将打印输出导向日志文件</a></li>
<li><a href="http://blog.csdn.net/m1mory/article/details/56029638" target="_blank" rel="external">python requests报错InsecureRequestWarning的解决方案</a></li>
<li><a href="http://blog.csdn.net/xie_0723/article/details/53424809" target="_blank" rel="external">Python requests移除SSL认证，控制台输出InsecureRequestWarning取消方法</a></li>
<li><a href="http://blog.csdn.net/mach_learn/article/details/41744487" target="_blank" rel="external">python 过滤中文、英文标点特殊符号</a></li>
<li><a href="http://blog.csdn.net/itmyhome1990/article/details/44085539" target="_blank" rel="external">Markdown之表格table的处理</a></li>
<li><a href="http://blog.csdn.net/txiaomiao/article/details/50967223" target="_blank" rel="external">用numpy打开图像和保存图像</a></li>
<li><a href="http://www.cnblogs.com/pzxbc/archive/2012/03/18/2404715.html" target="_blank" rel="external">pickle模块的基本使用</a></li>
<li><a href="http://blog.csdn.net/xiemanr/article/details/72796739" target="_blank" rel="external">词云库wordcloud显示中文</a></li>
<li><a href="http://www.runoob.com/python3/python3-string-find.html" target="_blank" rel="external">Python3 find()方法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> pycharm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于TensorFlow的简单语音识别]]></title>
      <url>/2017/12/28/TensorFlow_speech_commands/</url>
      <content type="html"><![CDATA[<h2 id="简单语音识别教程"><a href="#简单语音识别教程" class="headerlink" title="简单语音识别教程"></a>简单语音识别教程</h2><p>虽然真正的语音和音频识别系统要复杂得多，但是像MNIST（入门级的CV数据集）一样，本教程应该会让你对所涉技术有一个基本的了解。</p>
<p>完成本教程后，你将可以尝试创建一个模型，将一秒钟的音频剪辑去噪，并且能识别如下单词： <code>“yes”，“no”，“up”，“down”，&quot;left&quot;，&quot;right&quot;，&quot;on&quot;，&quot;off&quot;，&quot;stop&quot;，or &quot;go&quot;</code>。</p>
<p>你也可以在Android应用程序中运行该模型。</p>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>你要确保已经安装了TensorFlow，由于该版本下载了超过1GB的训练数据，因此你需要电脑有足够的内存，另外网速要快，训练过程可能需要几个小时。</p>
<h2 id="出错与解决"><a href="#出错与解决" class="headerlink" title="出错与解决"></a>出错与解决</h2><h3 id="找不到audio-ops"><a href="#找不到audio-ops" class="headerlink" title="找不到audio_ops"></a>找不到audio_ops</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"train.py"</span>, line <span class="number">79</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">import</span> input_data</div><div class="line">  File <span class="string">"/home/philglau/speech_commands/input_data.py"</span>, line <span class="number">35</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">from</span> tensorflow.contrib.framework.python.ops <span class="keyword">import</span> audio_ops <span class="keyword">as</span> contrib_audio</div><div class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">'audio_ops'</span></div></pre></td></tr></table></figure>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个’audio_ops’只在TensorFlow1.4版本中有，所以，如果不是1.4的版本，一般都会有这个错误。</p>
<p>此时的解决方案，一是更新TensorFlow版本，二是使用如下命令安装tf-nightly即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tf-nightly</div></pre></td></tr></table></figure>
<p>详见参考连接三。</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>要开始训练过程，请访问<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow源代码树</a>下载并运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/train.py</div></pre></td></tr></table></figure>
<p>训练过程将从下载“ 语音命令”数据集开始，该数据集由65000个WAVE音频文件组成，其中有30个不同的单词。</p>
<p>这些数据是由Google收集的，并根据CCBY许可证发布。存档超过1GB，所以下载可能需要一段时间，但你应该能看到进度日志，一旦下载完成，你就不用再次执行此步骤了。</p>
<p>下载完成后，你将看到如下所示的日志记录信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I0730 16:53:44.766740 55030 train.py:176] Training from step: 1</div><div class="line"></div><div class="line">I0730 16:53:47.289078 55030 train.py:217] Step #1: rate 0.001000, accuracy 7.0%, cross entropy 2.611571</div></pre></td></tr></table></figure>
<p>这表明初始化过程已经完成，循环训练已经开始。你会看到它输出每个训练步骤的信息。</p>
<p>步骤分解：</p>
<p>Step #1表明我们正在循环训练的第一步。在这种情况下，总共将有18000个步骤，所以你可以查看步骤号码，了解其完成程度有多接近。</p>
<p>rate 0.001000是控制网络权重更新速度的学习率。早期的这个数字是相对较高的（0.001），但是对于后来的训练周期，它会减少10倍到0.0001。</p>
<p><code>accuracy 7.0%</code>在这个训练步骤中正确地预测了有多少classes。value函数往往波动很大，但随着训练的进行，平均值会增加。该模型输出一个数字数组，每个标签一个，每个数字是该类输入的预测可能性。</p>
<p>通过选择具有最高分数的条目来选择预测的标签，分数总是在零和一之间。</p>
<p><code>cross entropy 2.611571</code>是我们用来指导培训过程的损失功能的结果。这是通过比较当前训练运动与正确标签的分数向量获得的分数，这在训练期间应该向下倾斜。</p>
<p>经过一百步，你应该看到这样的一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I0730 16:54:41.813438 55030 train.py:252] Saving to &quot;/tmp/speech_commands_train/conv.ckpt-100&quot;</div></pre></td></tr></table></figure></p>
<p>这是将当前训练的权重保存到checkpoint文件中。如果你的训练脚本中断，可以查找最后保存的checkpoint，然后：<br><code>--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-100</code>使用命令行参数重新启动脚本， 从那里开始。</p>
<h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>四百步后，将记录以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">I0730 16:57:38.073667 55030 train.py:243] Confusion Matrix:</div><div class="line"></div><div class="line">[[258 0  0  0  0 0  0 0  0  0 0 0]</div><div class="line"></div><div class="line">[  7  6  26 94  7 49 1 15 40 2 0 11]</div><div class="line"></div><div class="line">[ 10  1 107 80 13 22 0 13 10 1 0  4]</div><div class="line"></div><div class="line">[ 1  3  16 163  6 48 0  5 10 1 0  17]</div><div class="line"></div><div class="line">[ 15 1  17 114 55 13 0  9 22 5 0  9]</div><div class="line"></div><div class="line">[ 1  1  6  97  3  87 1 12 46 0 0  10]</div><div class="line"></div><div class="line">[ 8  6 86  84 13  24 1  9  9 1 0  6]</div><div class="line"></div><div class="line">[ 9  3 32 112  9  26 1 36 19 0 0  9]</div><div class="line"></div><div class="line">[ 8  2 12  94  9  52 0  6 72 0 0  2]</div><div class="line"></div><div class="line">[ 16 1 39  74 29  42 0  6 37 9 0  3]</div><div class="line"></div><div class="line">[ 15 6 17  71 50  37 0  6 32 2 1  9]</div><div class="line"></div><div class="line">[ 11 1  6 151 5   42 0  8 16 0 0 20]]</div></pre></td></tr></table></figure></p>
<p>第一部分是<strong>混淆矩阵</strong>。要了解这是什么意思，你首先需要知道正在使用的标签，在这种情况下，它们分别表示为<code>静音、未知yes、no、up、down、left、right、on、off、stop、go</code>。</p>
<p>第一行是所有的静音剪辑，第二个剪辑是未知的单词，第三个“yes”等。</p>
<p>该矩阵可以比单个准确率得分更有用，因为它可以很好地总结出网络发生的错误。在此示例中，你可以看到除了初始条目之外，第一行中的所有条目都为零。</p>
<p>因为第一行实际上都是静音的片段，所以这意味着它们都没有被错误的标注为文字，所以我们没有任何静音的否定。这表明网络已经越来越好地区分了静音与谈话。</p>
<p><strong>一个完美的模型将产生一个混淆矩阵，其中所有的条目都是从对角线穿过中心的零点</strong>。一旦你确定了可以通过添加更多数据来解决问题，该模型的方差可以帮助你了解模型怎样最容易混淆。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>混淆矩阵之后，你会看到如下一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I0730 16:57:38.073777 55030 train.py:245] Step 400: Validation accuracy = 26.3% (N=3093)</div></pre></td></tr></table></figure></p>
<p>将数据集分为三类是很好的做法。最大的（大约是数据的80％）用于训练网络，一个较小的集（10％ “validation”）被保留用于评估训练中的准确性，另一组10％，“testing”）用于在训练完成后评估准确度。</p>
<p>通过将数据集分类为训练集、验证集、测试集，你可以确保该模型适用于之前从未见过的数据。测试集是一个额外的保障措施，以确保不仅仅是以适用于训练和验证集拟合调整模型。</p>
<p>训练脚本将数据集自动分成这三个类别，上面的记录行显示了在验证集上运行时的模型准确率。理想情况下，这应该与训练准确性相当接近。如果训练准确性增加但验证不是这样，这表明过度拟合正在发生，你的模型只是学习关于训练剪辑的东西，而不是真正的训练模式。</p>
<h2 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h2><p>使用Tensorboard可以看出训练进展。默认情况下，脚本将事件保存到/ tmp / retrain_logs，可以通过运行以下命令来加载它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tensorboard --logdir /tmp/retrain_logs</div></pre></td></tr></table></figure></p>
<p>然后在浏览器中导航到<code>http：// localhost：6006</code>，将看到显示模型进度的图表。</p>
<h2 id="完成训练"><a href="#完成训练" class="headerlink" title="完成训练"></a>完成训练</h2><p>经过几个小时的训练（取决于你的电脑快慢），脚本应该已经完成了所有18000个步骤。它将识别出最终的混淆矩阵，以及准确率分数，全部运行在测试集上。使用默认设置，准确率在85％到90％之间。</p>
<p>因为音频识别在移动设备上特别有用，接下来我们将其导出为，在移动平台上易于使用的格式。要执行此操作，请运行以下命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/freeze.py</div><div class="line"></div><div class="line">--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-18000</div><div class="line"></div><div class="line">--output_file=/tmp/my_frozen_graph.pb</div></pre></td></tr></table></figure></p>
<p>创建固定模型后，可以使用<code>label_wav.py</code>脚本进行测试，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/label_wav.py</div><div class="line"></div><div class="line">--graph=/tmp/my_frozen_graph.pb</div><div class="line"></div><div class="line">--labels=/tmp/speech_commands_train/conv_labels.txt</div><div class="line"></div><div class="line">--wav=/tmp/speech_dataset/left/a5d485dc_nohash_0.wav</div></pre></td></tr></table></figure></p>
<p>可以识别出三个标签：</p>
<p>left (score = 0.81477)</p>
<p>right (score = 0.14139)</p>
<p>_unknown_ (score = 0.03808)</p>
<p>更多内容请查看论文：<a href="http://suo.im/3PW89b" target="_blank" rel="external">http://suo.im/3PW89b</a></p>
<h2 id="在Android应用程序中运行模型"><a href="#在Android应用程序中运行模型" class="headerlink" title="在Android应用程序中运行模型"></a>在Android应用程序中运行模型</h2><p>查看此模型在真实应用程序中如何工作的最简单的方法是，下载预构建的<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android#prebuilt-components" target="_blank" rel="external">Android演示应用程序</a>并将其安装在手机上。</p>
<p>你会看到“TF Speech”出现在应用程序列表中，打开它将显示我们刚刚训练过单词列表，从“yes”和“no”开始。</p>
<p>你还可以自己构建此应用程序，因为它是开源的， 并可作为github上TensorFlow<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android#building-in-android-studio-using-the-tensorflow-aar-from-jcenter" target="_blank" rel="external">存储库的一部分使用</a>。<br>默认情况下，它从tensorflow.org下载一个预先训练的模型，但你可以轻松地用自己训练的模型替换它。</p>
<p>如果你自己创建的话，你需要确保SpeechActivity Java<a href="http://suo.im/2fWbai" target="_blank" rel="external">源文件</a>中的 SAMPLE_RATE，SAMPLE_DURATION符合你训练时的默认设置所做的任何更改。</p>
<p>你还会看到一个Java版本的<a href="http://suo.im/31vKvx" target="_blank" rel="external">Rec<br>ognizeCommands模块</a>。</p>
<p>这与本教程中的C++版本非常相似。如果你调整了参数，还可以在SpeechActivity中进行更新，以获得与服务器测试相同的结果。</p>
<p>演示应用程序，根据你在固定模型复制到模型中的标签文本文件，自动更新其用户界面列表，可以轻松地尝试不同的模型，而无需进行任何代码更改。如果你更改路径，需要update LABEL_FILENAME，MODEL_FILENAME添加到文件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.tensorflow.org/versions/master/tutorials/audio_recognition" target="_blank" rel="external">TensorFlow官网教程：Simple Audio Recognition</a></li>
<li><a href="http://www.sohu.com/a/167209693_798050" target="_blank" rel="external">中文翻译参考</a></li>
<li><a href="https://stackoverflow.com/questions/45952387/anaconda-install-of-tensorflow-missing-audio-ops-from-contrib-framework" target="_blank" rel="external">Tensorflow missing ‘audio_ops’ from contrib framework</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> TensorFlow系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> TensorFlow </tag>
            
            <tag> speech recognition </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TensorFlow基础篇与搭建深层神经网络]]></title>
      <url>/2017/12/28/tensorflow_base/</url>
      <content type="html"><![CDATA[<p>本文是 Tensorflow：实战Google深度学习框架的第三章与第四章。<br><a id="more"></a></p>
<h1 id="第3章-TensorFlow入门"><a href="#第3章-TensorFlow入门" class="headerlink" title="第3章 TensorFlow入门"></a>第3章 TensorFlow入门</h1><h2 id="0-1-查看已安装tensorflow版本"><a href="#0-1-查看已安装tensorflow版本" class="headerlink" title="0.1 查看已安装tensorflow版本"></a>0.1 查看已安装tensorflow版本</h2><p>由于tensorflow版本不同,可能一些函数的调用也有变换,这时候可能需要查看tensorflow版本,可以在终端输入查询命令如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python //windows下cmd进入python环境，linux下终端类似</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line">tf.__version__</div></pre></td></tr></table></figure></p>
<p>查询tensorflow安装路径为:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tf.__path__</div></pre></td></tr></table></figure></p>
<p>参考自：<a href="http://blog.csdn.net/u011961856/article/details/76861052" target="_blank" rel="external">查看已安装tensorflow版本</a></p>
<h2 id="0-2-Tensorflow：实战Google深度学习框架-源码下载"><a href="#0-2-Tensorflow：实战Google深度学习框架-源码下载" class="headerlink" title="0.2 Tensorflow：实战Google深度学习框架 源码下载"></a>0.2 Tensorflow：实战Google深度学习框架 源码下载</h2><ul>
<li><a href="http://www.broadview.com.cn/book/111" target="_blank" rel="external">Tensorflow：实战Google深度学习框架</a></li>
<li><a href="https://github.com/caicloud/tensorflow-tutorial/tree/master/Deep_Learning_with_TensorFlow" target="_blank" rel="external">caicloud/tensorflow-tutorial</a></li>
</ul>
<h2 id="3-2-TensorFlow数据模型——张量"><a href="#3-2-TensorFlow数据模型——张量" class="headerlink" title="3.2 TensorFlow数据模型——张量"></a>3.2 TensorFlow数据模型——张量</h2><h3 id="3-2-1-张量的概念"><a href="#3-2-1-张量的概念" class="headerlink" title="3.2.1 张量的概念"></a>3.2.1 张量的概念</h3><p>一个张量中主要保存了三个属性：名字（name）、维度（shape）、类型（type）。</p>
<h3 id="3-2-2-张量的使用"><a href="#3-2-2-张量的使用" class="headerlink" title="3.2.2 张量的使用"></a>3.2.2 张量的使用</h3><p>两大类。</p>
<p>一是对中间结果的引用。</p>
<p>二是用来获得计算的结果。tf.Session().run(result)</p>
<h2 id="3-3-TensorFlow运行模型——会话"><a href="#3-3-TensorFlow运行模型——会话" class="headerlink" title="3.3 TensorFlow运行模型——会话"></a>3.3 TensorFlow运行模型——会话</h2><h3 id="3-3-1-创建和关闭会话"><a href="#3-3-1-创建和关闭会话" class="headerlink" title="3.3.1 创建和关闭会话"></a>3.3.1 创建和关闭会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个会话。</span></div><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line"><span class="comment"># 使用会话得到之前计算的结果。</span></div><div class="line">print(sess.run(result))</div><div class="line"></div><div class="line"><span class="comment"># 关闭会话使得本次运行中使用到的资源可以被释放。</span></div><div class="line">sess.close()</div></pre></td></tr></table></figure>
<h3 id="3-3-2-使用with-statement-来创建会话"><a href="#3-3-2-使用with-statement-来创建会话" class="headerlink" title="3.3.2 使用with statement 来创建会话"></a>3.3.2 使用with statement 来创建会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">   print(sess.run(result))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 下面的两个命令有相同的功能。</span></div><div class="line">print(sess.run(result))</div><div class="line">print(result.eval(session=sess))</div></pre></td></tr></table></figure>
<h3 id="3-3-3-指定默认会话"><a href="#3-3-3-指定默认会话" class="headerlink" title="3.3.3 指定默认会话"></a>3.3.3 指定默认会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line"><span class="comment"># 下面的两个命令有相同的功能。</span></div><div class="line">print(sess.run(result))</div><div class="line">print(result.eval(session=sess))</div></pre></td></tr></table></figure>
<h3 id="3-3-4-通过ConfigProto配置会话"><a href="#3-3-4-通过ConfigProto配置会话" class="headerlink" title="3.3.4 通过ConfigProto配置会话"></a>3.3.4 通过ConfigProto配置会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">config=tf.ConfigProto(allow_soft_placement=<span class="keyword">True</span>, log_device_placement=<span class="keyword">True</span>)</div><div class="line">sess1 = tf.InteractiveSession(config=config)</div><div class="line">sess2 = tf.Session(config=config)</div></pre></td></tr></table></figure>
<h2 id="3-4-TensorFlow实现神经网络"><a href="#3-4-TensorFlow实现神经网络" class="headerlink" title="3.4 TensorFlow实现神经网络"></a>3.4 TensorFlow实现神经网络</h2><h3 id="3-4-2-前向传播算法简介"><a href="#3-4-2-前向传播算法简介" class="headerlink" title="3.4.2 前向传播算法简介"></a>3.4.2 前向传播算法简介</h3><p>tf.matmul 矩阵乘法</p>
<h3 id="3-4-3-神经网络参数与tensorflow变量"><a href="#3-4-3-神经网络参数与tensorflow变量" class="headerlink" title="3.4.3 神经网络参数与tensorflow变量"></a>3.4.3 神经网络参数与tensorflow变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weights = tf.Variable(tf.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">2</span>))</div></pre></td></tr></table></figure>
<p>产生一个[2,3]的矩阵，矩阵中元素是均值为0，方差为2的随机数。</p>
<p> <strong>1.TensorFlow随机数生成函数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名称</th>
<th style="text-align:center">随机数分布</th>
<th style="text-align:center">主要参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tf.random_normal</td>
<td style="text-align:center">正态分布</td>
<td style="text-align:center">平均值、标准差、取值类型</td>
</tr>
<tr>
<td style="text-align:center">tf.truncated_normal</td>
<td style="text-align:center">正太分布,但如果随机出来的值离平均值超过2个标准差，那么这个数将会被重新随机</td>
<td style="text-align:center">平均值、标准差、取值类型</td>
</tr>
<tr>
<td style="text-align:center">tf.random_uniform</td>
<td style="text-align:center">平均分布</td>
<td style="text-align:center">最小、最大取值、取值类型</td>
</tr>
<tr>
<td style="text-align:center">tf.random_gramma</td>
<td style="text-align:center">Gramma分布</td>
<td style="text-align:center">形状参数alpha、尺度参数beta、取值类型</td>
</tr>
</tbody>
</table>
<p> <strong>2.TensorFlow常数生成函数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名称</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">样例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">tf.zeros</td>
<td style="text-align:center">产生全0的数组</td>
<td style="text-align:center">tf.zeros([2,3],int32)-&gt;[[0,0,0],[0,0,0]]</td>
</tr>
<tr>
<td style="text-align:center">tf.ones</td>
<td style="text-align:center">产生全1的数组</td>
<td style="text-align:center">tf.ones([2,3],int32)-&gt;[[1,1,1],[1,1,1]]</td>
</tr>
<tr>
<td style="text-align:center">tf.fill</td>
<td style="text-align:center">产生一个全部为给定数字的数组</td>
<td style="text-align:center">tf.fill([2,3],9)-&gt;[[9,9,9],[9,9,9]]</td>
</tr>
<tr>
<td style="text-align:center">tf.constant</td>
<td style="text-align:center">产生一个给定值的常量</td>
<td style="text-align:center">tf.constant([1,2,3])-&gt;[1,2,3]</td>
</tr>
</tbody>
</table>
<p>声明了变量之后，程序的第二步会声明一个会话（session）。并通过会话计算结果。</p>
<p>在真正开始计算之前，必须对变量进行初始化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">init_op = tf.global_variables_initializer()  </div><div class="line">sess.run(init_op)</div></pre></td></tr></table></figure></p>
<p>变量分为需要优化的参数（比如神经网络中的参数）和其他参数。<br><code>trainable = True</code>，则该变量会加入<code>GraphKeys.TRAINABLE_VARIABLES</code>集合。</p>
<p>维度（shape）和类型（type）是变量最重要的两个属性。</p>
<h3 id="3-4-4-通过tensorflow训练神经网络模型"><a href="#3-4-4-通过tensorflow训练神经网络模型" class="headerlink" title="3.4.4 通过tensorflow训练神经网络模型"></a>3.4.4 通过tensorflow训练神经网络模型</h3><p>监督学习的思想。</p>
<p>神经网络优化算法中，最常用的是反向传播算法。</p>
<pre><code>x = tf.constant([[0.7, 0.9]])
</code></pre><p>常量表示样例导致计算图特变大。使用<strong>placeholder机制</strong>提供输入数据。</p>
<p>在placeholder定义的时候，这个位置上的数据类型是需要指定的。和其他张量一样，placeholder的类型不可以被改变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = tf.placeholder(tf.float32, shape=(<span class="number">1</span>, <span class="number">2</span>), name=<span class="string">"input"</span>)</div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line">init_op = tf.global_variables_initializer()</div><div class="line">sess.run(init_op)</div><div class="line"></div><div class="line">print(sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>, <span class="number">0.9</span>]]&#125;))</div></pre></td></tr></table></figure></p>
<p>feed_dict时一个字典（map），在字典中需要给出每个用到的placeholder的取值，否则运行会报错。</p>
<p>输入的数据一般是一个batch，不止一个，placeholder也支持输入多个数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = tf.placeholder(tf.float32, shape=(<span class="number">3</span>, <span class="number">2</span>), name=<span class="string">"input"</span>)</div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line"><span class="comment">#使用tf.global_variables_initializer()来初始化所有的变量</span></div><div class="line">init_op = tf.global_variables_initializer()  </div><div class="line">sess.run(init_op)</div><div class="line"></div><div class="line">print(sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>,<span class="number">0.9</span>],[<span class="number">0.1</span>,<span class="number">0.4</span>],[<span class="number">0.5</span>,<span class="number">0.8</span>]]&#125;))</div></pre></td></tr></table></figure></p>
<p>在得到一个batch的前向传播结果之后，需要<strong>定义一个损失函数</strong>来刻画当前的预测值与真实答案之间的差距。然后通过反向传播算法来调整网络参数之间的取值使得差距可以被缩小。</p>
<h3 id="3-4-5-完整的神经网络样例程序"><a href="#3-4-5-完整的神经网络样例程序" class="headerlink" title="3.4.5 完整的神经网络样例程序"></a>3.4.5 完整的神经网络样例程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> RandomState</div><div class="line"></div><div class="line"><span class="comment"># 1. 定义神经网络的参数，输入和输出节点。</span></div><div class="line">batch_size = <span class="number">8</span></div><div class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</div><div class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</div><div class="line">x = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">2</span>), name=<span class="string">"x-input"</span>)</div><div class="line">y_ = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y-input'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 定义前向传播过程，损失函数及反向传播算法。</span></div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"><span class="comment"># tf.clip_by_value(A, min, max)：输入一个张量A，把A中的每一个元素的值都压缩在min和max之间。小于min的让它等于min，大于max的元素的值等于max。</span></div><div class="line">cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, <span class="number">1e-10</span>, <span class="number">1.0</span>)))</div><div class="line">train_step = tf.train.AdamOptimizer(<span class="number">0.001</span>).minimize(cross_entropy)</div><div class="line"></div><div class="line"><span class="comment"># 3. 生成模拟数据集。</span></div><div class="line">rdm = RandomState(<span class="number">1</span>)</div><div class="line">dataset_size = <span class="number">128</span></div><div class="line">X = rdm.rand(dataset_size, <span class="number">2</span>)</div><div class="line">Y = [[int(x1 + x2 &lt; <span class="number">1</span>)] <span class="keyword">for</span> (x1, x2) <span class="keyword">in</span> X]</div><div class="line"></div><div class="line"><span class="comment"># 4. 创建一个会话来运行TensorFlow程序。</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    init_op = tf.global_variables_initializer()</div><div class="line">    sess.run(init_op)</div><div class="line"></div><div class="line">    <span class="comment"># 输出目前（未经训练）的参数取值。</span></div><div class="line">    print(<span class="string">"w1:"</span>, sess.run(w1))</div><div class="line">    print(<span class="string">"w2:"</span>, sess.run(w2))</div><div class="line">    print(<span class="string">"\n"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 训练模型。</span></div><div class="line">    STEPS = <span class="number">5000</span>  <span class="comment"># 设定训练的轮数</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</div><div class="line">        start = (i * batch_size) % <span class="number">128</span></div><div class="line">        end = (i * batch_size) % <span class="number">128</span> + batch_size</div><div class="line">        sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y[start:end]&#125;)</div><div class="line">        <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</div><div class="line">            total_cross_entropy = sess.run(cross_entropy, feed_dict=&#123;x: X, y_: Y&#125;)</div><div class="line">            print(<span class="string">"After %d training step(s), cross entropy on all data is %g"</span> % (i, total_cross_entropy))</div><div class="line"></div><div class="line">    <span class="comment"># 输出训练后的参数取值。</span></div><div class="line">    print(<span class="string">"\n"</span>)</div><div class="line">    print(<span class="string">"w1:"</span>, sess.run(w1))</div><div class="line">    print(<span class="string">"w2:"</span>, sess.run(w2))</div></pre></td></tr></table></figure>
<p>输出为：</p>
<p>训练之前的神经网络的参数值：</p>
<blockquote>
<p>w1: [[-0.81131822  1.48459876  0.06532937]<br> [-2.4427042   0.0992484   0.59122431]]</p>
<p>w2: [[-0.81131822]<br> [ 1.48459876]<br> [ 0.06532937]]</p>
</blockquote>
<p>可以发现，随着训练的进行，交叉熵是逐渐减小的。交叉熵越小说明预测的结果和真实的结果差距越小。</p>
<blockquote>
<p>After 0 training step(s), cross entropy on all data is 0.0674925</p>
<p>After 1000 training step(s), cross entropy on all data is 0.0163385</p>
<p>After 2000 training step(s), cross entropy on all data is 0.00907547</p>
<p>After 3000 training step(s), cross entropy on all data is 0.00714436</p>
<p>After 4000 training step(s), cross entropy on all data is 0.00578471<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">训练之后的神经网络的参数值：</div><div class="line">&gt; </div><div class="line">&gt; w1: [[-1.9618274   2.58235407  1.68203783]</div><div class="line">&gt;  [-3.46817183  1.06982327  2.11789012]]</div><div class="line">&gt;  </div><div class="line">&gt; w2: [[-1.82471502]</div><div class="line">&gt;  [ 2.68546653]</div><div class="line">&gt;  [ 1.41819513]]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 第4章 深层神经网络</div><div class="line"></div><div class="line">## 4.1 深度学习与深层神经网络</div><div class="line"></div><div class="line">### 4.1.1 线性模型的局限性</div><div class="line">### 4.1.2 激活函数实现去线性化</div><div class="line"></div><div class="line">激活函数：tf.nn.relu、tf.sigmoid和tf.tanh。</div><div class="line"></div><div class="line">### 4.1.3 多层网络解决异或运算</div><div class="line"></div><div class="line">单层感知机无法模拟异或运算。加入了隐含层之后，就可以解决异或问题。</div><div class="line"></div><div class="line">## 4.2损失函数的定义</div><div class="line"></div><div class="line">### 4.2.1 经典损失函数</div><div class="line"></div><div class="line">交叉熵(cross entropy)。用q来表示p的交叉熵为：</div><div class="line">$$H(p,q)=-\sum_x p(x)\text&#123;log&#125; q(x)$$</div><div class="line"></div><div class="line">p代表的是正确答案，q代表的是预测值。交叉熵刻画的是两个概率分布的距离，也就是说交叉熵越小，两个概率分布越接近。</div><div class="line"></div><div class="line">`softmax`回归：将神经网络的输出变成一个概率分布。</div><div class="line"></div><div class="line">交叉熵的代码实现：</div><div class="line"></div><div class="line">	cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))</div><div class="line"></div><div class="line"></div><div class="line">其中，`tf.clip_by_value`的用法</div><div class="line"></div><div class="line">`tf.clip_by_value(A, min, max)：`输入一个张量A，把A中的每一个元素的值都压缩在`min`和`max`之间。小于`min`的让它等于`min`，大于`max`的元素的值等于`max`。</div><div class="line"></div><div class="line">	import tensorflow as tf;  </div><div class="line">	import numpy as np;  </div><div class="line">	  </div><div class="line">	A = np.array([[1,1,2,4], [3,4,8,5]])  </div><div class="line">	  </div><div class="line">	with tf.Session() as sess:  </div><div class="line">	    print sess.run(tf.clip_by_value(A, 2, 5)) </div><div class="line"></div><div class="line">输出：</div><div class="line"></div><div class="line">&gt; [[2 2 2 4]</div><div class="line">&gt; </div><div class="line">&gt;  [3 4 5 5]]</div><div class="line"></div><div class="line">`tf.log`是对张量中所有元素依次求对数。</div><div class="line"></div><div class="line">`*`操作是元素之间直接相乘，矩阵乘法是`tf.matmul`。</div><div class="line"></div><div class="line">上面三个计算得到的结果是nxm的矩阵。</div><div class="line"></div><div class="line">`tf.reduce_mean`的用法。</div><div class="line"></div><div class="line">	v = tf.constant([[1.0, 2.0, 3.0, 4.0], [4.0, 5.0, 6.0, 7.0]])</div><div class="line">	sess = tf.Session()</div><div class="line">	init_op = tf.global_variables_initializer()</div><div class="line">	sess.run(init_op)</div><div class="line">	print(tf.reduce_mean(v).eval(session=sess))</div><div class="line">	# 程序输出为：4.0 = sum/8</div><div class="line"></div><div class="line">### 4.2.2 自定义损失函数</div><div class="line">当然tensorflow也支持自定义损失函数。</div><div class="line">## 4.3 神经网络优化算法</div><div class="line">假设用$\theta$表示神经网络中的参数，$J(\theta)$表示在给定的参数取值下，训练集上损失函数的大小，那么整个优化过程可以抽象为：寻找一个参数$\theta$，使得$J(\theta)$最小。</div><div class="line"></div><div class="line">对于参数$\theta$，其梯度为$\frac&#123;\partial&#125;&#123;\partial\theta&#125;J(\theta)$。有了梯度，还需要学习率$\eta $(learning rate)来控制每次参数更新的幅度。</div><div class="line">因此，参数更新的公式为：</div><div class="line">$$\theta_&#123;n+1&#125; = \theta_n -  \eta \frac&#123;\partial&#125;&#123;\partial\theta&#125;J(\theta)$$</div><div class="line"></div><div class="line">需要注意的是梯度下降算法并不能保证达到全局最优解，此外还存在计算时间过长的问题。</div><div class="line"></div><div class="line">为了加速训练过程，可以使用随机梯度下降(stochastic gradient descent)算法。每一轮迭代中随机优化某一条训练数据的损失函数。</div><div class="line"></div><div class="line">在实际应用中，采用折中的方法：**每次计算一小部分训练数据的损失函数**。这一小部分数据被称为&lt;font color=AA00AA&gt;**batch**&lt;/font&gt;。</div><div class="line"></div><div class="line">## 4.4 神经网络进一步优化</div><div class="line">### 4.4.1 学习率的设置</div><div class="line"></div><div class="line">假设我们要最小化函数  $y=x^2$, 选择初始点   $x_0=5$。</div><div class="line">#### 1. 学习率为1时</div><div class="line">```python</div><div class="line">import tensorflow as tf</div><div class="line">TRAINING_STEPS = 10</div><div class="line">LEARNING_RATE = 1</div><div class="line">x = tf.Variable(tf.constant(5, dtype=tf.float32), name=&quot;x&quot;)</div><div class="line">y = tf.square(x)</div><div class="line"></div><div class="line">train_op = tf.train.GradientDescentOptimizer(LEARNING_RATE).minimize(y)</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    for i in range(TRAINING_STEPS):</div><div class="line">        sess.run(train_op)</div><div class="line">        x_value = sess.run(x)</div><div class="line">        print &quot;After %s iteration(s): x%s is %f.&quot;% (i+1, i+1, x_value)</div></pre></td></tr></table></figure></p>
</blockquote>
<p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">After 1 iteration(s): x1 is -5.000000.</div><div class="line">After 2 iteration(s): x2 is 5.000000.</div><div class="line">After 3 iteration(s): x3 is -5.000000.</div><div class="line">After 4 iteration(s): x4 is 5.000000.</div><div class="line">After 5 iteration(s): x5 is -5.000000.</div><div class="line">After 6 iteration(s): x6 is 5.000000.</div><div class="line">After 7 iteration(s): x7 is -5.000000.</div><div class="line">After 8 iteration(s): x8 is 5.000000.</div><div class="line">After 9 iteration(s): x9 is -5.000000.</div><div class="line">After 10 iteration(s): x10 is 5.000000.</div></pre></td></tr></table></figure></p>
<p>学习率为1的时候，x在5和-5之间震荡。</p>
<h4 id="2-学习率为0-001时"><a href="#2-学习率为0-001时" class="headerlink" title="2. 学习率为0.001时"></a>2. 学习率为0.001时</h4><p>将上述代码中的学习率设为0.001（很小），如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LEARNING_RATE = <span class="number">0.001</span></div></pre></td></tr></table></figure></p>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">After 1 iteration(s): x1 is 4.990000.</div><div class="line">After 101 iteration(s): x101 is 4.084646.</div><div class="line">After 201 iteration(s): x201 is 3.343555.</div><div class="line">After 301 iteration(s): x301 is 2.736923.</div><div class="line">After 401 iteration(s): x401 is 2.240355.</div><div class="line">After 501 iteration(s): x501 is 1.833880.</div><div class="line">After 601 iteration(s): x601 is 1.501153.</div><div class="line">After 701 iteration(s): x701 is 1.228794.</div><div class="line">After 801 iteration(s): x801 is 1.005850.</div><div class="line">After 901 iteration(s): x901 is 0.823355.</div></pre></td></tr></table></figure></p>
<p>学习率为0.001的时候，下降速度过慢，在901轮时才收敛到0.823355。</p>
<h4 id="3-使用指数衰减的学习率"><a href="#3-使用指数衰减的学习率" class="headerlink" title="3. 使用指数衰减的学习率"></a>3. 使用指数衰减的学习率</h4><p>将上述代码中的学习率设为指数衰减的方式，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LEARNING_RATE = tf.train.exponential_decay(<span class="number">0.1</span>, global_step, <span class="number">1</span>, <span class="number">0.96</span>, staircase=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">After 1 iteration(s): x1 is 4.000000, learning rate is 0.096000.</div><div class="line">After 11 iteration(s): x11 is 0.690561, learning rate is 0.063824.</div><div class="line">After 21 iteration(s): x21 is 0.222583, learning rate is 0.042432.</div><div class="line">After 31 iteration(s): x31 is 0.106405, learning rate is 0.028210.</div><div class="line">After 41 iteration(s): x41 is 0.065548, learning rate is 0.018755.</div><div class="line">After 51 iteration(s): x51 is 0.047625, learning rate is 0.012469.</div><div class="line">After 61 iteration(s): x61 is 0.038558, learning rate is 0.008290.</div><div class="line">After 71 iteration(s): x71 is 0.033523, learning rate is 0.005511.</div><div class="line">After 81 iteration(s): x81 is 0.030553, learning rate is 0.003664.</div><div class="line">After 91 iteration(s): x91 is 0.028727, learning rate is 0.002436.</div></pre></td></tr></table></figure></p>
<p>使用指数衰减的学习率，在迭代初期得到较高的下降速度，可以在较小的训练轮数下取得不错的收敛程度。</p>
<h3 id="4-4-2-过拟合问题"><a href="#4-4-2-过拟合问题" class="headerlink" title="4.4.2 过拟合问题"></a>4.4.2 过拟合问题</h3><p>为了避免过拟合，一个非常常用的方法是正则化(regularization)，加入刻画模型复杂程度的指标$R(w)$，优化时优化$J(\theta)+\lambda R(w) $。</p>
<p>常用的正则化方法有：L1正则化和L2正则化。<br>$$R(w) =||w||_1 =\sum_i|w_i|$$<br>$$R(w) =||w||_2^2 =\sum_i|w_i^2|$$</p>
<p>无论哪一种正则化的方式，其思想都是通过限制权重的大小，使得模型不能任意拟合训练数据中的随机噪声。</p>
<p>区别在于，L1正则化会使得参数变得更加稀疏，而L2正则化则不会；此外，L1正则化的计算公式不可导，而L2正则化公式可导。</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VS2015 设置调试时不加载符号]]></title>
      <url>/2017/12/27/CPP_VS2015_noPDB/</url>
      <content type="html"><![CDATA[<p><img src="https://images2.imgbox.com/1c/a2/uWHMn9oN_o.png" alt="调试加载界面"><br>人生苦短，消除等待！！</p>
<a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用VS2015打开代码文件，按下F5进行调试，当电脑接入网络后系统会<strong>自动从Microsoft符号服务器加载PDB符号文件</strong>，而且是每次都会加载。如下图所示：<br><img src="https://images2.imgbox.com/1c/a2/uWHMn9oN_o.png" alt="调试加载界面"></p>
<p>此加载符号过程使得调试变得非常慢。</p>
<p>通过查阅得知，此类的pdb调试器在编写代码时对于新手来说，根本用不到。也就是说完全可以不需要加载。</p>
<p>那么如何避免VS2013调试时自动加载符号呢？</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li><p>打开VS的【工具】-【选项】：<br><img src="https://images2.imgbox.com/bc/8e/PXMTNcYk_o.png" alt="工具选项"></p>
</li>
<li><p>选择其中的【调试】-【符号】，并 取消勾选“Microsoft符号服务器” ：<br><img src="https://images2.imgbox.com/eb/35/XrMdw2M8_o.png" alt="取消勾选"></p>
</li>
<li><p>确定并退出即可，此后再次按F5进行调试。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><p><a href="https://jingyan.baidu.com/article/fea4511a1a1040f7bb91251a.html" target="_blank" rel="external">VS2013代码调试：如何避免调试时加载符号</a></p>
</li>
<li><p><a href="http://blog.csdn.net/u010186001/article/details/52759945" target="_blank" rel="external">vs2015加载符号慢，请问怎么解决</a></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> VS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习技法笔记01：最佳分类超平面]]></title>
      <url>/2017/12/26/ML_taiwan_01/</url>
      <content type="html"><![CDATA[<h2 id="Large-Margin-Separating-Hyperplane"><a href="#Large-Margin-Separating-Hyperplane" class="headerlink" title="Large-Margin Separating Hyperplane"></a>Large-Margin Separating Hyperplane</h2><p>题目翻译为中文的意思大体上是 最大余量分类超平面。本节主要讲解如何确定该最佳分类超平面。</p>
<a id="more"></a>
<p>首先，我们回顾一下之前讲过的Linear Classfication ：有$\circ$和$\times$，我们用一条直线将$\circ$和$\times$分开，或者在高维空间中使用超平面将其分开。数学上，将资料拿来计算一个加权和，根据和的正负预测$\circ$和$\times$。</p>
<p>现在，给定一个线性可分的资料，则会有很多条线将和分开，但是下图中的那条线会更好呢？</p>
<p><img src="/2017/12/26/ML_taiwan_01/ML01.png" alt=""></p>
<p>PLA(Perceptron learning algorithm,For binary classification解决是非问题)会选哪一条线与PLA看到的错误有关，因此PLA得到哪一条线不定。从之前的理论来看，三条线似乎也没什么区别，例如从VC Bound来看：<br>$$E_{out}(w)\leqslant E_{in}(w) + \Omega(H) $$</p>
<p>其中$E_{in}(w)$为训练样本上的错误率，三条线都满足；$\Omega(H)$为复杂度，都是线，因此复杂度都为<code>d+1</code>。但是我们的直觉告诉我们最右边是最好的线。</p>
<p>一种原始的解释：<br>假设我们已经拿到原始资料，即图上的点，但是在测试的时候我们拿到跟原始资料相近的资料(测量误差、资料收集等造成)，下图中灰色的x。所以，测试资料可能会和训练资料有点出入。</p>
<p>假设我们绝对相信我们的训练资料，若果有误差，则我们人为最好的预测为将测试资料预测的与训练资料很接近(不完全一样)。</p>
<p><img src="/2017/12/26/ML_taiwan_01/ML02.png" alt=""></p>
<p>上图中左边与右边最大的差别就在于<strong>对测量误差的容忍度</strong>，点距离线越远则容忍度越好(<code>tolerate more noise</code>)，进而可以避免过拟合(<code>more robust to overfitting</code>)。</p>
<p>或者换个角度，看这条线有多胖（能涨出去多少），倾向于选择胖的线。</p>
<p><img src="/2017/12/26/ML_taiwan_01/ML03.png" alt=""></p>
<blockquote>
<p>robustness = fatness: distance to closest xn<br>比较胖的线是比较好的。</p>
<p>goal: find fattest separating hyperplane<br>在分类正确的基础上，找出最胖、最强壮(鲁棒)的线。</p>
</blockquote>
<p><strong>目标</strong>是：<br>我们要找出一条线，首先这条线可以将$\circ$和$\times$分开(线性可分)，然后取最胖的一条线，即计算所有点到线的距离，取其中最小的距离。也就是下面的公式所描述的：<br><img src="/2017/12/26/ML_taiwan_01/ML04.png" alt=""></p>
<p><code>fatness: formally called margin</code>：<br>最胖的线，术语上叫“margin”，余量，留白的多少。</p>
<p><code>correctness: yn = sign(w^T x_n)</code><br>算出来的分数是正的还是负的，相乘是同号(分类正确)就可以。</p>
<p><code>goal: find largest-margin separating hyperplane</code>：寻找边界最宽，能够完全分开的线（超平面）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/nysyxxg/article/details/52843827" target="_blank" rel="external">台大林轩田《机器学习基石》学习笔记5：线性模型一（PLA/pocket、Linearregression ）</a></li>
<li><a href="http://blog.csdn.net/xiong452980729/article/details/52234270" target="_blank" rel="external">机器学习技法(林軒田)笔记之一</a></li>
<li>机器学习技法(林軒田)视频与讲稿。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Machine Learning </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Primer学习笔记：(一/二)从基本类型开始]]></title>
      <url>/2017/12/25/CPP_01_02/</url>
      <content type="html"><![CDATA[<p>本文介绍了C++的基础知识点。包括但不限于：</p>
<ul>
<li>顶层const与底层const</li>
<li>constexpr</li>
<li>auto</li>
<li>decltype</li>
<li>struct</li>
<li>头文件保护符</li>
</ul>
<a id="more"></a>
<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="include指令-P6-1-2"><a href="#include指令-P6-1-2" class="headerlink" title="include指令(P6,1.2)"></a>include指令(P6,1.2)</h2><p>通常情况下<code>#include</code>指令必须在所有函数之外。include和它想包含的头文件名字必须在同一行里，不然会报错。</p>
<p>一般情况下我们把include指令放在源文件代码内容的最前面，当你在源文件中使用<code>#include</code>声明了一个头文件，效果相当于你把整个头文件黏贴到对应的那一行上。</p>
<h2 id="编译器-P14-1-4"><a href="#编译器-P14-1-4" class="headerlink" title="编译器(P14,1.4)"></a>编译器(P14,1.4)</h2><p>编译器的一部分工作是寻找程序文本中的错误。<br>常见错误类型：</p>
<ul>
<li>语法错误(syntax error)</li>
<li>类型错误(type error)</li>
<li>声明错误(declaration error)</li>
</ul>
<p><strong>“编辑-编译-调试”（edit-compile-debug）</strong>周期。</p>
<h2 id="文件重定向-P19-1-5"><a href="#文件重定向-P19-1-5" class="headerlink" title="文件重定向(P19,1.5)"></a>文件重定向(P19,1.5)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> addItems &lt;infile &gt;outfile</div></pre></td></tr></table></figure>
<h2 id="术语表-P23"><a href="#术语表-P23" class="headerlink" title="术语表(P23)"></a>术语表(P23)</h2><ol>
<li>花括号 curly brace</li>
<li>内置类型 built-in type</li>
<li>形参列表 parameter list</li>
<li>字符串字面值常量 string literal</li>
<li>操作符 manipulator</li>
<li>变量 variable</li>
<li>初始化 initialize</li>
<li>注释 comments</li>
<li>集成开发环境 Integrated Developed Environment,IDE</li>
<li>条件 condition</li>
<li>赋值 assignment</li>
<li>表达式 expression</li>
<li>语法错误 syntax error</li>
<li>方法（类方法） method</li>
</ol>
<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="C-语言关于类型的规定-P30-2-1-1"><a href="#C-语言关于类型的规定-P30-2-1-1" class="headerlink" title="C++语言关于类型的规定(P30,2.1.1)"></a>C++语言关于类型的规定(P30,2.1.1)</h2><p>C++语言的基本类型的设定与硬件紧密相关，因此很多类型的内存尺寸也都只是给了一个范围，其实各家IDE（LLVM，GCC，Visaul C++）的实现都是在范围内，具体的实现细节都是不确定的。</p>
<p>其中bool最小尺寸未定义，char最小尺寸是8位，wchar_t和char16_t的最小尺寸都是16位，char32_t的最小尺寸是32位，int的最小尺寸是16位，long和long long的最小尺寸分别是32位和64位，对于浮点型数据的表现尺寸是按照精度计算的，其中float的最小尺寸精度是小数点后6位(通常占内存32bytes)，double（通常占内存 64bytes）和long double(通常占内存 96~128bytes)的最小尺寸精度则是小数点后10位(实际可能比这个精度要大一些，比如float小数点后有效位为7，double为16)。</p>
<p>int不得小于short,long不得小于int,long long不得小于long。float,double,long double也应该是精度递增（或者相同）的关系。</p>
<p>要特别注意的是，<strong>扩展的字符类型</strong>(char16_t，char32_t，wchar_t)<strong>和布尔类型都没有带符号和无符号之分</strong>（尽管它们也确实属于算数类型）。</p>
<h2 id="类型转换-P32-2-1-2"><a href="#类型转换-P32-2-1-2" class="headerlink" title="类型转换(P32,2.1.2)"></a>类型转换(P32,2.1.2)</h2><p>程序自动执行的类型转换操作发生在程序里IDE预期我们使用A类型但是实际上我们使用B类型的时候，B类型的对象会自动转换为A类型的，如果没法转换，程序就会报错。赋值操作中就可能发生这样的情况。</p>
<p>我们先看赋值操作里表达式里面发生的自动转换，赋值操作A=B中，等号左边的A被叫做<strong>左值</strong>，B被叫做<strong>右值</strong>，程序期待事情是你给定的右值和左值类型完全相同。如果不相同，这里就会发生<strong>强制的类型转换</strong>，即把B的类型转化为A的类型。如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个无符号类型，比如<code>unsigned char c=-1;</code>这时-1（整型，负的），右值会转化为无符号字符型，初始值对无符号类型表示数值总数取模，然后求余数，这个余数就是转化后的数。</p>
<p>因为C++没有明确规定有符号类型的数应该如何表示，因此如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个有符号类型，这种行为的结果是不一定的，因为C++标准委员会没有规定这样做之后到底会发生什么，因此各个IDE可能会有不同的实现。我们把这种不确定造成结果的行为叫做<strong>未定义行为</strong>。</p>
<p><strong>建议：避免无法预知和依赖于环境的行为</strong>。</p>
<p><strong>提示：切勿混用带符号类型和无符号类型</strong>。</p>
<h2 id="转义序列-P36，2-1-3"><a href="#转义序列-P36，2-1-3" class="headerlink" title="转义序列(P36，2.1.3)"></a>转义序列(P36，2.1.3)</h2><p>字符的转义序列可以为<code>\</code>后面加上最多3个8进制数字（如果多于3个不会引发报错，多出的部分会被当成字符），或者<code>\x</code>后面加上最多两个16进制数字（多出会报错）。数字转换成10进制后的大小不得超过字符集的限定范围。一般的字面值转义无此限制，不过，一般的字面值的类型是不确定的。10进制数字类型字面值会被转换为能够容纳这个数的带符号整数类型，其他进制中它们则会被转换为能容纳它们的占内存最小的类型的值。</p>
<p>在最新的C++14标准中，数字字面值里还允许以0b或者0B开头，后面加上二进制数成为二进制字面值。如0B101，代表数字5；0b11，代表数字3。</p>
<p>指定字面值的常量：当使用一个长整型字面值时，请使用大写字母<code>L</code>来标记，因为小写字母<code>l</code>和数字<code>1</code>太容易混淆了。</p>
<h2 id="变量-P38"><a href="#变量-P38" class="headerlink" title="变量(P38)"></a>变量(P38)</h2><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>C++11标准：列表初始化(list initialization)，用一组花括号来初始化变量。下面的第三种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong>声明变量：在变量名前添加关键字<code>extern</code>，而且不要显示地初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;        <span class="comment">// 仅仅是声明</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">0</span>;     <span class="comment">// 声明且定义</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> v;             <span class="comment">// 声明且定义</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;        <span class="comment">// 声明且定义</span></div></pre></td></tr></table></figure></p>
<p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p>
<p>补：</p>
<blockquote>
<p>extern外部变量声明其实是在IDE进行编译的时候告诉IDE，这有一个外部变量你要去别的地方找。因此我们应该掌握编译链接这套流程才能够更加方便的会用extern。假设有一个头文件a.h，这个头文件里面定义了int aaa=0;还有一个源文件b.cpp。这个b.cpp里面使用了extern int aaa;这样的语句，那么这个b.cpp是编译不了的。因为头文件如果不被别的源文件引用，是不参与被编译为obj的过程的，一旦它不参与这个过程，它里面声明的aaa这个全局变量其实就不存在，因此在b.cpp里面外部生命一个不存在的变量自然就是非法的。另外，使用extern也要和static做区分并考量它在别的文件中会不会造成内存污染等问题。这里应该掌握分离式编译的编译和链接特性再使用extern比较好。</p>
</blockquote>
<p><strong>静态类型</strong>(P42)</p>
<h3 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h3><p><strong>初始化所有指针</strong>： 初始化为nullptr或0。</p>
<p><strong>void *指针</strong>(P50)：特殊的指针类型，可以存放任意对象的地址。我们对该指针中到底是个什么类型的对象并不了解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1,p2;</div></pre></td></tr></table></figure>
<p>其中，p1是指向int的指针，p2是int。(强调变量具有的复合类型。)</p>
<p><strong>指向指针的指针</strong>：通过<code>*</code>的个数可以区分指针的级别，即：<code>**</code>表示指向指针的指针，<code>***</code>表示指向指针的指针的指针。</p>
<p><strong>指向指针的引用</strong>(P52)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p;</div><div class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是对指针p的引用</span></div><div class="line"></div><div class="line">r = &amp;i; <span class="comment">//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></div><div class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></div></pre></td></tr></table></figure></p>
<p><font color="00cc00"><strong>面对一条比较复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义</strong></font>。<br>离变量名最近的符号（此例中是<code>&amp;r</code>的符号<code>&amp;</code>）对<strong>变量的类型有最直接的影响</strong>，因此<code>r</code>是一个引用。声明符的其余部分用以确定<code>r</code>引用的类型是是什么，此例中的符号<code>*</code>说明<code>r</code>引用的是一个指针。最后，声明的基本数据类型部分指出<code>r</code>引用的是一个<code>int</code>指针。</p>
<h2 id="顶层const-P57-2-4-3"><a href="#顶层const-P57-2-4-3" class="headerlink" title="顶层const(P57,2.4.3)"></a>顶层const(P57,2.4.3)</h2><p>顶层const是对const而言的，“顶层”可以用来修饰<code>const</code>状态的形容词。一个<code>const</code>使对象本身的值固定，这个<code>const</code>就被称为顶层const;一个<code>const</code>是对象指向或引用的对象成为固定值，这个const就被称为底层const。</p>
<p>顶层和底层const对拷贝来说密切相关，有相同底层const资格的两个对象才能够互相拷贝，而且顶层const声明变量之后不允许再次改变const的值。<br><code>int p,const int *a＝&amp;p;</code>这种语句中的const就是底层const。<br>像<code>int v1=9;const int *p=&amp;v1;int *p2=p;</code>这种语句如果能够通过编译，那么我们就可以使用p2的性质改变p1指向的常量的值，但是常量的值是不能够被改变的，因此这种变相改变常量的值的表达式都是错误的。可以通过分析const级别得到表达式中常量是否被更改，从而判断语句的正确性。</p>
<p>说到底，顶层底层说的是对拷贝控制的约束。总的规则就是“不能改变常量的值”。因此“拷入和拷出的对象都要有相同的底层const资格，或者两个对象数据类型必须能转换”，例如，有<code>int *p1,const int *p2;</code>。p1没有底层const,p2有底层const。p1=p2;这时<code>const int*</code>不能转换成<code>int *</code>(如果转换，就违反了“不能改变常量的值这一约束条件”)，因此<code>p1=p2;</code>不合法。<code>p2=p1;``int *</code>能够转换成<code>const int *</code>,因此<code>p2=p1</code>合法。</p>
<h2 id="constexpr-P58-2-4-4"><a href="#constexpr-P58-2-4-4" class="headerlink" title="constexpr(P58,2.4.4)"></a>constexpr(P58,2.4.4)</h2><p>我们在了解<code>constexpr</code>之前，应该先了解<strong>常量表达式</strong>。所谓常量就是固定的量，那么常量表达式就是值固定不变的表达式，这里“值固定不变”，指的是程序编译阶段，常量表达式的值就能被确定下来之后也不能对其进行任何种方式的修改。因此这个固定，是编译之后固定的。像<code>cout&lt;&lt;1234&lt;&lt;endl;</code>中的1234，就是常量表达式，显然，字面值是常量表达式。</p>
<p><code>constexpr</code>的作用之一就是帮助程序员在IDE的提示下查看一个赋值语句是不是常量表达式。使用的方式包含在声明语句里面，形如<code>constexpr 变量类型 变量名=右值;</code>如果右值是一个常量，这条语句就是正确的。在所有函数体外声明的全局变量的地址就符合“在编译期间能确定，编译后值不被改变”这两个条件，因此也属于常量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>; <span class="comment">// 20是常量表达式</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// mf+1是常量表达式</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size(); <span class="comment">//只有当size是一个constexpr函数时，才是一条正确的语句。</span></div></pre></td></tr></table></figure></p>
<p>另外，用constexpr声明的指针(比如，<code>constexpr int *p=&amp;v1;</code>中的<code>*p</code>，相当于<code>int *const p=&amp;v1;</code>)都是顶层const，即指针本身值固定。但是指针指向的内容是可以变的。引用也一样。</p>
<p><strong>定义于函数体之外的变量的地址是固定的，可以用来初始化constexpr指针</strong>。</p>
<p>当你使用constexpr定义引用变量的时候，这个变量引用的对象只能是全局基本数据类型（引用类型除外的）变量（因为要求的内存地址必须是固定不变的）。constexpr引用的结果和正常的引用的结果是一致的，因为引用本身就是固定不变的，因此相当于顶层const修饰的constexpr对引用类型类说没有特殊的意义。 </p>
<h2 id="类型别名-P61-2-4-4"><a href="#类型别名-P61-2-4-4" class="headerlink" title="类型别名(P61,2.4.4)"></a>类型别名(P61,2.4.4)</h2><p>使用<code>typedef int zhengxing;</code>这种对简单的类型名进行替换的方式无疑是非常直观并且好理解的，但是在涉及到复杂的类型名的时候往往会出现各种各样的问题。</p>
<p>比如<code>typedef char *Pstring;</code>这条语句是不是就意味着我们看到<code>Pstring</code>就可以用<code>char *</code>替换呢。其实并不是，实际上类型别名不只是替换的规则，而是要复杂很多。</p>
<p>比如我们遇到<code>const Pstring a;</code>的时候，按照替换的规则，这条语句就相当于<code>const char * a;</code>这里的const这种情况下是底层const，但是结果并不是这样的，这条语句正确的等同语句应该是<code>char *const a;</code>是一个顶层const，即指针本身是一个常量。让我们来分析一下为什么是这个样子，而不是简单的替换就行了。<code>typedef char *Pstring；</code>这条语句就是说<code>Pstring</code>是一个类型别名，它是什么类型的类型别名呢？Pstring是 指向char的指针的类型别名，也就是说，这个类型修饰的对象必须是一个指针，这个指针也必须指向char而不能指向别的什么东西，比如，不能指向<code>const char</code>。我们再看看<code>const Pstring a;</code>这个语句，首先a一定是指向char的指针。所以这个前面的const应该是用来修饰这个指针本身。也就是说，这个指针是<strong>常量指针</strong>而非指向常量的指针。这一点非常重要。</p>
<p><code>const char * a</code>这个语句里面，实际上类型是<code>const char</code>，<code>*</code>是声明符的一部分。我们说过，定义一个变量由两部分组成，类型名和声明符，声明符可以是<code>*</code>或者<code>&amp;</code>加上变量名的形式。而类型别名只是给类型一个别名，至于声明符是怎样的，不在它修饰的范围内。因此在有const的情况下，就可以看出来这两者之间的区别还是很明显的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</div><div class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></div><div class="line"><span class="keyword">const</span> pstring *ps; <span class="comment">//ps是一个指针，它的对象是指向char的常量指针。</span></div></pre></td></tr></table></figure>
<p>pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const char *cstr = 0; //是对const pstring的错误理解</div></pre></td></tr></table></figure></p>
<p>数据类型就变成了<code>char</code>，<code>*</code>成为了声明符的一部分。这样改写的结果是，<code>const char</code>成了基本数据类型。cstr是一个指针，指向了常量字符。</p>
<h2 id="auto类型声明符-P61-2-5-2"><a href="#auto类型声明符-P61-2-5-2" class="headerlink" title="auto类型声明符(P61,2.5.2)"></a>auto类型声明符(P61,2.5.2)</h2><p>C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。</p>
<p><code>auto</code>变量通过初始化语句，计算出右值的类型，并推导出左值的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>, &amp;r = i;</div><div class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个整数（r是i的别名，而i是一个整数）</span></div></pre></td></tr></table></figure></p>
<p>这个过程中auto将会忽视顶层const和引用类型，可用<code>const auto &amp;a=i;</code>这种方式显式地指出了：指出要推导的结果是带顶层指针属性的或者是引用属性的。</p>
<p>auto推导多个值时，这些值的类型必须是一样的。因为auto是利用初始化赋值，因此它的行为基本上也和初始化有关。</p>
<p>关于auto的更多用法：<a href="http://blog.csdn.net/zxh2075/article/details/9235591" target="_blank" rel="external">【C++11】新特性——auto的使用</a></p>
<h2 id="decltype类型指示符-P62-2-5-3"><a href="#decltype类型指示符-P62-2-5-3" class="headerlink" title="decltype类型指示符(P62,2.5.3)"></a>decltype类型指示符(P62,2.5.3)</h2><p>有时候会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为此，C++11新标准引入第二种类型说明符<code>decltype</code>。</p>
<p><code>decltype</code>不通过计算，只通过推算出变量应有的值，表达式本身应有的值和函数的返回值来<strong>推导类型</strong>。</p>
<p>对于变量类型，<code>decltype</code>保留顶层const和引用的属性。对于表达式，<strong>解引用表达式(如:<code>int i=1; int *p=&amp;i; decltype (*p) a=i;</code>中的<code>*p</code>,对p解引用是<code>int &amp;</code>类型的)和带括号的表达式，（如：<code>decltype ((a+1)) c=i;</code>）的结果都将是引用类型</strong>。因为decltype通过处理表达式得到结果，因此更详细的内容在<em>第四章</em>将会被提到。有的表达式返回左值，有的表达式返回右值，返回左值的表达式在decltype类型推导下得到的将是引用的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>,*p = &amp;i, &amp;r = i;</div><div class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">//正确，加法结果为int，因此b是一个（未初始化的）int</span></div><div class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">//错误，c是int&amp;，必须初始化</span></div><div class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误，c是int&amp;，必须初始化</span></div><div class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确，e是一个（未初始化的）int</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>decltype((variable)) (注意是双层括号)的结果永远是引用</strong>，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p>
</blockquote>
<p>补：</p>
<ol>
<li><p>一般情况下，出现数组名的表达式时会把数组名转换为<strong>指针</strong>，而用decltype一个数组名时，其返回类型是<strong>该数组的类型</strong>，如有int ia[10]，则<code>decltype(ia) da</code>，此时da也为包含10个int元素的数组。用于函数时也一样，不会自动把函数名转换为指针，而是返回该函数类型。</p>
</li>
<li><p>如果作用于一个取地址运算符，则为指向指针的指针，如有int p，则<code>decltype(&amp;p)</code>的结果是<code>int **</code>类型。</p>
</li>
</ol>
<h2 id="用关键字struct自定义数据结构"><a href="#用关键字struct自定义数据结构" class="headerlink" title="用关键字struct自定义数据结构"></a>用关键字struct自定义数据结构</h2><p>使用struct关键字定义类的形式如<code>struct 类名｛数据成员类型1 数据成员名1；数据成员类型2 数据成员名2;｝;</code>，C++11规定可以给类内成员提供类内初始值用于初始化用我们自定义类创建的对象实例中的成员的值。形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> student=<span class="number">0</span>;</div><div class="line">    <span class="keyword">float</span> numbers=<span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p> 很多新手程序员忘记在类定义的最后加上分号。</p>
</blockquote>
<h2 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>头文件保护符依赖于预处理变量。如<code>#define DEBUG</code>，此时<code>DEBUG</code>就是预处理器变量。预处理变量无视C++语言中关于作用域的规则。</p>
<blockquote>
<p>头文件保护符很简单， 程序员只要<strong>习惯性加上</strong>就可以了，没必要太在乎你的程序到底需不需要。</p>
</blockquote>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.算数类型 arithmetic type<br>2.整型 integral type<br>3.转换 convert<br>4.不可打印 nonprintable<br>5.转义序列 escape sequence<br>6.类型说明符 type specifier<br>7.分离式编译 separate compilation<br>8.声明 declaration<br>9.声明符 declarator<br>10.静态类型 statically typed<br>11.类型检查 type checking<br>12.标识符 identifier<br>13.内层作用域 inner scope<br>14.复合类型 compound type<br>15.左值引用 lvalue reference<br>16.预处理 preprocessor<br>17.临时量 temporary<br>18.指向常量的指针 pointer to const<br>19.常量指针 const pointer<br>20.字面值类型 literal type<br>21.类型别名 type alias<br>22.类内初始值 in-class initializer<br>23.预处理器 preprocessor<br>24.头文件保护符 header guard</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>C++ Primer 中文版 第5版</li>
<li><a href="https://zhuanlan.zhihu.com/p/21820756" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21820756</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> C++ Primer </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[photoshop白色背景图片转换为透明背景]]></title>
      <url>/2017/12/21/ps_white2transparent/</url>
      <content type="html"><![CDATA[<p>1.打开Adobe Photoshop以及待处理的图片，如果图层上有“锁”的标志，就双击进行解锁；<br><img src="https://images2.imgbox.com/4e/6d/W7BRQIVn_o.png" alt="1"></p>
<a id="more"></a>
<p>2.在图层上右击，选择最上方的“混合选项”；<br><img src="https://images2.imgbox.com/40/79/k93NwYyF_o.png" alt=""></p>
<p>3.在混合选项中的本图层中，拖动右侧的白色小三角，向左滑动至适当位置。<br><img src="https://images2.imgbox.com/e4/a0/9gpxW33B_o.png" alt=""></p>
<p>4.效果展示。滑动之前的效果：<br><img src="https://images2.imgbox.com/93/b7/CRkJk51e_o.jpg" alt=""><br>滑动之后的效果：<br><img src="https://images2.imgbox.com/64/5c/lcI8vPjg_o.jpg" alt=""></p>
<p>5.存储。选择“文件”中的“存储为”；<br><img src="https://images2.imgbox.com/90/bf/osDfROqU_o.png" alt=""></p>
<p>在弹出窗口中选择保存类型为“PNG”格式，保存即可。也可以根据需要，选择合适的格式。<br><img src="https://images2.imgbox.com/18/da/M04vdmM2_o.png" alt=""></p>
<p>最后附上全文的<a href="https://wx3.sinaimg.cn/mw1024/c38a0784ly1fmop679zh6j215z2sn7wh.jpg" target="_blank" rel="external">图片链接</a>。</p>
]]></content>
      
        <categories>
            
            <category> Photoshop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Photoshop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[万网域名注册、域名解析与备案流程]]></title>
      <url>/2017/12/19/blog_domain_register/</url>
      <content type="html"><![CDATA[<p><img src="https://images2.imgbox.com/cc/51/JLumBDiL_o.png" alt="域名列表界面"></p>
<a id="more"></a>
<h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>简要说一下为什么选择<strong>万网</strong>。</p>
<p>看到网上的教程一般都是推荐到国外网站注册，如godaddy，Gandi，Namesilo等等。<br>但一般都是比较早期的回答(2011-13)了，目前(2017/12)来说，仅从<strong>价格</strong>因素考虑，阿里云万网域名是普遍低于国外网站的。</p>
<p><strong>万网域名注册地址</strong>：<a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="external">https://wanwang.aliyun.com/domain/</a></p>
<p>另外，关于<strong>域名后缀</strong>选择问题，一般来说，<strong>首选com域名</strong>，不推荐cn域名（国内监管严格的原因？）。其次，个人博客站点可以考虑其他后缀，如net，top，me(貌似万网不支持了)，xyz等等。</p>
<p>选择了心仪的域名之后，购买。以阿里云为例，购买完成后，点击右上角的<strong>控制台</strong>；进入控制台后，选择左下角的<strong>域名与网站（万网）</strong>下的<strong>域名</strong>，进入域名列表界面。</p>
<p>可以看到，右方出现了三个选项【续费】、【解析】【管理】<br><img src="https://images2.imgbox.com/cc/51/JLumBDiL_o.png" alt="域名列表界面"></p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>点击<strong>解析</strong>，按照操作，添加解析即可。主要填写三个参数：记录类型、主机记录和记录值。</p>
<p><strong>记录类型</strong>：CNAME是跳转到其他网址，我的是github博客，就直接让他跳转到github博客即可。A是指向IPV4地址。</p>
<p><strong>主机记录</strong>是网址的前缀，比如说注册的网址是xxx.com，那么blog.xxx.com的主机记录就是blog，xxx.com的主机记录可以不填，也可以填上一个@</p>
<p>给出我目前的解析值作为参考。<br><img src="https://images2.imgbox.com/8f/d8/befX67KY_o.png" alt="解析值"><br>第一个是为了让百度搜索引擎抓取的，每个网址的主机记录都不同，可以忽略。</p>
<h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>我使用的是<a href="http://wangwlj.com/2017/09/08/blog_setup/">hexo+Github搭建个人博客</a>，因此，只买了域名（也可以不买，直接使用github.io地址），没有买云服务器、虚拟主机之类的，因此无法备案。</p>
<p>简而言之，备案需要有<strong>服务器</strong>，然后到服务器提供商处备案即可。</p>
<p>阿里云官方的备案完整流程，可供备案参考：<a href="https://help.aliyun.com/knowledge_detail/36895.html" target="_blank" rel="external">https://help.aliyun.com/knowledge_detail/36895.html</a></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 域名 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客优化之实现来必力评论功能]]></title>
      <url>/2017/12/18/blog_comment/</url>
      <content type="html"><![CDATA[<p><img src="https://images2.imgbox.com/b3/f1/9s6btT5a_o.png" alt=""></p>
<a id="more"></a>
<h2 id="评论功能概述"><a href="#评论功能概述" class="headerlink" title="评论功能概述"></a>评论功能概述</h2><p>目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。</p>
<p>可用的评论系统大概有：</p>
<ul>
<li><p>HyperComments：<a href="https://www.hypercomments.com" target="_blank" rel="external">https://www.hypercomments.com</a> （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，）</p>
</li>
<li><p>来必力：<a href="https://livere.com" target="_blank" rel="external">https://livere.com</a> （来自韩国，使用邮箱注册。）</p>
</li>
<li><p>畅言： <a href="http://changyan.kuaizhan.com" target="_blank" rel="external">http://changyan.kuaizhan.com</a> （安装需要备案号。不太好用。）</p>
</li>
<li><p>Gitment： <a href="https://github.com/imsun/gitment" target="_blank" rel="external">https://github.com/imsun/gitment</a> （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。）</p>
</li>
<li><p>Valine:  <a href="https://github.com/xCss/Valine" target="_blank" rel="external">https://github.com/xCss/Valine</a> (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？）</p>
</li>
</ul>
<p>综上，最终采用了来必力。</p>
<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>打开来必力官网：<br><a href="https://livere.com" target="_blank" rel="external">https://livere.com</a></p>
<p>按套路注册（有可能注册上面要花费点功夫）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击上方的安装，选择免费的city版本。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5edyp4bj20wt0lymyx.jpg" alt=""></p>
<p>并点击现在安装，出现如下界面。<br><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5ekh4erj20yh0me0uf.jpg" alt=""></p>
<p>复制其中的uid字段。</p>
<p>打开主题目录下的<code>blog/themes/next/_config.yml</code>配置文件，定位到<code>livere_uid</code>字段，粘贴上刚刚复制的UID。</p>
<p>至此，大功告成。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>测试评论如图所示：<br><img src="https://images2.imgbox.com/b3/f1/9s6btT5a_o.png" alt=""></p>
<h2 id="设置提醒"><a href="#设置提醒" class="headerlink" title="设置提醒"></a>设置提醒</h2><p>当有新评论出现时，通过邮箱提醒。</p>
<p>点击<code>右上角-&gt;管理页面</code>。选择<code>评论提醒</code>，按照下图设置，输入邮箱、选择间隔时间。</p>
<p><img src="https://images2.imgbox.com/36/9a/23YhEmlz_o.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 来必力 </tag>
            
            <tag> 评论功能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法导论详解(2) 第三章函数的增长]]></title>
      <url>/2017/12/13/algorithm_tutorial_chapter_3/</url>
      <content type="html"><![CDATA[<p>本文是《算法导论》第三章：函数的增长的学习笔记。<br>没有涉及到具体的算法。<br>主要内容有：</p>
<ul>
<li>五种渐近记号的表示</li>
<li>常用的函数与标记</li>
</ul>
<a id="more"></a>
<h2 id="3-1-渐近记号"><a href="#3-1-渐近记号" class="headerlink" title="3.1 渐近记号"></a>3.1 渐近记号</h2><p>$\Theta、 \text{O}和\Omega $三种记号的图示：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_1.png" alt="1"></p>
<h3 id="先看第一幅图-a-——-Theta-记号"><a href="#先看第一幅图-a-——-Theta-记号" class="headerlink" title="先看第一幅图(a)——$\Theta$记号"></a>先看第一幅图(a)——$\Theta$记号</h3><p>若存在正常量$c_1,c_2,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant c_1g(n)\leqslant f(n) \leqslant c_2g(n)$，则$f(n)$属于集合$\Theta(g(n))$，<br>可以记为$f(n)\in \Theta(g(n))$，我们通常用$f(n)=\Theta(g(n))$表达相同的概念。</p>
<p>上述公式的含义：函数f(n)能“夹入”$c_1g(n)$和$c_2g(n)$之间。换句话说，对所有的$n\geqslant n_0$，函数$f(n)$在一个常量因子内等于$g(n)$，我们称$g(n)$是$f(n)$的一个渐近紧确界(asymptotically tight bound)。</p>
<p>实例：可以用上述的形式化定义来证明：$\frac{1}{2}n^2-3n =\Theta(n^2)$，以及$6n^3 \neq \Theta(n^2)$。</p>
<p>渐近正函数就是对足够大的n均为正的函数。</p>
<p>直觉上，一个渐近正函数的低阶项 在确定渐近确界时可以被忽略，因为对于大的n，它们是无足轻重的。</p>
<p>一般来说，对任意多项式$p(n)=\sum_{i=0}^d a_i n^i$，其中$a_i$为常量且$a_d&gt;0$（最高阶的系数大于零），则有$p(n)=\Theta(n_d)$。</p>
<h3 id="接着看图-b-——-text-O-记号"><a href="#接着看图-b-——-text-O-记号" class="headerlink" title="接着看图(b)——$\text{O}$记号"></a>接着看图(b)——$\text{O}$记号</h3><p>$\Theta$记号渐近地给出了一个函数的上界和下届。当只有一个<em>渐近上界</em>时，使用$\text{O}$记号。</p>
<p>$\text{O}(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) \leqslant cg(n)}$</p>
<p>我们记$f(n)=\text{O}(g(n))$表示$f(n)$是集合$\text{O}(g(n))$的成员。注意$f(n)=\Theta(g(n))$蕴含了$f(n)=\text{O}(g(n))$，因为$\Theta$记号是一个比$\text{O}$记号更强的概念。</p>
<p>使用$\text{O}$记号，我们常常可以仅仅通过检查算法的总体结构来描述算法的运行时间。$\text{O}$记号描述上界，对插入排序算法的最坏情况运行时间的界$\text{O}(n^2)$也适合于该算法对每个输入的运行时间。该算法对每个输入的运行时间都有一个界，这就是综合性描述。</p>
<h3 id="最后看图-c-——-Omega-记号"><a href="#最后看图-c-——-Omega-记号" class="headerlink" title="最后看图(c)——$\Omega$记号"></a>最后看图(c)——$\Omega$记号</h3><p>正如$\text{O}$记号提供了渐近上界，$\Omega$记号提供了渐进下界。</p>
<p>$\Omega(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  cg(n) \leqslant f(n)}$</p>
<p>于是，由此引出了定理3.1。</p>
<h4 id="定理-3-1"><a href="#定理-3-1" class="headerlink" title="定理 3.1"></a>定理 3.1</h4><p>对任意两个函数$f(n)$和$g(n)$，我们有$f(n)=\Theta(g(n))$，当且仅当$f(n)=\text{O}(g(n))$且$f(n)=\Omega(g(n))$。</p>
<p>当一个算法的运行时间为$\Omega(g(n))$时，我们意指不管n是什么规模，只要n足够大，对那个输入的运行时间至少是$g(n)$的常数倍。</p>
<h3 id="等式和不等式中的渐近记号"><a href="#等式和不等式中的渐近记号" class="headerlink" title="等式和不等式中的渐近记号"></a>等式和不等式中的渐近记号</h3><p>当渐近记号出现在某个公式中时，我们将其解释为代表某个我们不关注名称的匿名函数。</p>
<p>例如：$2n^2+3n+1 = 2n^2 +\Theta(n)$。</p>
<p>按这种方式使用渐记号可以帮助消除一个等式中无关紧要的细节与混乱。</p>
<p>例如：归并排序的最坏情况运行时间：<br>$$T(n) = 2T(n/2)+\Theta(n)$$<br>如果只对T(n)的渐近行为感兴趣，就没必要准确说明所以低阶项，它们都被理解为包含在由项$\Theta(n)$表示的匿名函数中。</p>
<p>在某些例子中，渐近记号出现在等式的左边，如：<br>$$2n^2+\Theta(n) = \Theta(n^2) $$</p>
<p>无论怎么选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。</p>
<h3 id="text-o-记号"><a href="#text-o-记号" class="headerlink" title="$\text{o}$记号"></a>$\text{o}$记号</h3><p>$\text{o}$记号，非渐近紧确的上界。</p>
<p>$\text{o}(g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) &lt; cg(n)}$。</p>
<p>$\text{O}$记号与$\text{o}$记号类似，主要的区别 是在$f(n)=\text{O}(g(n))$中，界$0\leqslant  f(n) \leqslant cg(n)$对某个常量$c&gt;0$成立，但在$f(n)=\text{o}(g(n))$中，界$0\leqslant  f(n) &lt; cg(n)$对所有常量$c&gt;0$成立。</p>
<p>直观上，在$\text{o}$记号中，当n趋向于无穷时，函数$f(n)$相对于$g(n)$来说变得微不足道了，即：<br>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = 0$$</p>
<h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>非渐近紧确下界。</p>
<p>$\omega (g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant cg(n) &lt;  f(n) }$。</p>
<p>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = \infty $$</p>
<h3 id="渐近运算的运算性质"><a href="#渐近运算的运算性质" class="headerlink" title="渐近运算的运算性质"></a>渐近运算的运算性质</h3><p>传递性、自反性、对称性与转置对称性：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_2.png" alt="2"><br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_3.png" alt="3"><br>而且：两个函数f和g的渐近比较关系可与实数a与b之间的比较做类比： </p>
<ul>
<li>f(n)=O(g(n)) 类似于a&lt;= b </li>
<li>f(n)=Ω(g(n)) 类似于a&gt;= b </li>
<li>f(n)=Θ(g(n)) 类似于a= b </li>
<li>f(n)=o(g(n)) 类似于a&lt; b </li>
<li>f(n)=w(g(n)) 类似于a&gt; b</li>
</ul>
<p>三分性：虽然实数具有三分性，即对于任意两个实数a、b，下列三种情况必须有一种成立：$a<b$，$a=b$或$a>b$。但是不是所有函数都可以渐近比较。</b$，$a=b$或$a></p>
<h2 id="3-2-标准记号与常用函数"><a href="#3-2-标准记号与常用函数" class="headerlink" title="3.2 标准记号与常用函数"></a>3.2 标准记号与常用函数</h2><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>单调递增/单调递减：包含等号；严格递增/严格递减：不包含等号。</p>
<h3 id="向下取整与向上取整"><a href="#向下取整与向上取整" class="headerlink" title="向下取整与向上取整"></a>向下取整与向上取整</h3><p>x的向下取整：$\lfloor x \rfloor$；x的向上取整：$\lceil x \rceil$。</p>
<h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>对任意整数a和正整数n，$a\ \text{mod}\ n$ 的值就是商a/n的余数。<br>$$a\ \text{mod}\ n = a-n\lfloor a/n\rfloor $$</p>
<p>若$(a\ \text{mod}\ n)=(b\ \text{mod}\ n)$，则记$a\equiv b(\text{mod}n)$</p>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>给定一个非负整数d，n的d次多项式$p(n)$：<br>$$p(n)=\sum_{i=0}^d a_i n^i$$<br>其中，$a_d \neq 0 $。</p>
<p>多项式为渐近正的当且仅当$a_d &gt; 0 $。对于一个d次渐近正的多项式$p(n)$，有$p(n)=\Theta(n^d)$</p>
<p>若对于某个常量k，有$f(n)=\text{O}(n^k)$，则称函数$f(n)$是多项式有界的。</p>
<h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><p>对所有使得$a&gt;1$的实常量a和b，有<br>$$\lim_{n\rightarrow \infty} \frac{n^b}{a^n} = 0$$<br>据此可得：<br>$$n^b = \text{o}(a^n)$$</p>
<h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>以2为底的自然数：<br>$$\text{lg}n = \text{log}_2n$$<br>自然对数：<br>$$\text{ln}n = \text{log}_en$$<br>取幂：<br>$$\text{lg}^kn = (\text{lg}n)^k$$<br>复合：<br>$$\text{lg}\text{lg}n =\text{lg} (\text{lg}n)$$</p>
<p>一个重要的记号约定：对数函数只适用于公式中的下一项，所以$\text{lg}n+k$意思是指$(\text{lg}n)+k$</p>
<p>对于$a&gt;0,b&gt;0,c&gt;0$和n，有<br>$$a = b^{\text{log}_ba}$$<br>$$\text{log}_c(ab) = \text{log}_ca +\text{log}_cb$$<br>$$\text{log}_b(a^n) = n\text{log}_ba$$<br>$$\text{log}_ba =\frac{\text{log}_ca}{\text{log}_cb} $$<br>$$\text{log}_b(1/a) =- \text{log}_ba $$<br>$$\text{log}_ba =\frac{1}{\text{log}_ab} $$<br>$$a^{\text{log}_bc} = c^{\text{log}_ba}$$<br>其中，上述等式的对数底不为1。</p>
<p>对任意常量a，有<br>$$\text{log}^bn = \text{o}(n^a)$$<br>表示任意正的多项式函数都比任意多对数函数增长得快。</p>
<h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>$n!$，读作“n的阶乘”。其定义为对整数$n \geqslant 0$：<br>$$n! = \begin{cases}<br>1 &amp; 若n=0\\<br>n\cdot (n-1)! &amp; 若n&gt;0<br>\end{cases}$$</p>
<p>阶乘函数的一个弱上界是$n! \leqslant n^n$，因为在阶乘中，n项的每项最多为n。</p>
<h4 id="斯特林-Stirling-近似公式"><a href="#斯特林-Stirling-近似公式" class="headerlink" title="斯特林(Stirling)近似公式"></a>斯特林(Stirling)近似公式</h4><p>$$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n})) $$</p>
<p>由上述公式可以证明：<br>$$n! = o(n^n)$$<br>$$n! = \omega(2^n)$$<br>$$\text{lg}n! = \Theta(n\text{lg}n)$$</p>
<h3 id="多重函数"><a href="#多重函数" class="headerlink" title="多重函数"></a>多重函数</h3><p>记号$f^{(i)}(n)$表示f(n)重复i次作用于一个初值n上。对非负整数i，我们递归地定义：<br>$$f^{(i)}(n)=\begin{cases}<br>n &amp; 若i=0 \\<br>f(f^{(i-1)}(n)) &amp; 若i&gt;0<br>\end{cases}$$</p>
<h3 id="多重对数函数"><a href="#多重对数函数" class="headerlink" title="多重对数函数"></a>多重对数函数</h3><p>$\text{lg}^*n$表示多重对数，多重对数增长非常慢。</p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数的递归定义：<br>$$F_0 = 0$$<br>$$F_1 = 1$$<br>$$F_i = F_{i-1}+F_{i-2}, i \geqslant 2$$</p>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法导论 </tag>
            
            <tag> 函数渐近 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法导论详解(1) 第二章算法基础]]></title>
      <url>/2017/12/12/algorithm_tutolrial_chapter_2/</url>
      <content type="html"><![CDATA[<p>本文是《算法导论》的第二章：算法基础的笔记整理。<br>其中主要包括两个算法：</p>
<ul>
<li>插入排序</li>
<li>归并排序</li>
</ul>
<a id="more"></a>
<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><h2 id="伪码说明"><a href="#伪码说明" class="headerlink" title="伪码说明"></a>伪码说明</h2><ol>
<li><p>数组A[1,…,n]长度为n的待排序序列。<br>注意，书中的下标都是从1开始的。python中是从0开始的。</p>
</li>
<li><p>伪码中，A的长度用A.length表示。python中使用len(A)表示。</p>
</li>
<li>缩进表示块结构。提高代码清晰度。</li>
<li>while, for, repeat-until 在循环结束后，循环计数器仍然保持其值。</li>
<li>符号“//”后面是注释。</li>
<li>数组元素通过“数组名[下标]”这样的形式来访问。</li>
<li>复合数据通常被组织成<em>对象</em>，对象又由<em>属性</em>组成。</li>
<li>return允许返回多个值</li>
<li>按值把参数传递给过程，被调用过程接收其参数自身的副本。</li>
<li>布尔运算符“and”和“or”都是短路的。</li>
</ol>
<h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>插入排序的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(A)</span>:</span></div><div class="line">    length = len(A)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length):</div><div class="line">        key = A[j]</div><div class="line">        i = j - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</div><div class="line">            A[i + <span class="number">1</span>] = A[i]</div><div class="line">            i = i - <span class="number">1</span></div><div class="line">        A[i + <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">return</span> A</div><div class="line">A = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">8</span>, ]</div><div class="line">print(insertion_sort(A))</div></pre></td></tr></table></figure></p>
<p>对插入排序的简单理解：<br>从第二个数开始，依次比较前面的数和key的大小，若大于key，则后移。<br>最后将key插入到最前方停下的位置。<br>j是遍历数组每个元素；<br>i是每个元素前面、需要移动的最前方。</p>
<p>形象的解释：插入纸牌：key是当前带插入的牌，找到插入的位置，先把每个大的都往后挪一个位置出来，再把key插入到空出来的位置。</p>
<h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>RAM（Random-access machine,RAM）模型:单处理器计算模型，指令一条接一条地执行，没有并发操作。</p>
<p>真实计算机如何设计，RAM模型就是如何设计的，RAM模型包含真实计算机的常见指令：算术指令（加减乘除，取余，向下取整，向上取整），数据移动指令（装入、存储和复制）和控制指令（条件与无条件转移、子程序调用与返回）。</p>
<p>灰色区域：真实计算机中未列出的指令。如指数运算算是常量时间的指令吗？</p>
<p>答案：①一般情况下不是，如$x^y$，当x和y都是实数的时候。②在受限情况下，可以当做一个常量时间的操作。如$2^k$是一个常量的操作。</p>
<p>一个整数的各位左移k位等价于将该整数乘以$2^k$。</p>
<h3 id="插入排序算法的分析"><a href="#插入排序算法的分析" class="headerlink" title="插入排序算法的分析"></a>插入排序算法的分析</h3><p>算法需要的时间与输入规模同步增长，通常把一个程序的运行时间描述成其输入规模的函数。</p>
<p>输入规模的最佳概念依赖于研究的问题。</p>
<p>一个算法在特定输入上的运行时间是指执行的基本操作数或步数。<br>算法的运行时间是执行每条语句的运行时间之和。</p>
<p>若数组已排好序，则出现最佳情况：$T(n)=an+b$<br>若数组已反向排序（即按递减序排好序），则导致最坏情况：$T(n)=an^2+b$，是n的二次函数。</p>
<h3 id="最坏情况与平均情况分析"><a href="#最坏情况与平均情况分析" class="headerlink" title="最坏情况与平均情况分析"></a>最坏情况与平均情况分析</h3><p>本书往往集中于只求<em>最坏情况运行时间</em>，即对于规模为n的任何输入，算法的最长时间。</p>
<p>书中给出了三个理由，在此不详述。其中一点是平均情况往往与最坏情况一样差。</p>
<h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><p>最坏情况运行时间表示为：$T(n)=an^2+b$。</p>
<p>现在我们做出一种更简化的抽象：我们真正感兴趣的运行时间的$增长率$或$增长量级$。</p>
<h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>许多算法在结构上是递归的，算法依次或多次递归地调用其自身以解决紧密相关的若干子问题。</p>
<p>分治模式在每层递归时都有三个步骤：</p>
<ul>
<li>分解原问题为若干子问题；</li>
<li>解决这些子问题，递归地求解各子问题。</li>
<li>合并这些子问题的解成原问题的解。</li>
</ul>
<p><em>归并排序</em>算法完全遵循分治模式。归并算法的关键在于合并。<br>归并排序的的基本步骤如下：</p>
<ol>
<li>把待排序的数组分为左数组和右数组</li>
<li>对左数组和右数组进行迭代排序</li>
<li>将左数组和右数组进行合并</li>
</ol>
<p>显然这些基本步骤符合分治模式在每一层递归上的三个步骤：分解、解决、合并。</p>
<h2 id="2-3-2-归并排序算法（分治算法）"><a href="#2-3-2-归并排序算法（分治算法）" class="headerlink" title="2.3.2 归并排序算法（分治算法）"></a>2.3.2 归并排序算法（分治算法）</h2><p>MERGE(A,p,q,r)：完成合并。A是一个数组，p,q,r是数组的下标，满足$p\leqslant q&lt;r$。假设A[p..q]与A[q+1..r]都已排好序，MERGE函数的目的就是合并这两个子数组形成单一的已排好序的数组A[p..r]。</p>
<p>形象地描述：同样以插入排序时的扑克牌为例，现在的情况是有两堆牌（两个输入堆），牌面朝上（可见，已排序），每次选取两堆中较小的放入到输出堆，牌面朝下。重复这个步骤，直到一个输入堆为空，则把另一个输入堆直接牌面朝下的放置到输出堆。</p>
<p>MERGE-SORT(A,p,r)排序子数组A[p,r]中的元素。若$p\geqslant r$，则该子数组最多只有一个元素，所以已经排好序，直接返回。否则，分解步骤。计算下表q，将A[p..r]分为A[p..q]和A[q+1..r]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># author: wangwlj</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"></div><div class="line">MAX = <span class="number">1</span> &lt;&lt; <span class="number">31</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(A, p, q, r)</span>:</span></div><div class="line">    n1 = q - p + <span class="number">1</span></div><div class="line">    n2 = r - q</div><div class="line">    L = []</div><div class="line">    R = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n1):</div><div class="line">        L.append(A[p + i])  <span class="comment"># 因为我初始化为空列表，所以直接赋值的话会报错，只能以append的形式追加值。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n2):</div><div class="line">        R.append(A[q + i + <span class="number">1</span>])</div><div class="line">    L.append(MAX)  <span class="comment"># 使用无穷大作为哨兵</span></div><div class="line">    R.append(MAX)</div><div class="line">    <span class="keyword">assert</span> len(L) == n1 + <span class="number">1</span> <span class="keyword">and</span> len(R) == n2 + <span class="number">1</span></div><div class="line"></div><div class="line">    i = <span class="number">0</span>  <span class="comment"># python是从0开始</span></div><div class="line">    j = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):  <span class="comment"># 需要加1，因为首尾每个都算</span></div><div class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</div><div class="line">            A[k] = L[i]</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            A[k] = R[j]</div><div class="line">            j += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = floor((p + r) / <span class="number">2</span>)</div><div class="line">        merge_sort(A, p, q)</div><div class="line">        merge_sort(A, q + <span class="number">1</span>, r)  <span class="comment"># 首尾都包含了，所以要加1</span></div><div class="line">        merge(A, p, q, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># test function</span></div><div class="line">    A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>]</div><div class="line">    merge_sort(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)</div><div class="line">    print(A)</div></pre></td></tr></table></figure>
<p>上述代码测试成功。</p>
<h3 id="2-3-2-分析分治算法"><a href="#2-3-2-分析分治算法" class="headerlink" title="2.3.2 分析分治算法"></a>2.3.2 分析分治算法</h3><p>假设把原问题分解为a个子问题，每个子问题的规模都是原问题的1/b。（对于归并排序，a和b都是2，然而在许多分治算法中，$a\neq b $。）</p>
<p>求解规模为n/b的子问题，需要$T(n/b)$的时间，所以需要花费$aT(n/b)$的时间来求解a个子问题。</p>
<p>下面分析归并排序n个数的最坏情况运行时间$T(n)$的递归式。</p>
<ul>
<li>分解：分解步骤只计算子数组的中间位置，需要常量时间，因此，$D(n)=\Theta(n)$</li>
<li>解决：递归地求解两个规模为n/2的子问题，将贡献$2T(n/2)$的运行时间。</li>
<li>合并：n个子元素的数组上的merge需要$\Theta(n)$的时间（线性复杂度），所以$C(n)=\Theta(n)$。</li>
</ul>
<p>$D(n)$和$C(n)$相加的和，仍然是n的线性复杂度，即$\Theta(n)$。再与“解决”步骤相加，为：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>  $$</p>
<p>在第四章，我们将看到“主定理”，可以用该定理来证明$T(n)$ 为$\Theta(n\text{lg}n)$。（即时间复杂度为nlgn）</p>
<p>运行时间为$\Theta(n\text{lg}n)$的归并排序优于运行时间为$\Theta(n^2)$的插入排序。</p>
<p>$T(n) =\Theta(n\text{lg}n)$的直观理解：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4sa97j67j20ew0i6my6.jpg" alt="归并排序复杂度的直观理解"><br>由(d)图，每层对n等分，可以展开为lgn层(再加上原来的一层，一共lgn+1层)。每层的复杂度都是cn，所以总的复杂度为$cn\text{lg}n+cn = cn(\text{lg}n+1)$。</p>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法导论 </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一起开始机器学习吧——知乎live笔记]]></title>
      <url>/2017/12/12/Start_Machine_Learning_review/</url>
      <content type="html"><![CDATA[<p>本文纯干货，想要入门机器学习的同学可以参考一下。</p>
<a id="more"></a>
<h2 id="问答干货"><a href="#问答干货" class="headerlink" title="问答干货"></a>问答干货</h2><p>①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。</p>
<p>②教程推荐：公开课（吴恩达、coursera等），coursera上吴恩达的公开课</p>
<p>③语言推荐：python，MATLAB。很多开源工具（MXNet，Tensorflow，Keras）都有Python接口。</p>
<p>④python方面，网上有很多博客，比如廖雪峰的博客，感觉只需要了解即可，会用就行；传统算法入门的话，推荐李航的《统计学习方法》,入门最合适。最近出了Bengio的《Deep learning》书，有中文翻译，前面章节全是传统算法。不推荐一上来就看大家都说的《pattern recognition and machine learning》以及《模式分类》,这两本书不适合入门。</p>
<p>⑤完全零基础的入门性质的资料：视频：<a href="https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s" target="_blank" rel="external">https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s</a><br>机器学习入门： <a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a></p>
<p>⑥数学基础课：数学（概率、线代、高数、随机过程，排名分先后）</p>
<p>⑦发论文经验：目前我只是有paper在投，还没有成功发过，哈哈。经验嘛，主要就是一定要敢于否定自己，我在写的paper一共两篇，每一篇都几乎改了七八次，每次都很严格地要求自己。同时，最好要把paper发给同组的人一起看看，不同的角度给你提问题，会帮助你认识到自己容易忽视的问题。视觉方面发paper其实很容易的。通常来说你需要在同一个数据集上跟最好的方法做对比。</p>
<p>⑧我数学基础不太牢固 想一边看机器学习一边补数学 但有很多数学符号甚至都不认识 百度也没法搜索 你有什么建议吗？<br>答：专业书籍都有符号索引表；学习简单的数学工具，如latex；matrix cookbook 矩阵常用的手册。</p>
<h2 id="PPT干货"><a href="#PPT干货" class="headerlink" title="PPT干货"></a>PPT干货</h2><ul>
<li>机器学习常用分类：监督学习、半监督学习、无监督学习、增强学习</li>
<li><p>②无监督才是世界的本质，标注数据往往要花费大量的人力物力。<br>没有标注这么做呢？迁移学习是可以类比无监督学习来做的事情。<br>人是有类比能力的，计算机可以吗？我们想让它有这个能力。（就是迁移学习）<br>通过迁移学习的方式可以部分地接近无监督学习的目标。<br>迁移学习的好处是什么？利用已有的知识，节约新学习的成本。<br>但需要找到两者的相似性。骑自行车-&gt;开汽车？ 不行！ 需要有相似性。<br>深度学习算是对迁移学习的改进（我的总结）？，因为深度学习不像迁移学习需要手动提取特征。</p>
</li>
<li><p>准备工作<br>  理论知识（高数、概率、线性代数、随机过程）<br>  编码能力（Python, Matlab, Java）</p>
</li>
<li>基本入门<br>  李航《统计学习方法》<br>  周志华《机器学习》<br>  吴恩达公开课<br>  Kaggle竞赛</li>
<li><p>进阶提高<br>  《模式分类》、《PRML》<br>  ICML、NIPS等国际会议<br>  做自己的研究工作</p>
</li>
<li><p>书籍资料整理：<a href="https://github.com/ty4z2008/Qix/blob/master/dl.md" target="_blank" rel="external">https://github.com/ty4z2008/Qix/blob/master/dl.md</a><br>  入门资料：<a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a><br>  公开课：<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">http://open.163.com/special/opencourse/machinelearning.html</a><br>  Kaggle竞赛：<a href="https://www.kaggle.com/" target="_blank" rel="external">https://www.kaggle.com/</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python爬虫实战--selenium模拟登录并自动点击]]></title>
      <url>/2017/12/09/HDHome_clawler_tutorial/</url>
      <content type="html"><![CDATA[<p>爬虫实战项目。</p>
<p>爬虫利器：selenium的使用。</p>
<a id="more"></a>
<h1 id="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"><a href="#python爬虫实战–selenium模拟登录网站HDH并刷魔力值" class="headerlink" title="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"></a>python爬虫实战–selenium模拟登录网站HDH并刷魔力值</h1><h2 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h2><p>最近刚刚注册了某个网站：<a href="http://hdhome.org/" target="_blank" rel="external">HDHome</a>，该站有新手考核任务，其中有一项是需要达到魔力值5000。在魔力值获取方式中，我们看到这一项：“说谢谢 = 0.5个魔力值”，而网站存活种子数量达到16000+，也就意味着对每个种子说一下谢谢，轻松达到8000+的魔力值，于是，这个项目应运而生。</p>
<p>实现思路：<br>获取种子的页面，在每个页面中找到说谢谢的按钮，并点击后，关闭。依次进行下去即可。</p>
<p>相似任务：</p>
<p>实现对某论坛的自动回复，实现自动获取所有帖子的信息等等相关操作，无论是否需要模拟登录、模拟鼠标操作还是直接解析网站元素。</p>
<h2 id="selenium-牛刀小试"><a href="#selenium-牛刀小试" class="headerlink" title="selenium 牛刀小试"></a>selenium 牛刀小试</h2><p>首先导入相关的库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> selenium.webdriver <span class="keyword">as</span> webdriver</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</div></pre></td></tr></table></figure>
<p>这是整个程序里面用到的所有内容。<br>其中，<code>webdriver</code>是主浏览器，<code>selenium</code>都是基于整个浏览器的对象；<code>WebDriverWait、EC、By</code>是等待网页元素加载相关的操作；<code>Keys</code>是键值，如<code>Keys.CONTROL</code>，<code>Keys.ENTER</code>等等，<code>ActionChains</code>是用鼠标进行一系列的操作。</p>
<p><code>webdriver</code>可用的浏览器有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">webdriver.Firefox</div><div class="line">webdriver.FirefoxProfile</div><div class="line">webdriver.Chrome</div><div class="line">webdriver.ChromeOptions</div><div class="line">webdriver.Ie</div><div class="line">webdriver.Opera</div><div class="line">webdriver.PhantomJS</div><div class="line">webdriver.Remote</div><div class="line">webdriver.DesiredCapabilities</div><div class="line">webdriver.ActionChains</div><div class="line">webdriver.TouchActions</div><div class="line">webdriver.Proxy</div></pre></td></tr></table></figure></p>
<p>一开始我选择的是Chrome浏览器，后来改为了Firefox火狐。Chrome浏览器在执行单个元素（如验证码）截图时有坑（下文有详细说），所以后来才用的Firefox。此外，PhantomJS是匿名浏览器，没有显式的窗口。</p>
<p>那么，开始写程序吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">driver = webdriver.Firefox()</div><div class="line">login_url = <span class="string">"http://hdhome.org/login.php"</span></div><div class="line">login_failed_url = <span class="string">"http://hdhome.org/takelogin.php"</span></div><div class="line">driver.get(login_url)</div><div class="line"><span class="keyword">while</span> self.driver.current_url == login_url <span class="keyword">or</span> self.driver.current_url == login_failed_url:</div><div class="line">    time.sleep(<span class="number">10</span>)</div><div class="line"><span class="comment"># do something</span></div></pre></td></tr></table></figure></p>
<p>首先，实体化浏览器driver，执行<code>driver = webdriver.Firefox()</code>这句的时候，就会有firefox浏览器弹出来了。当执行到<code>driver.get(login_url)</code>时，浏览器转到相应的网址，后面的while语句是用来等待我们手动登录的，当我们手动登录成功后，会进入到<code>&quot;http://hdhome.org/index.php&quot;</code>，与login_url及login_failed_url都不同。接着便可以做自己想做的事情了。</p>
<p>我们发现单个种子的网址是类似这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">single_link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div></pre></td></tr></table></figure></p>
<p>i可以从1到30000多。于是，我们可以这样写程序，依次对每个种子执行“说谢谢”操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">(link)</span>:</span></div><div class="line">    driver.get(link)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">        print(link, <span class="string">" succeed\n"</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        print(link, <span class="string">" not succeed\n"</span>)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">        </div><div class="line">START = <span class="number">1</span></div><div class="line">END = <span class="number">30000</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(START, END):</div><div class="line">    link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div><div class="line">    saythanks(link)</div><div class="line">driver.close()</div></pre></td></tr></table></figure></p>
<p>其中，我们使用<code>try</code>、<code>except</code>、<code>finally</code>语句来尝试定位到’saythanks’说谢谢的按钮元素。由于有时候加载较慢就会找不到，或者是这个种子已经被删除了，所以也导致找不到该元素。</p>
<p>其中定位网页元素的方法有一下几种：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># locate single element in a page:</span></div><div class="line">find_element_by_id</div><div class="line">find_element_by_name</div><div class="line">find_element_by_xpath</div><div class="line">find_element_by_link_text</div><div class="line">find_element_by_partial_link_text</div><div class="line">find_element_by_tag_name</div><div class="line">find_element_by_class_name</div><div class="line">find_element_by_css_selector</div><div class="line"></div><div class="line"><span class="comment"># To find multiple elements (these methods will return a list):</span></div><div class="line">find_elements_by_name</div><div class="line">find_elements_by_xpath</div><div class="line">find_elements_by_link_text</div><div class="line">find_elements_by_partial_link_text</div><div class="line">find_elements_by_tag_name</div><div class="line">find_elements_by_class_name</div><div class="line">find_elements_by_css_selector</div></pre></td></tr></table></figure></p>
<p>从上面可以看出，我们也可以用<code>find_element_by_id(&quot;saythanks&quot;)</code>同样可以找到说谢谢的按钮。</p>
<p>附上到目前为止的所有程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_2.py" target="_blank" rel="external">GitHub地址1</a><br>完整程序中加上了logging模块，将输出日志也导入到了文件，方面以后查阅。</p>
<h2 id="改进一：使用多线程多标签"><a href="#改进一：使用多线程多标签" class="headerlink" title="改进一：使用多线程多标签"></a>改进一：使用多线程多标签</h2><p>在上述模块中，可以看到，我们按照种子的顺序依次进行相应的操作。在种子数量很多的时候，会显得很慢，于是，有了这个改进：使用多线程。</p>
<p>我们使用multiprocessing库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div></pre></td></tr></table></figure></p>
<p>先来看一个使用该多线程库的示例程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(fn)</span>:</span></div><div class="line">    <span class="comment"># fn: 函数参数是数据列表的一个元素</span></div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> fn * fn</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    testFL = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">    print(<span class="string">'shunxu:'</span>)  <span class="comment"># 顺序执行(也就是串行执行，单进程)</span></div><div class="line">    s = time.time()</div><div class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> testFL:</div><div class="line">        run(fn)</div><div class="line"></div><div class="line">    e1 = time.time()</div><div class="line">    print(<span class="string">"顺序执行时间："</span>, int(e1 - s))</div><div class="line"></div><div class="line">    print(<span class="string">'concurrent:'</span>)  <span class="comment"># 创建多个进程，并行执行</span></div><div class="line">    pool = Pool(<span class="number">5</span>)  <span class="comment"># 创建拥有5个进程数量的进程池</span></div><div class="line">    <span class="comment"># testFL:要处理的数据列表，run：处理testFL列表中数据的函数</span></div><div class="line">    rl = pool.map(run, testFL)</div><div class="line">    pool.close()  <span class="comment"># 关闭进程池，不再接受新的进程</span></div><div class="line">    pool.join()  <span class="comment"># 主进程阻塞等待子进程的退出</span></div><div class="line">    e2 = time.time()</div><div class="line">    print(<span class="string">"并行执行时间："</span>, int(e2 - e1))</div><div class="line">    print(rl)</div></pre></td></tr></table></figure></p>
<p>于是，模仿上述程序，我们也使用多线程来执行说谢谢。说谢谢的过程其实有两步：一是打开网页，二是对每个网页定位到每个元素并点击。</p>
<p>如果对一、二两个步骤都执行多线程会出错，可能是由于多窗口的原因。因此我目前只对打开网页的步骤执行了多线程的操作。</p>
<p>上述也提到了，要同时打开多个窗口，则需要使用浏览器的多标签功能。打开一个新的标签的程序需要执行js脚本，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_url</span><span class="params">(url)</span>:</span></div><div class="line">    newwindow = <span class="string">'window.open("&#123;&#125;")'</span>.format(url)</div><div class="line">    driver.execute_script(newwindow)</div></pre></td></tr></table></figure></p>
<p>于是多线程部分的改进如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">START = <span class="number">25980</span></div><div class="line">    END = <span class="number">30000</span></div><div class="line">    Thread_Num = <span class="number">3</span></div><div class="line">    t = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(START, END, Thread_Num):</div><div class="line"></div><div class="line">        pool = Pool(Thread_Num)</div><div class="line">        all_links = [<span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(i, i + Thread_Num)]</div><div class="line">        print(all_links)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            rl = pool.map(open_url, all_links)</div><div class="line">            pool.close()</div><div class="line">            pool.join()</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            logging.info(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            time.sleep(<span class="number">5</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="comment"># 通过移动句柄来说谢谢</span></div><div class="line">        saythanks()</div><div class="line">        <span class="comment"># sleep more</span></div><div class="line">        time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">3</span> == <span class="number">0</span>:</div><div class="line">            time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">5</span> == <span class="number">0</span>:</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">0</span>])</div><div class="line">            driver.refresh()</div><div class="line">            mystr = driver.find_elements_by_xpath(<span class="string">'//span[@class="medium"]'</span>)[<span class="number">0</span>].text</div><div class="line">            bonus = re.search(<span class="string">"\s[0-9,.]*\s"</span>, mystr).group()</div><div class="line">            usrName = re.search(<span class="string">"\s[a-zA-Z0-9]*\s"</span>, mystr).group()</div><div class="line">            print(driver.current_url, <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            logging.info(driver.current_url + <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">        t = t + <span class="number">1</span></div><div class="line">    driver.quit()</div><div class="line">    logging.info(<span class="string">"&#123;&#125;: driver quit, program stop."</span>.format(</div><div class="line">        time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time()))))</div></pre></td></tr></table></figure></p>
<p>为了不让浏览器检测到，我只是用了三个线程，可以适当的增加。saythanks()下面的部分程序是为了增加更多的延迟并且显示相应的信息。其中<code>if t % 5 == 0:</code>中，我们移动到主页上，进行刷新操作，然后定位到用户信息那一栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bonus = re.search(&quot;\s[0-9,.]*\s&quot;, mystr).group()</div><div class="line">usrName = re.search(&quot;\s[a-zA-Z0-9]*\s&quot;, mystr).group()</div></pre></td></tr></table></figure></p>
<p>这个部分使用了re正则项来找出当前的魔力值以及用户名，并显示出来。</p>
<p>其中，说谢谢的程序也需要对多标签进行相应的改进，程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> len(driver.window_handles) &gt; <span class="number">1</span>:</div><div class="line">        driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            driver.refresh()</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            print(driver.current_url, <span class="string">" refresh ---"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">            print(driver.current_url, <span class="string">" succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" succeed~"</span>)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(driver.current_url, <span class="string">" not succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" not succeed!"</span>)</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            driver.close()</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p>
<p>通过在不同窗口的句柄之间移动，来依次进行说谢谢的步骤。<br>在每个网页加载的时候，我们执行了等待的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div></pre></td></tr></table></figure></p>
<p>一直等到最外层的元素出现。我选择的”outer”这个元素，是在无论这个种子是否存在的时候都会出现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure>
<p>将窗口转移到最后打开的那个窗口。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">driver.close()</div><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p>
<p>关闭当前的个窗口，并转到当前的最后一个窗口。需要注意的是：窗口虽然关闭了，但是，driver依旧会停在那个已经失效的窗口，并不会自动的转到新的窗口（虽然在浏览器中看上去到了新的窗口），所以，需要我们自己手动的移动窗口的句柄。</p>
<p>这边还存在一个问题，就是多标签的时候，自动切换标签的时候，浏览器会自动弹出来。这样子便有点烦人，毕竟我们只是想让他在后台自己跑， 所以，我加上了一个虚拟窗口，使用的是<code>pyvirtualdisplay</code>库。</p>
<p>以下是<code>pyvirtualdisplay</code>库在ubuntu中的安装步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pip install pyvirtualdisplay</div><div class="line">sudo apt install xvfb</div><div class="line">sudo apt install xserver-xephyr</div></pre></td></tr></table></figure></p>
<p>下面是<code>pyvirtualdisplay</code>具体的使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from pyvirtualdisplay import Display</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    display = Display(visible=1, size=(800, 600))</div><div class="line">    display.start()</div></pre></td></tr></table></figure></p>
<p>把虚拟窗口放在一开始处的位置即可。<br>也可以将visible改为0，浏览器就完全不可见了。</p>
<p>最后附上这个阶段的完整程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_4.py" target="_blank" rel="external">github地址2</a></p>
<h2 id="改进二：验证码保存-面向对象编程"><a href="#改进二：验证码保存-面向对象编程" class="headerlink" title="改进二：验证码保存+面向对象编程"></a>改进二：验证码保存+面向对象编程</h2><p>验证码保存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">code = self.driver.find_element_by_xpath(<span class="string">"//img[@alt='CAPTCHA']"</span>)</div><div class="line">        img = code.screenshot_as_png</div><div class="line">        img_name = <span class="string">"./code/code&#123;&#125;.png"</span>.format(time.strftime(<span class="string">'%Y-%m-%d_%H%M%S'</span>, time.localtime(time.time())))</div><div class="line">        <span class="keyword">with</span> open(img_name, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(img)</div><div class="line">        rec_code = self.code_recog(img_name)</div></pre></td></tr></table></figure></p>
<p>其中，验证码保存步骤使用了selenium自带的<em>元素截图</em>功能，而不是全屏截图。这边正是我从chrome浏览器改为firefox浏览器的真实原因。chrome浏览器中的元素截图不可用！会报错！故此选用firefox浏览器。</p>
<p>面向对象编程就是对函数使用了类，把多个函数合并到了同一个类中去。</p>
<p>完整程序在最后给出。</p>
<h2 id="改进三：使用pyqt获得验证码图片"><a href="#改进三：使用pyqt获得验证码图片" class="headerlink" title="改进三：使用pyqt获得验证码图片"></a>改进三：使用pyqt获得验证码图片</h2><p>思路是：从网页中解析到验证码的图片，然后下载到本地；接着使用pyqt弹出一个窗口，窗口中显示获取到的验证码，手动输入验证码后点击关闭。</p>
<p>简化了每次登录的流程，账号、密码记录在程序中自动输入，只需要手动输入验证码。</p>
<p>其中，基于pyqt5图形界面的窗口部分的程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># CodeRecognition.py</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</div><div class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeRecognition</span><span class="params">(QtWidgets.QWidget)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></div><div class="line">        QtWidgets.QWidget.__init__(self, parent)</div><div class="line">        self.setWindowTitle(<span class="string">"请手动输入验证码"</span>)</div><div class="line">        self.resize(<span class="number">250</span>, <span class="number">150</span>)</div><div class="line">        self.center()</div><div class="line">        <span class="comment"># 界面初始化</span></div><div class="line">        self.code_edit = QLineEdit()</div><div class="line">        self.label_code = QtWidgets.QLabel()</div><div class="line">        self.init_interface()</div><div class="line">        self.img_path = <span class="string">'./image_3.png'</span></div><div class="line">        self.show_code_img()</div><div class="line">        <span class="comment"># 输出的识别码</span></div><div class="line">        self.out_code = <span class="string">'To_be_recognize'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_interface</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        label1 = QtWidgets.QLabel(<span class="string">'请输入验证码：'</span>, self)</div><div class="line">        label2 = QtWidgets.QLabel(<span class="string">'输入完成后点击关闭按钮即可。'</span>, self)</div><div class="line">        self.code_edit.setToolTip(<span class="string">'请输入验证码'</span>)</div><div class="line">        button2 = QtWidgets.QPushButton(<span class="string">'关闭'</span>, self)</div><div class="line"></div><div class="line">        grid = QGridLayout()</div><div class="line">        grid.setSpacing(<span class="number">0</span>)</div><div class="line"></div><div class="line">        grid.addWidget(self.label_code, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">        grid.addWidget(label1, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(self.code_edit, <span class="number">2</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(label2, <span class="number">3</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(button2, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 关闭窗口</span></div><div class="line">        button2.clicked.connect(self.close)</div><div class="line">        self.setLayout(grid)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 该语句用来计算出显示器的分辨率（screen.width, screen.height）</span></div><div class="line">        screen = QtWidgets.QDesktopWidget().screenGeometry()</div><div class="line">        size = self.geometry()</div><div class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_text</span><span class="params">(self)</span>:</span></div><div class="line">        self.out_code = self.code_edit.text()</div><div class="line">        <span class="comment"># print(self.out_code)</span></div><div class="line">        <span class="keyword">return</span> self.out_code</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_code_img</span><span class="params">(self)</span>:</span></div><div class="line">        img = QtGui.QPixmap(self.img_path)</div><div class="line">        self.label_code.setPixmap(img)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></div><div class="line">        code = self.get_text()</div><div class="line">        <span class="keyword">if</span> len(code) &lt; <span class="number">4</span> <span class="keyword">or</span> len(code) &gt;= <span class="number">8</span>:</div><div class="line">            QtWidgets.QMessageBox.about(self, <span class="string">"验证码输入错误"</span>, <span class="string">"请注意：\n验证码一般为4-6位，请重新输入!"</span>)</div><div class="line">            event.ignore()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            event.accept()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app = QtWidgets.QApplication(sys.argv)</div><div class="line">    center = CodeRecognition()</div><div class="line"></div><div class="line">    <span class="comment"># 改变输入的图片。</span></div><div class="line">    path = <span class="string">"image_2.png"</span></div><div class="line">    center.img_path = path</div><div class="line">    center.show_code_img()</div><div class="line"></div><div class="line">    center.show()</div><div class="line">    app.exec_()</div><div class="line">    rec_code = center.get_text()</div><div class="line">    print(<span class="string">"识别的验证码为："</span>, rec_code)</div></pre></td></tr></table></figure></p>
<p>之前学过qt的同学看起来应该不困难，没有学过qt<br>的同学想要入门的话建议查看官方文档或者小甲鱼论坛的<a href="http://bbs.fishc.com/forum.php?mod=collection&amp;action=view&amp;ctid=153" target="_blank" rel="external">pyqt连接</a>。</p>
<p>最后附上完整的程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master" target="_blank" rel="external">github地址3</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> selenium </tag>
            
            <tag> HDHome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python-基础篇]]></title>
      <url>/2017/11/27/python_base_NJU_1/</url>
      <content type="html"><![CDATA[<p>本文是学习南京大学Python玩转数据基础篇的笔记整理。<br>内容较为简洁，仅供参考。</p>
<a id="more"></a>
<h2 id="python类型"><a href="#python类型" class="headerlink" title="python类型"></a>python类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol>
<li>整型/长整型： 长度与机器有关。长整型：整型值后面加上L。</li>
<li>布尔型：True、False。</li>
<li>浮点型：数学中的实数。可以用科学计数法表示。 float</li>
<li>复数型：虚数部分用j。</li>
</ol>
<pre><code>x = 2.4+ 5j
Out[9]: (2.4+5j)
type(x)
Out[10]: complex
</code></pre><p>复数可以对实数和复数部分分离。imag、real。</p>
<p>复数的共轭：conjugate()</p>
<pre><code>x.real
Out[11]: 2.4
x.imag
Out[12]: 5.0
x.conjugate()
Out[13]: (2.4-5j)
</code></pre><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>字符串，列表[]，元组()</p>
<p>字符串：<br>        三种表示方式：单引号，双引号，三引号。<br>        可以使用索引操作符。</p>
<h3 id="映设类型"><a href="#映设类型" class="headerlink" title="映设类型"></a>映设类型</h3><p>字典：<br>        大括号{}鉴别；<br>        类似于哈希表的键值对。</p>
<h2 id="python运算"><a href="#python运算" class="headerlink" title="python运算"></a>python运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><pre><code>+ - × /
取余 %
乘方 **
整除 //  ----地板除
</code></pre><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><pre><code>数值的比较：按值的大小
字符串的比较：按ASCII码值的大小
</code></pre><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><pre><code>not and or
</code></pre><h3 id="字符运算"><a href="#字符运算" class="headerlink" title="字符运算"></a>字符运算</h3><pre><code>r / R,  ---原始字符串
u / U
</code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><pre><code>&lt;左移 &gt;右移
</code></pre><h2 id="函数、模块与包"><a href="#函数、模块与包" class="headerlink" title="函数、模块与包"></a>函数、模块与包</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以看成类似于数学中的函数。完成一个特定功能的一段代码。如绝对值函数<code>abs()</code>，类型函数<code>type()</code>，四舍五入函数<code>round()</code>。</p>
<h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>如何查看python中自带的内建函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir(__builtins__)</div></pre></td></tr></table></figure></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>非内建函数如何使用呢？</p>
<p>如floor()函数，不是内建函数，但包含在math的头文件中，因此只需要导入该模块即可，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div></pre></td></tr></table></figure></p>
<p>什么是模块？<br>模块就是一个完整的python文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">文件：物理上的组织方式：math.py</div><div class="line">模块：逻辑上的组织方式：math</div></pre></td></tr></table></figure></p>
<p>Python中通常用<code>import 模块</code>的方式将现成模块中的函数、类重用到其他代码块中。</p>
<blockquote>
<p>用help(math)打印所有math内部的函数和变量。</p>
</blockquote>
<p>可以导入多个模快。可以从模块中导入指定的模块属性（把指定的名称导入）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleName</div><div class="line"><span class="keyword">import</span> ModuleName1,ModuleName2,...</div><div class="line"><span class="keyword">from</span> Module1 <span class="keyword">import</span> ModuleElement</div></pre></td></tr></table></figure></p>
<h3 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h3><p>包是有层次的文件目录结构。</p>
<p>比如说如下的目录结构定义了一个由模块和子包组成的Python应用程序执行环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AAA/</div><div class="line">    __init__.py</div><div class="line">    bbb.py</div><div class="line">    CCC/</div><div class="line">    	__init__.py</div><div class="line">        c1.py</div><div class="line">        c2.py</div><div class="line">    DDD/</div><div class="line">    	__init__.py</div><div class="line">        d1.py</div><div class="line">    EEE/</div><div class="line">    	...</div></pre></td></tr></table></figure></p>
<p>因此，我们可以这样使用该包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AAA.CCC.c1</div><div class="line">AAA.CCC.c1.func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> AAA.CCC.c1 <span class="keyword">import</span> func1</div><div class="line">func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p>
<h3 id="库（library）"><a href="#库（library）" class="headerlink" title="库（library）"></a>库（library）</h3><p>库是一组具有相关功能的模块的集合。<br>Python的一大特色就是具有强大的标准库、以及第三方库、以及自定义的模块。</p>
<h2 id="条件、循环与中断语句"><a href="#条件、循环与中断语句" class="headerlink" title="条件、循环与中断语句"></a>条件、循环与中断语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if语句<br>else语句<br>elif语句：多分支情况下使用</p>
<p>其中，条件语句可以嵌套使用。</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for iter_var in interable_object:</div><div class="line">    suite_to_repeat</div></pre></td></tr></table></figure>
<p>可以明确循环的次数，一般用在：</p>
<ul>
<li>遍历一个数据集的成员</li>
<li><p>在列表解析中使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">4</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</div><div class="line">Out[<span class="number">4</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">in</span>[<span class="number">5</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</div><div class="line">Out[<span class="number">5</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>在生成器表达式中使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">6</span>]: (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line">Out[<span class="number">6</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x7f44af56f570</span>&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可用于迭代的对象（iterable object）有：String、 List、Tuple、Dictionary、File。</p>
<h3 id="range语句"><a href="#range语句" class="headerlink" title="range语句"></a>range语句</h3><p>一般与for语句配合使用。</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while expression:</div><div class="line">	suitr_to_repeat</div></pre></td></tr></table></figure></p>
<p>其中，expression是条件表达式，当expression的值为    True的时候，执行suitr_to_repeat的代码块。</p>
<h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>while循环中的break与for循环中的break。</p>
<h3 id="循环中的else语句"><a href="#循环中的else语句" class="headerlink" title="循环中的else语句"></a>循环中的else语句</h3><p>循环中的else：<br>如果是正常结束，就执行else中的代码；break处中止，就不执行else。</p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="自定义函数的创建："><a href="#自定义函数的创建：" class="headerlink" title="自定义函数的创建："></a>自定义函数的创建：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def function_name([arguments]):</div><div class="line">    &quot;optional documentation string&quot;</div><div class="line">    function_suite</div></pre></td></tr></table></figure>
<p>其中，def下一行可以是函数文档。～～～～～要学会使用函数文档！！</p>
<h3 id="自定义函数的调用"><a href="#自定义函数的调用" class="headerlink" title="自定义函数的调用"></a>自定义函数的调用</h3><p>函数名加上函数运算符，一对小括号。</p>
<p>括号之间是所有可选的参数，即使没有参数，小括号也不能省略。</p>
<p>参数问题，有参数就必须加上去。除非有默认值的可以不需要。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>函数的参数可以有一个默认值，如果提供有默认值，在函数定义中，默认参数以赋值语句的形式提供。</p>
<p>默认参数的值可以改变。</p>
<p>默认参数一般需要放置在参数列表的最后。默认参数后面不能有非默认参数。</p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是让调用者通过使用参数名区分参数。允许你改变参数列表中的参数顺序。</p>
<h3 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h3><p>函数可以像参数一样传递给另外一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def addMe2Me(x):</div><div class="line">    return (x+x)</div><div class="line">def self(f,y):</div><div class="line">    print f(y)</div><div class="line"></div><div class="line">&gt;&gt;&gt; self(addMe2Me,2.2)</div><div class="line">4.4</div></pre></td></tr></table></figure></p>
<h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>匿名函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_add</span><span class="params">(x,y)</span>:</span> <span class="keyword">return</span> x+y</div><div class="line"><span class="comment"># 匿名函数</span></div><div class="line"><span class="keyword">lambda</span> x, y : x + y</div><div class="line">my_add = <span class="keyword">lambda</span> x, y : x + y</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_add(<span class="number">3</span>,<span class="number">5</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>函数内部就是局部变量。</p>
<p>函数内部可以调用全局变量，使用<code>global</code>语句。</p>
<p>当全局变量和局部变量使用的是同一个名字时，内层会屏蔽外层。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归介绍"><a href="#递归介绍" class="headerlink" title="递归介绍"></a>递归介绍</h3><p>递归必须有边界条件，即停止递归的条件。 如n==0 或者n==1的情况。</p>
<p>递归的代码更简洁，更符合自然逻辑，更容易理解。</p>
<p>递归的执行方式：逐层递归调用，遇到边界条件停止递归，逐层返回调用至最初层，系统资源的消耗比循环大。</p>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Filename: Hanoi.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(a, b, c, n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line"></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        hanoi(a, c, b, n - <span class="number">1</span>)</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line">        hanoi(b, a, c, n - <span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line">hanoi(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a -&gt; c</div><div class="line">a -&gt; b</div><div class="line">c -&gt; b</div><div class="line">a -&gt; c</div><div class="line">b -&gt; a</div><div class="line">b -&gt; c</div><div class="line">a -&gt; c</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DeepLab简介及其pytorch实现]]></title>
      <url>/2017/11/23/Torch_DeepLab/</url>
      <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4s5bcwnbj20my0bm0t5.jpg" alt="different_rate"></p>
<p>本文实现了使用pytorch搭建DeepLab。算是第一批采用Pytorch的吧，到目前为止，网上还没有类似的实现。</p>
<a id="more"></a>
<h2 id="DeepLab简介"><a href="#DeepLab简介" class="headerlink" title="DeepLab简介"></a>DeepLab简介</h2><p>DeepLab文章的下载地址：<a href="https://arxiv.org/abs/1606.00915" target="_blank" rel="external">https://arxiv.org/abs/1606.00915</a></p>
<p>该文章的主要思想之一：<br>提出了Atrous convolution（带孔卷积）。<br>扩大视野但不增加计算量。</p>
<p>所谓的带孔卷积，就是在卷积核之间加上0。rate参数为2（torch中对应的参数为dilation）的示意图如下<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4s5vutk2j20kl0dngmq.jpg" alt="Atrous convolution(rate=2)" title="Atrous convolution(rate=2)"></p>
<p>rate = 2就是在原卷积核相邻两个元素之间补上一个0，假设原卷积核为3x3，rate = 2的带孔卷积核的大小就为<code>3+(3-1) × (rate-1)=5</code>。</p>
<p>下图是不同rate的带孔卷积。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4s5bcwnbj20my0bm0t5.jpg" alt="different_rate"></p>
<p>以<code>rate = 12</code> 为例，带孔卷积的核的大小为：<code>3+(3-1)x(12-1)=25</code>，即新卷积核的大小为：<code>25*25</code>。</p>
<p>总的来说，对于<code>rate=r</code>的带孔卷积，在连接着的卷积核元素间插入<code>r-1</code>个元素。因此，扩展后的卷积核大小为$k_{new}=k+(k-1)(r-1)$。</p>
<h2 id="pytorch实现deeplab"><a href="#pytorch实现deeplab" class="headerlink" title="pytorch实现deeplab"></a>pytorch实现deeplab</h2><p>笔者主要目的是实现一下不同视野的concat过程。</p>
<p>在torch中，卷积函数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</div><div class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p>
<p>其中的dilation参数就是带孔卷积的参数（也就是tensorFlow下的rate），默认情况下为1，就是普通的卷积，所以带孔卷积只需要修改这个参数就可以了。</p>
<p>比如说，我们已经写好了不同的视野下的卷积，然后需要将他们的feature map叠加起来，torch中使用<code>torch.cat(inputs, dimension=0)</code>函数来进行叠加。torch的参数一般是四个维度的：<code>[n_batch_size, n_feature_map, height, weight]</code>，所以参数中的<code>dimension = 1</code>就是对<code>feature map</code>叠加。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>叠加的这一步非常容易出错，原因在于，要求叠加的所有图片大小是一样的。而视野不同导致的卷积核的大小不同，也会导致最终输出的图像大小的变化，因此，需要恰当的调整zero-padding的数目来使得最终输出图像的大小保持一致。</p>
<p>另外稍微提一下，全连接层的输入向量大小的确定方法。全连接层是将上一步所得到的图像reshape为一个一维的向量之后，作为它的输入，因此，输入向量的长度为： <code>in_channels = nFeatureMap * height * weight</code>。</p>
<p>网络整体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(Net, self).__init__()</div><div class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2_drop = nn.Dropout2d() </div><div class="line">        self.fc1 = nn.Linear(<span class="number">40</span> * <span class="number">4</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">50</span>) </div><div class="line">        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">        self.conv_rate_1 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">2</span>, padding=<span class="number">2</span>) </div><div class="line">        self.conv_rate_2 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">3</span>, padding=<span class="number">3</span>) </div><div class="line">        self.conv_rate_3 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">4</span>, padding=<span class="number">4</span>)</div><div class="line">        self.conv_rate_4 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">5</span>, padding=<span class="number">5</span>)</div><div class="line">        self.conv_rate_5 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), <span class="number">2</span>)</div><div class="line">        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), <span class="number">2</span>))</div><div class="line">        x = self.conv_rate_1(x)</div><div class="line">        x2 = self.conv_rate_2(x)</div><div class="line">        x3 = self.conv_rate_3(x)</div><div class="line">        x4 = self.conv_rate_4(x)</div><div class="line">        x5 = self.conv_rate_5(x)</div><div class="line">        <span class="comment"># print(x.data.shape)</span></div><div class="line">        <span class="comment"># print(x2.data.shape)</span></div><div class="line">        <span class="comment"># print(x3.data.shape)</span></div><div class="line">        <span class="comment"># print(x4.data.shape)</span></div><div class="line">        <span class="comment"># print(x5.data.shape)</span></div><div class="line">        x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="comment"># for FC</span></div><div class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))  <span class="comment"># origin is 320</span></div><div class="line">        x = F.relu(self.fc1(x))  <span class="comment"># fc-&gt;relu</span></div><div class="line">        x = F.dropout(x, training=self.training)  <span class="comment"># dropout</span></div><div class="line">        x = self.fc2(x)</div><div class="line">        <span class="keyword">return</span> F.log_softmax(x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></div><div class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></div><div class="line">        num_features = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</div><div class="line">            num_features *= s</div><div class="line">        <span class="keyword">return</span> num_features</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PyTorch </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> pytorch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习系列：（七）深度学习中的正则化]]></title>
      <url>/2017/10/22/DL_chap_7/</url>
      <content type="html"><![CDATA[<p>本文是对《深度学习》的第七章，正则化方法的简单学习记录。</p>
<p>本文尚未完成。仅供参考。<br><a id="more"></a></p>
<h2 id="7-1-参数范式惩罚"><a href="#7-1-参数范式惩罚" class="headerlink" title="7.1 参数范式惩罚"></a>7.1 参数范式惩罚</h2><p>对目标模型J添加一个参数范数惩罚$\Omega (\theta)$，限制模型 的学习能力。正则化后的目标函数记为：<br>$$\tilde{J}(\theta ;X,y) = J(\theta ;X,y) +\alpha \Omega (\theta)$$</p>
<p>我们通常只对权重做惩罚而不对偏置做正则惩罚。</p>
<p>神经网络情况下，有时候希望对网络的每一层使用单独的惩罚，并分配不同的$\alpha$系数。寻找合适的多个超参数的代价很大，因此为了减少搜索空间，我们会在所以层使用相同的权重衰减。</p>
<p>符号约束说明：向量$w$表示所有应受范数惩罚影响的权重，而向量$\theta$表示所有参数（包括w和无须正则化的参数）。</p>
<h3 id="7-1-1-L-2-参数正则化"><a href="#7-1-1-L-2-参数正则化" class="headerlink" title="7.1.1 $L^2$参数正则化"></a>7.1.1 $L^2$参数正则化</h3><p><em>5.2节</em>中已经见过最简单的、最常见的$L^2$参数范数惩罚。其正则项为：<br>$$\Omega (\theta) = \frac 12 ||w||^2_2$$</p>
<p>令$w^\ast $为未正则化的目标函数取得最小训练误差时的权重向量，即$w^\ast =\text {argmin}_w J(w)$，并在$w^\ast $的邻域对目标函数做<strong>二次近似</strong>。</p>
<p>近似的$\hat J (\theta)$如下：</p>
<p>$$\hat J (\theta) = J (w^\ast) + \frac 12 (w-w^\ast)^TH(w-w^\ast) $$</p>
<p>其中，$H$是$J$在$w^\ast $处计算的Hessian矩阵（关于$w$）。因为$w^\ast $被定义为最优，所以该二次近似中<strong>没有一阶项</strong>。同样地，因为$w^\ast $是$J$的一个最优点，可以得出$H$是<strong>半正定</strong>。</p>
<h3 id="7-1-2-L-1-正则化"><a href="#7-1-2-L-1-正则化" class="headerlink" title="7.1.2 $L^1$正则化"></a>7.1.2 $L^1$正则化</h3><h2 id="7-2-作为约束的范数惩罚"><a href="#7-2-作为约束的范数惩罚" class="headerlink" title="7.2 作为约束的范数惩罚"></a>7.2 作为约束的范数惩罚</h2><h2 id="7-3-正则化和欠约束问题"><a href="#7-3-正则化和欠约束问题" class="headerlink" title="7.3 正则化和欠约束问题"></a>7.3 正则化和欠约束问题</h2><h2 id="7-4-数据集增强"><a href="#7-4-数据集增强" class="headerlink" title="7.4 数据集增强"></a>7.4 数据集增强</h2><p>使用更多的数据进行训练。</p>
<p>创建假数据并添加到训练集中。</p>
<p>图像：沿着训练图像每个方向平移几个像素。旋转。缩放。</p>
<p>数据集增强对语音识别也是有效的。</p>
<p>网络输入层注入噪声，</p>
<p>算法性能对比时，应确保算法使用同一 人工设计的数据集增强方案。</p>
<h2 id="7-5-噪声鲁棒性"><a href="#7-5-噪声鲁棒性" class="headerlink" title="7.5 噪声鲁棒性"></a>7.5 噪声鲁棒性</h2><h2 id="7-6-半监督学习"><a href="#7-6-半监督学习" class="headerlink" title="7.6 半监督学习"></a>7.6 半监督学习</h2><p>在半监督学习的框架下，$P(x)$产生的未标记样本和$P(x,y)$中的标记样本都用于估计$P(y|x)$或者根据x预测y。</p>
<p>半监督学习通常是学习一个表示：$h=f(x)$。学习表示的目的是<strong>使相同类的样本有类似的表示</strong>。</p>
<p>无监督学习可以为如何在空间聚集样本提供有用的线索。</p>
<p>模型的构建：生成模型$P(x)$或$P(x,y)$与判别模型$P(y|x)$共享参数，而不用分离无监督和监督部分。<br>权衡监督模型准则$-\text{log}P(y|x)$和无监督(或生成)模型准则$-\text{log}P(x)$或$-\text{log}P(x,y)$。</p>
<p>生成模型准则表达了对 监督学习问题的特殊形式的先验知识，即$P(x)$的结构通过某种共享参宿的方式连接到$P(y|x)$。</p>
<h2 id="7-7-多任务学习"><a href="#7-7-多任务学习" class="headerlink" title="7.7 多任务学习"></a>7.7 多任务学习</h2><h2 id="7-8-提前终止"><a href="#7-8-提前终止" class="headerlink" title="7.8 提前终止"></a>7.8 提前终止</h2><p>在训练有足够表示能力甚至会过拟合的大模型时，经常会出现：训练误差随着时间推移逐渐降低但验证集的误差会再次上升。</p>
<p>此时，我们只需要返回验证集误差最低的参数设置。</p>
<p>在每次验证集误差有所改善时，我们存储模型参数的副本。当验证集的误差在事先指定的循环次数内没有进一步改善时，算法就会终止。</p>
<p>这就是提前终止（early stopping）。</p>
<p>两个代价：一是训练步数作为超参数，训练期间需要定期评估验证集。而是需要保持最佳的参数副本。</p>
<p>提前终止是一个不显眼的正则化形式。</p>
<p>提前终止需要验证集，意味着一部分训练数据不能馈送到模型。<br>为了更好地利用这部分数据，可以在提前终止的首次训练后，进行额外的训练。在第二轮（额外的）训练中，所有的训练数据都被包括在内。</p>
<p>未完待续。</p>
<h2 id="7-9-参数绑定和参数共享"><a href="#7-9-参数绑定和参数共享" class="headerlink" title="7.9 参数绑定和参数共享"></a>7.9 参数绑定和参数共享</h2><h2 id="7-10-稀疏表示"><a href="#7-10-稀疏表示" class="headerlink" title="7.10 稀疏表示"></a>7.10 稀疏表示</h2><h2 id="7-13-Bagging和其他集成方法"><a href="#7-13-Bagging和其他集成方法" class="headerlink" title="7.13 Bagging和其他集成方法"></a>7.13 Bagging和其他集成方法</h2><p>Bagging(bootstrap aggregating)是通过结合几个模型降低泛化误差的技术。</p>
<p>主要想法是分别训练几个不同的模型，然后让所有模型表决测试样例的输出。</p>
<p>这是机器学习的一项常规策略，被称为：<strong>模型平均</strong>（model averaging）。采用这种策略的技术被称为：<strong>集成方法</strong>。</p>
<h2 id="7-12-Dropout"><a href="#7-12-Dropout" class="headerlink" title="7.12 Dropout"></a>7.12 Dropout</h2><h2 id="7-13-对抗训练"><a href="#7-13-对抗训练" class="headerlink" title="7.13 对抗训练"></a>7.13 对抗训练</h2><h2 id="7-14-切面距离、正切传播和流形正切分类器"><a href="#7-14-切面距离、正切传播和流形正切分类器" class="headerlink" title="7.14 切面距离、正切传播和流形正切分类器"></a>7.14 切面距离、正切传播和流形正切分类器</h2>]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习系列：（九）卷积网络]]></title>
      <url>/2017/10/20/DL_chap_9/</url>
      <content type="html"><![CDATA[<p>本文主要简单地介绍一下图像处理中必备的卷积网络。</p>
<a id="more"></a>
<h2 id="9-1-卷积运算"><a href="#9-1-卷积运算" class="headerlink" title="9.1 卷积运算"></a>9.1 卷积运算</h2><p>卷积的第一个参数： 输入，第二个参数： 核函数。输出有时被称为特征映射。</p>
<p>对于二维图像I，二维的核K。卷积可以写为：</p>
<p>$$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(m,n)K(i-m,j-n)$$</p>
<p>卷积是可交换的。可以等价地写为：</p>
<p>$$S(i,j) = (K\times I )(i,j) = \sum_m \sum_n I(i-m,j-n)K(m,n)$$</p>
<p>卷积运算可交换性的出现时因为我们将核相对输入进行了<strong>翻转</strong>(flip)，从m增大的角度来看，输入的索引在增大，但是核的索引在减小。</p>
<p>互相关函数：和卷积一样，但是没有对核翻转，互相关函数的公式如下：</p>
<p>$$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(i+m,j+n)K(m,n)$$</p>
<h2 id="9-2-动机"><a href="#9-2-动机" class="headerlink" title="9.2 动机"></a>9.2 动机</h2><p>卷积运算的三个重要思想：</p>
<ul>
<li><p>参数共享–绑定的权重。在一个模型的多个函数中使用相同的参数。</p>
</li>
<li><p>平移等变–输入改变，输出也以同样的方式改变。</p>
</li>
</ul>
<h2 id="9-3-池化"><a href="#9-3-池化" class="headerlink" title="9.3 池化"></a>9.3 池化</h2><p>池化函数：使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。</p>
<p>最大池化函数（Max pooling）：相邻矩形区域内的最大值</p>
<p>其他常用的池化函数：相邻区域内的平均值，L2范数，基于距中心像素位置的加权平均函数。</p>
<p>局部平移不变性。</p>
<p>池化综合了全部邻居的反馈，这使得<strong>池化单元少于探测单元</strong>成为可能，我们可以通过综合池化区域的<strong>k个像素</strong>的统计特征而不是单个像素来实现。这种方式提高了网络的计算效率，因为<strong>下一层少了约k倍的输入</strong>。（downsampling）</p>
<h2 id="9-4-卷积与池化作为一种无限强的先验"><a href="#9-4-卷积与池化作为一种无限强的先验" class="headerlink" title="9.4 卷积与池化作为一种无限强的先验"></a>9.4 卷积与池化作为一种无限强的先验</h2><p>先验概率分布（第5.2节）。弱先验具有较高的熵值，强先验具有较低的熵值。</p>
<p>一个<strong>无限强的先验</strong>需要对一些参数的概率置零并且完全禁止对这些参数赋值。</p>
<p>可以把<strong>卷机网络</strong>类比为全连接网络，但对于这个全连接网络的权重有一个无限强的先验。这个无限强的先验是说一个隐藏单元的权重必须和它邻居的权重相同，但可以在空间上移动。这个先验也要求除了那些处在隐藏单元的小的空间连续的接受域内的权重以外，其余的权重为零。 </p>
<p>类似地，使用<strong>池化</strong>也是一个无限强的先验：每个单元都具有对少量平移的不变性。</p>
<p><strong>卷积和池化可能导致欠拟合</strong>。</p>
<h2 id="9-5-基本卷积函数的变体"><a href="#9-5-基本卷积函数的变体" class="headerlink" title="9.5 基本卷积函数的变体"></a>9.5 基本卷积函数的变体</h2><p>神经网络中的卷积是由<strong>多个并行卷积组成</strong>的计算：单个核的卷积只能提取一种类型的特征。</p>
<p>卷积的输入输出可以看作3维的张量，其中一个索引用于标明不同的通道，另外两个索引用于标明每一个通道上的空间坐标。</p>
<p>$$<br>Z_{i,j,k}<br>= c(K,V,s)_{i,j,k}<br>= \sum\limits_{l,m,n}<br>[V_{l,(j - 1) \times s + m,(k - 1) \times s + m} K_{i,l,m,n}]<br>$$<br>输入是观测数据V，每个元素是$V_{i,j,k}$，表示通道i中第j行第k列的值。$K_{i,j,k,l}$输出通道i的一个单元和输入通道j中的一个单元的链接强度，并且在输出单元和输入单元之间有k行l列的偏置。</p>
<p>三种零填充方式：</p>
<ul>
<li>有效(valid)卷积：不适用零填充。输出的大小在每一层都会缩减。</li>
<li>相同(same)卷积：进行足够的零填充，保持输出和输入</li>
<li>全(full)卷积：每个像素咋每个方向上恰好被访问k次，最终输出的图像宽度为m+k-1。</li>
</ul>
<p>通常零填充的最优数量处于“有效卷积”和“相同卷积”之间的某个位置。</p>
<p>三种卷积方式：</p>
<ul>
<li><p>非共享卷积(unsahred convolution)：不横跨位置来共享参数。局部连接层没有参数共享。</p>
</li>
<li><p>平铺卷积(tiled convolution)：学习一组核，当在空间移动时它们可以循环利用。平铺卷积有t个不同的核。</p>
</li>
<li><p>标准卷积(standard convolution)：等效于t=1的平铺卷积。</p>
</li>
</ul>
<p>我们采用的一般就是标准卷积，其他的了解一下即可。</p>
<h2 id="9-6-结构化输出"><a href="#9-6-结构化输出" class="headerlink" title="9.6 结构化输出"></a>9.6 结构化输出</h2><p>卷积神经网络可以输出高维的结构化对象，通常这个对象只是一个张量，由标准卷积层产生。</p>
<p>假设为$S$，其中$S_{i,j,k}$是网络的输入像素$(j,k)$属于类$i$的概率。这允许模型<strong>标记图像中的每个像素</strong>，并绘制沿着单个对象轮廓的精确掩膜。</p>
<h2 id="9-7-数据类型"><a href="#9-7-数据类型" class="headerlink" title="9.7 数据类型"></a>9.7 数据类型</h2><p>卷积网络的优点：可以处理具有可变的空间尺度的输入。</p>
<p>可变尺寸的输入，仅对输入是因为包含对同种事物的不同量的观察（时间上不同长度的记录，空间上不同宽度的观察等）而导致的尺寸变化才有意义。</p>
<h2 id="9-8-高效的卷积算法"><a href="#9-8-高效的卷积算法" class="headerlink" title="9.8 高效的卷积算法"></a>9.8 高效的卷积算法</h2><p>朴素卷积$O(w^d) $与可分离(seperable)卷积$O(w\times d) $。</p>
<h2 id="9-9-随机或无监督的特征"><a href="#9-9-随机或无监督的特征" class="headerlink" title="9.9 随机或无监督的特征"></a>9.9 随机或无监督的特征</h2><p>卷积网络训练中最昂贵的部分是学习特征。（输出层计算代价相对不高，池化后特征少）减少训练成本：使用那些不是由监督方式得到的特征。</p>
<p>三种基本策略：</p>
<ul>
<li>简单地随机初始化它们；</li>
<li>手动设计它们，如设置每个核在一个特定的方向或尺度来检测边缘；</li>
<li>使用无监督的标准来学习核。</li>
</ul>
<h2 id="9-10-卷积网络的神经科学基础"><a href="#9-10-卷积网络的神经科学基础" class="headerlink" title="9.10 卷积网络的神经科学基础"></a>9.10 卷积网络的神经科学基础</h2><p>初级视觉皮层(primary visual cortex)。</p>
<p>Gabor函数(Gabor function)。</p>
<h2 id="9-11-卷积网络与深度学习的历史"><a href="#9-11-卷积网络与深度学习的历史" class="headerlink" title="9.11 卷积网络与深度学习的历史"></a>9.11 卷积网络与深度学习的历史</h2><p>ImageNet</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[import TensorFlow出错解决方案]]></title>
      <url>/2017/10/19/tensorflow_import_error/</url>
      <content type="html"><![CDATA[<p>本文纯属折腾TensorFlow时的一个出错记录。</p>
<p>如果你以前<code>import tensorflow</code>还没有问题，突然<code>import</code>出错的时候，可以进来看看。</p>
<a id="more"></a>
<h1 id="出错与解决历程"><a href="#出错与解决历程" class="headerlink" title="出错与解决历程"></a>出错与解决历程</h1><p>先介绍一下我的python环境：3.5.2</p>
<p>一开始是tensorflow找不到cudn的几个库，虽然问题不大。看到有教程说要升级tensorflow（<font color="#FF0000"> 请不要尝试升级 </font> ），于是抱着试试看的想法，升级了tensorflow版本：</p>
<blockquote>
<p>pip install –trusted-host pypi.python.org –upgrade tensorflow-gpu </p>
</blockquote>
<p>升级之后是1.3.0的最新版本。</p>
<p>接着<code>import tensorflow</code>的时候，出现错误：</p>
<pre><code>Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 18, in swig_import_helper
    return importlib.import_module(mname)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 969, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 958, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 666, in _load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 577, in module_from_spec
  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 906, in create_module
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removed
ImportError: DLL load failed: The specified module could not be found.
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 21, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 20, in swig_import_helper
    return importlib.import_module(&apos;_pywrap_tensorflow_internal&apos;)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
ImportError: No module named &apos;_pywrap_tensorflow_internal&apos;
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt;
    import tensorflow as tf
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\__init__.py&quot;, line 24, in &lt;module&gt;
    from tensorflow.python import *
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\__init__.py&quot;, line 51, in &lt;module&gt;
    from tensorflow.python import pywrap_tensorflow
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 52, in &lt;module&gt;
    raise ImportError(msg)
ImportError: Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 18, in swig_import_helper
    return importlib.import_module(mname)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 969, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 958, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 666, in _load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 577, in module_from_spec
  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 906, in create_module
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removed
ImportError: DLL load failed: The specified module could not be found.
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 21, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 20, in swig_import_helper
    return importlib.import_module(&apos;_pywrap_tensorflow_internal&apos;)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
ImportError: No module named &apos;_pywrap_tensorflow_internal&apos;

Failed to load the native TensorFlow runtime.
See https://www.tensorflow.org/install/install_sources#common_installation_problems
for some common reasons and solutions.  Include the entire stack trace
above this error message when asking for help.
</code></pre><p>查找到相关解决方案：</p>
<p><a href="https://stackoverflow.com/questions/43942185/failed-to-load-the-native-tensorflow-runtime-python-3-5-2" target="_blank" rel="external">https://stackoverflow.com/questions/43942185/failed-to-load-the-native-tensorflow-runtime-python-3-5-2</a></p>
<p>按照高票回答上面做出来后，依旧无效。其中5.1步骤找“curses”，需要<code>pip install curses</code> (从<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>)</p>
<p>简直气疯了。然后，尝试下载了cuda cudnn 9.0的版本，并且加上了系统环境变量，依旧无效。</p>
<p>之后在贴吧<a href="http://tieba.baidu.com/p/5147977587" target="_blank" rel="external">http://tieba.baidu.com/p/5147977587</a>  看到11楼说：</p>
<blockquote>
<p>我也是同样的问题</p>
<p>是tensorflow-gpu版本不兼容的问题</p>
<p>之前是1.3 后来安装的的1.0.1</p>
<p>亲测有效</p>
</blockquote>
<p>于是回退tensorflow的版本。</p>
<p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
<p>下载了1.1.0版本。</p>
<pre><code>Traceback (most recent call last):
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 35, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 30, in swig_import_helper
    _mod = imp.load_module(&apos;_pywrap_tensorflow_internal&apos;, fp, pathname, description)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 242, in load_module
    return load_dynamic(name, filename, file)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 342, in load_dynamic
    return _load(spec)
ImportError: DLL load failed: 找不到指定的模块。

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;D:/python/py3_prog/TensorFlow/setup_test.py&quot;, line 4, in &lt;module&gt;
    import tensorflow as tf
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\__init__.py&quot;, line 24, in &lt;module&gt;
    from tensorflow.python import *
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\__init__.py&quot;, line 51, in &lt;module&gt;
    from tensorflow.python import pywrap_tensorflow
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 52, in &lt;module&gt;
    raise ImportError(msg)
ImportError: Traceback (most recent call last):
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 35, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 30, in swig_import_helper
    _mod = imp.load_module(&apos;_pywrap_tensorflow_internal&apos;, fp, pathname, description)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 242, in load_module
    return load_dynamic(name, filename, file)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 342, in load_dynamic
    return _load(spec)
ImportError: DLL load failed: 找不到指定的模块。


Failed to load the native TensorFlow runtime.

See https://www.tensorflow.org/install/install_sources#common_installation_problems

for some common reasons and solutions.  Include the entire stack trace
above this error message when asking for help.
</code></pre><p>提示缺少dll。在<code>c/windows/system32</code>中添加了一下<code>msvcp140.dll</code>  （680kb的，不是400多kb的）<br>问题终于解决。</p>
<p>dll问题具体方案：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=53587" target="_blank" rel="external">https://www.microsoft.com/en-us/download/details.aspx?id=53587</a>下载Microsoft Visual C++ 2015 Redistributable 并安装。</p>
<p>更多解决办法可参考：<a href="https://github.com/tensorflow/tensorflow/issues/8385" target="_blank" rel="external">https://github.com/tensorflow/tensorflow/issues/8385</a></p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><ul>
<li>千万不要去更新tensorflow的版本。能用就行，不要用最新的1.3.0版本。 </li>
<li>cuda，cudnn也不要用最新的9.0版本，就用8.0版本即可。</li>
<li>import tensorflow出错时，有几个方向检查：cudn/cudaa环境变量，dll库的问题，版本是否匹配：python3.5，回退tensorflow版本，回退cuda/cudnn版本。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TensorFlow系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习中防止过拟合的方法]]></title>
      <url>/2017/10/18/DL_overfitting/</url>
      <content type="html"><![CDATA[<p>“什么是过拟合？以及如何预防过拟合？”</p>
<p>上述是机器学习常见面试题之一，本文将对其稍作解答，仅供参考。</p>
<a id="more"></a>
<h2 id="0-什么是过拟合"><a href="#0-什么是过拟合" class="headerlink" title="0. 什么是过拟合"></a>0. 什么是过拟合</h2><p>过拟合即在<strong>训练误差很小，而泛化误差很大</strong>，因为模型可能过于的复杂，使其”记住”了训练样本，然而其泛化误差却很大。</p>
<p><img src="/2017/10/18/DL_overfitting/overfitting_1.png" alt=""></p>
<p>在传统的机器学习方法中有很大防止过拟合的方法，同样这些方法很多也适合用于深度学习中，同时深度学习中又有一些独特的防止过拟合的方法，下面对其进行简单的梳理。</p>
<h2 id="1-获取更多数据"><a href="#1-获取更多数据" class="headerlink" title="1. 获取更多数据"></a>1. 获取更多数据</h2><p>让模型泛化的能力更好的最好办法就是使用<strong>更多的训练数据</strong>进行训练，但是在实践中，我们拥有的数据是有限的，解决这一问题可以人为的<strong>创造一些假数据</strong>添加到训练集中。</p>
<p>一个具体的例子:<br>在AlexNet中，将$256\times 256$图像随机的截取$224\times 224$大小，增加了许多的训练样本，同时可以对图像进行左右翻转，增加样本的个数，实验的结果可以可降低1%的误差。 </p>
<p>在神经网络中输入噪声也可以看做是数据增强的一种方式。</p>
<p>通俗得讲，<strong>数据集扩增</strong>即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。一般有以下方法：</p>
<ul>
<li>从数据源头采集更多数据</li>
<li>复制原有数据并加上随机噪声</li>
<li>重采样</li>
<li>根据当前数据集估计数据分布参数，使用该分布产生更多数据等</li>
</ul>
<h2 id="2-选用合适的模型"><a href="#2-选用合适的模型" class="headerlink" title="2.选用合适的模型"></a>2.选用合适的模型</h2><h3 id="2-1-网络结构-Architecture"><a href="#2-1-网络结构-Architecture" class="headerlink" title="2.1 网络结构 Architecture"></a>2.1 网络结构 Architecture</h3><p>这个很好理解，减少网络的层数、神经元个数等均可以限制网络的拟合能力。</p>
<h3 id="2-2-参数范数惩罚-regularization"><a href="#2-2-参数范数惩罚-regularization" class="headerlink" title="2.2 参数范数惩罚 regularization"></a>2.2 参数范数惩罚 regularization</h3><p>范数正则化是一种非常普遍的方法，也是最常用的方法，假如优化: </p>
<p>$$minObj(\theta)=L(y,f(x))+\alpha G(\theta)$$</p>
<p>其中L为经验风险，其为在训练样本上的误差，而G为对参数的惩罚，也叫结构风险。α是平衡两者，如果太大则对应的惩罚越大，如过太小，甚至接近与0，则没有惩罚。</p>
<p>最常用的范数惩罚为L1，L2正则化。</p>
<h4 id="L1正则"><a href="#L1正则" class="headerlink" title="L1正则"></a>L1正则</h4><p>L1又被成为Lasso:<br>$$||w||1=|w1|+|w2|+…$$</p>
<p>即绝对值相加，其趋向于是一些参数为0。可以起到特征选择的作用。 </p>
<h4 id="L2正则"><a href="#L2正则" class="headerlink" title="L2正则"></a>L2正则</h4><p>L2正则化为: </p>
<p>$$||w||_2=w12+w22+…$$</p>
<p>L2范数是指向量各元素的平方和然后求平方根。它有两个美称，在回归里面，有人把有它的回归叫“岭回归”（<code>Ridge Regression</code>），有人也叫它“权值衰减<code>weight decay</code>”。它的强大功效是改善机器学习里面一个非常重要的问题：过拟合。</p>
<p>其趋向与，使权重很小。其又成为ridge。</p>
<p>拟合过程中通常都倾向于让<strong>权值尽可能小</strong>，最后构造一个所有参数都比较小的模型。因为一般认为<strong>参数值小的模型比较简单</strong>，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。</p>
<p>这里也一句话总结下：通过L2范数，我们可以实现了对模型空间的限制，从而在一定程度上避免了过拟合。</p>
<p>关于更多正则化的内容可以参考《deep learning》第七章：深度学习中的正则化。</p>
<h3 id="2-3-训练时间-Early-stopping"><a href="#2-3-训练时间-Early-stopping" class="headerlink" title="2.3 训练时间 Early stopping"></a>2.3 训练时间 Early stopping</h3><p>当随着模型的能力提升，训练集的误差会先减小再增大，这样可以提前终止算法减缓过拟合现象。</p>
<p>Early stopping方法的具体做法是，在每一个Epoch结束时（一个Epoch集为对所有的训练数据的一轮遍历）计算validation data的accuracy，当accuracy不再提高时，就停止训练。这种做法很符合直观感受，因为accurary都不再提高了，在继续训练也是无益的，只会提高训练的时间。那么该做法的一个重点便是怎样才认为<code>validation accurary</code>不再提高了呢？并不是说<code>validation accuracy</code>一降下来便认为不再提高了，因为可能经过这个Epoch后，accuracy降低了，但是随后的Epoch又让accuracy又上去了，所以不能根据一两次的连续降低就判断不再提高。一般的做法是，在训练的过程中，记录到目前为止最好的<code>validation accuracy</code>，当连续10次Epoch（或者更多次）没达到最佳accuracy时，则可以认为accuracy不再提高了。此时便可以停止迭代了（<code>Early Stopping</code>）。这种策略也称为“<code>No-improvement-in-n</code>”，n即Epoch的次数，可以根据实际情况取，如10、20、30……</p>
<p>提前终止是一种很常用的缓解过拟合的方法，如在决策树的先剪枝的算法，提前终止算法，使得树的深度降低，防止其过拟合。</p>
<h3 id="添加噪声"><a href="#添加噪声" class="headerlink" title="添加噪声"></a>添加噪声</h3><p>给网络加噪声也有很多方法：</p>
<p>在输入中加噪声</p>
<p>在权值上加噪声</p>
<p>对网络的响应加噪声</p>
<h2 id="3-结合多种模型"><a href="#3-结合多种模型" class="headerlink" title="3. 结合多种模型"></a>3. 结合多种模型</h2><p>集成学习是一种比较奇特的方法，如果我们训练多个不同的模型，然后将它们的输出汇总，例如平均起来或者投票汇总，那么汇总的结果可以在一定程度上自动克服过拟合，哪怕每个模型都过拟合了。</p>
<h3 id="3-1-bagging-boosting"><a href="#3-1-bagging-boosting" class="headerlink" title="3.1 bagging boosting"></a>3.1 bagging boosting</h3><p><code>Bagging</code> 是 <code>Bootstrap Aggregating</code> 的简称。简单理解：就是分段函数的概念：用不同的模型拟合不同部分的训练集。</p>
<p>其实bagging的方法是可以起到正则化的作用，因为正则化就是要减少泛化误差，而bagging的方法可以<strong>组合多个模型</strong>起到<strong>减少泛化误差</strong>的作用。<br>在深度学习中同样可以使用此方法，但是其会<strong>增加计算和存储的成本</strong>。</p>
<p>由于训练网络本身就要耗费较多资源，所以一般不单独使用神经网络做<code>bagging</code>。</p>
<p>类似的还有<code>boosting</code>。</p>
<p>bagging中的模型是强模型，偏差低，方差高。目标是降低方差。在bagging中，每个模型的bias和variance近似相同，但是互相相关性不太高，因此一般不能降低Bias，而一定程度上能降低variance。典型的bagging是random forest。</p>
<p>boosting中每个模型是弱模型，偏差高，方差低。目标是通过平均降低偏差。boosting的基本思想就是用贪心法最小化损失函数，显然能降低偏差，但是通常模型的相关性很强，因此不能显著降低variance。典型的Boosting是adaboost，另外一个常用的并行Boosting算法是GBDT（gradient boosting decision tree）。这一类算法通常不容易出现过拟合。</p>
<h3 id="3-2-Dropout"><a href="#3-2-Dropout" class="headerlink" title="3.2 Dropout"></a>3.2 Dropout</h3><p>正则是通过在代价函数后面加上正则项来防止模型过拟合的。而在神经网络中，有一种方法是通过<strong>修改神经网络本身结构</strong>来实现的，其名为<code>Dropout</code>。该方法是在对网络进行训练时用一种技巧（<code>trick</code>），对于如下所示的三层人工神经网络： </p>
<p><img src="/2017/10/18/DL_overfitting/dropout_1.png" alt=""></p>
<p>对于上图所示的网络，在训练开始时，随机得删除一些（可以设定为一半，也可以为1/3，1/4等）隐藏层神经元，即认为这些神经元不存在，同时保持输入层与输出层神经元的个数不变，这样便得到如下的ANN： </p>
<p><img src="/2017/10/18/DL_overfitting/dropout_2.png" alt=""></p>
<p>然后按照BP学习算法对ANN中的参数进行学习更新（虚线连接的单元不更新，因为认为这些神经元被临时删除了）。这样一次迭代更新便完成了。下一次迭代中，同样随机删除一些神经元，与上次不一样，做随机选择。这样一直进行下去，直至训练结束。</p>
<p><code>Dropout</code>提供了一种廉价的<code>Bagging</code>集成近似，能够训练和评估指数级数量的神经网络。dropout可以随机的让一部分神经元失活，这样仿佛是bagging的采样过程，因此可以看做是bagging的廉价的实现。<br>但是它们训练不太一样，因为bagging，所有的模型都是独立的，而dropout下所有模型的参数是共享的。</p>
<p>通常可以这样理解<code>dropout</code>:假设我们要判别一只猫，有一个神经元说看到有毛就是猫，但是如果我让这个神经元失活，它还能判断出来是猫的话，这样就比较具有泛化的能力，减轻了过拟合的风险。</p>
<h2 id="4-Batch-Normalization"><a href="#4-Batch-Normalization" class="headerlink" title="4. Batch Normalization"></a>4. Batch Normalization</h2><p>在Google Inception V2中所采用，是一种非常有用的正则化方法，可以让大型的卷积网络训练速度加快很多倍，同事收敛后分类的准确率也可以大幅度的提高。<br>BN在训练某层时，会对每一个mini-batch数据进行标准化(normalization)处理，使输出规范到N(0,1)的正太分布，减少了Internal convariate shift(内部神经元分布的改变)，传统的深度神经网络在训练是，每一层的输入的分布都在改变，因此训练困难，只能选择用一个很小的学习速率，但是每一层用了BN后，可以有效的解决这个问题，学习速率可以增大很多倍。</p>
<h2 id="5-参数绑定与参数共享"><a href="#5-参数绑定与参数共享" class="headerlink" title="5. 参数绑定与参数共享"></a>5. 参数绑定与参数共享</h2><p>在卷积神经网络CNN中(计算机视觉与卷积神经网络 )，卷积层就是其中权值共享的方式，一个卷积核通过在图像上滑动从而实现共享参数，大幅度减少参数的个数，用卷积的形式是合理的，因为对于一副猫的图片来说，右移一个像素同样还是猫，其具有局部的特征。这是一种很好的缓解过拟合现象的方法。 </p>
<p>同样在RNN中用到的参数共享，在其整条时间链上可以进行参数的共享，这样才使得其能够被训练。</p>
<h2 id="6-辅助分类节点-auxiliary-classifiers"><a href="#6-辅助分类节点-auxiliary-classifiers" class="headerlink" title="6. 辅助分类节点(auxiliary classifiers)"></a>6. 辅助分类节点(auxiliary classifiers)</h2><p>在Google Inception V1中，采用了辅助分类节点的策略，即将中间某一层的输出用作分类，并按一个较小的权重加到最终的分类结果中，这样相当于做了模型的融合，同时给网络增加了反向传播的梯度信号，提供了额外的正则化的思想。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/taoyanqi8932/article/details/71101699" target="_blank" rel="external">http://blog.csdn.net/taoyanqi8932/article/details/71101699</a></li>
<li><a href="http://blog.csdn.net/heyongluoyao8/article/details/49429629" target="_blank" rel="external">http://blog.csdn.net/heyongluoyao8/article/details/49429629</a></li>
<li><a href="https://www.zhihu.com/question/26760839" target="_blank" rel="external">https://www.zhihu.com/question/26760839</a></li>
<li><a href="https://www.zhihu.com/question/59201590" target="_blank" rel="external">https://www.zhihu.com/question/59201590</a></li>
<li><a href="https://www.zhihu.com/question/26898675" target="_blank" rel="external">https://www.zhihu.com/question/26898675</a></li>
<li>正则化 <a href="http://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="external">http://blog.csdn.net/jinping_shi/article/details/52433975</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> overfitting </tag>
            
            <tag> 过拟合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[党的十九大报告全文]]></title>
      <url>/2017/10/18/Opening_ceremony_19th_CPC/</url>
      <content type="html"><![CDATA[<p>中国共产党第十九次全国代表大会开幕会今天上午9点在人民大会堂大礼堂举行。习近平代表第十八届中央委员会向党的十九大作报告。</p>
<p>笔者在当天即对报告全文进行了学习并转载。</p>
<a id="more"></a>
<p>以下是报告全文：</p>
<p>同志们：</p>
<p>现在，我代表第十八届中央委员会向大会作报告。</p>
<p>中国共产党第十九次全国代表大会，是在全面建成小康社会决胜阶段、中国特色社会主义进入新时代的关键时期召开的一次十分重要的大会。</p>
<p>大会的<strong>主题</strong>是：不忘初心，牢记使命，高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。</p>
<p>不忘初心，方得始终。中国共产党人的初心和使命，就是为中国人民谋幸福，为中华民族谋复兴。这个初心和使命是激励中国共产党人不断前进的根本动力。全党同志一定要永远与人民同呼吸、共命运、心连心，永远把人民对美好生活的向往作为奋斗目标，以永不懈怠的精神状态和一往无前的奋斗姿态，继续朝着实现中华民族伟大复兴的宏伟目标奋勇前进。</p>
<p>当前，国内外形势正在发生深刻复杂变化，我国发展仍处于重要战略机遇期，前景十分光明，挑战也十分严峻。全党同志一定要登高望远、居安思危，勇于变革、勇于创新，永不僵化、永不停滞，团结带领全国各族人民决胜全面建成小康社会，奋力夺取新时代中国特色社会主义伟大胜利。</p>
<p>一、过去五年的工作和历史性变革</p>
<p>十八大以来的五年，是党和国家发展进程中极不平凡的五年。面对世界经济复苏乏力、局部冲突和动荡频发、全球性问题加剧的外部环境，面对我国经济发展进入新常态等一系列深刻变化，我们坚持稳中求进工作总基调，迎难而上，开拓进取，取得了改革开放和社会主义现代化建设的历史性成就。</p>
<p>为贯彻十八大精神，党中央召开七次全会，分别就政府机构改革和职能转变、全面深化改革、全面推进依法治国、制定“十三五”规划、全面从严治党等重大问题作出决定和部署。五年来，我们统筹推进“五位一体”总体布局、协调推进“四个全面”战略布局，“十二五”规划胜利完成，“十三五”规划顺利实施，党和国家事业全面开创新局面。</p>
<p><strong>经济建设取得重大成就</strong>。坚定不移贯彻新发展理念，坚决端正发展观念、转变发展方式，发展质量和效益不断提升。经济保持中高速增长，在世界主要国家中名列前茅，国内生产总值从五十四万亿元增长到八十万亿元，稳居世界第二，对世界经济增长贡献率超过百分之三十。供给侧结构性改革深入推进，经济结构不断优化，数字经济等新兴产业蓬勃发展，高铁、公路、桥梁、港口、机场等基础设施建设快速推进。农业现代化稳步推进，粮食生产能力达到一万二千亿斤。城镇化率年均提高一点二个百分点，八千多万农业转移人口成为城镇居民。区域发展协调性增强，“一带一路”建设、京津冀协同发展、长江经济带发展成效显著。创新驱动发展战略大力实施，创新型国家建设成果丰硕，天宫、蛟龙、天眼、悟空、墨子、大飞机等重大科技成果相继问世。南海岛礁建设积极推进。开放型经济新体制逐步健全，对外贸易、对外投资、外汇储备稳居世界前列。</p>
<p><strong>全面深化改革取得重大突破</strong>。蹄疾步稳推进全面深化改革，坚决破除各方面体制机制弊端。改革全面发力、多点突破、纵深推进，着力增强改革系统性、整体性、协同性，压茬拓展改革广度和深度，推出一千五百多项改革举措，重要领域和关键环节改革取得突破性进展，主要领域改革主体框架基本确立。中国特色社会主义制度更加完善，国家治理体系和治理能力现代化水平明显提高，全社会发展活力和创新活力明显增强。</p>
<p><strong>民主法治建设迈出重大步伐</strong>。积极发展社会主义民主政治，推进全面依法治国，党的领导、人民当家作主、依法治国有机统一的制度建设全面加强，党的领导体制机制不断完善，社会主义民主不断发展，党内民主更加广泛，社会主义协商民主全面展开，爱国统一战线巩固发展，民族宗教工作创新推进。科学立法、严格执法、公正司法、全民守法深入推进，法治国家、法治政府、法治社会建设相互促进，中国特色社会主义法治体系日益完善，全社会法治观念明显增强。国家监察体制改革试点取得实效，行政体制改革、司法体制改革、权力运行制约和监督体系建设有效实施。</p>
<p><strong>思想文化建设取得重大进展</strong>。加强党对意识形态工作的领导，党的理论创新全面推进，马克思主义在意识形态领域的指导地位更加鲜明，中国特色社会主义和中国梦深入人心，社会主义核心价值观和中华优秀传统文化广泛弘扬，群众性精神文明创建活动扎实开展。公共文化服务水平不断提高，文艺创作持续繁荣，文化事业和文化产业蓬勃发展，互联网建设管理运用不断完善，全民健身和竞技体育全面发展。主旋律更加响亮，正能量更加强劲，文化自信得到彰显，国家文化软实力和中华文化影响力大幅提升，全党全社会思想上的团结统一更加巩固。</p>
<p><strong>人民生活不断改善</strong>。深入贯彻以人民为中心的发展思想，一大批惠民举措落地实施，人民获得感显著增强。脱贫攻坚战取得决定性进展，六千多万贫困人口稳定脱贫，贫困发生率从百分之十点二下降到百分之四以下。教育事业全面发展，中西部和农村教育明显加强。就业状况持续改善，城镇新增就业年均一千三百万人以上。城乡居民收入增速超过经济增速，中等收入群体持续扩大。覆盖城乡居民的社会保障体系基本建立，人民健康和医疗卫生水平大幅提高，保障性住房建设稳步推进。社会治理体系更加完善，社会大局保持稳定，国家安全全面加强。</p>
<p><strong>生态文明建设成效显著</strong>。大力度推进生态文明建设，全党全国贯彻绿色发展理念的自觉性和主动性显著增强，忽视生态环境保护的状况明显改变。生态文明制度体系加快形成，主体功能区制度逐步健全，国家公园体制试点积极推进。全面节约资源有效推进，能源资源消耗强度大幅下降。重大生态保护和修复工程进展顺利，森林覆盖率持续提高。生态环境治理明显加强，环境状况得到改善。引导应对气候变化国际合作，成为全球生态文明建设的重要参与者、贡献者、引领者。</p>
<p><strong>强军兴军开创新局面</strong>。着眼于实现中国梦强军梦，制定新形势下军事战略方针，全力推进国防和军队现代化。召开古田全军政治工作会议，恢复和发扬我党我军光荣传统和优良作风，人民军队政治生态得到有效治理。国防和军队改革取得历史性突破，形成军委管总、战区主战、军种主建新格局，人民军队组织架构和力量体系实现革命性重塑。加强练兵备战，有效遂行海上维权、反恐维稳、抢险救灾、国际维和、亚丁湾护航、人道主义救援等重大任务，武器装备加快发展，军事斗争准备取得重大进展。人民军队在中国特色强军之路上迈出坚定步伐。</p>
<p><strong>港澳台工作取得新进展</strong>。全面准确贯彻“一国两制”方针，牢牢掌握宪法和基本法赋予的中央对香港、澳门全面管治权，深化内地和港澳地区交流合作，保持香港、澳门繁荣稳定。坚持一个中国原则和“九二共识”，推动两岸关系和平发展，加强两岸经济文化交流合作，实现两岸领导人历史性会晤。妥善应对台湾局势变化，坚决反对和遏制“台独”分裂势力，有力维护台海和平稳定。</p>
<p><strong>全方位外交布局深入展开</strong>。全面推进中国特色大国外交，形成全方位、多层次、立体化的外交布局，为我国发展营造了良好外部条件。实施共建“一带一路”倡议，发起创办亚洲基础设施投资银行，设立丝路基金，举办首届“一带一路”国际合作高峰论坛、亚太经合组织领导人非正式会议、二十国集团领导人杭州峰会、金砖国家领导人厦门会晤、亚信峰会。倡导构建人类命运共同体，促进全球治理体系变革。我国国际影响力、感召力、塑造力进一步提高，为世界和平与发展作出新的重大贡献。</p>
<p><strong>全面从严治党成效卓著</strong>。全面加强党的领导和党的建设，坚决改变管党治党宽松软状况。推动全党尊崇党章，增强政治意识、大局意识、核心意识、看齐意识，坚决维护党中央权威和集中统一领导，严明党的政治纪律和政治规矩，层层落实管党治党政治责任。坚持照镜子、正衣冠、洗洗澡、治治病的要求，开展党的群众路线教育实践活动和“三严三实”专题教育，推进“两学一做”学习教育常态化制度化，全党理想信念更加坚定、党性更加坚强。贯彻新时期好干部标准，选人用人状况和风气明显好转。党的建设制度改革深入推进，党内法规制度体系不断完善。把纪律挺在前面，着力解决人民群众反映最强烈、对党的执政基础威胁最大的突出问题。出台中央八项规定，严厉整治形式主义、官僚主义、享乐主义和奢靡之风，坚决反对特权。巡视利剑作用彰显，实现中央和省级党委巡视全覆盖。坚持反腐败无禁区、全覆盖、零容忍，坚定不移“打虎”、“拍蝇”、“猎狐”，不敢腐的目标初步实现，不能腐的笼子越扎越牢，不想腐的堤坝正在构筑，反腐败斗争压倒性态势已经形成并巩固发展。</p>
<p>五年来的成就是全方位的、开创性的，五年来的变革是深层次的、根本性的。五年来，我们党以巨大的政治勇气和强烈的责任担当，提出一系列新理念新思想新战略，出台一系列重大方针政策，推出一系列重大举措，推进一系列重大工作，解决了许多长期想解决而没有解决的难题，办成了许多过去想办而没有办成的大事，推动党和国家事业发生历史性变革。这些历史性变革，对党和国家事业发展具有重大而深远的影响。</p>
<p>五年来，我们勇于面对党面临的重大风险考验和党内存在的突出问题，以顽强意志品质正风肃纪、反腐惩恶，消除了党和国家内部存在的严重隐患，党内政治生活气象更新，党内政治生态明显好转，党的创造力、凝聚力、战斗力显著增强，党的团结统一更加巩固，党群关系明显改善，党在革命性锻造中更加坚强，焕发出新的强大生机活力，为党和国家事业发展提供了坚强政治保证。</p>
<p>同时，必须清醒看到，我们的工作还存在许多不足，也面临不少困难和挑战。主要是：发展不平衡不充分的一些突出问题尚未解决，发展质量和效益还不高，创新能力不够强，实体经济水平有待提高，生态环境保护任重道远；民生领域还有不少短板，脱贫攻坚任务艰巨，城乡区域发展和收入分配差距依然较大，群众在就业、教育、医疗、居住、养老等方面面临不少难题；社会文明水平尚需提高；社会矛盾和问题交织叠加，全面依法治国任务依然繁重，国家治理体系和治理能力有待加强；意识形态领域斗争依然复杂，国家安全面临新情况；一些改革部署和重大政策措施需要进一步落实；党的建设方面还存在不少薄弱环节。这些问题，必须着力加以解决。</p>
<p>五年来的成就，是党中央坚强领导的结果，更是全党全国各族人民共同奋斗的结果。我代表中共中央，向全国各族人民，向各民主党派、各人民团体和各界爱国人士，向香港特别行政区同胞、澳门特别行政区同胞和台湾同胞以及广大侨胞，向关心和支持中国现代化建设的各国朋友，表示衷心的感谢！</p>
<p>同志们！改革开放之初，我们党发出了走自己的路、建设中国特色社会主义的伟大号召。从那时以来，我们党团结带领全国各族人民不懈奋斗，推动我国经济实力、科技实力、国防实力、综合国力进入世界前列，推动我国国际地位实现前所未有的提升，党的面貌、国家的面貌、人民的面貌、军队的面貌、中华民族的面貌发生了前所未有的变化，中华民族正以崭新姿态屹立于世界的东方。</p>
<p>经过长期努力，中国特色社会主义进入了新时代，这是我国发展新的历史方位。</p>
<p>中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景；意味着科学社会主义在二十一世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜；意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。</p>
<p>这个新时代，是承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代，是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代，是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代，是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代，是我国日益走近世界舞台中央、不断为人类作出更大贡献的时代。</p>
<p><strong>中国特色社会主义进入新时代，我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</strong>。我国稳定解决了十几亿人的温饱问题，总体上实现小康，不久将全面建成小康社会，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。同时，我国社会生产力水平总体上显著提高，社会生产能力在很多方面进入世界前列，更加突出的问题是发展不平衡不充分，这已经成为满足人民日益增长的美好生活需要的主要制约因素。</p>
<p>我们必须认识到，我国社会主要矛盾的变化没有改变我们所处社会主义历史阶段的判断，我国仍处于并将长期处于社会主义初级阶段的<strong>基本国情没有变</strong>，我国是世界上最大发展中国家的国际地位没有变。全党要牢牢把握社会主义初级阶段这个基本国情，牢牢立足社会主义初级阶段这个最大实际，牢牢坚持党的基本路线这个党和国家的生命线，人民的幸福线。领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明、和谐、<strong>美丽</strong>的社会主义现代化强国而奋斗。</p>
<p>同志们！中国特色社会主义进入新时代，在中华人民共和国发展史上、中华民族发展史上具有重大意义，在世界社会主义发展史上、人类社会发展史上也具有重大意义。全党要坚定信心、奋发有为，让中国特色社会主义展现出更加强大的生命力！</p>
<p>二、新时代中国共产党的历史使命</p>
<p>一百年前，十月革命一声炮响，给中国送来了马克思列宁主义。中国先进分子从马克思列宁主义的科学真理中看到了解决中国问题的出路。在近代以后中国社会的剧烈运动中，在中国人民反抗封建统治和外来侵略的激烈斗争中，在马克思列宁主义同中国工人运动的结合过程中，一九二一年中国共产党应运而生。从此，中国人民谋求民族独立、人民解放和国家富强、人民幸福的斗争就有了主心骨，中国人民就从精神上由被动转为主动。</p>
<p>中华民族有五千多年的文明历史，创造了灿烂的中华文明，为人类作出了卓越贡献，成为世界上伟大的民族。鸦片战争后，中国陷入内忧外患的黑暗境地，中国人民经历了战乱频仍、山河破碎、民不聊生的深重苦难。为了民族复兴，无数仁人志士不屈不挠、前仆后继，进行了可歌可泣的斗争，进行了各式各样的尝试，但终究未能改变旧中国的社会性质和中国人民的悲惨命运。</p>
<p>实现中华民族伟大复兴是近代以来中华民族最伟大的梦想。中国共产党一经成立，就把实现共产主义作为党的最高理想和最终目标，义无反顾肩负起实现中华民族伟大复兴的历史使命，团结带领人民进行了艰苦卓绝的斗争，谱写了气吞山河的壮丽史诗。</p>
<p>我们党深刻认识到，实现中华民族伟大复兴，必须推翻压在中国人民头上的帝国主义、封建主义、官僚资本主义三座大山，实现民族独立、人民解放、国家统一、社会稳定。我们党团结带领人民找到了一条以农村包围城市、武装夺取政权的正确革命道路，进行了二十八年浴血奋战，完成了新民主主义革命，一九四九年建立了中华人民共和国，实现了中国从几千年封建专制政治向人民民主的伟大飞跃。</p>
<p>我们党深刻认识到，实现中华民族伟大复兴，必须建立符合我国实际的先进社会制度。我们党团结带领人民完成社会主义革命，确立社会主义基本制度，推进社会主义建设，完成了中华民族有史以来最为广泛而深刻的社会变革，为当代中国一切发展进步奠定了根本政治前提和制度基础，实现了中华民族由近代不断衰落到根本扭转命运、持续走向繁荣富强的伟大飞跃。</p>
<p>我们党深刻认识到，实现中华民族伟大复兴，必须合乎时代潮流、顺应人民意愿，勇于改革开放，让党和人民事业始终充满奋勇前进的强大动力。我们党团结带领人民进行改革开放新的伟大革命，破除阻碍国家和民族发展的一切思想和体制障碍，开辟了中国特色社会主义道路，使中国大踏步赶上时代。</p>
<p>九十六年来，为了实现中华民族伟大复兴的历史使命，无论是弱小还是强大，无论是顺境还是逆境，我们党都初心不改、矢志不渝，团结带领人民历经千难万险，付出巨大牺牲，敢于面对曲折，勇于修正错误，攻克了一个又一个看似不可攻克的难关，创造了一个又一个彪炳史册的人间奇迹。</p>
<p><strong>同志们！今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标。</strong></p>
<p>行百里者半九十。中华民族伟大复兴，绝不是轻轻松松、敲锣打鼓就能实现的。全党必须准备付出更为艰巨、更为艰苦的努力。</p>
<p><strong>实现伟大梦想，必须进行伟大斗争</strong>。社会是在矛盾运动中前进的，有矛盾就会有斗争。我们党要团结带领人民有效应对重大挑战、抵御重大风险、克服重大阻力、解决重大矛盾，必须进行具有许多新的历史特点的伟大斗争，任何贪图享受、消极懈怠、回避矛盾的思想和行为都是错误的。全党要更加自觉地坚持党的领导和我国社会主义制度，坚决反对一切削弱、歪曲、否定党的领导和我国社会主义制度的言行；更加自觉地维护人民利益，坚决反对一切损害人民利益、脱离群众的行为；更加自觉地投身改革创新时代潮流，坚决破除一切顽瘴痼疾；更加自觉地维护我国主权、安全、发展利益，坚决反对一切分裂祖国、破坏民族团结和社会和谐稳定的行为；更加自觉地防范各种风险，坚决战胜一切在政治、经济、文化、社会等领域和自然界出现的困难和挑战。全党要充分认识这场伟大斗争的长期性、复杂性、艰巨性，发扬斗争精神，提高斗争本领，不断夺取伟大斗争新胜利。</p>
<p><strong>实现伟大梦想，必须建设伟大工程</strong>。这个伟大工程就是我们党正在深入推进的党的建设新的伟大工程。历史已经并将继续证明，没有中国共产党的领导，民族复兴必然是空想。我们党要始终成为时代先锋、民族脊梁，始终成为马克思主义执政党，自身必须始终过硬。全党要更加自觉地坚定党性原则，勇于直面问题，敢于刮骨疗毒，消除一切损害党的先进性和纯洁性的因素，清除一切侵蚀党的健康肌体的病毒，不断增强党的政治领导力、思想引领力、群众组织力、社会号召力，确保我们党永葆旺盛生命力和强大战斗力。</p>
<p><strong>实现伟大梦想，必须推进伟大事业</strong>。中国特色社会主义是改革开放以来党的全部理论和实践的主题，是党和人民历尽千辛万苦、付出巨大代价取得的根本成就。中国特色社会主义道路是实现社会主义现代化、创造人民美好生活的必由之路，中国特色社会主义理论体系是指导党和人民实现中华民族伟大复兴的正确理论，中国特色社会主义制度是当代中国发展进步的根本制度保障，中国特色社会主义文化是激励全党全国各族人民奋勇前进的强大精神力量。全党要更加自觉地增强道路自信、理论自信、制度自信、文化自信，既不走封闭僵化的老路，也不走改旗易帜的邪路，保持政治定力，坚持实干兴邦，始终坚持和发展中国特色社会主义。</p>
<p>伟大斗争，伟大工程，伟大事业，伟大梦想，紧密联系、相互贯通、相互作用，其中起决定性作用的是党的建设新的伟大工程。推进伟大工程，要结合伟大斗争、伟大事业、伟大梦想的实践来进行，确保党在世界形势深刻变化的历史进程中始终走在时代前列，在应对国内外各种风险和考验的历史进程中始终成为全国人民的主心骨，在坚持和发展中国特色社会主义的历史进程中始终成为坚强领导核心。</p>
<p>同志们！使命呼唤担当，使命引领未来。我们要不负人民重托、无愧历史选择，在新时代中国特色社会主义的伟大实践中，以党的坚强领导和顽强奋斗，激励全体中华儿女不断奋进，凝聚起同心共筑中国梦的磅礴力量！</p>
<p>三、新时代中国特色社会主义思想和基本方略</p>
<p>十八大以来，国内外形势变化和我国各项事业发展都给我们提出了一个重大时代课题，这就是必须从理论和实践结合上系统回答新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，包括新时代坚持和发展中国特色社会主义的总目标、总任务、总体布局、战略布局和发展方向、发展方式、发展动力、战略步骤、外部条件、政治保证等基本问题，并且要根据新的实践对经济、政治、法治、科技、文化、教育、民生、民族、宗教、社会、生态文明、国家安全、国防和军队、“一国两制”和祖国统一、统一战线、外交、党的建设等各方面作出理论分析和政策指导，以利于更好坚持和发展中国特色社会主义。</p>
<p>围绕这个重大时代课题，我们党坚持以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观为指导，坚持解放思想、实事求是、与时俱进、求真务实，坚持辩证唯物主义和历史唯物主义，紧密结合新的时代条件和实践要求，以全新的视野深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，进行艰辛理论探索，取得重大理论创新成果，形成了新时代中国特色社会主义思想。</p>
<p>新时代中国特色社会主义思想，明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国；明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕；明确<strong>中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”</strong>，强调坚定道路自信、理论自信、制度自信、文化自信；明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化；明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家；明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队；明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体；明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。</p>
<p>新时代中国特色社会主义思想，是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是马克思主义中国化最新成果，是党和人民实践经验和集体智慧的结晶，是中国特色社会主义理论体系的重要组成部分，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南，必须长期坚持并不断发展。全党要深刻领会新时代中国特色社会主义思想的精神实质和丰富内涵，在各项工作中全面准确贯彻落实。</p>
<p>（一）坚持党对一切工作的领导。党政军民学，东西南北中，党是领导一切的。必须增强政治意识、大局意识、核心意识、看齐意识，自觉维护党中央权威和集中统一领导，自觉在思想上政治上行动上同党中央保持高度一致，完善坚持党的领导的体制机制，坚持稳中求进工作总基调，统筹推进“五位一体”总体布局，协调推进“四个全面”战略布局，提高党把方向、谋大局、定政策、促改革的能力和定力，确保党始终总揽全局、协调各方。</p>
<p>（二）坚持以人民为中心。人民是历史的创造者，是决定党和国家前途命运的根本力量。必须坚持人民主体地位，坚持立党为公、执政为民，践行全心全意为人民服务的根本宗旨，把党的群众路线贯彻到治国理政全部活动之中，把人民对美好生活的向往作为奋斗目标，依靠人民创造历史伟业。</p>
<p>（三）坚持全面深化改革。只有社会主义才能救中国，只有改革开放才能发展中国、发展社会主义、发展马克思主义。必须坚持和完善中国特色社会主义制度，不断推进国家治理体系和治理能力现代化，坚决破除一切不合时宜的思想观念和体制机制弊端，突破利益固化的藩篱，吸收人类文明有益成果，构建系统完备、科学规范、运行有效的制度体系，充分发挥我国社会主义制度优越性。</p>
<p>（四）坚持新发展理念。发展是解决我国一切问题的基础和关键，发展必须是科学发展，必须坚定不移贯彻创新、协调、绿色、开放、共享的发展理念。必须坚持和完善我国社会主义基本经济制度和分配制度，毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展，使市场在资源配置中起决定性作用，更好发挥政府作用，推动新型工业化、信息化、城镇化、农业现代化同步发展，主动参与和推动经济全球化进程，发展更高层次的开放型经济，不断壮大我国经济实力和综合国力。</p>
<p>（五）坚持人民当家作主。坚持党的领导、人民当家作主、依法治国有机统一是社会主义政治发展的必然要求。必须坚持中国特色社会主义政治发展道路，坚持和完善人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度、基层群众自治制度，巩固和发展最广泛的爱国统一战线，发展社会主义协商民主，健全民主制度，丰富民主形式，拓宽民主渠道，保证人民当家作主落实到国家政治生活和社会生活之中。</p>
<p>（六）坚持全面依法治国。全面依法治国是中国特色社会主义的本质要求和重要保障。必须把党的领导贯彻落实到依法治国全过程和各方面，坚定不移走中国特色社会主义法治道路，完善以宪法为核心的中国特色社会主义法律体系，建设中国特色社会主义法治体系，建设社会主义法治国家，发展中国特色社会主义法治理论，坚持依法治国、依法执政、依法行政共同推进，坚持法治国家、法治政府、法治社会一体建设，坚持依法治国和以德治国相结合，依法治国和依规治党有机统一，深化司法体制改革，提高全民族法治素养和道德素质。</p>
<p>（七）坚持社会主义核心价值体系。文化自信是一个国家、一个民族发展中更基本、更深沉、更持久的力量。必须坚持马克思主义，牢固树立共产主义远大理想和中国特色社会主义共同理想，培育和践行社会主义核心价值观，不断增强意识形态领域主导权和话语权，推动中华优秀传统文化创造性转化、创新性发展，继承革命文化，发展社会主义先进文化，不忘本来、吸收外来、面向未来，更好构筑中国精神、中国价值、中国力量，为人民提供精神指引。</p>
<p>（八）坚持在发展中保障和改善民生。增进民生福祉是发展的根本目的。必须多谋民生之利、多解民生之忧，在发展中补齐民生短板、促进社会公平正义，在幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶上不断取得新进展，深入开展脱贫攻坚，保证全体人民在共建共享发展中有更多获得感，不断促进人的全面发展、全体人民共同富裕。建设平安中国，加强和创新社会治理，维护社会和谐稳定，确保国家长治久安、人民安居乐业。</p>
<p>（九）坚持人与自然和谐共生。建设生态文明是中华民族永续发展的千年大计。必须树立和践行绿水青山就是金山银山的理念，坚持节约资源和保护环境的基本国策，像对待生命一样对待生态环境，统筹山水林田湖草系统治理，实行最严格的生态环境保护制度，形成绿色发展方式和生活方式，坚定走生产发展、生活富裕、生态良好的文明发展道路，建设美丽中国，为人民创造良好生产生活环境，为全球生态安全作出贡献。</p>
<p>（十）坚持总体国家安全观。统筹发展和安全，增强忧患意识，做到居安思危，是我们党治国理政的一个重大原则。必须坚持国家利益至上，以人民安全为宗旨，以政治安全为根本，统筹外部安全和内部安全、国土安全和国民安全、传统安全和非传统安全、自身安全和共同安全，完善国家安全制度体系，加强国家安全能力建设，坚决维护国家主权、安全、发展利益。</p>
<p>（十一）坚持党对人民军队的绝对领导。建设一支听党指挥、能打胜仗、作风优良的人民军队，是实现“两个一百年”奋斗目标、实现中华民族伟大复兴的战略支撑。必须全面贯彻党领导人民军队的一系列根本原则和制度，确立新时代党的强军思想在国防和军队建设中的指导地位，坚持政治建军、改革强军、科技兴军、依法治军，更加注重聚焦实战，更加注重创新驱动，更加注重体系建设，更加注重集约高效，更加注重军民融合，实现党在新时代的强军目标。</p>
<p>（十二）坚持“一国两制”和推进祖国统一。保持香港、澳门长期繁荣稳定，实现祖国完全统一，是实现中华民族伟大复兴的必然要求。必须把维护中央对香港、澳门特别行政区全面管治权和保障特别行政区高度自治权有机结合起来，确保“一国两制”方针不会变、不动摇，确保“一国两制”实践不变形、不走样。必须坚持一个中国原则，坚持“九二共识”，推动两岸关系和平发展，深化两岸经济合作和文化往来，推动两岸同胞共同反对一切分裂国家的活动，共同为实现中华民族伟大复兴而奋斗。</p>
<p>（十三）坚持推动构建人类命运共同体。中国人民的梦想同各国人民的梦想息息相通，实现中国梦离不开和平的国际环境和稳定的国际秩序。必须统筹国内国际两个大局，始终不渝走和平发展道路、奉行互利共赢的开放战略，坚持正确义利观，树立共同、综合、合作、可持续的新安全观，谋求开放创新、包容互惠的发展前景，促进和而不同、兼收并蓄的文明交流，构筑尊崇自然、绿色发展的生态体系，始终做世界和平的建设者、全球发展的贡献者、国际秩序的维护者。</p>
<p>（十四）坚持全面从严治党。勇于自我革命，从严管党治党，是我们党最鲜明的品格。必须以党章为根本遵循，把党的政治建设摆在首位，思想建党和制度治党同向发力，统筹推进党的各项建设，抓住“关键少数”，坚持“三严三实”，坚持民主集中制，严肃党内政治生活，严明党的纪律，强化党内监督，发展积极健康的党内政治文化，全面净化党内政治生态，坚决纠正各种不正之风，以零容忍态度惩治腐败，不断增强党自我净化、自我完善、自我革新、自我提高的能力，始终保持党同人民群众的血肉联系。</p>
<p>以上十四条，构成新时代坚持和发展中国特色社会主义的基本方略。全党同志必须全面贯彻党的基本理论、基本路线、基本方略，更好引领党和人民事业发展。</p>
<p>实践没有止境，理论创新也没有止境。世界每时每刻都在发生变化，中国也每时每刻都在发生变化，我们必须在理论上跟上时代，不断认识规律，不断推进理论创新、实践创新、制度创新、文化创新以及其他各方面创新。</p>
<p>同志们！时代是思想之母，实践是理论之源。只要我们善于聆听时代声音，勇于坚持真理、修正错误，二十一世纪中国的马克思主义一定能够展现出更强大、更有说服力的真理力量！</p>
<p>四、决胜全面建成小康社会，开启全面建设社会主义现代化国家新征程</p>
<p>改革开放之后，我们党对我国社会主义现代化建设作出战略安排，提出“三步走”战略目标。解决人民温饱问题、人民生活总体上达到小康水平这两个目标已提前实现。在这个基础上，我们党提出，到建党一百年时建成经济更加发展、民主更加健全、科教更加进步、文化更加繁荣、社会更加和谐、人民生活更加殷实的小康社会，然后再奋斗三十年，到新中国成立一百年时，基本实现现代化，把我国建成社会主义现代化国家。</p>
<p>从现在到二〇二〇年，是全面建成小康社会决胜期。要按照十六大、十七大、十八大提出的全面建成小康社会各项要求，紧扣我国社会主要矛盾变化，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设，坚定实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战略、区域协调发展战略、可持续发展战略、军民融合发展战略，突出抓重点、补短板、强弱项，特别是要坚决打好防范化解重大风险、精准脱贫、污染防治的攻坚战，使全面建成小康社会得到人民认可、经得起历史检验。</p>
<p>从十九大到二十大，是“两个一百年”奋斗目标的历史交汇期。我们既要全面建成小康社会、实现第一个百年奋斗目标，又要乘势而上开启全面建设社会主义现代化国家新征程，向第二个百年奋斗目标进军。</p>
<p><strong>综合分析国际国内形势和我国发展条件，从二〇二〇年到本世纪中叶可以分两个阶段来安排</strong>。</p>
<p>第一个阶段，<strong>从二〇二〇年到二〇三五年</strong>，在全面建成小康社会的基础上，再奋斗十五年，基本实现社会主义现代化。到那时，我国经济实力、科技实力将大幅跃升，跻身创新型国家前列；人民平等参与、平等发展权利得到充分保障，法治国家、法治政府、法治社会基本建成，各方面制度更加完善，国家治理体系和治理能力现代化基本实现；社会文明程度达到新的高度，国家文化软实力显著增强，中华文化影响更加广泛深入；人民生活更为宽裕，中等收入群体比例明显提高，城乡区域发展差距和居民生活水平差距显著缩小，基本公共服务均等化基本实现，全体人民共同富裕迈出坚实步伐；现代社会治理格局基本形成，社会充满活力又和谐有序；生态环境根本好转，美丽中国目标基本实现。</p>
<p>第二个阶段，<strong>从二〇三五年到本世纪中叶</strong>，在基本实现现代化的基础上，再奋斗十五年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。到那时，我国物质文明、政治文明、精神文明、社会文明、生态文明将全面提升，实现国家治理体系和治理能力现代化，成为综合国力和国际影响力领先的国家，全体人民共同富裕基本实现，我国人民将享有更加幸福安康的生活，中华民族将以更加昂扬的姿态屹立于世界民族之林。</p>
<p>同志们！从全面建成小康社会到基本实现现代化，再到全面建成社会主义现代化强国，是新时代中国特色社会主义发展的战略安排。我们要坚忍不拔、锲而不舍，奋力谱写社会主义现代化新征程的壮丽篇章！</p>
<p>五、贯彻新发展理念，建设现代化经济体系</p>
<p>实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦，不断提高人民生活水平，<strong>必须坚定不移把发展作为党执政兴国的第一要务，坚持解放和发展社会生产力，坚持社会主义市场经济改革方向，推动经济持续健康发展</strong>。</p>
<p>我国经济已由高速增长阶段转向高质量发展阶段，正处在转变发展方式、优化经济结构、转换增长动力的攻关期，建设现代化经济体系是跨越关口的迫切要求和我国发展的战略目标。必须坚持质量第一、效益优先，以供给侧结构性改革为主线，推动经济发展质量变革、效率变革、动力变革，提高全要素生产率，着力加快建设实体经济、科技创新、现代金融、人力资源协同发展的产业体系，着力构建市场机制有效、微观主体有活力、宏观调控有度的经济体制，不断增强我国经济创新力和竞争力。</p>
<p>（一）深化供给侧结构性改革。建设现代化经济体系，必须把发展经济的着力点放在实体经济上，把提高供给体系质量作为主攻方向，显著增强我国经济质量优势。加快建设制造强国，加快发展先进制造业，推动互联网、大数据、人工智能和实体经济深度融合，在中高端消费、创新引领、绿色低碳、共享经济、现代供应链、人力资本服务等领域培育新增长点、形成新动能。支持传统产业优化升级，加快发展现代服务业，瞄准国际标准提高水平。促进我国产业迈向全球价值链中高端，培育若干世界级先进制造业集群。加强水利、铁路、公路、水运、航空、管道、电网、信息、物流等基础设施网络建设。坚持去产能、去库存、去杠杆、降成本、补短板，优化存量资源配置，扩大优质增量供给，实现供需动态平衡。激发和保护企业家精神，鼓励更多社会主体投身创新创业。建设知识型、技能型、创新型劳动者大军，弘扬劳模精神和工匠精神，营造劳动光荣的社会风尚和精益求精的敬业风气。</p>
<p>（二）加快建设创新型国家。创新是引领发展的第一动力，是建设现代化经济体系的战略支撑。要瞄准世界科技前沿，强化基础研究，实现前瞻性基础研究、引领性原创成果重大突破。加强应用基础研究，拓展实施国家重大科技项目，突出关键共性技术、前沿引领技术、现代工程技术、颠覆性技术创新，为建设科技强国、质量强国、航天强国、网络强国、交通强国、数字中国、智慧社会提供有力支撑。加强国家创新体系建设，强化战略科技力量。深化科技体制改革，建立以企业为主体、市场为导向、产学研深度融合的技术创新体系，加强对中小企业创新的支持，促进科技成果转化。倡导创新文化，强化知识产权创造、保护、运用。培养造就一大批具有国际水平的战略科技人才、科技领军人才、青年科技人才和高水平创新团队。</p>
<p>（三）实施乡村振兴战略。农业农村农民问题是关系国计民生的根本性问题，<strong>必须始终把解决好“三农”问题作为全党工作重中之重。</strong>要坚持农业农村优先发展，按照产业兴旺、生态宜居、乡风文明、治理有效、生活富裕的总要求，建立健全城乡融合发展体制机制和政策体系，加快推进农业农村现代化。巩固和完善农村基本经营制度，深化农村土地制度改革，完善承包地“三权”分置制度。<strong>保持土地承包关系稳定并长久不变，第二轮土地承包到期后再延长三十年。</strong>深化农村集体产权制度改革，保障农民财产权益，壮大集体经济。确保国家粮食安全，把中国人的饭碗牢牢端在自己手中。构建现代农业产业体系、生产体系、经营体系，完善农业支持保护制度，发展多种形式适度规模经营，培育新型农业经营主体，健全农业社会化服务体系，实现小农户和现代农业发展有机衔接。促进农村一二三产业融合发展，支持和鼓励农民就业创业，拓宽增收渠道。加强农村基层基础工作，健全自治、法治、德治相结合的乡村治理体系。培养造就一支懂农业、爱农村、爱农民的“三农”工作队伍。</p>
<p>（四）实施区域协调发展战略。加大力度支持革命老区、民族地区、边疆地区、贫困地区加快发展，强化举措推进西部大开发形成新格局，深化改革加快东北等老工业基地振兴，发挥优势推动中部地区崛起，创新引领率先实现东部地区优化发展，建立更加有效的区域协调发展新机制。以城市群为主体构建大中小城市和小城镇协调发展的城镇格局，加快农业转移人口市民化。以疏解北京非首都功能为“牛鼻子”推动京津冀协同发展，高起点规划、高标准建设雄安新区。以共抓大保护、不搞大开发为导向推动长江经济带发展。支持资源型地区经济转型发展。加快边疆发展，确保边疆巩固、边境安全。坚持陆海统筹，加快建设海洋强国。</p>
<p>（五）加快完善社会主义市场经济体制。经济体制改革必须以完善产权制度和要素市场化配置为重点，实现产权有效激励、要素自由流动、价格反应灵活、竞争公平有序、企业优胜劣汰。要完善各类国有资产管理体制，改革国有资本授权经营体制，加快国有经济布局优化、结构调整、战略性重组，促进国有资产保值增值，推动国有资本做强做优做大，有效防止国有资产流失。深化国有企业改革，发展混合所有制经济，培育具有全球竞争力的世界一流企业。全面实施市场准入负面清单制度，清理废除妨碍统一市场和公平竞争的各种规定和做法，支持民营企业发展，激发各类市场主体活力。深化商事制度改革，打破行政性垄断，防止市场垄断，加快要素价格市场化改革，放宽服务业准入限制，完善市场监管体制。创新和完善宏观调控，发挥国家发展规划的战略导向作用，健全财政、货币、产业、区域等经济政策协调机制。完善促进消费的体制机制，增强消费对经济发展的基础性作用。深化投融资体制改革，发挥投资对优化供给结构的关键性作用。加快建立现代财政制度，建立权责清晰、财力协调、区域均衡的中央和地方财政关系。建立全面规范透明、标准科学、约束有力的预算制度，全面实施绩效管理。深化税收制度改革，健全地方税体系。深化金融体制改革，增强金融服务实体经济能力，提高直接融资比重，促进多层次资本市场健康发展。健全货币政策和宏观审慎政策双支柱调控框架，深化利率和汇率市场化改革。健全金融监管体系，守住不发生系统性金融风险的底线。</p>
<p>（六）推动形成全面开放新格局。开放带来进步，封闭必然落后。中国开放的大门不会关闭，只会越开越大。要以“一带一路”建设为重点，坚持引进来和走出去并重，遵循共商共建共享原则，加强创新能力开放合作，形成陆海内外联动、东西双向互济的开放格局。拓展对外贸易，培育贸易新业态新模式，推进贸易强国建设。实行高水平的贸易和投资自由化便利化政策，全面实行准入前国民待遇加负面清单管理制度，大幅度放宽市场准入，扩大服务业对外开放，保护外商投资合法权益。凡是在我国境内注册的企业，都要一视同仁、平等对待。优化区域开放布局，加大西部开放力度。赋予自由贸易试验区更大改革自主权，探索建设自由贸易港。创新对外投资方式，促进国际产能合作，形成面向全球的贸易、投融资、生产、服务网络，加快培育国际经济合作和竞争新优势。</p>
<p>同志们！<strong>解放和发展社会生产力，是社会主义的本质要求</strong>。我们要激发全社会创造力和发展活力，努力实现更高质量、更有效率、更加公平、更可持续的发展！</p>
<p>六、健全人民当家作主制度体系，发展社会主义民主政治</p>
<p><strong>我国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家，国家一切权力属于人民。</strong>我国社会主义民主是维护人民根本利益的最广泛、最真实、最管用的民主。发展社会主义民主政治就是要体现人民意志、保障人民权益、激发人民创造活力，用制度体系保证人民当家作主。</p>
<p>中国特色社会主义政治发展道路，是近代以来中国人民长期奋斗历史逻辑、理论逻辑、实践逻辑的必然结果，是坚持党的本质属性、践行党的根本宗旨的必然要求。世界上没有完全相同的政治制度模式，政治制度不能脱离特定社会政治条件和历史文化传统来抽象评判，不能定于一尊，不能生搬硬套外国政治制度模式。要长期坚持、不断发展我国社会主义民主政治，积极稳妥推进政治体制改革，推进社会主义民主政治制度化、规范化、法治化、程序化，保证人民依法通过各种途径和形式管理国家事务，管理经济文化事业，管理社会事务，巩固和发展生动活泼、安定团结的政治局面。</p>
<p>（一）坚持党的领导、人民当家作主、依法治国有机统一。党的领导是人民当家作主和依法治国的根本保证，人民当家作主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式，三者统一于我国社会主义民主政治伟大实践。在我国政治生活中，党是居于领导地位的，加强党的集中统一领导，支持人大、政府、政协和法院、检察院依法依章程履行职能、开展工作、发挥作用，这两个方面是统一的。要改进党的领导方式和执政方式，保证党领导人民有效治理国家；扩大人民有序政治参与，保证人民依法实行民主选举、民主协商、民主决策、民主管理、民主监督；维护国家法制统一、尊严、权威，加强人权法治保障，保证人民依法享有广泛权利和自由。巩固基层政权，完善基层民主制度，保障人民知情权、参与权、表达权、监督权。健全依法决策机制，构建决策科学、执行坚决、监督有力的权力运行机制。各级领导干部要增强民主意识，发扬民主作风，接受人民监督，当好人民公仆。</p>
<p>（二）加强人民当家作主制度保障。人民代表大会制度是坚持党的领导、人民当家作主、依法治国有机统一的根本政治制度安排，必须长期坚持、不断完善。要支持和保证人民通过人民代表大会行使国家权力。发挥人大及其常委会在立法工作中的主导作用，健全人大组织制度和工作制度，支持和保证人大依法行使立法权、监督权、决定权、任免权，更好发挥人大代表作用，使各级人大及其常委会成为全面担负起宪法法律赋予的各项职责的工作机关，成为同人民群众保持密切联系的代表机关。完善人大专门委员会设置，优化人大常委会和专门委员会组成人员结构。</p>
<p>（三）发挥社会主义协商民主重要作用。有事好商量，众人的事情由众人商量，是人民民主的真谛。协商民主是实现党的领导的重要方式，是我国社会主义民主政治的特有形式和独特优势。要推动协商民主广泛、多层、制度化发展，统筹推进政党协商、人大协商、政府协商、政协协商、人民团体协商、基层协商以及社会组织协商。加强协商民主制度建设，形成完整的制度程序和参与实践，保证人民在日常政治生活中有广泛持续深入参与的权利。</p>
<p>人民政协是具有中国特色的制度安排，是社会主义协商民主的重要渠道和专门协商机构。人民政协工作要聚焦党和国家中心任务，围绕团结和民主两大主题，把协商民主贯穿政治协商、民主监督、参政议政全过程，完善协商议政内容和形式，着力增进共识、促进团结。加强人民政协民主监督，重点监督党和国家重大方针政策和重要决策部署的贯彻落实。增强人民政协界别的代表性，加强委员队伍建设。</p>
<p>（四）深化依法治国实践。全面依法治国是国家治理的一场深刻革命，必须坚持厉行法治，推进科学立法、严格执法、公正司法、全民守法。成立中央全面依法治国领导小组，加强对法治中国建设的统一领导。加强宪法实施和监督，推进合宪性审查工作，维护宪法权威。推进科学立法、民主立法、依法立法，以良法促进发展、保障善治。建设法治政府，推进依法行政，严格规范公正文明执法。深化司法体制综合配套改革，全面落实司法责任制，努力让人民群众在每一个司法案件中感受到公平正义。加大全民普法力度，建设社会主义法治文化，树立宪法法律至上、法律面前人人平等的法治理念。各级党组织和全体党员要带头尊法学法守法用法，任何组织和个人都不得有超越宪法法律的特权，绝不允许以言代法、以权压法、逐利违法、徇私枉法。</p>
<p>（五）深化机构和行政体制改革。统筹考虑各类机构设置，科学配置党政部门及内设机构权力、明确职责。统筹使用各类编制资源，形成科学合理的管理体制，完善国家机构组织法。转变政府职能，深化简政放权，创新监管方式，增强政府公信力和执行力，建设人民满意的服务型政府。赋予省级及以下政府更多自主权。在省市县对职能相近的党政机关探索合并设立或合署办公。深化事业单位改革，强化公益属性，推进政事分开、事企分开、管办分离。</p>
<p>（六）巩固和发展爱国统一战线。统一战线是党的事业取得胜利的重要法宝，必须长期坚持。要高举爱国主义、社会主义旗帜，牢牢把握大团结大联合的主题，坚持一致性和多样性统一，<strong>找到最大公约数，画出最大同心圆</strong>。坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派按照中国特色社会主义参政党要求更好履行职能。深化民族团结进步教育，铸牢中华民族共同体意识，加强各民族交往交流交融，促进各民族像石榴籽一样紧紧抱在一起，共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，坚持我国宗教的中国化方向，积极引导宗教与社会主义社会相适应。加强党外知识分子工作，做好新的社会阶层人士工作，发挥他们在中国特色社会主义事业中的重要作用。构建亲、清新型政商关系，促进非公有制经济健康发展和非公有制经济人士健康成长。广泛团结联系海外侨胞和归侨侨眷，共同致力于中华民族伟大复兴。</p>
<p>同志们！中国特色社会主义政治制度是中国共产党和中国人民的伟大创造。我们完全有信心、有能力把我国社会主义民主政治的优势和特点充分发挥出来，为人类政治文明进步作出充满中国智慧的贡献！</p>
<p>七、坚定文化自信，推动社会主义文化繁荣兴盛</p>
<p>文化是一个国家、一个民族的灵魂。文化兴国运兴，文化强民族强。没有高度的文化自信，没有文化的繁荣兴盛，就没有中华民族伟大复兴。要坚持中国特色社会主义文化发展道路，激发全民族文化创新创造活力，建设社会主义文化强国。</p>
<p>中国特色社会主义文化，源自于中华民族五千多年文明历史所孕育的中华优秀传统文化，熔铸于党领导人民在革命、建设、改革中创造的革命文化和社会主义先进文化，植根于中国特色社会主义伟大实践。发展中国特色社会主义文化，就是以马克思主义为指导，坚守中华文化立场，立足当代中国现实，结合当今时代条件，发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化，推动社会主义精神文明和物质文明协调发展。要坚持为人民服务、为社会主义服务，坚持百花齐放、百家争鸣，坚持创造性转化、创新性发展，不断铸就中华文化新辉煌。</p>
<p>（一）牢牢掌握意识形态工作领导权。意识形态决定文化前进方向和发展道路。必须推进马克思主义中国化时代化大众化，建设具有强大凝聚力和引领力的社会主义意识形态，使全体人民在理想信念、价值理念、道德观念上紧紧团结在一起。要加强理论武装，推动新时代中国特色社会主义思想深入人心。深化马克思主义理论研究和建设，加快构建中国特色哲学社会科学，加强中国特色新型智库建设。高度重视传播手段建设和创新，提高新闻舆论传播力、引导力、影响力、公信力。加强互联网内容建设，建立网络综合治理体系，营造清朗的网络空间。落实意识形态工作责任制，加强阵地建设和管理，注意区分政治原则问题、思想认识问题、学术观点问题，旗帜鲜明反对和抵制各种错误观点。</p>
<p>（二）培育和践行社会主义核心价值观。社会主义核心价值观是当代中国精神的集中体现，凝结着全体人民共同的价值追求。要以培养担当民族复兴大任的时代新人为着眼点，强化教育引导、实践养成、制度保障，发挥社会主义核心价值观对国民教育、精神文明创建、精神文化产品创作生产传播的引领作用，把社会主义核心价值观融入社会发展各方面，转化为人们的情感认同和行为习惯。坚持全民行动、干部带头，从家庭做起，从娃娃抓起。深入挖掘中华优秀传统文化蕴含的思想观念、人文精神、道德规范，结合时代要求继承创新，让中华文化展现出永久魅力和时代风采。</p>
<p>（三）加强思想道德建设。人民有信仰，国家有力量，民族有希望。要提高人民思想觉悟、道德水准、文明素养，提高全社会文明程度。广泛开展理想信念教育，深化中国特色社会主义和中国梦宣传教育，弘扬民族精神和时代精神，加强爱国主义、集体主义、社会主义教育，引导人们树立正确的历史观、民族观、国家观、文化观。深入实施公民道德建设工程，推进社会公德、职业道德、家庭美德、个人品德建设，激励人们向上向善、孝老爱亲，忠于祖国、忠于人民。加强和改进思想政治工作，深化群众性精神文明创建活动。弘扬科学精神，普及科学知识，开展移风易俗、弘扬时代新风行动，抵制腐朽落后文化侵蚀。推进诚信建设和志愿服务制度化，强化社会责任意识、规则意识、奉献意识。</p>
<p>（四）繁荣发展社会主义文艺。社会主义文艺是人民的文艺，必须坚持以人民为中心的创作导向，在深入生活、扎根人民中进行无愧于时代的文艺创造。要繁荣文艺创作，坚持思想精深、艺术精湛、制作精良相统一，加强现实题材创作，不断推出讴歌党、讴歌祖国、讴歌人民、讴歌英雄的精品力作。发扬学术民主、艺术民主，提升文艺原创力，推动文艺创新。倡导讲品位、讲格调、讲责任，抵制低俗、庸俗、媚俗。加强文艺队伍建设，造就一大批德艺双馨名家大师，培育一大批高水平创作人才。</p>
<p>（五）推动文化事业和文化产业发展。满足人民过上美好生活的新期待，必须提供丰富的精神食粮。要深化文化体制改革，完善文化管理体制，加快构建把社会效益放在首位、社会效益和经济效益相统一的体制机制。完善公共文化服务体系，深入实施文化惠民工程，丰富群众性文化活动。加强文物保护利用和文化遗产保护传承。健全现代文化产业体系和市场体系，创新生产经营机制，完善文化经济政策，培育新型文化业态。广泛开展全民健身活动，加快推进体育强国建设，筹办好北京冬奥会、冬残奥会。加强中外人文交流，以我为主、兼收并蓄。推进国际传播能力建设，讲好中国故事，展现真实、立体、全面的中国，提高国家文化软实力。</p>
<p>同志们！中国共产党从成立之日起，既是中国先进文化的积极引领者和践行者，又是中华优秀传统文化的忠实传承者和弘扬者。当代中国共产党人和中国人民应该而且一定能够担负起新的文化使命，在实践创造中进行文化创造，在历史进步中实现文化进步！</p>
<p>八、提高保障和改善民生水平，加强和创新社会治理</p>
<p>全党必须牢记，为什么人的问题，是检验一个政党、一个政权性质的试金石。带领人民创造美好生活，是我们党始终不渝的奋斗目标。必须始终把<strong>人民利益</strong>摆在至高无上的地位，让改革发展成果更多更公平惠及全体人民，朝着实现全体人民共同富裕不断迈进。</p>
<p>保障和改善民生要抓住人民最关心最直接最现实的利益问题，既尽力而为，又量力而行，一件事情接着一件事情办，一年接着一年干。坚持人人尽责、人人享有，坚守底线、突出重点、完善制度、引导预期，完善公共服务体系，保障群众基本生活，<strong>不断满足人民日益增长的美好生活需要</strong>，不断促进社会公平正义，形成有效的社会治理、良好的社会秩序，使人民获得感、幸福感、安全感更加充实、更有保障、更可持续。</p>
<p>（一）优先发展教育事业。建设教育强国是中华民族伟大复兴的基础工程，必须把教育事业放在优先位置，加快教育现代化，办好人民满意的教育。要全面贯彻党的教育方针，落实立德树人根本任务，发展素质教育，推进教育公平，培养德智体美全面发展的社会主义建设者和接班人。推动城乡义务教育一体化发展，高度重视农村义务教育，办好学前教育、特殊教育和网络教育，普及高中阶段教育，努力让每个孩子都能享有公平而有质量的教育。完善职业教育和培训体系，深化产教融合、校企合作。加快一流大学和一流学科建设，实现高等教育内涵式发展。健全学生资助制度，使绝大多数城乡新增劳动力接受高中阶段教育、更多接受高等教育。支持和规范社会力量兴办教育。加强师德师风建设，培养高素质教师队伍，倡导全社会尊师重教。办好继续教育，加快建设学习型社会，大力提高国民素质。</p>
<p>（二）提高就业质量和人民收入水平。<strong>就业是最大的民生。</strong>要坚持就业优先战略和积极就业政策，实现更高质量和更充分就业。大规模开展职业技能培训，注重解决结构性就业矛盾，鼓励创业带动就业。提供全方位公共就业服务，促进高校毕业生等青年群体、农民工多渠道就业创业。破除妨碍劳动力、人才社会性流动的体制机制弊端，使人人都有通过辛勤劳动实现自身发展的机会。完善政府、工会、企业共同参与的协商协调机制，构建和谐劳动关系。坚持按劳分配原则，完善按要素分配的体制机制，促进收入分配更合理、更有序。鼓励勤劳守法致富，扩大中等收入群体，增加低收入者收入，调节过高收入，取缔非法收入。坚持在经济增长的同时实现居民收入同步增长、在劳动生产率提高的同时实现劳动报酬同步提高。拓宽居民劳动收入和财产性收入渠道。履行好政府再分配调节职能，加快推进基本公共服务均等化，缩小收入分配差距。</p>
<p>（三）加强社会保障体系建设。按照兜底线、织密网、建机制的要求，全面建成覆盖全民、城乡统筹、权责清晰、保障适度、可持续的多层次社会保障体系。全面实施全民参保计划。完善城镇职工基本养老保险和城乡居民基本养老保险制度，尽快实现养老保险全国统筹。完善统一的城乡居民基本医疗保险制度和大病保险制度。完善失业、工伤保险制度。建立全国统一的社会保险公共服务平台。统筹城乡社会救助体系，完善最低生活保障制度。坚持男女平等基本国策，保障妇女儿童合法权益。完善社会救助、社会福利、慈善事业、优抚安置等制度，健全农村留守儿童和妇女、老年人关爱服务体系。发展残疾人事业，加强残疾康复服务。坚持房子是用来住的、不是用来炒的定位，加快建立多主体供给、多渠道保障、租购并举的住房制度，让全体人民住有所居。</p>
<p>（四）坚决打赢脱贫攻坚战。让贫困人口和贫困地区同全国一道进入全面小康社会是我们党的庄严承诺。要动员全党全国全社会力量，坚持精准扶贫、精准脱贫，坚持中央统筹省负总责市县抓落实的工作机制，强化党政一把手负总责的责任制，坚持大扶贫格局，注重扶贫同扶志、扶智相结合，深入实施东西部扶贫协作，重点攻克深度贫困地区脱贫任务，<strong>确保到二〇二〇年我国现行标准下农村贫困人口实现脱贫，贫困县全部摘帽，解决区域性整体贫困，做到脱真贫、真脱贫</strong>。</p>
<p>（五）实施健康中国战略。人民健康是民族昌盛和国家富强的重要标志。要完善国民健康政策，为人民群众提供全方位全周期健康服务。深化医药卫生体制改革，全面建立中国特色基本医疗卫生制度、医疗保障制度和优质高效的医疗卫生服务体系，健全现代医院管理制度。加强基层医疗卫生服务体系和全科医生队伍建设。全面取消以药养医，健全药品供应保障制度。坚持预防为主，深入开展爱国卫生运动，倡导健康文明生活方式，预防控制重大疾病。实施食品安全战略，让人民吃得放心。坚持中西医并重，传承发展中医药事业。支持社会办医，发展健康产业。促进生育政策和相关经济社会政策配套衔接，加强人口发展战略研究。积极应对人口老龄化，构建养老、孝老、敬老政策体系和社会环境，推进医养结合，加快老龄事业和产业发展。</p>
<p>（六）打造共建共治共享的社会治理格局。加强社会治理制度建设，完善党委领导、政府负责、社会协同、公众参与、法治保障的社会治理体制，提高社会治理社会化、法治化、智能化、专业化水平。加强预防和化解社会矛盾机制建设，正确处理人民内部矛盾。树立安全发展理念，弘扬生命至上、安全第一的思想，健全公共安全体系，完善安全生产责任制，坚决遏制重特大安全事故，提升防灾减灾救灾能力。加快社会治安防控体系建设，依法打击和惩治黄赌毒黑拐骗等违法犯罪活动，保护人民人身权、财产权、人格权。加强社会心理服务体系建设，培育自尊自信、理性平和、积极向上的社会心态。加强社区治理体系建设，推动社会治理重心向基层下移，发挥社会组织作用，实现政府治理和社会调节、居民自治良性互动。</p>
<p>（七）有效维护国家安全。国家安全是安邦定国的重要基石，维护国家安全是全国各族人民根本利益所在。要完善国家安全战略和国家安全政策，坚决维护国家政治安全，统筹推进各项安全工作。健全国家安全体系，加强国家安全法治保障，提高防范和抵御安全风险能力。严密防范和坚决打击各种渗透颠覆破坏活动、暴力恐怖活动、民族分裂活动、宗教极端活动。加强国家安全教育，增强全党全国人民国家安全意识，推动全社会形成维护国家安全的强大合力。</p>
<p>同志们！<strong>党的一切工作必须以最广大人民根本利益为最高标准</strong>。我们要坚持把人民群众的小事当作自己的大事，从人民群众关心的事情做起，从让人民群众满意的事情做起，带领人民不断创造美好生活！</p>
<p>九、加快生态文明体制改革，建设美丽中国</p>
<p>人与自然是生命共同体，人类必须尊重自然、顺应自然、保护自然。人类只有遵循自然规律才能有效防止在开发利用自然上走弯路，人类对大自然的伤害最终会伤及人类自身，这是无法抗拒的规律。</p>
<p>（一）推进绿色发展。加快建立绿色生产和消费的法律制度和政策导向，建立健全绿色低碳循环发展的经济体系。构建市场导向的绿色技术创新体系，发展绿色金融，壮大节能环保产业、清洁生产产业、清洁能源产业。推进能源生产和消费革命，构建清洁低碳、安全高效的能源体系。推进资源全面节约和循环利用，实施国家节水行动，降低能耗、物耗，实现生产系统和生活系统循环链接。倡导简约适度、绿色低碳的生活方式，反对奢侈浪费和不合理消费，开展创建节约型机关、绿色家庭、绿色学校、绿色社区和绿色出行等行动。</p>
<p>（二）着力解决突出环境问题。坚持全民共治、源头防治，持续实施大气污染防治行动，打赢蓝天保卫战。加快水污染防治，实施流域环境和近岸海域综合治理。强化土壤污染管控和修复，加强农业面源污染防治，开展农村人居环境整治行动。加强固体废弃物和垃圾处置。提高污染排放标准，强化排污者责任，健全环保信用评价、信息强制性披露、严惩重罚等制度。构建政府为主导、企业为主体、社会组织和公众共同参与的环境治理体系。积极参与全球环境治理，落实减排承诺。</p>
<p>（三）加大生态系统保护力度。实施重要生态系统保护和修复重大工程，优化生态安全屏障体系，构建生态廊道和生物多样性保护网络，提升生态系统质量和稳定性。完成生态保护红线、永久基本农田、城镇开发边界三条控制线划定工作。开展国土绿化行动，推进荒漠化、石漠化、水土流失综合治理，强化湿地保护和恢复，加强地质灾害防治。完善天然林保护制度，扩大退耕还林还草。严格保护耕地，扩大轮作休耕试点，健全耕地草原森林河流湖泊休养生息制度，建立市场化、多元化生态补偿机制。</p>
<p>（四）改革生态环境监管体制。加强对生态文明建设的总体设计和组织领导，设立国有自然资源资产管理和自然生态监管机构，完善生态环境管理制度，统一行使全民所有自然资源资产所有者职责，统一行使所有国土空间用途管制和生态保护修复职责，统一行使监管城乡各类污染排放和行政执法职责。构建国土空间开发保护制度，完善主体功能区配套政策，建立以国家公园为主体的自然保护地体系。坚决制止和惩处破坏生态环境行为。</p>
<p>同志们！<strong>生态文明建设功在当代、利在千秋。</strong>我们要牢固树立社会主义生态文明观，推动形成人与自然和谐发展现代化建设新格局，为保护生态环境作出我们这代人的努力！</p>
<p>十、坚持走中国特色强军之路，全面推进国防和军队现代化</p>
<p>国防和军队建设正站在新的历史起点上。面对国家安全环境的深刻变化，面对强国强军的时代要求，必须全面贯彻新时代党的强军思想，贯彻新形势下军事战略方针，建设强大的现代化陆军、海军、空军、火箭军和战略支援部队，打造坚强高效的战区联合作战指挥机构，构建中国特色现代作战体系，担当起党和人民赋予的新时代使命任务。</p>
<p>适应世界新军事革命发展趋势和国家安全需求，提高建设质量和效益，<strong>确保到二〇二〇年基本实现机械化，信息化建设取得重大进展</strong>，战略能力有大的提升。同国家现代化进程相一致，全面推进军事理论现代化、军队组织形态现代化、军事人员现代化、武器装备现代化，<strong>力争到二〇三五年基本实现国防和军队现代化，到本世纪中叶把人民军队全面建成世界一流军队</strong>。</p>
<p>加强军队党的建设，开展“传承红色基因、担当强军重任”主题教育，推进军人荣誉体系建设，培养有灵魂、有本事、有血性、有品德的新时代革命军人，永葆人民军队性质、宗旨、本色。继续深化国防和军队改革，深化军官职业化制度、文职人员制度等重大政策制度改革，推进军事管理革命，完善和发展中国特色社会主义军事制度。树立科技是核心战斗力的思想，推进重大技术创新、自主创新，加强军事人才培养体系建设，建设创新型人民军队。全面从严治军，推动治军方式根本性转变，提高国防和军队建设法治化水平。</p>
<p>军队是要准备打仗的，一切工作都必须坚持战斗力标准，向能打仗、打胜仗聚焦。扎实做好各战略方向军事斗争准备，统筹推进传统安全领域和新型安全领域军事斗争准备，发展新型作战力量和保障力量，开展实战化军事训练，加强军事力量运用，加快军事智能化发展，提高基于网络信息体系的联合作战能力、全域作战能力，有效塑造态势、管控危机、遏制战争、打赢战争。</p>
<p>坚持富国和强军相统一，强化统一领导、顶层设计、改革创新和重大项目落实，深化国防科技工业改革，形成军民融合深度发展格局，构建一体化的国家战略体系和能力。完善国防动员体系，建设强大稳固的现代边海空防。组建退役军人管理保障机构，维护军人军属合法权益，让军人成为全社会尊崇的职业。深化武警部队改革，建设现代化武装警察部队。</p>
<p>同志们！我们的军队是人民军队，我们的国防是全民国防。我们要加强全民国防教育，巩固军政军民团结，为实现中国梦强军梦凝聚强大力量！</p>
<p>十一、坚持“一国两制”，推进祖国统一</p>
<p>香港、澳门回归祖国以来，“一国两制”实践取得举世公认的成功。事实证明，“一国两制”是解决历史遗留的香港、澳门问题的最佳方案，也是香港、澳门回归后保持长期繁荣稳定的最佳制度。</p>
<p>保持香港、澳门长期繁荣稳定，必须全面准确贯彻“一国两制”、“港人治港”、“澳人治澳”、高度自治的方针，严格依照宪法和基本法办事，完善与基本法实施相关的制度和机制。要支持特别行政区政府和行政长官依法施政、积极作为，团结带领香港、澳门各界人士齐心协力谋发展、促和谐，保障和改善民生，有序推进民主，维护社会稳定，履行维护国家主权、安全、发展利益的宪制责任。</p>
<p>香港、澳门发展同内地发展紧密相连。要支持香港、澳门融入国家发展大局，以粤港澳大湾区建设、粤港澳合作、泛珠三角区域合作等为重点，全面推进内地同香港、澳门互利合作，制定完善便利香港、澳门居民在内地发展的政策措施。</p>
<p>我们坚持爱国者为主体的“港人治港”、“澳人治澳”，发展壮大爱国爱港爱澳力量，增强香港、澳门同胞的国家意识和爱国精神，让香港、澳门同胞同祖国人民共担民族复兴的历史责任、共享祖国繁荣富强的伟大荣光。</p>
<p>解决台湾问题、实现祖国完全统一，是全体中华儿女共同愿望，是中华民族根本利益所在。必须继续坚持“和平统一、一国两制”方针，推动两岸关系和平发展，推进祖国和平统一进程。“一个中国”原则是两岸关系的政治基础，体现一个中国原则的九二共识明确鉴定了两岸关系的根本性质，是确保两岸关系和平发展的关键。承认九二共识的历史事实、认同两岸同属一个中国，两岸双方就能开展对话协商解决两岸同胞关心的问题。台湾任何政党和团体同大陆交往也不会存在障碍。(add)</p>
<p>两岸同胞是命运与共的骨肉兄弟，是血浓于水的一家人。我们秉持“两岸一家亲”理念，尊重台湾现有的社会制度和台湾同胞生活方式，愿意率先同台湾同胞分享大陆发展的机遇。我们将扩大两岸经济文化交流合作，实现互利互惠，逐步为台湾同胞在大陆学习、创业、就业、生活提供与大陆同胞同等的待遇，增进台湾同胞福祉。我们将推动两岸同胞共同弘扬中华文化，促进心灵契合。</p>
<p><strong>我们坚决维护国家主权和领土完整，绝不容忍国家分裂的历史悲剧重演（鼓掌）。一切分裂祖国的活动都必将遭到全体中国人坚决反对（鼓掌）。我们有坚定的意志、充分的信心、足够的能力挫败任何形式的“台独”分裂图谋（鼓掌）。我们绝不允许任何人、任何组织、任何政党、在任何时候、以任何形式、把任何一块中国领土从中国分裂出去！（鼓掌）</strong></p>
<p>同志们！实现中华民族伟大复兴，是全体中国人共同的梦想。我们坚信，只要包括港澳台同胞在内的全体中华儿女顺应历史大势、共担民族大义，把民族命运牢牢掌握在自己手中，就一定能够共创中华民族伟大复兴的美好未来！</p>
<p>十二、坚持和平发展道路，推动构建人类命运共同体</p>
<p>中国共产党是为中国人民谋幸福的政党，也是为人类进步事业而奋斗的政党。中国共产党始终把为人类作出新的更大的贡献作为自己的使命。</p>
<p>中国将高举和平、发展、合作、共赢的旗帜，恪守维护世界和平、促进共同发展的外交政策宗旨，坚定不移在和平共处五项原则基础上发展同各国的友好合作，推动建设相互尊重、公平正义、合作共赢的新型国际关系。</p>
<p>世界正处于大发展大变革大调整时期，和平与发展仍然是时代主题。世界多极化、经济全球化、社会信息化、文化多样化深入发展，全球治理体系和国际秩序变革加速推进，各国相互联系和依存日益加深，国际力量对比更趋平衡，和平发展大势不可逆转。同时，世界面临的不稳定性不确定性突出，世界经济增长动能不足，贫富分化日益严重，地区热点问题此起彼伏，恐怖主义、网络安全、重大传染性疾病、气候变化等非传统安全威胁持续蔓延，人类面临许多共同挑战。</p>
<p>我们生活的世界充满希望，也充满挑战。我们不能因现实复杂而放弃梦想，不能因理想遥远而放弃追求。没有哪个国家能够独自应对人类面临的各种挑战，也没有哪个国家能够退回到自我封闭的孤岛。</p>
<p>我们呼吁，各国人民同心协力，构建人类命运共同体，建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往新路。要坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义。要同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展。要尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越。要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园。</p>
<p>中国坚定奉行独立自主的和平外交政策，尊重各国人民自主选择发展道路的权利，维护国际公平正义，反对把自己的意志强加于人，反对干涉别国内政，反对以强凌弱。中国决不会以牺牲别国利益为代价来发展自己，也决不放弃自己的正当权益，任何人不要幻想让中国吞下损害自身利益的苦果。中国奉行防御性的国防政策。中国发展不对任何国家构成威胁。<strong>中国无论发展到什么程度，永远不称霸，永远不搞扩张。</strong></p>
<p>中国积极发展全球伙伴关系，扩大同各国的利益交汇点，推进大国协调和合作，构建总体稳定、均衡发展的大国关系框架，按照亲诚惠容理念和与邻为善、以邻为伴周边外交方针深化同周边国家关系，秉持正确义利观和真实亲诚理念加强同发展中国家团结合作。加强同各国政党和政治组织的交流合作，推进人大、政协、军队、地方、人民团体等的对外交往。</p>
<p>中国坚持对外开放的基本国策，坚持打开国门搞建设，积极促进“一带一路”国际合作，努力实现政策沟通、设施联通、贸易畅通、资金融通、民心相通，打造国际合作新平台，增添共同发展新动力。加大对发展中国家特别是最不发达国家援助力度，促进缩小南北发展差距。中国支持多边贸易体制，促进自由贸易区建设，推动建设开放型世界经济。</p>
<p>中国秉持共商共建共享的全球治理观，倡导国际关系民主化，坚持国家不分大小、强弱、贫富一律平等，支持联合国发挥积极作用，支持扩大发展中国家在国际事务中的代表性和发言权。中国将继续发挥负责任大国作用，积极参与全球治理体系改革和建设，不断贡献中国智慧和力量。</p>
<p>同志们！世界命运握在各国人民手中，人类前途系于各国人民的抉择。中国人民愿同各国人民一道，推动人类命运共同体建设，共同创造人类的美好未来！</p>
<p>十三、坚定不移全面从严治党，不断提高党的执政能力和领导水平</p>
<p>中国特色社会主义进入新时代，我们党一定要有新气象新作为。打铁必须自身硬。党要团结带领人民进行伟大斗争、推进伟大事业、实现伟大梦想，必须毫不动摇坚持和完善党的领导，毫不动摇把党建设得更加坚强有力。</p>
<p>全面从严治党永远在路上。一个政党，一个政权，其前途命运取决于人心向背。人民群众反对什么、痛恨什么，我们就要坚决防范和纠正什么。全党要清醒认识到，我们党面临的执政环境是复杂的，影响党的先进性、弱化党的纯洁性的因素也是复杂的，党内存在的思想不纯、组织不纯、作风不纯等突出问题尚未得到根本解决。要深刻认识党面临的执政考验、改革开放考验、市场经济考验、外部环境考验的长期性和复杂性，深刻认识党面临的精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险的尖锐性和严峻性，坚持问题导向，保持战略定力，推动全面从严治党向纵深发展。</p>
<p>新时代党的建设总要求是：坚持和加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提高党的建设质量，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。</p>
<p>  (一)把党的政治建设摆在首位。旗帜鲜明讲政治是我们党作为马克思主义政党的根本要求。党的政治建设是党的根本性建设，决定党的建设方向和效果。保证全党服从中央，坚持党中央权威和集中统一领导，是党的政治建设的首要任务。全党要坚定执行党的政治路线，严格遵守政治纪律和政治规矩，在政治立场、政治方向、政治原则、政治道路上同党中央保持高度一致。要尊崇党章，严格执行新形势下党内政治生活若干准则，增强党内政治生活的政治性、时代性、原则性、战斗性，自觉抵制商品交换原则对党内生活的侵蚀，营造风清气正的良好政治生态。完善和落实民主集中制的各项制度，坚持民主基础上的集中和集中指导下的民主相结合，既充分发扬民主，又善于集中统一。弘扬忠诚老实、公道正派、实事求是、清正廉洁等价值观，坚决防止和反对个人主义、分散主义、自由主义、本位主义、好人主义，坚决防止和反对宗派主义、圈子文化、码头文化，坚决反对搞两面派、做两面人。全党同志特别是高级干部要加强党性锻炼，不断提高政治觉悟和政治能力，把对党忠诚、为党分忧、为党尽职、为民造福作为根本政治担当，永葆共产党人政治本色。</p>
<p>  (二)用新时代中国特色社会主义思想武装全党。思想建设是党的基础性建设。革命理想高于天。共产主义远大理想和中国特色社会主义共同理想，是中国共产党人的精神支柱和政治灵魂，也是保持党的团结统一的思想基础。要把坚定理想信念作为党的思想建设的首要任务，教育引导全党牢记党的宗旨，挺起共产党人的精神脊梁，解决好世界观、人生观、价值观这个“总开关”问题，自觉做共产主义远大理想和中国特色社会主义共同理想的坚定信仰者和忠实实践者。弘扬马克思主义学风，推进“两学一做”学习教育常态化制度化，以县处级以上领导干部为重点，在全党开展“不忘初心、牢记使命”主题教育，用党的创新理论武装头脑，推动全党更加自觉地为实现新时代党的历史使命不懈奋斗。</p>
<p>  (三)建设高素质专业化干部队伍。党的干部是党和国家事业的中坚力量。要坚持党管干部原则，坚持德才兼备、以德为先，坚持五湖四海、任人唯贤，坚持事业为上、公道正派，把好干部标准落到实处。坚持正确选人用人导向，匡正选人用人风气，突出政治标准，提拔重用牢固树立“四个意识”和“四个自信”、坚决维护党中央权威、全面贯彻执行党的理论和路线方针政策、忠诚干净担当的干部，选优配强各级领导班子。注重培养专业能力、专业精神，增强干部队伍适应新时代中国特色社会主义发展要求的能力。大力发现储备年轻干部，注重在基层一线和困难艰苦的地方培养锻炼年轻干部，源源不断选拔使用经过实践考验的优秀年轻干部。统筹做好培养选拔女干部、少数民族干部和党外干部工作。认真做好离退体干部工作。坚持严管和厚爱结合、激励和约束并重，完善干部考核评价机制，建立激励机制和容错纠错机制，旗帜鲜明为那些敢于担当、踏实做事、不谋私利的干部撑腰鼓劲。各级党组织要关心爱护基层干部，主动为他们排忧解难。</p>
<p>人才是实现民族振兴、赢得国际竞争主动的战略资源。要坚持党管人才原则，聚天下英才而用之，加快建设人才强国。实行更加积极、更加开放、更加有效的人才政策，以识才的慧眼、爱才的诚意、用才的胆识、容才的雅量、聚才的良方，把党内和党外、国内和国外各方面优秀人才集聚到党和人民的伟大奋斗中来，鼓励引导人才向边远贫困地区、边疆民族地区、革命老区和基层一线流动，努力形成人人渴望成才、人人努力成才、人人皆可成才、人人尽展其才的良好局面，让各类人才的创造活力竞相进发、聪明才智充分涌流。</p>
<p>  (四)加强基层组织建设。党的基层组织是确保党的路线方针政策和决策部署贯彻落实的基础。要以提升组织力为重点，突出政治功能，把企业、农村、机关、学校、科研院所、街道社区、社会组织等基层党组织建设成为宣传党的主张、贯彻党的决定、领导基层治理、团结动员群众、推动改革发展的坚强战斗堡垒。党支部要担负好直接教育党员、管理党员、监督党员和组织群众、宣传群众、凝聚群众、服务群众的职责，引导广大党员发挥先锋模范作用。坚持“三会一课”制度，推进党的基层组织设置和活动方式创新，加强基层党组织带头人队伍建设，扩大基层党组织覆盖面，着力解决一些基层党组织弱化、虚化、边缘化问题。扩大党内基层民主，推进党务公开，畅通党员参与党内事务、监督党的组织和干部、向上级党组织提出意见和建议的渠道。注重从产业工人、青年农民、高知识群体中和在非公有制经济组织、社会组织中发展党员。加强党内激励关怀帮扶。增强党员教育管理针对性和有效性，稳妥有序开展不合格党员组织处置工作。</p>
<p>  (五)持之以恒正风肃纪。我们党来自人民、植根人民、服务人民，一旦脱离群众，就会失去生命力。加强作风建设，必须紧紧围绕保持党同人民群众的血肉联系，增强群众观念和群众感情，不断厚植党执政的群众基础。凡是群众反映强烈的问题都要严肃认真对待，凡是损害群众利益的行为都要坚决纠正。坚持以上率下，巩固拓展落实中央八项规定精神成果，继续整治“四风”问题，坚决反对特权思想和特权现象。重点强化政治纪律和组织纪律，带动廉洁纪律、群众纪律、工作纪律、生活纪律严起来。坚持开展批评和自我批评，坚持惩前毖后、治病救人，运用监督执纪“四种形态”，抓早抓小、防微杜渐。赋予有干部管理权限的党组相应纪律处分权限，强化监督执纪问责。加强纪律教育，强化纪律执行，让党员、干部知敬畏、存戒惧、守底线，习惯在受监督和约束的环境中工作生活。</p>
<p>  (六)<strong>夺取反腐败斗争压倒性胜利</strong>。人民群众最痛恨腐败现象，腐败是我们党面临的最大威胁。只有以反腐败永远在路上的坚韧和执着，深化标本兼治，保证干部清正、政府清廉、政治清明，才能跳出历史周期率，确保党和国家长治久安。当前，反腐败斗争形势依然严峻复杂，巩固压倒性态势、夺取压倒性胜利的决心必须坚如磐石。要坚持无禁区、全覆盖、零容忍，坚持重遏制、强高压、长震慑，坚持受贿行贿一起查，坚决防止党内形成利益集团。在市县党委建立巡察制度，加大整治群众身边腐败问题力度。不管腐败分子逃到哪里，都要缉拿归案、绳之以法。推进反腐败国家立法，建设覆盖纪检监察系统的检举举报平台。强化不敢腐的震慑，扎牢不能腐的笼子，增强不想腐的自觉，通过不懈努力换来海晏河清、朗朗乾坤。</p>
<p>  (七)健全党和国家监督体系。增强党自我净化能力，根本靠强化党的自我监督和群众监督。要加强对权力运行的制约和监督，让人民监督权力，让权力在阳光下运行，把权力关进制度的笼子。强化自上而下的组织监督，改进自下而上的民主监督，发挥同级相互监督作用，加强对党员领导干部的日常管理监督。深化政治巡视，坚持发现问题、形成震慑不动摇，建立巡视巡察上下联动的监督网。深化国家监察体制改革，将试点工作在全国推开，组建国家、省、市、县监察委员会，同党的纪律检查机关合署办公，实现对所有行使公权力的公职人员监察全覆盖。制定国家监察法，依法赋予监察委员会职责权限和调查手段，用留置取代“两规”措施。改革审计管理体制，完善统计体制。构建党统一指挥、全面覆盖、权威高效的监督体系，把党内监督同国家机关监督、民主监督、司法监督、群众监督、舆论监督贯通起来，增强监督合力。</p>
<p>  (八)全面增强执政本领。领导十三亿多人的社会主义大国，我们党既要政治过硬，也要本领高强。要增强学习本领，在全党营造善于学习、勇于实践的浓厚氛围，建设马克思主义学习型政党，推动建设学习大国。增强政治领导本领，坚持战略思维、创新思维、辩证思维、法治思维、底线思维，科学制定和坚决执行党的路线方针政策，把党总揽全局、协调各方落到实处。增强改革创新本领，保持锐意进取的精神风貌，善于结合实际创造性推动工作，善于运用互联网技术和信息化手段开展工作。增强科学发展本领，善于贯彻新发展理念，不断开创发展新局面。增强依法执政本领，加快形成覆盖党的领导和党的建设各方面的党内法规制度体系，加强和改善对国家政权机关的领导。增强群众工作本领，创新群众工作体制机制和方式方法，推动工会、共青团、妇联等群团组织增强政治性、先进性、群众性，发挥联系群众的桥梁纽带作用，组织动员广大人民群众坚定不移跟党走。增强狠抓落实本领，坚持说实话、谋实事、出实招、求实效，把雷厉风行和久久为功有机结合起来，勇于攻坚克难，以钉钉子精神做实做细做好各项工作。增强驾驭风险本领，健全各方面风险防控机制，善于处理各种复杂矛盾，勇于战胜前进道路上的各种艰难险阻，牢牢把握工作主动权。</p>
<p>同志们！伟大的事业必须有坚强的党来领导。只要我们党把自身建设好、建设强，确保党始终同人民想在一起、干在一起，就一定能够引领承载看中国人民伟大梦想的航船破浪前进，胜利驶向光辉的彼岸！</p>
<p>同志们！中华民族是历经磨难、不屈不挠的伟大民族，中国人民是勤劳勇敢、自强不息的伟大人民，中国共产党是敢于斗争、敢于胜利的伟大政党。历史车轮滚滚向前，时代潮流浩浩荡荡。历史只会眷顾坚定者、奋进者、搏击者，而不会等待犹豫者、懈怠者、畏难者。全党一定要保持艰苦奋斗、戒骄戒躁的作风，以时不我待、只争朝夕的精神，奋力走好新时代的长征路。全党一定要自觉维护党的团结统一，保持党同人民群众的血肉联系，巩固全国各族人民大团结，加强海内外中华儿女大团结，团结一切可以团结的力量，齐心协力走向中华民族伟大复兴的光明前景。</p>
<p>青年兴则国家兴，青年强则国家强。青年一代有理想、有本领、有担当，国家就有前途，民族就有希望。中国梦是历史的、现实的，也是未来的；是我们这一代的，更是青年一代的。中华民族伟大复兴的中国梦终将在一代代青年的接力奋斗中变为现实。全党要关心和爱护青年，为他们实现人生出彩搭建舞台。广大青年要坚定理想信念，志存高远，脚踏实地，勇做时代的弄潮儿，在实现中国梦的生动实践中放飞青春梦想，在为人民利益的不懈奋斗中书写人生华章！</p>
<p>大道之行，天下为公。站立在九百六十多万平方公里的广裹土地上，吸吮着五千多年中华民族漫长奋斗积累的文化养分，拥有十三亿多中国人民聚合的磅礴之力，我们走中国特色社会主义道路，具有无比广阔的时代舞台，具有无比深厚的历史底蕴，具有无比强大的前进定力。全党全国各族人民要紧密团结在党中央周围，高举中国特色社会主义伟大旗帜，锐意进取，埋头苦干，为实现推进现代化建设、完成祖国统一、维护世界和平与促进共同发展三大历史任务，为决胜全面建成小康社会、夺取新时代中国特色社会主义伟大胜利、实现中华民族伟大复兴的中国梦、实现人民对美好生活的向往继续奋斗！</p>
<p>参考自：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/e6quFK5Ct4hDHRZ6Hv8j7g" target="_blank" rel="external">https://mp.weixin.qq.com/s/e6quFK5Ct4hDHRZ6Hv8j7g</a> 根据开幕式现场视频做出了增加。并将最后的图片识别为文字。</li>
<li><a href="http://tv.cctv.com/live/cctv13/" target="_blank" rel="external">http://tv.cctv.com/live/cctv13/</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 十九大 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[梯度下降及其优化算法]]></title>
      <url>/2017/10/17/DL_gradient_descent/</url>
      <content type="html"><![CDATA[<p>“请简述梯度下降算法以及如何优化梯度下降算法？”</p>
<p>上述是机器学习中常见面试题之一，本文将稍作阐述，仅供参考。<br><a id="more"></a></p>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>梯度下降是一个最优化算法，通俗的来讲也就是沿着梯度下降的方向来求出一个函数的极小值。</p>
<p>那么我们在高等数学中学过，对于一些我们了解的函数方程，我们可以对其求一阶导和二阶导，比如说二次函数。可是我们在处理问题的时候遇到的并不都是我们熟悉的函数，并且既然是机器学习就应该让机器自己去学习如何对其进行求解，显然我们需要换一个思路。因此我们采用梯度下降，不断迭代，沿着梯度下降的方向来移动，求出极小值。</p>
<h3 id="批量梯度下降（Batch-gradient-descent）"><a href="#批量梯度下降（Batch-gradient-descent）" class="headerlink" title="批量梯度下降（Batch gradient descent）"></a>批量梯度下降（Batch gradient descent）</h3><p>现在我们就要求出<code>J(θ)</code>取到极小值时的θT向量。之前已经说过了，沿着函数梯度的方向下降就能最快的找到极小值。</p>
<p>$$\theta=\theta-\eta \nabla_\theta{J(\theta)}$$</p>
<ul>
<li><p>计算<code>J(θ)</code>关于θT的<strong>偏导数</strong>,也就得到了向量中每一个θ的梯度。</p>
</li>
<li><p>沿着梯度的方向更新参数θ的值</p>
</li>
<li><p>迭代直到收敛。</p>
</li>
</ul>
<p>批量梯度下降算法使用整个训练集计算目标函数的梯度并更新参数。代码如下：</p>
<pre><code>for i in range(nb_epochs):
    params_grad = evaluate_gradient(loss_function, data, params)
    params = params - learning_rate * params_grad
</code></pre><p>可以看到，批量梯度下降是用了训练集中的所有样本。因此在数据量很大的时候，每次迭代都要遍历训练集一遍，<strong>开销</strong>会很大，所以在数据量大的时候，可以采用随机梯度下降法。</p>
<h3 id="随机梯度下降（Stochastic-gradient-descent）"><a href="#随机梯度下降（Stochastic-gradient-descent）" class="headerlink" title="随机梯度下降（Stochastic gradient descent）"></a>随机梯度下降（Stochastic gradient descent）</h3><p>和批量梯度有所不同的地方在于，每次迭代只选取一个样本的数据，一旦到达最大的迭代次数或是满足预期的精度，就停止。</p>
<p>可以得出随机梯度下降法的θ更新表达式。</p>
<p>$$\theta=\theta-\eta\nabla_\theta{J(\theta;x^{(i)},y^{(i)})}$$</p>
<p>因为每次只计算<strong>一个样本</strong>，所以<code>SGD</code>计算非常快并且适合线上更新模型。但是，频繁地更新参数也使得<strong>目标函数抖动</strong>非常厉害。</p>
<p><code>SGD</code>频繁地参数更新可以使算法跳出局部最优点，更可能寻找到接近全局最优的解。<br><code>SGD</code>代码如下：</p>
<pre><code>for i in range(nb_epochs):
  np.random.shuffle(data)
  for example in data:
    params_grad = evaluate_gradient(loss_function, example, params)
    patams = params - learning_rate * params_grad
</code></pre><p>注意，上面的代码在每个epoch都对训练数据进行了打乱操作，这样可以保证不同epoch学习到的特征和训练样本的出现顺序没有关系。</p>
<h2 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h2><p>如果仅从测试误差出发，标准梯度下降的效果会比随机梯度下降要好。但是标准梯度下降的训练时间会比随机梯度下降要长。</p>
<p>像线性回归这种简单的模型，训练时间的优先级不高，所以用标准梯度下降会比随机梯度下降要好。像神经网络这种复杂的模型，训练时间的优先级比较高，所以用随机梯度下降比较好。</p>
<p>如果模型的损失函数是<strong>凸函数</strong>，那么使用标准梯度下降一定能达到全局最优。如果<strong>模型比较复杂</strong>，容易进入局部最优，那么使用随机梯度下降会发生震荡，容易从局部最优中跳出，进入全局最优。</p>
<p>另外，神经网络模型使用标准梯度下降最重要的原因是神经网络容易过拟合，而不是训练时间。</p>
<h2 id="小批量梯度下降-mini-batch-gradient-descent"><a href="#小批量梯度下降-mini-batch-gradient-descent" class="headerlink" title="小批量梯度下降(mini-batch gradient descent)"></a>小批量梯度下降(mini-batch gradient descent)</h2><p>小批量梯度下降结合了批量梯度下降和随机梯度下降的优点，它一次以小批量的训练数据计算目标函数的权重并更新参数。公式如下：</p>
<p>$$\theta=\theta-\eta\nabla_\theta{J(\theta;x^{(i:i+n)};y^{(i:i+n)})}$$</p>
<p>其中，n为每批训练集的数量，一般设为50到256。 </p>
<pre><code>for i in range(nb_epochs):
  np.random.shuffle(data)
  for batch in get_batches(data, batch_size=50):
    params_grad = evaluate_gradient(loss_function, batch, params)
    params = params - learning_rate * params_grad
</code></pre><p>这个算法有下面几个方面的优点： </p>
<ol>
<li><p>相比较SGD增加了一次更新使用的训练数据量，使得目标函数收敛得更加平稳； </p>
</li>
<li><p>可以使用矩阵操作对每批数据进行计算，大大提升了算法的效率。</p>
</li>
</ol>
<h2 id="梯度下降的优缺点"><a href="#梯度下降的优缺点" class="headerlink" title="梯度下降的优缺点"></a>梯度下降的优缺点</h2><p><code>mini-batch gradient descent</code>虽然相较于批量梯度下降和随机梯度下降方法效果有所改善但是任然存在许多挑战： </p>
<ol>
<li>难以选择合适的学习速率：如果学习速率选择过小会造成网络收敛太慢，但是设得太大可能使得损失函数在最小点周围不断摇摆而永远达不到最小点； </li>
<li>可以在训练开始时设置一个较大地学习率然后每训练若干个周期后按比例降低学习率，虽然这个方法有一些作用，但是由于降低学习率的周期是人为事先设定的，所以它不能很好地适应数据内在的规律； </li>
<li>另一方面，我们对特征向量中的所有的特征都采用了相同的学习率，如果训练数据十分稀疏并且不同特征的变化频率差别很大，这时候对变化频率慢得特征采用大的学习率而对变化频率快的特征采用小的学习率是更好的选择。 </li>
<li>这些梯度下降方法难以逃脱”鞍点”, 如下图所示，鞍点既不是最大点也不是最小点，在这个点附近，所有方向上的梯度都接近于0，这些梯度下降算法很难逃离它。</li>
</ol>
<p><img src="/2017/10/17/DL_gradient_descent/Saddle.png" alt=""></p>
<h2 id="梯度下降算法的改进"><a href="#梯度下降算法的改进" class="headerlink" title="梯度下降算法的改进"></a>梯度下降算法的改进</h2><h3 id="冲量-Momentum"><a href="#冲量-Momentum" class="headerlink" title="冲量(Momentum)"></a>冲量(Momentum)</h3><p>实际中，我们遇到的目标函数往往在不同的维度上梯度相差很大，比如在下面的函数等高线图中可以看出函数在纵向上要比横向陡峭得多。</p>
<p><img src="/2017/10/17/DL_gradient_descent/SGD_momen.jpg" alt=""></p>
<p>然而<code>SGD</code>等基本梯度下降算法并不知道这些，因为y方向梯度大x方向梯度小所以它们会在y方向上不断摇摆而沿x方向缓慢移动，但是我们知道在y方向的震荡是无用的只有x方向的才在不断接近最优点。</p>
<p>冲量方法在<code>SGD</code>的基础上，加上了上一步的梯度：</p>
<p><img src="/2017/10/17/DL_gradient_descent/equa_1.png" alt=""></p>
<p>其中γ通常设为0.9。</p>
<p>由于目标函数在y方向上摇摆，所以前后两次计算的梯度在y方向上相反，所以相加后相互抵消，而x方向上梯度方向不变，所以x方向的梯度是累加的，其效果就是损失函数在y方向上的震荡减小了，而更加迅速地从x方向接近最优点。</p>
<p>也可以把这个过程和在斜坡放一个球让其滚下类比：当从斜坡顶端释放一个小球时，由于重力的作用小球滚下的速度会越来越快；与此类似，冲量的作用会使相同方向的梯度不断累加，不同方向的梯度相互抵消，其效果就是逼近最优点的速度不断加快。</p>
<h3 id="Nesterov-accelerated-gradient"><a href="#Nesterov-accelerated-gradient" class="headerlink" title="Nesterov accelerated gradient"></a>Nesterov accelerated gradient</h3><p>想象小球从山坡上滑落，它的速度沿着山坡不断加快，然而这并不是令我们满意的结果，当小球接近山谷(最优点)时，它已经有了很大的速度，很可能会再次冲向山谷的另一边，而错过了最优点。我们需要一颗更加“聪明”的小球，它能够感知坡度的变化，从而在它再次冲上山坡之前减速而避免错过山谷。</p>
<p>Nesterov accelerated gradient(NAG)就是一种让小球变“聪明”的方法。NAG不但增加了动量项，并且计算参数的梯度时，在损失函数中减去了梯度项将其作为下一次参数所在位置的预估：</p>
<p><img src="/2017/10/17/DL_gradient_descent/equ_NAG.png" alt=""></p>
<p>同样，上式中的<code>γ</code> 一般设为0.9。 </p>
<p>如下图所示，蓝色的是动量方法的更新路径，首先计算一次梯度更新一小步，然后在下一次累加上一次计算的梯度从而更新一大步。而NAG算法每一步更新过程由两个步骤组成：第一步($\gamma v_{t−1}$, 图中棕色)使用之前计算的梯度移动一大步，第二步在移动后的位置计算的梯度方向移动一小步(图中红色线)进行修正，经过这样的两步合成了最终的绿线部分。</p>
<p><img src="/2017/10/17/DL_gradient_descent/NAG.png" alt=""></p>
<p>分析上面的原理可知，当“小球”将要冲上山坡的另一面时，红色线表示的预测梯度方向发生改变，从而将棕色向量往回拉达到了“减速”的效果。</p>
<p>通过NAG方法，我们使参数更新速率能够自适应“坡度”的变化，另一方面，我们希望每个单独的参数能够自适应各自的变化频率，比如，稀疏特征采用高的更新速率，其他特征采用相对较低的更新速率。下面介绍几种常用的方法。</p>
<p>详细介绍可以参见<code>Ilya Sutskever</code>的<code>PhD</code>论文<br><code>Sutskever, I. (2013). Training Recurrent neural Networks. PhD Thesis.</code></p>
<p><img src="/2017/10/17/DL_gradient_descent/opt1_mom.png" alt="梯度优化之Momentum"></p>
<p><img src="/2017/10/17/DL_gradient_descent/opt2_NAG.png" alt="梯度优化之NAG"></p>
<h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><h3 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h3><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p><code>Adam</code>的全称是<code>Adaptive Moment Estimation</code>, 它也是一种自适应学习率方法，与Adadelta和RMSprop类似，它将每个参数的历史梯度平方均值存于$v_t$中，不同的是，<code>Adam</code>还使用了类似冲量的衰减项$m_t$:</p>
<p><img src="/2017/10/17/DL_gradient_descent/adam.png" alt=""></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>图a中，所有方法都从相同位置出发，经历不同的路径到达了最小点，其中<code>Adagrad</code>、<code>Adadelta</code>和<code>RMSprop</code>一开始就朝向正确的方向并且迅速收敛，而冲量、<code>NAG</code>则会冲向错误的方向，但是由于<code>NAG</code>会向前多“看”一步所以能很快找到正确的方向。</p>
<p><img src="/2017/10/17/DL_gradient_descent/gif_1.gif" alt=""></p>
<p>图b显示了这些方法逃离鞍点的能力，鞍点有部分方向有正梯度另一些方向有负梯度，<code>SGD</code>方法逃离能力最差，冲量和<code>NAG</code>方法也不尽如人意，而<code>Adagrad</code>、<code>RMSprop</code>、<code>Adadelta</code>很快就能从鞍点逃离出来。</p>
<p><img src="/2017/10/17/DL_gradient_descent/gif_2.gif" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/Sinte-Beuve/p/6164689.html" target="_blank" rel="external">http://www.cnblogs.com/Sinte-Beuve/p/6164689.html</a></li>
<li><a href="http://blog.csdn.net/ortyijing/article/details/54984058" target="_blank" rel="external">http://blog.csdn.net/ortyijing/article/details/54984058</a></li>
<li><a href="http://blog.csdn.net/bupt_wx/article/details/52761751" target="_blank" rel="external">http://blog.csdn.net/bupt_wx/article/details/52761751</a></li>
<li><a href="http://blog.csdn.net/heyongluoyao8/article/details/52478715" target="_blank" rel="external">http://blog.csdn.net/heyongluoyao8/article/details/52478715</a></li>
<li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="external">http://cs231n.github.io/neural-networks-3/</a></li>
<li><a href="http://www.360doc.com/content/16/1010/08/36492363_597225745.shtml" target="_blank" rel="external">http://www.360doc.com/content/16/1010/08/36492363_597225745.shtml</a><br>其中，第四个文章写得不错。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> gradient descent </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BAT批处理中的字符串处理(字符串截取等)]]></title>
      <url>/2017/10/10/batch_string_process/</url>
      <content type="html"><![CDATA[<p>什么是批处理？<br>在windows下，以<code>cmd</code>或者<code>bat</code>结尾的文件就是批处理文件；linux下，也有以<code>sh</code>结尾的shell脚本文件。</p>
<p>本文主要介绍了批处理在字符串处理中的一些方法：</p>
<ul>
<li>字符串截取</li>
<li>字符串替换</li>
<li>字符串合并</li>
<li>字符串扩充</li>
</ul>
<a id="more"></a>
<h1 id="1、截取字符串"><a href="#1、截取字符串" class="headerlink" title="1、截取字符串"></a>1、截取字符串</h1><p>截取字符串可以说是字符串处理功能中最常用的一个子功能了，能够实现截取字符串中的特定位置的一个或多个字符。举例说明其基本功能：</p>
<pre><code>@echo off
set ifo=abcdefghijklmnopqrstuvwxyz0123456789
echo 原字符串（第二行为各字符的序号）：
echo %ifo%
echo 123456789012345678901234567890123456
echo 截取前5个字符：
echo %ifo:~0,5%
echo 截取最后5个字符：
echo %ifo:~-5%
echo 截取第一个到倒数第6个字符：
echo %ifo:~0,-5%
echo 从第4个字符开始，截取5个字符：
echo %ifo:~3,5%
echo 从倒数第14个字符开始，截取5个字符：
echo %ifo:~-14,5%
pause
</code></pre><p>当然，上面的例子只是将字符串处理的基本功能展示出来了，还看不出字符串处理具体有什么用处。下面这个例子是对时间进行处理。</p>
<pre><code>@echo off
echo 当前时间是：%time% 即 %time:~0,2%点%time:~3,2%分%time:~6,2%秒%time:~9,2%厘秒
pause
</code></pre><h1 id="2、替换字符串"><a href="#2、替换字符串" class="headerlink" title="2、替换字符串"></a>2、替换字符串</h1><p>替换字符串，即将某一字符串中的特定字符或字符串替换为给定的字符串。举例说明其功能：</p>
<pre><code>@echo off
set aa=伟大的中国！我为你自豪！
echo 替换前：%aa%
echo 替换后：%aa:中国=中华人民共和国%
echo aa = %aa%
set &quot;aa=%aa:中国=中华人民共和国%&quot;
echo aa = %aa%
pause
</code></pre><p>对于上面的例子有一点说明，对比两个echo aa = %aa%可以发现，如果要修改变量aa的内容的话，就需要将修改结果“%aa:中国=中华人民共和国%”赋值给变量aa。上面的字符串截取也有着同样的特点。</p>
<h1 id="3、字符串合并"><a href="#3、字符串合并" class="headerlink" title="3、字符串合并"></a>3、字符串合并</h1><p>其实，合并字符串就是将两个字符串放在一起就可以了。举例说明：</p>
<pre><code>@echo off
set aa=伟大的中国！
set bb=我为你自豪！
echo %aa%%bb%
echo aa=%aa%
echo bb=%bb%
set &quot;aa=%aa%%bb%&quot;
echo aa=%aa%
pause
</code></pre><p>同样，如果要改变变量aa的内容的话，就需要将合并结果“%aa%%bb%”赋值给变量aa。</p>
<h1 id="4、扩充字符串"><a href="#4、扩充字符串" class="headerlink" title="4、扩充字符串"></a>4、扩充字符串</h1><p>　“扩充”这个词汇来自于微软自己的翻译，意思就是对表示文件路径的字符串进行特殊的处理，具体功能罗列如下：</p>
<pre><code>=========================================
~I - 删除任何引号(&quot;)，扩充 %I
%~fI - 将 %I 扩充到一个完全合格的路径名
%~dI - 仅将 %I 扩充到一个驱动器号
%~pI - 仅将 %I 扩充到一个路径
%~nI - 仅将 %I 扩充到一个文件名
%~xI - 仅将 %I 扩充到一个文件扩展名
%~sI - 扩充的路径只含有短名
%~aI - 将 %I 扩充到文件的文件属性
%~tI - 将 %I 扩充到文件的日期/时间
%~zI - 将 %I 扩充到文件的大小
%~$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串可以组合修饰符来得到多重结果:
%~dpI - 仅将 %I 扩充到一个驱动器号和路径
%~nxI - 仅将 %I 扩充到一个文件名和扩展名
%~fsI - 仅将 %I 扩充到一个带有短名的完整路径名
%~dp$PATH:i - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个驱动器号和路径。
%~ftzaI - 将 %I 扩充到类似输出线路的 DIR
=========================================
</code></pre><p>以上内容引用于for /?帮助信息。其中的I代表变量I，不过需要说明的是，不是所有的变量都能够进行扩充的，有两个条件：1、该字符串代表一个文件路径；2、变量要用%x来表示，x可取a-z A-Z 0-9共62个字符中的任意一个。举例说明：</p>
<pre><code>@echo off
echo 正在运行的这个批处理：
echo 完全路径：%0
echo 去掉引号：%~0
echo 所在分区：%~d0
echo 所处路径：%~p0
echo 文件名：%~n0
echo 扩展名：%~x0
echo 文件属性：%~a0
echo 修改时间：%~t0
echo 文件大小：%~z0
pause
</code></pre><p>其中的%0是批处理里面的参数，代表当前运行的批处理的完全路径。类似的还有%1-%9，分别代表传递来的第1-9个参数。例子如下：</p>
<pre><code>@echo off
set aa=C:\Windows\PPP\a.btx
call :deal aaa %aa% &quot;c c&quot; ddd eee
pause&gt;nul
exit
:deal
echo %%0 = %0
echo %%1 = %1
echo %%2 = %2
echo %%3 = %3
echo %%4 = %4
echo %%5 = %5
</code></pre><p>其中，变量aa在之前是不可以扩充的，通过call命令并将aa作为参数传递给子函数:deal，将aa变量转换成了变量%1，即符合%x格式，从而可以进行字符串扩充。</p>
<p>至于%x中x取a-z A-Z的形式，可以复习一下for语句，for语句里面的变量就是用%x来表示的，因而可以直接进行扩充。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="C语中的strcpy函数"><a href="#C语中的strcpy函数" class="headerlink" title="C语中的strcpy函数"></a>C语中的strcpy函数</h2><p>C语中的strcpy函数，将一个字符串复制到另一个字符型指针或字符数组，覆盖原来的字符串。</p>
<p>C语言中的调用方法：strcpy(目标字符串,源字符串)</p>
<p>在批处理中的实现方法：</p>
<p>set 目标字符串=%源字符串%</p>
<p>示例：</p>
<pre><code>@echo off
::关闭屏幕回显（可选）
set str1=This is old string
::设置str1中存储的字符串，注意没有双引号，这点与C语言等不同！
set str2=This is new string
::设置str2中存储的字符串
echo 执行字符串拷贝以前：
echo str1=%str1%
echo str2=%str2%
::先输出一次原有的字符串
set str1=%str2%
::字符串拷贝
echo 执行字符串拷贝以后：
echo str1=%str1%
echo str2=%str2%
::输出执行完字符串拷贝后的字符串
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
::输出信息，当用户按任意键时，结束该批处理。
</code></pre><h2 id="2-C语中的strcat函数"><a href="#2-C语中的strcat函数" class="headerlink" title="2.C语中的strcat函数"></a>2.C语中的strcat函数</h2><p>C语中的strcat函数，将一个字符串连接到另一个字符型指针或字符数组的末尾。</p>
<p>C语言中的调用方法：strcat(目标字符串,源字符串)</p>
<p>在批处理中的实现方法：</p>
<p>set 目标字符串=%目标字符串%%源字符串%</p>
<p>示例：</p>
<pre><code>@echo off
set str1=This is string1
set str2=This is string2
::设置str1和str2中存储的字符串
echo 连接字符串以前：
echo str1=%str1%
echo str2=%str2%
::先输出一次原有的字符串
set str1=%str1%%str2%
::字符串连接
echo 连接字符串以后：
echo str1=%str1%
echo str2=%str2%
::输出执行完字符串连接后的两个字符串
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><h2 id="3、字符串截取"><a href="#3、字符串截取" class="headerlink" title="3、字符串截取"></a>3、字符串截取</h2><p>C中没有这种函数，不过可以通过语句实现，不再介绍，直接说批处理的。</p>
<pre><code>set 目标字符串=%源字符串:~起始值,截取长度%
</code></pre><p>注意，起始值从0开始！</p>
<p>截取长度是可选的，如果省略逗号和截取长度，将会从起始值一直截取到字符串的结尾。</p>
<p>示例：</p>
<pre><code>@echo off
set str1=This is string1
::设置str1中存储的字符串
set str2=%str1:~8,6%
set str3=%str1:~0,4%
set str4=%str1:~5%
::字符串截取
echo 原字符串：
echo str1=%str1%
echo 截取得到的字符串：
echo str2=%str2%
echo str3=%str3%
echo str4=%str4%
::输出执行结果
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><h2 id="4、C语中的strlen函数，取得字符串的长度。"><a href="#4、C语中的strlen函数，取得字符串的长度。" class="headerlink" title="4、C语中的strlen函数，取得字符串的长度。"></a>4、C语中的strlen函数，取得字符串的长度。</h2><p>C语言中的调用方法：strlen(字符串)</p>
<p>在批处理中的实现方法是利用goto和标签，形成循环结构，不断将字符串截短1字符，并用变量记录截短的次数，直到字符串变成空串。</p>
<p>示例：</p>
<pre><code>@echo off
set str1=This is a test string
set str2=Hello World
::设置两个字符串
set str=%str1%
::将str1复制到str
:next1
::标签，用于goto跳转
::注意与注释语句的区别，注释用两个冒号开头，标签则为一个冒号
if not &quot;%str%&quot;==&quot;&quot; (
::判断str是不是空串，如果不是则执行下边的语句
set /a num+=1
::算术运算，使num的值自增1，相当于num++或者++num语句
set &quot;str=%str:~1%&quot;
::截取字符串，赋给自身
goto next1
::跳转到next1标签
::这里利用goto和标签，构成循环结构
)
::当以上循环结构执行完毕时，会执行下边的语句
echo str1=%str1%
echo str1的长度为：%num%
::输出结果
set num=0
::将记和用的环境变量num置0，以便开始下一次运算。
set str=%str2%
::将str2复制到str
:next2
::定义一个新的标签
::注意不能与已有的标签同名，否则会出错！
if not &quot;%str%&quot;==&quot;&quot; (
set /a num+=1
set &quot;str=%str:~1%&quot;
goto next2
)
::和上一个循环相似，不再介绍
echo str2=%str2%
echo str2的长度为：%num%
::输出结果
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><p>5、C语中的strchr函数，在一个字符串中查找一个字符的首次出现位置，找到时返回所在位置，找不到时返回0值。</p>
<p>批处理中的思路：不断截短字符串，并取截短后字符串中的首字符，和要求的字符比较，如果相同就利用goto语句跳出循环，输出结果，如果没有相同的字符，执行到最后就输出0值。</p>
<p>示例：</p>
<pre><code>@echo off
Setlocal ENABLEDELAYEDEXPANSION
::启用命令扩展，参加setlocal /?命令
set str1=This is a test string
set ch1=t
::注意，这里是区分大小写的！
set str=%str1%
::复制字符串，用来截短，而不影响源字符串
:next
if not &quot;%str%&quot;==&quot;&quot; (
set /a num+=1
if &quot;!str:~0,1!&quot;==&quot;%ch1%&quot; goto last
::比较首字符是否为要求的字符，如果是则跳出循环
set &quot;str=%str:~1%&quot;
goto next
)
set /a num=0
::没有找到字符时，将num置零
:last
echo 字符&apos;%ch1%&apos;在字符串&quot;%str1%&quot;中的首次出现位置为%num%
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><p>参考自：<a href="http://www.jb51.net/article/52744.htm" target="_blank" rel="external">http://www.jb51.net/article/52744.htm</a></p>
]]></content>
      
        <categories>
            
            <category> 批处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 批处理 </tag>
            
            <tag> bat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习系列：（五）机器学习基础]]></title>
      <url>/2017/10/08/DL_chap_5/</url>
      <content type="html"><![CDATA[<p>本文尚未全部完成。</p>
<p>待补充。</p>
<a id="more"></a>
<h2 id="5-8-无监督学习"><a href="#5-8-无监督学习" class="headerlink" title="5.8 无监督学习"></a>5.8 无监督学习</h2><p>从不需要人为注释的样本中抽取信息。</p>
<p>通常与密度估计有关。 学习从分布中采样，学习从分布中去噪，寻找数据分布的流形 或是 将数据中相关的样本聚类。</p>
<p>一个经典的无监督学习任务：找到数据的“最佳”表示。</p>
<p>较简单表示主要有三种：<strong>低维表示</strong>、<strong>稀疏表示</strong>和<strong>独立表示</strong>。</p>
<p><strong>表示</strong>的概念是<font color="#0000FF">深度学习的核心主题</font>之一，也是本书的核心主题之一。</p>
<h3 id="5-8-1-主成分分析"><a href="#5-8-1-主成分分析" class="headerlink" title="5.8.1 主成分分析"></a>5.8.1 主成分分析</h3><p>通过线性变换W将数据从x投影到z时，得到的数据表示的协方差矩阵为<strong>对角</strong>的。即：z中的元素是<strong>彼此无关</strong>的。</p>
<h3 id="5-8-2-k-均值聚类"><a href="#5-8-2-k-均值聚类" class="headerlink" title="5.8.2 k-均值聚类"></a>5.8.2 k-均值聚类</h3><p>k均值聚类的算法提供了k维的<strong>one-hot编码向量h</strong>以表示输入x。当x属于聚类i时，有$h_i=1$，h的其他项为零。</p>
<p><strong>one-hot编码</strong>是稀疏表示的极端示例，丢失了很多分布式表示的优点。</p>
<p>k-均值聚类初始化k个不同的中心点$\mu^{(1)},\cdots ,\mu^{(k)}$，然后迭代交换两个不同的步骤直到收敛。</p>
<p>步骤一，每个训练样本分配到最近的中心点$\mu^{(i)}$所代表的聚类$i\ $。<br>步骤二，每个中心点更新为聚类$i\ $中所有训练样本$x^{(i)}$的均值。</p>
<p>聚类问题的本身是病态的。没有单一的标准去度量聚类的数据在真实世界中效果如何。</p>
<p>因此，我们可能更偏好于<strong>分布式表示</strong>。分布式表示可以对每个车辆赋予两个属性——一个表示它的颜色，一个表示它是汽车还是卡车。</p>
<h2 id="5-9-随机梯度下降"><a href="#5-9-随机梯度下降" class="headerlink" title="5.9 随机梯度下降"></a>5.9 随机梯度下降</h2><p>随机梯度下降：stochastic gradient descent,SGD。</p>
<p>机器学习中的代价函数通常可以分解为每个样本的代价函数的总和。</p>
<p><em>训练数据的负条件对数似然</em> $\;$可以写为：</p>
<p>$$J(\theta) = E_{x,\; y \sim \hat P_{data}}L(x,y,\theta ) = \frac 1m \sum_{i=1}^m  L(x^{(i)},y^{(i)},\theta )  $$</p>
<p>其中，L是每个样本的损失函数。</p>
<p>随机梯度下降的<strong>核心</strong>是，梯度是期望。<font color="#0000FF">期望可使用小规模的样本近似估计</font>。</p>
<h2 id="5-10-构建机器学习算法"><a href="#5-10-构建机器学习算法" class="headerlink" title="5.10 构建机器学习算法"></a>5.10 构建机器学习算法</h2><p>组合模型、代价和优化算法 来构建机器学习算法的配方。适用于监督学习以及非监督学习。</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[准确率、召回率与F1值]]></title>
      <url>/2017/10/08/DL_Precision_and_Recall/</url>
      <content type="html"><![CDATA[<p>“什么是准确率和召回率？”<br>“什么是查准率和查全率？”</p>
<p>机器学习常见面试题之一，本文将对上述问题进行解答。</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>下面有关分类算法的准确率，召回率，F1 值的描述，错误的是？<br>A.准确率是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率<br>B.召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率<br>C.正确率、召回率和 F 值取值都在0和1之间，数值越接近0，查准率或查全率就越高<br>D.为了解决准确率和召回率冲突问题，引入了F1分数</p>
<p>正确答案将在本文最后揭晓。</p>
<pre><code>TP——将正类预测为正类数
FN——将正类预测为负类数
FP——将负类预测为正类数
TN——将负类预测为负类数
</code></pre><h2 id="准确率（Precision）"><a href="#准确率（Precision）" class="headerlink" title="准确率（Precision）"></a>准确率（Precision）</h2><p>P = TP/(TP+FP)<br>反映了被分类器判定的正例中真正的正例样本的比重。</p>
<p>准确率是针对我们<strong>预测结果</strong>而言的，它表示的是预测为正的样本中有多少是真正的正样本。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)。</p>
<h2 id="召回率（Recall）："><a href="#召回率（Recall）：" class="headerlink" title="召回率（Recall）："></a>召回率（Recall）：</h2><p>R = TP/（TP+FN）= 1-[FN/（TP+FN）]<br>反映了被正确判定的正例占总的正例的比重。</p>
<p>而召回率是针对我们<strong>原来的样本</strong>而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。</p>
<p>所有正例中被分对的比例，衡量了分类器对正例的识别能力。</p>
<p>准确率和召回率，两者取值在0和1之间，数值越接近<code>1</code>，查准率或查全率就越高。</p>
<h2 id="F1值"><a href="#F1值" class="headerlink" title="F1值"></a>F1值</h2><p>F1 = 2<em>（Recall </em> Precision）/（Recall + Precision）</p>
<p>精准率和召回率和F1取值都在0和1之间，精准率和召回率高，F1值也会高，不存在数值越接近0越高的说法，应该是数值越接近1越高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一句话概括：精确率Precision是<strong>预测的正例</strong>里有多少是预测正确的，召回率Recall是<strong>真正的正例</strong>里有多少预测正确的。</p>
<p><strong>精确是预测，召回是原本</strong>。</p>
<p>所以开始的问题的正确答案为“C”，三者都是越接近于1越好。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://www.zhihu.com/question/19645541/answer/12502751" target="_blank" rel="external">https://www.zhihu.com/question/19645541/answer/12502751</a></p>
</li>
<li><p><a href="https://www.nowcoder.com/test/question/done?tid=11555865&amp;qid=14638#summary" target="_blank" rel="external">https://www.nowcoder.com/test/question/done?tid=11555865&amp;qid=14638#summary</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 准确率 </tag>
            
            <tag> 召回率 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习系列：（六）前馈神经网络]]></title>
      <url>/2017/10/08/DL_chap_6/</url>
      <content type="html"><![CDATA[<p>本文是《深度学习》第六章的学习笔记.</p>
<p>本章是对前馈网络的整体内容进行详细地论述。</p>
<a id="more"></a>
<h2 id="6-1-实例：学习XOR"><a href="#6-1-实例：学习XOR" class="headerlink" title="6.1 实例：学习XOR"></a>6.1 实例：学习XOR</h2><p>采用一个简单的前馈神经网络，一个隐含层，隐含层包含两个单元。</p>
<p>整个网络为：</p>
<p>$$f(x;W,c,w,b) = w^T\text{max}(0,W^Tx+c)+b$$</p>
<p>隐含层激活函数采用的是<code>ReLU</code>。</p>
<p>给出一个解：<br>$$W=<br>  \begin{bmatrix}<br>  1 &amp; 1  \\<br>  1 &amp; 1  \\<br>  \end{bmatrix}<br>$$<br>$$c=<br>  \begin{bmatrix}<br>  0   \\<br>  -1   \\<br>  \end{bmatrix}<br>$$<br>$$w=<br>  \begin{bmatrix}<br>  1   \\<br>  -2   \\<br>  \end{bmatrix}<br>$$<br>以及：$$ b = 0 $$</p>
<h2 id="6-2-基于梯度的学习"><a href="#6-2-基于梯度的学习" class="headerlink" title="6.2 基于梯度的学习"></a>6.2 基于梯度的学习</h2><p>对于前馈神经网络，将所有权重初始化为小的值是很重要的。偏置可以初始化为0或者小的正值(如0.1)。</p>
<p>第8章介绍迭代的基于梯度的优化算法，<em>8.4节</em>为参数初始化，<br><em>4.3节</em>介绍了一些特别的算法，是对梯度下降思想的改进和提纯。<br>随机梯度下降将算法的改进在<em>5.9节</em>。</p>
<h3 id="6-2-1-代价函数"><a href="#6-2-1-代价函数" class="headerlink" title="6.2.1 代价函数"></a>6.2.1 代价函数</h3><p>大多数情况下，参数模型定义了一个分布$p(y|x;\theta)$，并且简单地使用<strong>最大似然</strong>原理。<br>使用训练数据和模型预测间的交叉熵作为代价函数。</p>
<pre><code>完整的代价函数 = 基本代价函数 + 正则项。
</code></pre><p>最流行的正则化策略：<strong>权重衰减</strong>（weight decay）。</p>
<p><em>第7章</em>介绍更高级的正则化策略。</p>
<h4 id="6-2-1-1-使用最大似然学习条件分布"><a href="#6-2-1-1-使用最大似然学习条件分布" class="headerlink" title="6.2.1.1 使用最大似然学习条件分布"></a>6.2.1.1 使用最大似然学习条件分布</h4><p>使用最大似然训练意味着代价函数就是负的对数似然。</p>
<p><strong>负的对数似然 = 训练数据和模型分布间的交叉熵</strong> 。</p>
<p>代价函数为：</p>
<p>$$J(\theta) = E_{x,\; y \sim \hat P_{data}} logP_{model}(y|x)  $$</p>
<p>代价函数的具体形式取决于模型$logP_{model}$的具体形式。展开后的代价函数，可以舍去其中不依赖于模型的参数。</p>
<p>如果有：$$P_{model}(y|x)  = N(y;f(x;\theta),I) $$</p>
<p>就可以得到均方误差代价：</p>
<p>$$J(\theta) = \frac{1}{2} E_{x,\; y \sim \hat P_{data}} || y-f(x;\theta )||^2 +\text{const}  $$</p>
<p>代价函数的梯度必须足够大和具有足够的预测性，来为学习算法提供一个好的指引。</p>
<p><strong>饱和</strong>（变得非常平）的函数破坏了这一目标，梯度非常小。该情况很常见是因为隐藏单元或输出单元的激活函数会饱和。</p>
<h4 id="6-2-1-2-学习条件统计量"><a href="#6-2-1-2-学习条件统计量" class="headerlink" title="6.2.1.2 学习条件统计量"></a>6.2.1.2 学习条件统计量</h4><p>预测器$f(x;\theta)$，预测y的均值。</p>
<p>代价泛函(可以表示一大类函数中的任何一个函数，仅仅被一些特征所限制，而不是具有特殊的参数形式)。 <font color="#FF0000">泛函是指函数到实数的映射</font>。</p>
<p>对函数求解问题需要用到<strong>变分法</strong>(19.4.2节)。</p>
<p>变分法导出的第一个结果是解优化问题：<br>$$f^* =\underset{f}{\mathrm{argmin}} E_{x,\; y \sim  P_{data}}|| y-f(x)||^2$$</p>
<p>得到：<br>$$f^*(x) = E_{ y \sim  P_{data}(y|x)}[y]$$</p>
<p>最小化均方误差代价函数将得到一个函数，可以用来对每个x的值预测出y的<strong>均值</strong>。</p>
<p>第二个使用变分法得到的结果是：</p>
<p>$$f^* =  \underset{f}{\mathrm{argmin}} E_{x,\; y \sim  P_{data}}|| y-f(x)||_1$$</p>
<p>将得到一个函数可以对每个x预测y取值的<strong>中位数</strong>，只要这个函数在我们要优化的函数族里。这个函数通常被称为<strong>平均绝对误差</strong>(mean absolute error)。最小化平均绝对误差代价函数。</p>
<p><font color="#FF0000">交叉熵代价函数</font> 比均方误差或者平均绝对误差更受欢迎的原因也在此，饱和的输出单元当结合后两个代价函数时会产生非常小的梯度。</p>
<h3 id="6-2-2-输出单元"><a href="#6-2-2-输出单元" class="headerlink" title="6.2.2 输出单元"></a>6.2.2 输出单元</h3><p>代价函数的选择：大多数情况下，简单使用数据分布和模型分布间的<font color="#FF0000">交叉熵</font>。</p>
<p>本节中，假设前馈网络提供了一组定义为$h=f(x;\theta )$的<strong>隐藏特征</strong>。输出层的作用则是随后对这些特征进行额外的变换完成整个网络必须完成的任务。</p>
<h4 id="6-2-2-1-用于Bernoulli输出分布的sigmoid单元"><a href="#6-2-2-1-用于Bernoulli输出分布的sigmoid单元" class="headerlink" title="6.2.2.1 用于Bernoulli输出分布的sigmoid单元"></a>6.2.2.1 用于Bernoulli输出分布的sigmoid单元</h4><p>两个类的分类问题，即预测二值型变量y。</p>
<p>最大似然定义$y\ $在$x\ $条件下的<code>Bernoulli</code>分布。</p>
<h4 id="6-2-2-2-用于Multinoulli输出分布的softmax单元"><a href="#6-2-2-2-用于Multinoulli输出分布的softmax单元" class="headerlink" title="6.2.2.2 用于Multinoulli输出分布的softmax单元"></a>6.2.2.2 用于Multinoulli输出分布的softmax单元</h4><p>任何时候，当我们想要表示一个具有<strong>n个可能取值的离散型随机变量的分布</strong>时，都可以使用<strong>softmax</strong>函数。</p>
<p><code>softmax</code>函数最常用作分类器的输出，来表示$n\ $个不同类上的概率分布。</p>
<p>首先，线性层预测了未归一化的对数概率：<br>$$ z = W^Th+b$$<br>其中，$z_i = log \hat P (y=i|x)$，<code>softmax</code>函数然后对$z\ $<strong>指数化</strong>和<strong>归一化</strong>来获得需要的$\hat y$。最终，<code>softmax</code>函数的形式为：<br>$$ \text{softmax}(z)_i = \frac{\text{exp}(z_i)}{\sum_j \text{exp}(z_j)}$$</p>
<p>当使用最大化对数似然训练<code>softmax</code>来输出目标值$y\ $时，这时，我们想要最大化$logP(y=i;z)=\log \text{softmax}(z)_i$。将<code>softmax</code>定义为指数的形式是因为对数似然中的<code>log</code>可以抵消<code>softmax中</code>的<code>exp</code>：</p>
<p>$$\log \text{softmax(z)}_i = z_i -\log \sum_j \text{exp}(z_j)$$</p>
<p>关于<code>softmax</code>的解释：这个函数更接近<code>argmax</code>函数而不是max函数。“soft”术语来源于<code>softmax</code>函数是连续可微的。“argmax”函数的结果表示为一个<strong>one-hot向量</strong>（<em>只有一个元素为1，其余元素都为0的向量</em>），不是连续可微的。<code>softmax</code>函数因此提供了argmax的“软化”版本，max函数相应的软化版本是$\text{softmax}(z)^Tz$。可能最好是把softmax函数称为“<code>softargmax</code>”，但当前名字已经是一个根深蒂固的习惯了。</p>
<h4 id="6-2-2-4-其他的输出类型"><a href="#6-2-2-4-其他的输出类型" class="headerlink" title="6.2.2.4 其他的输出类型"></a>6.2.2.4 其他的输出类型</h4><h2 id="6-3-隐藏单元"><a href="#6-3-隐藏单元" class="headerlink" title="6.3 隐藏单元"></a>6.3 隐藏单元</h2><p><strong>整流线性单元</strong>是隐藏单元极好的默认选择。</p>
<p>大多数隐藏单元的区别仅仅在于<strong>激活函数</strong>$g(z)$的形式。</p>
<p>隐藏单元少数点不可微的解释。 可微的定义是：只有函数在$z\ $处的左导数与右导数都有定义并且相等时，函数在$z\ $处才是可微的。</p>
<p>$g(z) = \text{max}(0,z)$，在$z=0$处的左导数为0，右导数为1。软件中实现通常是返回左导数或者右导数的其中一个，而不是报告导数未定义或者产生一个错误。</p>
<h3 id="6-3-1-整流线性单元及其扩展"><a href="#6-3-1-整流线性单元及其扩展" class="headerlink" title="6.3.1 整流线性单元及其扩展"></a>6.3.1 整流线性单元及其扩展</h3><p>整流线性单元的激活函数：$g(z) = \text{max}(0,z)$</p>
<p>整流线性单元通常作用于仿射变换之上： $$h = g(W^Tx+b)$$</p>
<h3 id="6-3-2-logistic-sigmoid与双曲正切函数"><a href="#6-3-2-logistic-sigmoid与双曲正切函数" class="headerlink" title="6.3.2 logistic sigmoid与双曲正切函数"></a>6.3.2 logistic sigmoid与双曲正切函数</h3><p>双曲正切函数通常要比logistic sigmoid函数表现更好。</p>
<h3 id="6-3-3-其他隐藏单元"><a href="#6-3-3-其他隐藏单元" class="headerlink" title="6.3.3 其他隐藏单元"></a>6.3.3 其他隐藏单元</h3><p>其中一种是完全没有隐藏单元$g(z)$。也可以说是用单位函数作为激活函数。</p>
<p>softmax单元是一种经常用作输出的单元，但有时候也可以用作隐藏单元。<br>softmax单元很自然地表示具有k个可能值的离散型随机变量的概率分布，所以它们可以作为一种开关。将在<em>10.12节</em>介绍。</p>
<p>其他的一些隐藏单元包括：</p>
<ul>
<li>径向基函数(radial basis function, RBF)</li>
<li>softplus函数</li>
<li>硬双曲正切函数(hard tanh)</li>
</ul>
<h2 id="6-4-架构设计"><a href="#6-4-架构设计" class="headerlink" title="6.4 架构设计"></a>6.4 架构设计</h2><p>架构（architecture）一词指网络的整体结构：它应该具有多少单元，以及这些单元应该如何连接。</p>
<p>链式结构：每一层都是前一层的函数。主要的考虑因素是网络的深度和每层的宽度。</p>
<h3 id="6-4-1-万能近似性质和深度"><a href="#6-4-1-万能近似性质和深度" class="headerlink" title="6.4.1 万能近似性质和深度"></a>6.4.1 万能近似性质和深度</h3><p><strong>万能近似定理</strong>(universal approximation theorem)：一个前馈神经网络如果具有线性输出层和至少一层具有任何一种“挤压”性质的激活函数（例如sigmoid函数）的隐含层，只要给予网络足够数量的隐藏单元，它可以以任意的精度近似任何从一个有限维空间到另一个有限维空间的Borel可测函数。</p>
<p>单层的前馈网络虽然足以表示任何函数，但是网络层可能大得不可实现。<br>所以需要深度网络。</p>
<p>Montufar et al(2014):一些用深度整流网络表示的函数可能需要浅层网络（一个隐含层）<strong>指数级</strong>的隐藏单元才能表示。</p>
<p>根据经验，更深的模型确实在广泛的任务中泛化得更好。</p>
<h3 id="6-4-2-其他架构上的考虑"><a href="#6-4-2-其他架构上的考虑" class="headerlink" title="6.4.2 其他架构上的考虑"></a>6.4.2 其他架构上的考虑</h3><p>上述考虑的是简单的链式结构。在实践中，神经网络具有多样性。</p>
<p>用于计算机视觉的卷积神经网络的特殊架构在 <em>第9章</em> 中介绍。<br>前馈网络也可以推广到序列处理的循环神经网络，但有它们自己的架构考虑，将在<em>第10章</em>中介绍。</p>
<p>架构设计考虑的另一个关键点是如何将层与层之间连接起来。</p>
<h2 id="6-5-反向传播和其他的微分算法"><a href="#6-5-反向传播和其他的微分算法" class="headerlink" title="6.5 反向传播和其他的微分算法"></a>6.5 反向传播和其他的微分算法</h2><h3 id="6-5-1-计算图"><a href="#6-5-1-计算图" class="headerlink" title="6.5.1 计算图"></a>6.5.1 计算图</h3><p>图中每个节点表示一个变量。</p>
<h3 id="6-5-2-微积分中的链式法则"><a href="#6-5-2-微积分中的链式法则" class="headerlink" title="6.5.2 微积分中的链式法则"></a>6.5.2 微积分中的链式法则</h3><p>从标量扩展到向量的链式法则。</p>
<p>假设$x\in \mathbb R^m,\  y\in \mathbb R^n$，$g\ $是从$\mathbb R^m$到$\mathbb R^n$的映射，$f\ $是从$\mathbb R^n$到$\mathbb R\ $的映射。如果$y=g(x)$ 并且$z =f(y)$。那么：<br>$$\frac{\partial z}{\partial x_i} = \sum_j \frac{\partial z}{\partial y_j} \frac{\partial y_j}{\partial x_i}$$</p>
<p>使用向量记法，可以等价地写成：<br>$$\triangledown_xz = (\frac {\partial y}{\partial x})^T \triangledown_yz$$<br>这里的$\frac {\partial y}{\partial x}$是$g\ $的$n\times m $的<code>Jacobian</code>矩阵。</p>
<p>还可以从向量扩展到张量。</p>
<h3 id="6-5-3-递归地使用链式法则来实现反向传播"><a href="#6-5-3-递归地使用链式法则来实现反向传播" class="headerlink" title="6.5.3 递归地使用链式法则来实现反向传播"></a>6.5.3 递归地使用链式法则来实现反向传播</h3><h3 id="6-5-4-全连接MLP中的反向传播计算"><a href="#6-5-4-全连接MLP中的反向传播计算" class="headerlink" title="6.5.4 全连接MLP中的反向传播计算"></a>6.5.4 全连接MLP中的反向传播计算</h3><p>算法6.2反向传播时，偏导数的计算。</p>
<p>算法6.3是前向传播和代价函数的计算。</p>
<h3 id="6-5-5-符号到符号的导数"><a href="#6-5-5-符号到符号的导数" class="headerlink" title="6.5.5 符号到符号的导数"></a>6.5.5 符号到符号的导数</h3><p>符号表示</p>
<p>反向传播的方法。</p>
<p>1 符号到数值的微分：计算图和一组用于图的输入的数值</p>
<p>2 符号到符号的方法：采用计算图和添加额外的节点到计算图中，这些额外的节点提供了我们所需导数的符号描述。</p>
<h3 id="6-5-6-一般化的反向传播"><a href="#6-5-6-一般化的反向传播" class="headerlink" title="6.5.6 一般化的反向传播"></a>6.5.6 一般化的反向传播</h3><h3 id="6-5-7-实例：用于MLP训练的反向传播"><a href="#6-5-7-实例：用于MLP训练的反向传播" class="headerlink" title="6.5.7 实例：用于MLP训练的反向传播"></a>6.5.7 实例：用于MLP训练的反向传播</h3><p>训练多层感知机</p>
<p>交叉熵代价函数</p>
<h3 id="6-5-8-复杂化"><a href="#6-5-8-复杂化" class="headerlink" title="6.5.8 复杂化"></a>6.5.8 复杂化</h3><p>操作返回多个张量。反向传播的内存消耗、现实实现。</p>
<h3 id="6-5-9-深度学习界外的微分"><a href="#6-5-9-深度学习界外的微分" class="headerlink" title="6.5.9 深度学习界外的微分"></a>6.5.9 深度学习界外的微分</h3><p>自动微分领域关系如何以算法方式计算微分。</p>
<p>这里描述的反向传播算法只是自动微分算法的一种方法。</p>
<p>反向模式累加和前向模式累加。</p>
<p><code>Theano</code>和<code>TensorFlow</code>的实现使用基于匹配已知简化模式的试探法，以便重复地尝试去简化图。</p>
<p>在机器学习以外的社区，更常见的 是使用传统的编程语言来直接实现微分软件。例如用<code>Python</code>或者<code>C</code>来编程</p>
<h3 id="6-5-10-高阶微分"><a href="#6-5-10-高阶微分" class="headerlink" title="6.5.10 高阶微分"></a>6.5.10 高阶微分</h3><p>一些软件框架支持高阶导数。在深度学习软件框架中，这至少包括<code>Theano</code>和<code>TensorFlow</code>。</p>
<p>在深度学习的相关领域，很少会计算标量函数的单个二阶导数。相反，我们通常对<code>Hessian</code>矩阵的性质比较感兴趣。如果有函数$f:\mathbb{R}^n \to R$，那么<code>Hessian</code>矩阵的大小为$n\times n$。在典型的深度学习应用中，n将是模型的参数数量，可能很容易达到数十亿。因此，完整的<code>Hessian</code>矩阵甚至不能表示。</p>
<p>典型的深度学习方法是使用<code>Krylov</code>方法，而不是显式地计算<code>Hessian</code>矩阵。</p>
<p><code>Hessian</code>矩阵上使用<code>Krylov</code>方法，只需要计算<code>Hessian</code>矩阵$H$和一个任意向量$v$间的乘积即可。</p>
<h2 id="6-6-历史小记"><a href="#6-6-历史小记" class="headerlink" title="6.6 历史小记"></a>6.6 历史小记</h2><p>线性 -&gt; 非线性</p>
<p>反向传播</p>
<p>现代前馈网络的核心思想</p>
<p>交叉熵损失函数</p>
<p>分段线性隐藏单元（整流线性单元ReLU）</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MathJax的基本使用语法]]></title>
      <url>/2017/10/08/mathjax_basic/</url>
      <content type="html"><![CDATA[<p>本文主要介绍MathJax公式的基本语法。</p>
<a id="more"></a>
<h1 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h1><p>如果是在文本中插入公式，则用<code>$...$</code>。</p>
<p>如果公式自成段落，则使用<code>$$...$$</code>。</p>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><ul>
<li>使用\mathbb或\Bbb来显示黑板粗体字，$\mathbb{NQRZ}$</li>
<li>使用\mathbf来显示粗体字，$\mathbf {ABCDabcd}$</li>
<li>使用\mathtt来显示打印式字体，$\mathtt{ABCDabcd}$</li>
<li>使用\mathrm来显示罗马字体，$\mathrm{ABCDabcd}$</li>
<li>使用\mathcal来显示手写字体，$\mathcal{ABCDabcd}$</li>
<li>使用\mathscr来显示剧本字体，$\mathscr{ABCDabcd}$</li>
<li>使用\mathfrak来显示Fraktur字母(一种旧的德国字体)，$\mathfrak{ABCDabcd}$</li>
</ul>
<h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p>如果要写出多行公式，就使用</p>
<pre><code>\begin{equation}\begin{split} 
end{split}\end{equation}
</code></pre><p>\\ 符号表示换行，再使用&amp;符号表示要对齐的位置，例子如下</p>
<pre><code>\begin{equation}\begin{split}
H(Y|X)&amp;=\sum_{x\in X} p(x)H(Y|X)\\
&amp;=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\
&amp;=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x)
\end{split}\end{equation}
</code></pre><p>当然，再加上<code>$$...$$</code>之后，显示如下：<br>$$\begin{equation}\begin{split}<br>H(Y|X)&amp;=\sum_{x\in X} p(x)H(Y|X)\\<br>&amp;=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\<br>&amp;=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x)<br>\end{split}\end{equation}$$</p>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>通过大括号<code>{}</code>将操作数与符号分割开，消除二义性。</p>
<p>例如，若使用x^10，其效果为$x^10$，这里就要用到大括号，x^{10}，最终效果为$x^{10}$。</p>
<h1 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h1><p><code>MathJax</code>通常用自己的一套复杂策略来决定公式的空间距离。直接在两个元素之间加入空格是毫无用处的。</p>
<p>因此为了增加空间距离，使用<code>\,</code>可以增加稍许空间；使用<code>\;</code>可以增加更多的空间；<code>\quad</code>和<code>\qquad</code>分别对应更大的空间。</p>
<h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h2><p>上标或下标只需在后面加上<code>^</code>或<code>_</code>。另外需要注意的是，如果上下标不止一个字符，就需要用大括号括起来，表示是一个整体<code>{...}</code>。</p>
<h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><p>有两种方式做到这个效果。 </p>
<ol>
<li>使用\frac ab。如\frac {1+a}{4+b}，效果为$\frac{1+a}{4+b}$; </li>
<li>使用a \over b。如{1+a} \over {4+b}，效果为${1+a}\over {4+b}$。 </li>
</ol>
<p>一般推荐使用<strong>第二种</strong>。个人倾向于使用<strong>第一种</strong>。</p>
<h2 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h2><p>平方根： \sqrt{x^3}，效果为 $\sqrt{x^3} $。</p>
<p>其余： \sqrt[4]{\frac xy}，效果为 $\sqrt[4]{\frac xy}$。</p>
<h2 id="关系比较符号"><a href="#关系比较符号" class="headerlink" title="关系比较符号"></a>关系比较符号</h2><pre><code>&lt;    \lt
&gt;    \gt
≤    \le
≥    \ge
≠    \neq
</code></pre><p>$$\begin{array}{c|lcr}<br>\text{符号} &amp; \text{\表示} \\<br>\hline<br>&lt; &amp; lt \\<br>> &amp; gt \\<br>≤ &amp; le \\<br>≥ &amp; ge \\<br>≠ &amp; neq \\<br>\end{array}$$</p>
<h2 id="argmax"><a href="#argmax" class="headerlink" title="argmax"></a>argmax</h2><pre><code>\underset{f}{\mathrm{argmin}}
</code></pre><p>效果如下：<br>$$\underset{f}{\mathrm{argmin}}$$</p>
<h2 id="不显示斜体"><a href="#不显示斜体" class="headerlink" title="不显示斜体"></a>不显示斜体</h2><p>对于常量部分，有时候我们不想让他显示成斜体，而是正常的竖直显示，可加上<code>\text{...}</code>，就可以正常显示。</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>使用<code>$$\begin{matrix}…\end{matrix}$$</code>，每一行末用<code>\\</code>结束表示换行，用<code>&amp;</code>分隔矩阵元素。 </p>
<pre><code>$$
  \begin{matrix}
  1 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 \\
  0 &amp; 0 &amp; 1 \\
  \end{matrix}
$$
</code></pre><p>效果：<br>$$<br>\begin{matrix}<br>1 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 1 \\<br>\end{matrix}<br>$$</p>
<p>如果要加括号，可以使用上面的括号符号。<br>除此之外，还可以直接将<code>matrix</code>替换为<code>pmatrix</code>(小括号)，或者<code>bmatrix</code>(中括号)，或者<code>Bmatrix</code>(大括号)，或者<code>vmatrix</code>(竖线)，或者<code>Vmatrix</code>(是双竖线)</p>
<p>如果你想省略一些项，可以使用<code>\cdots</code>⋯，<code>\ddots</code>⋱，<code>\vdots</code>⋮。<br>如：</p>
<pre><code>$$
  \begin{pmatrix}
  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n\\
  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  
  1 &amp; a_n &amp; a_n^2 &amp; \cdots &amp; a_n^n  \\
  \end{pmatrix}
$$
</code></pre><p>效果：<br>$$<br>  \begin{pmatrix}<br>  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n\\<br>  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\<br>  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>  1 &amp; a_n &amp; a_n^2 &amp; \cdots &amp; a_n^n  \\<br>  \end{pmatrix}<br>$$</p>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>不同语言的代码块，可以用不同的标识符。如python语言，则代码块表示为` <figure class="highlight python"><figcaption><span>//下一行写具体代码 ```  `。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">就是用三个点号（英文状态下、键盘左上角、ESC下面的那个键）包围的部分就是代码块。</div><div class="line"></div><div class="line"></div><div class="line">测试：</div><div class="line"></div><div class="line"></div><div class="line">JavaScript代码块效果如下：</div><div class="line"></div><div class="line">```javascript</div><div class="line"><span class="keyword">if</span> (condition)&#123;</div><div class="line">    <span class="keyword">return</span> true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Python代码块效果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(A)</span>:</span></div><div class="line">	<span class="string">'''intresting document.'''</span></div><div class="line">    <span class="keyword">return</span> len(A)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MathJax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[批处理的常用命令及用法]]></title>
      <url>/2017/10/05/batch_basic_usage/</url>
      <content type="html"><![CDATA[<p>什么是批处理？<br>在windows下，以<code>cmd</code>或者<code>bat</code>结尾的文件就是批处理文件；linux下，也有以<code>sh</code>结尾的shell脚本文件。</p>
<p>本文主要介绍了批处理的一些常用命令。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这里，先解释什么是DOS？</p>
<p>DOS，即Disk Operation System，磁盘操作系统。</p>
<p>命令行就是在Windows操作系统中打开DOS窗口，以字符串的形式执行Windows管理程序。</p>
<p>那么，我们如何进入命令行窗口？</p>
<p>开始–&gt;运行–&gt;键入”cmd”，回车即可。</p>
<p>阅读本文需要一定的dos基础概念，例如：盘符、文件、目录(文件夹)、子目录、根目录、当前目录</p>
<p>每个命令的完整说明请加 /? 参数参考微软的帮助文档可以看到。</p>
<p>注：如果对某一命令还不是很熟悉，可以在命令行窗口下输入：命令名/?的方式来获得帮助。</p>
<p>例如：对dir命令的应用不熟悉，可以在命令行窗口下输入：</p>
<p><code>dir /?</code></p>
<p>批处理定义：顾名思义，批处理文件是将一系列命令按一定的顺序集合为一个可执行的文本文件，其扩展名为BAT或者CMD。这些命令统称批处理命令。</p>
<p>小知识：可以在键盘上按下Ctrl+C组合键来强行终止一个批处理的执行过程。</p>
<h2 id="1-echo-和-回显控制命令"><a href="#1-echo-和-回显控制命令" class="headerlink" title="1 echo 和 @回显控制命令"></a>1 echo 和 @回显控制命令</h2><pre><code>@                    #关闭单行回显
echo off             #从下一行开始关闭回显
@echo off            #从本行开始关闭回显。一般批处理第一行都是这个
echo on              #从下一行开始打开回显
echo                 #显示当前是 echo off 状态还是 echo on 状态
echo.                #输出一个&quot;回车换行&quot;，一般就是指空白行
echo hello world     #输出hello world
</code></pre><p>“关闭回显”是指运行批处理文件时，不显示文件里的每条命令，只显示运行结果。批处理开始和结束时，系统都会自动打开回显</p>
<h2 id="2-errorlevel程序返回码"><a href="#2-errorlevel程序返回码" class="headerlink" title="2 errorlevel程序返回码"></a>2 errorlevel程序返回码</h2><pre><code>echo %errorlevel%
</code></pre><p>每个命令运行结束，可以用这个命令行格式查看返回码用于判断刚才的命令是否执行成功默认值为0，</p>
<p>一般命令执行出错会设 errorlevel 为1</p>
<h2 id="3-dir显示目录中的文件和子目录列表"><a href="#3-dir显示目录中的文件和子目录列表" class="headerlink" title="3 dir显示目录中的文件和子目录列表"></a>3 dir显示目录中的文件和子目录列表</h2><pre><code>dir                 #显示当前目录中的文件和子目录
dir /a              #显示当前目录中的文件和子目录，包括隐藏文件和系统文件
dir c: /a:d         #显示 C 盘当前目录中的目录
dir c:\ /a:-d       #显示 C 盘根目录中的文件
dir d:\mp3 /b/p     #逐屏显示 d:\mp3 目录里的文件，只显示文件名，不显示时间和大小

dir *.exe /s        #显示当前目录和子目录里所有的.exe文件。
</code></pre><p>其中 <em> 是通配符，代表所有的文件名，还有一个通配符 ? 代表一个任意字母或汉字。如 `c</em>.*<code>代表以 c 开头的所有文件。</code>?.exe` 代表所有文件名是一个字母的.exe文件。</p>
<p>如果指定的目录或文件不存在，将返回 <code>errorlevel</code> 为1;每个文件夹的 dir 输出都会有2个子目录<code>.</code>和<code>..</code>。<code>.</code> 代表当前目录， <code>..</code> 代表当前目录的上级目录。</p>
<pre><code>dir .               #显示当前目录中的文件和子目录
dir ..              #显示当前目录的上级目录中的文件和子目录
</code></pre><p>其它参数可参考<code>dir /?</code></p>
<h2 id="4-cd更改当前目录"><a href="#4-cd更改当前目录" class="headerlink" title="4 cd更改当前目录"></a>4 cd更改当前目录</h2><pre><code>cd mp3              #进入当前目录中的mp3 目录
cd ..               #进入当前目录中的上级目录
cd\                 #进入根目录
cd                  #显示当前目录
cd /d d:\mp3        #可以同时更改盘符和目录
cd &quot;Documents and Settings&quot;\All users
</code></pre><p>文件名带空格，路径前需要加上引号！！如果更改到的目录不存在，则出错返回 <code>errorlevel=1</code></p>
<p><code>cd /d d:</code> 更改盘符需要加上/d参数。</p>
<h2 id="5-md创建目录"><a href="#5-md创建目录" class="headerlink" title="5 md创建目录"></a>5 md创建目录</h2><pre><code>md abc              #在当前目录里建立子目录 abc
md d:\a\b\c         #如果 d:\a 不存在，将会自动创建
</code></pre><h2 id="6-rd删除目录"><a href="#6-rd删除目录" class="headerlink" title="6 rd删除目录"></a>6 rd删除目录</h2><pre><code>rd abc              #删除当前目录里的 abc 子目录，要求为空目录
rd /s/q d:\temp     #删除 d:\temp 文件夹及其子文件夹和文件，不需要按 Y 确认
</code></pre><h2 id="7-del删除文件"><a href="#7-del删除文件" class="headerlink" title="7 del删除文件"></a>7 del删除文件</h2><pre><code>del d:\test.txt     #删除指定文件，不能是隐藏、系统、只读文件
del *.*删除当前目录里的所有文件，不包括隐藏、系统、只读文件，要求按 Y 确认
del /q/a/f d:\temp\*.*删除 d:\temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录
del /q/a/f/s d:\temp\*.*删除 d:\temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录
</code></pre><h2 id="8-ren文件重命名"><a href="#8-ren文件重命名" class="headerlink" title="8 ren文件重命名"></a>8 ren文件重命名</h2><pre><code>ren 1.txt 2.bak     #把 1.txt 更名为 2.bak
ren *.txt *.ini     #把当前目录里所有.txt文件改成.ini文件
ren d:\temp tmp     #支持对文件夹的重命名
</code></pre><h2 id="9-cls清屏"><a href="#9-cls清屏" class="headerlink" title="9 cls清屏"></a>9 cls清屏</h2><h2 id="10-type显示文件内容"><a href="#10-type显示文件内容" class="headerlink" title="10 type显示文件内容"></a>10 type显示文件内容</h2><pre><code>type c:\boot.ini    #显示指定文件的内容，程序文件一般会显示乱码
type *.txt          #显示当前目录里所有.txt文件的内容
</code></pre><h2 id="11-copy拷贝文件"><a href="#11-copy拷贝文件" class="headerlink" title="11 copy拷贝文件"></a>11 copy拷贝文件</h2><pre><code>copy c:\test.txt d:\         #复制 c:\test.txt 文件到 d:\
copy c:\test.txt d:\test.bak #复制 c:\test.txt 文件到 d:\ ，并重命名为 test.bak
copy c:\*.*                  #复制 c:\ 所有文件到当前目录，不包括隐藏文件和系统文件不指定目标路径，则默认目标路径为当前目录
copy con test.txt            #从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件con代表屏幕，prn代表打印机，nul代表空设备
copy 1.txt + 2.txt 3.txt     #合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件如果不指定 3.txt ，则保存到 1.txt
copy test.txt +              #复制文件到自己，实际上是修改了文件日期
</code></pre><h2 id="12-title设置cmd窗口的标题"><a href="#12-title设置cmd窗口的标题" class="headerlink" title="12 title设置cmd窗口的标题"></a>12 title设置cmd窗口的标题</h2><pre><code>title 新标题        #可以看到cmd窗口的标题栏变了
</code></pre><h2 id="13-ver显示系统版本"><a href="#13-ver显示系统版本" class="headerlink" title="13 ver显示系统版本"></a>13 ver显示系统版本</h2><h2 id="14-label-和-vol设置卷标"><a href="#14-label-和-vol设置卷标" class="headerlink" title="14 label 和 vol设置卷标"></a>14 label 和 vol设置卷标</h2><pre><code>vol                 #显示卷标
label               #显示卷标，同时提示输入新卷标
label c:system      #设置C盘的卷标为 system
</code></pre><h2 id="15-pause暂停命令"><a href="#15-pause暂停命令" class="headerlink" title="15 pause暂停命令"></a>15 pause暂停命令</h2><p>运行该命令时，将显示下面的消息：请按任意键继续 . . .<br>一般用于看清楚屏幕上显示的内容</p>
<h2 id="16-rem-和-注释命令"><a href="#16-rem-和-注释命令" class="headerlink" title="16 rem 和 ::注释命令"></a>16 rem 和 ::注释命令</h2><p>注释行，不执行操作</p>
<h2 id="17-date-和-time日期和时间"><a href="#17-date-和-time日期和时间" class="headerlink" title="17 date 和 time日期和时间"></a>17 date 和 time日期和时间</h2><pre><code>date          #显示当前日期，并提示输入新日期，按&quot;回车&quot;略过输入
date/t        #只显示当前日期，不提示输入新日期
time          #显示当前时间，并提示输入新时间，按&quot;回车&quot;略过输入
time/t        #只显示当前时间，不提示输入新时间
</code></pre><h2 id="18-goto-和-跳转命令"><a href="#18-goto-和-跳转命令" class="headerlink" title="18 goto 和 :跳转命令"></a>18 goto 和 :跳转命令</h2><pre><code>:label        #行首为:表示该行是标签行，标签行不执行操作
goto label    #跳转到指定的标签那一行
</code></pre><h2 id="19-find-外部命令-查找命令"><a href="#19-find-外部命令-查找命令" class="headerlink" title="19 find (外部命令)查找命令"></a>19 find (外部命令)查找命令</h2><pre><code>find &quot;abc&quot; c:\test.txt在 c:\test.txt 文件里查找含 abc 字符串的行如果找不到，将设 errorlevel 返回码为1
find /i &quot;abc&quot; c:\test.txt查找含 abc 的行，忽略大小写
find /c &quot;abc&quot; c:\test.txt显示含 abc 的行的行数
</code></pre><h2 id="20-more-外部命令-逐屏显示"><a href="#20-more-外部命令-逐屏显示" class="headerlink" title="20 more (外部命令)逐屏显示"></a>20 more (外部命令)逐屏显示</h2><pre><code>more c:\test.txt    #逐屏显示 c:\test.txt 的文件内容
</code></pre><h2 id="21-tree显示目录结构"><a href="#21-tree显示目录结构" class="headerlink" title="21 tree显示目录结构"></a>21 tree显示目录结构</h2><pre><code>tree d:\            #显示D盘的文件目录结构
</code></pre><h2 id="22-amp-顺序执行多条命令，而不管命令是否执行成功"><a href="#22-amp-顺序执行多条命令，而不管命令是否执行成功" class="headerlink" title="22 &amp;顺序执行多条命令，而不管命令是否执行成功"></a>22 &amp;顺序执行多条命令，而不管命令是否执行成功</h2><pre><code>c: &amp; cd\ &amp; dir /w   #相当于把下面3行命令写到1行去了c:cd\dir /w
</code></pre><h2 id="23-amp-amp-顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令"><a href="#23-amp-amp-顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令" class="headerlink" title="23 &amp;&amp;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令"></a>23 &amp;&amp;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令</h2><pre><code>f: &amp;&amp; cd\ &amp;&amp; dir &gt;c:\test.txt #注意如果f盘不存在，那么后面2条命令将不会执行
find &quot;ok&quot; c:\test.txt &amp;&amp; echo 成功  #如果找到了&quot;ok&quot;字样，就显示&quot;成功&quot;，找不到就不显示
</code></pre><h2 id="24-顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令"><a href="#24-顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令" class="headerlink" title="24 ||顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令"></a>24 ||顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令</h2><pre><code>find &quot;ok&quot; c:\test.txt || echo 不成功  #如果找不到&quot;ok&quot;字样，就显示&quot;不成功&quot;，找到了就不显示
</code></pre><h2 id="25-管道命令"><a href="#25-管道命令" class="headerlink" title="25 |管道命令"></a>25 |管道命令</h2><p>前一个命令的执行结果输出到后一个命令</p>
<pre><code>dir *.* /s/a | find /c &quot;.exe&quot;
</code></pre><p>管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数</p>
<pre><code>type c:\test.txt|more 这个和 more c:\test.txt 的效果是一样的
</code></pre><h2 id="26-gt-和-gt-gt-输出重定向命令"><a href="#26-gt-和-gt-gt-输出重定向命令" class="headerlink" title="26 &gt; 和 &gt;&gt;输出重定向命令"></a>26 &gt; 和 &gt;&gt;输出重定向命令</h2><pre><code>&gt; 清除文件中原有的内容后再写入

&gt;&gt; 追加内容到文件末尾，而不会清除原有的内容主要将本来显示在屏幕上的内容输出到指定文件中指定文件如果不存在，则自动生成该文件

echo hello world&gt;c:\test.txt生成c:\test.txt文件，内容为hello world这个格式在批处理文件里用得很多，可以成 .reg .bat .vbs 等临时文件

type c:\test.txt &gt;prn屏幕上不显示文件内容，转向输出到打印机
echo hello world&gt;con在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的
copy c:\test.txt f: &gt;nul拷贝文件，并且不显示&quot;文件复制成功&quot;的提示信息，但如果f盘不存在，还是会显示出错信息
copy c:\test.txt f: &gt;nul 2&gt;nul不显示&quot;文件复制成功&quot;的提示信息，并且f盘不存在的话，也不显示错误提示信息
echo ^^W ^&gt; ^W&gt;c:\test.txt生成的文件内容为 ^W &gt; W^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号
</code></pre><h2 id="27-lt-从文件中获得输入信息，而不是从屏幕上"><a href="#27-lt-从文件中获得输入信息，而不是从屏幕上" class="headerlink" title="27 &lt;从文件中获得输入信息，而不是从屏幕上"></a>27 &lt;从文件中获得输入信息，而不是从屏幕上</h2><p>一般用于 date time label 等需要等待输入的命令</p>
<pre><code>@echo offecho 2005-05-01&gt;temp.txtdate &lt;temp.txtdel temp.txt这样就可以不等待输入直接修改当前日期
</code></pre><h2 id="28-命令行传递给批处理参数"><a href="#28-命令行传递给批处理参数" class="headerlink" title="28 命令行传递给批处理参数"></a>28 命令行传递给批处理参数</h2><p>%0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %<em>命令行传递给批处理的参数<br>%0 批处理文件本身%1 第一个参数%9 第九个参数%</em> 从第一个参数开始的所有参数在C盘根目录新建test.bat，内容如下：</p>
<pre><code>@echo off
echo %0
echo %1
echo %2
echo %*
</code></pre><p>运行cmd，输入 <code>c:\test.bat &quot;/a&quot; /b /c /d</code>可以看出每个参数的含意</p>
<p>修改test.bat内容如下</p>
<pre><code>@echo off
echo %1
echo %~1
echo %0
echo %~f0
echo %~d0
echo %~p0
echo %~n0
echo %~x0
echo %~s0
echo %~a0
echo %~t0
echo %~z0
</code></pre><p>再运行cmd，输入 c:\test.bat “/a” /b /c /d可以参照 call/? 或 for/? 看出每个参数的含意。注意这里可以对文件进行日期比较和大小比较</p>
<pre><code>echo load &quot;%%1&quot; &quot;%%2&quot;&gt;c:\test.txt
</code></pre><p>生成的文件内容为 load “%1” “%2”<br>批处理文件里，用这个格式把命令行参数输出到文件</p>
<h2 id="31-set设置变量"><a href="#31-set设置变量" class="headerlink" title="31 set设置变量"></a>31 set设置变量</h2><p>引用变量可在变量名前后加 % ，即 %变量名%</p>
<pre><code>set                    #显示目前所有可用的变量，包括系统变量和自定义的变量
echo %SystemDrive%     #显示系统盘盘符。系统变量可以直接引用
set p                  #显示所有以p开头的变量，要是一个也没有就设errorlevel=1
set p=aa1bb1aa2bb2     #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2
echo %p%               #显示变量p代表的字符串，即aa1bb1aa2bb2
echo %p:~6%            #显示变量p中第6个字符以后的所有字符，即aa2bb2
echo %p:~6,3%          #显示第6个字符以后的3个字符，即aa2
echo %p:~0,3%          #显示前3个字符，即aa1
echo %p:~-2%           #显示最后面的2个字符，即b2
echo %p:~0,-2%         #显示除了最后2个字符以外的其它字符，即aa1bb1aa2b
echo %p:aa=c%          #用c替换变量p中所有的aa，即显示c1bb1c2bb2
echo %p:aa=%           #将变量p中的所有aa字符串置换为空，即显示1bb12bb2
echo %p:*bb=c%         #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2
set p=%p:*bb=c%        #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2
set /a p=39            #设置p为数值型变量，值为39
set /a p=39/10         #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3
set /a p=p/10          #用 /a 参数时，在 = 后面的变量可以不加%直接引用
set /a p=&quot;1&amp;0&quot;         #&quot;与&quot;运算，要加引号。其它支持的运算符参见set/?
set p=                 #取消p变量
set /p p=请输入         #屏幕上显示&quot;请输入&quot;，并会将输入的字符串赋值给变量p注意这条可以用来取代 choice 命令
</code></pre><p>注意变量在 if 和 for 的复合语句里是一次性全部替换的，如</p>
<pre><code>@echo off
set p=aaa
if %p%==aaa (    
  echo %p%   
  set p=bbb    
  echo %p%    )
</code></pre><p>结果将显示aaaaaa因为在读取 if 语句时已经将所有 %p% 替换为aaa这里的”替换”，在 /? 帮助里就是指”扩充”、”环境</p>
<p>变量扩充”可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!</p>
<pre><code>@echo off
SETLOCAL ENABLEDELAYEDEXPANSION
set p=aaaif %p%==aaa (  
  echo %p%    
set p=bbb    
echo !p!    )
ENDLOCAL
</code></pre><p>结果将显示aaabbb<br>还有几个动态变量，运行 set 看不到<br>    %CD%                  #代表当前目录的字符串<br>    %DATE%                #当前日期<br>    %TIME%                #当前时间<br>    %RANDOM%              #随机整数，介于0~32767<br>    %ERRORLEVEL%          #当前ERRORLEVEL 值<br>    %CMDEXTVERSION%       #当前命令处理器扩展名版本号<br>    %CMDCMDLINE%          #调用命令处理器的原始命令行可以用echo命令查看每个变量值，如 echo %time%注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到</p>
<h2 id="32-start调用外部程序"><a href="#32-start调用外部程序" class="headerlink" title="32 start调用外部程序"></a>32 start调用外部程序</h2><p>批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令</p>
<pre><code>start explorer d:\调用图形界面打开D盘
@echo off cd /d %~dp0regedit /s 劲舞团.regstart patcher.exe
</code></pre><p>不加 start 命令的话，”劲舞团”运行时，后面会有个黑乎乎的cmd窗口</p>
<h2 id="33-call调用另外一个批处理"><a href="#33-call调用另外一个批处理" class="headerlink" title="33 call调用另外一个批处理"></a>33 call调用另外一个批处理</h2><p>批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行有时有的应用程序用start调用出错的，也可以call调用</p>
<h2 id="34-choice-外部命令"><a href="#34-choice-外部命令" class="headerlink" title="34 choice (外部命令)"></a>34 choice (外部命令)</h2><p>选择命令让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……win98里</p>
<p>是choice.com win2000pro里没有，可以从win98里拷过来win2003里是choice.exechoice /N /C y /T 5 /D y&gt;nul延时5秒</p>
<p>下面是个 choice 语句的例子<br>    @echo off<br>    rem 以下在win2000pro运行通过，从win98里拷的chioce.com文件<br>    choice /c:abc aaa,bbb,ccc<br>    if errorlevel 3 goto ccc<br>    if %errorlevel%==2 goto bbb<br>    if errorlevel==1 goto aaa<br>rem 必须先判断数值高的返回码rem 可以看到 errorlevel 值的判断有3种写法，有时某种写法不好用，可以用另外的写法<br>rem 直接运行</p>
<p>chioce相当于运行</p>
<pre><code>choice /c:yn:aaa
echo aaa
goto end
:bbb
echo bbb
goto end
:ccc
echo ccc
goto end
:end
</code></pre><h2 id="35-assoc-和-ftype文件关联"><a href="#35-assoc-和-ftype文件关联" class="headerlink" title="35 assoc 和 ftype文件关联"></a>35 assoc 和 ftype文件关联</h2><p>assoc 设置’文件扩展名’关联，关联到’文件类型’ftype 设置’文件类型’关联，关联到’执行程序和参数’</p>
<p>当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开而是先判断.txt属于 txtfile ‘文件类型’再调用 txtfile 关联的命令行 txtfile=%SystemRoot%\system32\NOTEPAD.EXE %1</p>
<p>可以在”文件夹选项”→”文件类型”里修改这2种关联</p>
<pre><code>assoc           #显示所有&apos;文件扩展名&apos;关联
assoc .txt      #显示.txt代表的&apos;文件类型&apos;，结果显示 .txt=txtfile
assoc .doc      #显示.doc代表的&apos;文件类型&apos;，结果显示 .doc=Word.Document.8
assoc .exe      #显示.exe代表的&apos;文件类型&apos;，结果显示 .exe=exefile
ftype           #显示所有&apos;文件类型&apos;关联
ftype exefile   #显示exefile类型关联的命令行，结果显示 exefile=&quot;%1&quot; %* assoc .txt=Word.Document.8设置.txt为word类型的文档，可以看到.txt文件的图标都变了
assoc .txt=txtfile恢复.txt的正确关联 ftype exefile=&quot;%1&quot; %*恢复 exefile 的正确关联
</code></pre><p>如果该关联已经被破坏，可以运行 command.com ，再输入这条命令</p>
<h2 id="36-pushd-和-popd切换当前目录"><a href="#36-pushd-和-popd切换当前目录" class="headerlink" title="36 pushd 和 popd切换当前目录"></a>36 pushd 和 popd切换当前目录</h2><pre><code>@echo off
c: &amp; cd\ &amp; md mp3       #在 C:\ 建立 mp3 文件夹
md d:\mp4               #在 D:\ 建立 mp4 文件夹
cd /d d:\mp4            #更改当前目录为 d:\mp4
pushd c:\mp3            #保存当前目录，并切换当前目录为 c:\mp3
popd                    #恢复当前目录为刚才保存的 d:\mp4一般用处不大，在当前目录名不确定时，会有点帮助
</code></pre><h2 id="37-subst-外部命令-映射磁盘。"><a href="#37-subst-外部命令-映射磁盘。" class="headerlink" title="37 subst (外部命令)映射磁盘。"></a>37 subst (外部命令)映射磁盘。</h2><pre><code>subst z: \\server\d     #这样输入z:就可以访问\\server\d了
subst z: /d             #取消该映射
subst                   #显示目前所有的映射
</code></pre><h2 id="38-xcopy-外部命令-文件拷贝"><a href="#38-xcopy-外部命令-文件拷贝" class="headerlink" title="38  xcopy (外部命令)文件拷贝"></a>38  xcopy (外部命令)文件拷贝</h2><pre><code>xcopy d:\mp3 e:\mp3 /s/e/i/y  #复制 d:\mp3 文件夹、所有子文件夹和文件到 e:\ ，覆盖已有文件。加 /i 表示如果 e:\ 没有 mp3 文件夹就自动新建一个，否则会有询问
</code></pre><h2 id="39-一些不常用的内部命令"><a href="#39-一些不常用的内部命令" class="headerlink" title="39 一些不常用的内部命令"></a>39 一些不常用的内部命令</h2><pre><code>&gt;&amp; 将一个句柄的输出写入到另一个句柄的输入中
&lt;&amp; 从一个句柄读取输入并将其写入到另一个句柄输出中shift 命令行传递给批处理的参数不止9个时，用以切换参数color 设置cmd窗口的显示颜色
pormpt 更改命令提示符号，默认都是 盘符:\路径\&gt; ，如 c:\&gt;
</code></pre><h2 id="40-format-外部命令-格式化硬盘"><a href="#40-format-外部命令-格式化硬盘" class="headerlink" title="40 format (外部命令)格式化硬盘"></a>40 format (外部命令)格式化硬盘</h2><pre><code>format c: /q/u/autotest/q表示快速格式化，/autotest表示自动格式化，不需要按 Y 确认/u表示每字节用 

F6 覆盖硬盘数据，使其不可用软件恢复format c: /c格式化C盘，并检测坏道
</code></pre><h2 id="41-fdisk-外部命令-硬盘分区win2000不带"><a href="#41-fdisk-外部命令-硬盘分区win2000不带" class="headerlink" title="41 fdisk (外部命令)硬盘分区win2000不带"></a>41 fdisk (外部命令)硬盘分区win2000不带</h2><p>该命令win98里的fdisk不支持80G以上大硬盘，winme里的支持fdisk/mbr重建硬盘分区表，一般用于清除引导区病毒、还原精灵注意使用该命令不能从硬盘启动，必须软驱或光驱启动后直接运行</p>
<h2 id="42-ping-外部命令"><a href="#42-ping-外部命令" class="headerlink" title="42 ping (外部命令)"></a>42 ping (外部命令)</h2><pre><code>ping -l 65500 -t 192.168.1.200不停的向192.168.1.200计算机发送大小为65500byte的数据包
ping -n 10 127.0.0.1&gt;nulping自己10次，可用于批处理延时10秒
</code></pre><h2 id="43-SC-外部命令-服务控制命令"><a href="#43-SC-外部命令-服务控制命令" class="headerlink" title="43 SC (外部命令)服务控制命令"></a>43 SC (外部命令)服务控制命令</h2><pre><code>sc create aaa displayname= bbb start= auto binpath= &quot;C:\WINDOWS\System32\alg.exe&quot;创建服务，服务名称aaa，显示名称bbb，启动类型:自动可执行文件的路径&quot;C:\WINDOWS\System32\alg.exe&quot;
sc description aaa &quot;ccc&quot;更改aaa的描述为ccc
sc config aaa start= disabled binpath= &quot;C:\WINDOWS\System32\svchost.exe -k netsvcs&quot;更改aaa的启动类型:已禁用更改aaa的可执行文件的路径&quot;C:\WINDOWS\System32\svchost.exe -k netsvcs&quot;
sc config aaa start= demand displayname= ddd更改aaa的启动类型:手动更改aaa的显示名称ddd
sc start aaa启动aaa服务
sc stop aaa停止aaa服务
sc delete aaa删除aaa服务
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://bbs.bathome.net/thread-39-1-1.html" target="_blank" rel="external">http://bbs.bathome.net/thread-39-1-1.html</a></li>
<li><a href="http://www.cnblogs.com/DswCnblog/p/5436245.html" target="_blank" rel="external">http://www.cnblogs.com/DswCnblog/p/5436245.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 批处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 批处理 </tag>
            
            <tag> bat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[纪录片《轮回》观后记录]]></title>
      <url>/2017/09/25/samsara_documentary/</url>
      <content type="html"><![CDATA[<p><img src="/2017/09/25/samsara_documentary/samsara.png" alt=""></p>
<p><img src="/2017/09/25/samsara_documentary/douban.png" alt=""></p>
<blockquote>
<p>多图预警，流量慎点。GIF较大，可能加载会比较慢。</p>
</blockquote>
<a id="more"></a>
<p>001300 - 001640 延时摄影，日月星辰，风景变换。</p>
<h3 id="001804"><a href="#001804" class="headerlink" title="001804"></a>001804</h3><p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkp6wv52cj20z50ev1kx.jpg" alt=""></p>
<p>海啸后两幢平房中间翻斜挤压变形的汽车。</p>
<h3 id="00-21-06"><a href="#00-21-06" class="headerlink" title="00:21:06"></a>00:21:06</h3><p><img src="https://wx4.sinaimg.cn/mw690/c38a0784ly1fmkqnssi3jj20ws0elaz2.jpg" alt=""></p>
<p>巴西圣保罗的教堂中，儿童们在接受洗礼。 与此对比的是，00:25:15处一个夭折的小男孩躺在棺材里。 </p>
<h3 id="00-34-50"><a href="#00-34-50" class="headerlink" title="00:34:50"></a>00:34:50</h3><p>车灯比较有意思。车道右侧是向上前进的车，尾灯是红色的，前灯有白色的，还有蓝青色的。</p>
<p><img src="https://wx3.sinaimg.cn/mw1024/c38a0784ly1fmopqiv5sag20mw0ex7wh.gif" alt=""></p>
<p>追踪汽车尾灯的效果实在是太赞了。 </p>
<h3 id="00-39-49"><a href="#00-39-49" class="headerlink" title="00:39:49"></a>00:39:49</h3><p>法国行为艺术家Olivier de Sagazan震撼人心的表演。此人以往自己脸上身上涂粘土和颜料著称，展现人类内在的兽性。</p>
<p>当这个诡异的类似伏地魔的表演结束之后，用一个机器人表现出震惊的样子，实在是笑死。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkp69l047g20bt08h7wh.gif" alt=""></p>
<p>前面的表演的确震惊，表面斯文的人，作出如此疯狂的动作。</p>
<h3 id="00-41-00"><a href="#00-41-00" class="headerlink" title="00:41:00"></a>00:41:00</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkpldoazvj21ej0l8kjl.jpg" alt=""></p>
<p>人跌倒时候的配乐是亮点，第一次看的时候忍不住笑了，这么正经的片子，居然还有这种效果，哈哈。</p>
<h3 id="00-41-11"><a href="#00-41-11" class="headerlink" title="00:41:11"></a>00:41:11</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqns1fskj20z60eq1ee.jpg" alt=""><br><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplbrdpfj20yt0em1kx.jpg" alt=""><br><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplc97q0j20yz0es1kx.jpg" alt=""></p>
<p>迪拜的一系列人工奇迹：号称世界上唯一的七星级酒店——阿联酋迪拜的阿拉伯塔酒店（Burj Al Arab）。（阿拉伯塔酒店因外形酷似船帆，又称迪拜帆船酒店）</p>
<p>第一张图的右侧是其外观，左侧为清真寺。</p>
<p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplcixuoj20z10el7wh.jpg" alt=""><br><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnrxy5qj20zk0doe4l.jpg" alt=""></p>
<p>大型的填海工程令人叹为观止。</p>
<p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplc8shaj20zg0ez1kx.jpg" alt=""></p>
<p>迪拜的一系列人工奇迹: 迪拜购物中心，全球第一大购物中心。</p>
<p>室内瀑布也是迪拜购物中心的标志景观，位于中庭处，24米高的瀑布至今还保持着一个世界纪录，即世界上第一高的室内喷泉。瀑布中还设置了一排排跳水运动员塑像，动作整齐划一，栩栩如生。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkplcszhuj20yl0eyhcm.jpg" alt=""></p>
<p>迪拜的一系列人工奇迹: 世界第一高楼——哈里发塔（Burj Khalifa），也可译为哈利法塔。</p>
<p>这座全球第一高塔位于Downtown，与迪拜音乐喷泉（The Dubai Fountain）、迪拜购物中心（The Dubai Mall）相距不远。</p>
<h3 id="00-44-35"><a href="#00-44-35" class="headerlink" title="00:44:35"></a>00:44:35</h3><p>两名时尚女郎走在意大利米兰的埃马努埃莱二世拱廊（Galleria Vittorio Emanuele II）中。拱廊一端的斯卡拉大剧院（La Scala）。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkp6aeghxg20bt0721ky.gif" alt=""></p>
<p>左边这妹子的裤子看来需要我帮她提一下哈哈哈。</p>
<h3 id="……"><a href="#……" class="headerlink" title="……"></a>……</h3><p>中间省略一些，主要是繁忙的交通、生产（销毁）流水线、超市疯狂采购以及疯狂吃的人越来越胖具体内容如下：</p>
<p>日本东京繁忙的地铁。一些另类的奇装异服者。</p>
<p>厦门灿坤集团在福建漳州的小家电工厂城。工人们在流水线上如机器人般的劳作。马上跟着回收站中各种电器被压扁、绞碎、封存、筛选。同样是流水作业，一个制造，一个销毁。<br>郑州三全食品股份有限公司的速冻食品生产基地。一个个饺子就这样高效的产出。</p>
<p>在高度机械化的丹麦，一台神奇的机器把一只只活鸡收入囊中。在中国长春，身着粉红色防护服的工人们在把整鸡大卸八块。在美国加州，奶牛们头朝内尾朝外肩并肩的被放在大转盘上转啊转的被挤奶。</p>
<p>超市里，人们在疯狂购物。餐厅里，三个胖子在饕餮着垃圾食品。</p>
<p>最后，讽刺地是，吃胖了的人也得像鸡、猪一样，被画线切开、动手术。</p>
<p>同样需要画线的还有充气娃娃。。。</p>
<h3 id="00-57-30"><a href="#00-57-30" class="headerlink" title="00:57:30"></a>00:57:30</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnsykipj20zc0erkga.jpg" alt=""></p>
<p>日本生产充气娃娃的工厂。后面的就不截了。</p>
<h3 id="00-58-35"><a href="#00-58-35" class="headerlink" title="00:58:35"></a>00:58:35</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnta9q7j20zc0ey4qp.jpg" alt=""></p>
<p>泰国人妖俱乐部里，人妖们身着比基尼搔首弄姿的跳着钢管舞。</p>
<h3 id="01-00-20"><a href="#01-00-20" class="headerlink" title="01:00:20"></a>01:00:20</h3><p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkqnsdia3j20z10e9x0r.jpg" alt=""></p>
<p>伏见稻荷大社，日本京都市伏见区的稻荷神社（Fushimi Inari-taisha）。竖立的鸟居（Torii）排列成一条长长的甬道，即闻名于世的千本鸟居。</p>
<p>稻荷神是农业与商业的神明，香客前来祭拜求取农作丰收、生意兴隆、交通安全。它是京都地区香火最盛的神社之一。（摘自百科）</p>
<h3 id="01-01-31"><a href="#01-01-31" class="headerlink" title="01:01:31"></a>01:01:31</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkpljuhi3j20z30ef1kx.jpg" alt=""></p>
<p>上海黄浦江畔高楼林立。</p>
<h3 id="01-03-50"><a href="#01-03-50" class="headerlink" title="01:03:50"></a>01:03:50</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkp6pt1usj20z50eq4qp.jpg" alt=""></p>
<p>菲律宾宿务市（Cebu City）的一个监狱~ 比起让犯人做什么手工活，大概每个月都教他们一个新的舞蹈，还要在家属面前表演…</p>
<p>男人们卖力的跳着，女人们轻柔的和着，典狱长漠然的看着。</p>
<h3 id="01-06-59"><a href="#01-06-59" class="headerlink" title="01:06:59"></a>01:06:59</h3><p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkqns0xh9j20nm0a0ast.jpg" alt=""></p>
<p>这种房子的结构不错。</p>
<p>一边住人，一边养花草。很赞，第一次见到。</p>
<h3 id="01-10-00"><a href="#01-10-00" class="headerlink" title="01:10:00"></a>01:10:00</h3><p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkplbyledj20xy0ed1kx.jpg" alt="sulphur"></p>
<p>印尼的（卡瓦）伊真（Ijen）（活）火山上，赤膊的工人们在极具腐蚀性的硫酸雾气中把成筐的硫磺矿挑走。</p>
<h3 id="01-17-40"><a href="#01-17-40" class="headerlink" title="01:17:40"></a>01:17:40</h3><p><img src="/2017/09/25/samsara_documentary/yuebing.png" alt=""></p>
<p>中国国庆大阅兵。</p>
<h3 id="01-18-16"><a href="#01-18-16" class="headerlink" title="01:18:16"></a>01:18:16</h3><p><img src="/2017/09/25/samsara_documentary/school.png" alt=""></p>
<p>少林寺塔沟武校。</p>
<p>小时候，看了少年包青天之类的电视剧，就好想去武校学习的啊，可惜。</p>
<h3 id="01-19-31"><a href="#01-19-31" class="headerlink" title="01:19:31"></a>01:19:31</h3><p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkp6pck6oj20nm09zam0.jpg" alt=""></p>
<p>韩国的条子。不要问我怎么知道的（看字）。</p>
<h3 id="01-20-00"><a href="#01-20-00" class="headerlink" title="01:20:00"></a>01:20:00</h3><p><img src="https://wx4.sinaimg.cn/mw690/c38a0784ly1fmkp68jz5ej20nm09w188.jpg" alt="Berlin_Wall"></p>
<p>柏林墙是是这种大块的条状建筑组成，上面有很多涂鸦。</p>
<p><img src="/2017/09/25/samsara_documentary/Wailing_Wall.png" alt=""></p>
<p>耶路撒冷哭墙（Western/Wailing Wall）。哭墙是由砖块石头组成。</p>
<p>之前两个没有区分开，所以特此说明一下。</p>
<h3 id="01-33-00"><a href="#01-33-00" class="headerlink" title="01:33:00"></a>01:33:00</h3><p>千手观音是最美的。</p>
<p>由21位聋哑人表演的千手观音舞蹈。领舞是自幼失聪的邰丽华。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkp6a4yhrg20fr07p1ky.gif" alt=""></p>
<p>首尾呼应。此处有表演，开头的时候没有。</p>
<h3 id="01-25-29"><a href="#01-25-29" class="headerlink" title="01:25:29"></a>01:25:29</h3><p>影片接近尾声，镜头来到沙特麦加，记录下几百万汇聚在清真寺周围的虔诚信徒，如沙，如画。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkp68zpl5g20fr06mhdt.gif" alt=""></p>
<p>沙特麦加的禁寺（Masjid al-Haram）朝拜。镜头越来越高，那如沙砾般的白点点啊，围着克尔白（Kaaba）不停的转啊转。 </p>
<p>(让我想起了刚做的数模中动目标检测的那个素材。。17年全国研究生数模D题)</p>
<h3 id="01-30-47"><a href="#01-30-47" class="headerlink" title="01:30:47"></a>01:30:47</h3><p>转眼间，镜头又回到了华美绚烂而又精密有序的坛城沙画。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkplcn5epj20vi0dbb29.jpg" alt=""></p>
<p>然而，讶异的观众们此时看见，这个刚刚用沙子堆砌起来的世界，历经了积年累月呕心沥的创作，却在完成之后被毫不犹豫地全盘抹去。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkqnrutzaj20nm0a97n3.jpg" alt=""></p>
<p>一件拥有无上艺术价值的作品，顷刻之间，便化为乌有。</p>
<p>对于修行者来说，他们和它们的使命都已完成。于是那些色泽明艳的细沙将被装入瓶中，倾倒入河，顺流而去。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnrwlpej20nm0aawwb.jpg" alt=""></p>
<p><strong>繁华世界，不过一掬细沙</strong>。</p>
<blockquote>
<p>部分文字参考自豆瓣影评<a href="https://movie.douban.com/review/5584916/" target="_blank" rel="external">一沙一世界</a>，<a href="https://movie.douban.com/review/5815859/" target="_blank" rel="external">无声引导沉思</a>。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 观影指南 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 轮回 </tag>
            
            <tag> 纪录片 </tag>
            
            <tag> samsara </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DeepLearnToolBox之BP算法]]></title>
      <url>/2017/09/23/DeepLearnToolBox_BP/</url>
      <content type="html"><![CDATA[<p>这篇文章只要是基于BP网络代码的简单分析，基于公式推导的文章请参阅：<a href="https://qwerty200696.github.io/2017/09/12/BP_derivation/" target="_blank" rel="external">BP神经网络部分具体的推导</a>。<br><a id="more"></a></p>
<h1 id="工具箱下载"><a href="#工具箱下载" class="headerlink" title="工具箱下载"></a>工具箱下载</h1><p>下载地址：<br><a href="https://github.com/rasmusbergpalm/DeepLearnToolbox" target="_blank" rel="external">https://github.com/rasmusbergpalm/DeepLearnToolbox</a></p>
<h1 id="总体测试代码"><a href="#总体测试代码" class="headerlink" title="总体测试代码"></a>总体测试代码</h1><p>\tests\test_example_NN.m</p>
<pre><code>nn = nnsetup([784 100 10]);  
opts.numepochs =  1;   //  Number of full sweeps through data  
opts.batchsize = 100;  //  Take a mean gradient step over this many samples  
[nn, L] = nntrain(nn, train_x, train_y, opts);  
[er, bad] = nntest(nn, test_x, test_y); 
</code></pre><p>很简单的几步就训练了一个NN，我们发现其中最重要的几个函数就是<code>nnsetup</code>,<code>nntrain</code>和<code>nntest</code>了。</p>
<h1 id="nnsetup"><a href="#nnsetup" class="headerlink" title="nnsetup"></a>nnsetup</h1><p><code>NNSETUP</code>创建前向反馈神经网络。</p>
<h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>详细代码如下：</p>
<pre><code>function nn = nnsetup(architecture)
%NNSETUP creates a Feedforward Backpropagate Neural Network
% nn = nnsetup(architecture) returns an neural network structure with n=numel(architecture)
% layers, architecture being a n x 1 vector of layer sizes e.g. [784 100 10]

    nn.size   = architecture;
    nn.n      = numel(nn.size);

    nn.activation_function              = &apos;tanh_opt&apos;;   %  Activation functions of hidden layers: &apos;sigm&apos; (sigmoid) or &apos;tanh_opt&apos; (optimal tanh).
    nn.learningRate                     = 1;            %  learning rate Note: typically needs to be lower when using &apos;sigm&apos; activation function and non-normalized inputs.
    nn.momentum                         = 0.5;          %  Momentum 权值动量因子
    nn.scaling_learningRate             = 1;            %  Scaling factor for the learning rate (each epoch) 学习率变化因子 (each epoch)
    nn.weightPenaltyL2                  = 0;            %  L2 regularization
    nn.nonSparsityPenalty               = 0;            %  Non sparsity penalty 非稀疏惩罚
    nn.sparsityTarget                   = 0.05;         %  Sparsity target 稀疏目标值
    nn.inputZeroMaskedFraction          = 0;            %  Used for Denoising AutoEncoders 自动编码的去噪作用
    nn.dropoutFraction                  = 0;            %  Dropout level (http://www.cs.toronto.edu/~hinton/absps/dropout.pdf)
    nn.testing                          = 0;            %  Internal variable. nntest sets this to one. 一个标志参数--在nntest.m这个函数中会用到
    nn.output                           = &apos;softmax&apos;;       %  output unit &apos;sigm&apos; (=logistic), &apos;softmax&apos; and &apos;linear&apos;

    for i = 2 : nn.n   
        % weights and weight momentum
        nn.W{i - 1} = (rand(nn.size(i), nn.size(i - 1)+1) - 0.5) * 2 * 4 * sqrt(6 / (nn.size(i) + nn.size(i - 1)));
        nn.vW{i - 1} = zeros(size(nn.W{i - 1}));

        % average activations (for use with sparsity)
        nn.p{i}     = zeros(1, nn.size(i));   
    end
end
</code></pre><p>nnsetup初始化网络结构以及一系列参数。对照着代码，看一下具体含义。</p>
<p><code>nn = nnsetup(architecture)</code>返回一个神经网络结构，<code>architecture</code>为结构参数。<code>architecture</code>是一个n x 1 向量，表示每一层神经元的个数。</p>
<p>比如<code>architecture=[784 100 10]</code>，表示输入层为784维输入，100个隐含层，10个输出层</p>
<p>为什么是输入为784：因为每一个手写体大小为28*28的，也就是784维度</p>
<p>隐含层为什么是100：随便设置的，可以随意修改，需要设计</p>
<p>输出为什么是10：手写体有0-9这10种结果，所以为10</p>
<p>//对每一层的网络结构进行初始化，一共三个参数W,vW，p，其中W是主要的参数<br>//<code>vW</code>是更新参数时的临时参数，p是所谓的<code>sparsity</code>，(等看到代码了再细讲) </p>
<p>##使用实例</p>
<pre><code>nn=nnsetup([size(feature,2) 200 200 length(azimuth)]);
</code></pre><h1 id="nntrain"><a href="#nntrain" class="headerlink" title="nntrain"></a>nntrain</h1><p>截取出的主要框架为：</p>
<pre><code>for i = 1 : numepochs 
    for l = 1 : numbatches  

        nn = nnff(nn, batch_x, batch_y);  
        nn = nnbp(nn);  
        nn = nnapplygrads(nn);  
        L(n) = nn.L;  
        n = n + 1;  
    end  
end  
</code></pre><p>第一层for循环为迭代次数。第二次为遍历所有的batch。其中，先计算前向传播（<code>ff</code>），在计算反向传播（<code>bp</code>），接着更新参数（<code>nnapplygrads</code>），最后计算损失函数（代价函数）L。</p>
<p>下面分析三个函数<code>nnff</code>,<code>nnbp</code>和<code>nnapplygrads</code>。</p>
<h2 id="nnff"><a href="#nnff" class="headerlink" title="nnff"></a>nnff</h2><p>nnff就是进行<code>feedforward pass</code>，其实非常简单，就是整个网络正向跑一次就可以了</p>
<p>当然其中有dropout和sparsity的计算,具体的参见论文“<code>Improving Neural Networks with Dropout</code>“和<code>Autoencoders and Sparsity</code></p>
<p>提取出主要框架为：</p>
<pre><code>for i = 2 : n-1  （遍历隐含层）
    //根据激活函数计算隐层输出

    //隐层的dropout计算，舍弃部分输出

    //计算sparsity，nonSparsityPenalty 是对没达到sparsitytarget的参数的惩罚系数

    //Add the bias term 
end

//根据输出层的结构计算输出层的输出。

//计算误差以及损失函数  
</code></pre><h2 id="nnbp"><a href="#nnbp" class="headerlink" title="nnbp"></a>nnbp</h2><p>代码：<code>\NN\nnbp.m</code><br>nnbp呢是进行<code>back propagation</code>的过程。值得注意的还是dropout和sparsity的部分。</p>
<p>提取出主要框架为：</p>
<pre><code>①计算输出层的输出
②依次反向计算隐层输出
for i = (n - 1) : -1 : 2 （反向遍历隐层）
    d_act为隐层 激活函数的导数

    d{i}为隐层输出函数的导数。 计算中用到非稀疏惩罚项，以及dropout
end

③计算权值的导数nn.dW{i}
</code></pre><p>dW{i}基本就是计算的<code>gradient</code>(梯度)了，只是后面还要加入一些东西，进行一些修改。</p>
<h2 id="nnapplygrads"><a href="#nnapplygrads" class="headerlink" title="nnapplygrads"></a>nnapplygrads</h2><p>代码文件：<code>\NN\nnapplygrads.m</code></p>
<pre><code>for i = 1 : (nn.n - 1)

    //应用weightPenaltyL2，learningRate ，momentum修正dW

    nn.W{i} = nn.W{i} - dW;  //权值W更新

end
</code></pre><p>这个内容就简单了，<code>nn.weightPenaltyL2</code>是<code>weight decay</code>的部分，也是nnsetup时可以设置的一个参数</p>
<p>有的话就加入<code>weight Penalty</code>，防止过拟合，然后再根据<code>momentum</code>的大小调整一下，最后改变<code>nn.W{i}</code>即可</p>
<h1 id="nntest"><a href="#nntest" class="headerlink" title="nntest"></a>nntest</h1><pre><code>function [er, bad] = nntest(nn, x, y)  
    labels = nnpredict(nn, x);  
    [~, expected] = max(y,[],2);  
    bad = find(labels ~= expected);      
    er = numel(bad) / size(x, 1);  
end  
</code></pre><p><code>nntest</code>再简单不过了，就是调用一下<code>nnpredict</code>，在和test的集合进行比较</p>
<h2 id="nnpredict"><a href="#nnpredict" class="headerlink" title="nnpredict"></a>nnpredict</h2><p>代码文件：<code>\NN\nnpredict.m</code></p>
<pre><code>function labels = nnpredict(nn, x)  
    nn.testing = 1;  
    nn = nnff(nn, x, zeros(size(x,1), nn.size(end)));  
    nn.testing = 0;  

    [~, i] = max(nn.a{end},[],2);  
    labels = i;  
end  
</code></pre><p>继续非常简单，<code>predict</code>不过是<code>nnff</code>一次，得到最后的output~~</p>
<p><code>max(nn.a{end},[],2);</code> 是返回每一行的最大值以及所在的列数，所以labels返回的就是标号啦<br>(这个test好像是专门用来test分类问题的，我们知道nnff得到最后的值即可)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章只要是基于代码的简单分析，基于公式推导的文章请参阅：<a href="https://qwerty200696.github.io/2017/09/12/BP_derivation/" target="_blank" rel="external">BP神经网络部分具体的推导</a>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.sina.com.cn/s/blog_4a1853330102vupc.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4a1853330102vupc.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017“华为杯”第十四届中国研究生数学建模竞赛回顾]]></title>
      <url>/2017/09/22/review_of_MathModel/</url>
      <content type="html"><![CDATA[<h1 id="试题下载地址"><a href="#试题下载地址" class="headerlink" title="试题下载地址"></a>试题下载地址</h1><p>中国研究生数模竞赛官网：<a href="http://gmcm.seu.edu.cn/01/49/c12a329/page.htm" title="2017年研究生数模竞赛试题公布" target="_blank" rel="external">http://gmcm.seu.edu.cn/01/49/c12a329/page.htm</a></p>
<p>我们组选择了D题。<br><a id="more"></a></p>
<h2 id="D题题目"><a href="#D题题目" class="headerlink" title="D题题目"></a>D题题目</h2><h3 id="基于监控视频的前景目标提取"><a href="#基于监控视频的前景目标提取" class="headerlink" title="基于监控视频的前景目标提取"></a>基于监控视频的前景目标提取</h3><p>视频监控是中国安防产业中最为重要的信息获取手段。随着“平安城市”建设的顺利开展，各地普遍安装监控摄像头，利用大范围监控视频的信息，应对安防等领域存在的问题。近年来，中国各省市县乡的摄像头数目呈现井喷式增长，大量企业、部门甚至实现了监控视频的全方位覆盖。如北京、上海、杭州监控摄像头分布密度约分别为71、158、130个/平方公里，摄像头数量分别达到115万、100万、40万，为我们提供了丰富、海量的监控视频信息。</p>
<p>目前，监控视频信息的自动处理与预测在信息科学、计算机视觉、机器学习、模式识别等多个领域中受到极大的关注。而如何有效、快速抽取出监控视频中的前景目标信息，是其中非常重要而基础的问题[1-6]。这一问题的难度在于，需要有效分离出移动前景目标的视频往往具有复杂、多变、动态的背景[7，8]。这一技术往往能够对一般的视频处理任务提供有效的辅助。以筛选与跟踪夜晚时罪犯这一应用为例：若能够预先提取视频前景目标，判断出哪些视频并未包含移动前景目标，并事先从公安人员的辨识范围中排除；而对于剩下包含了移动目标的视频，只需辨识排除了背景干扰的纯粹前景，对比度显著，肉眼更易辨识。因此，这一技术已被广泛应用于视频目标追踪，城市交通检测，长时场景监测，视频动作捕捉，视频压缩等应用中。</p>
<p>下面简单介绍一下视频的存储格式与基本操作方法。一个视频由很多帧的图片构成，当逐帧播放这些图片时，类似放电影形成连续动态的视频效果。从数学表达上来看，存储于计算机中的视频，可理解为一个3维数据，其中代表视频帧的长，宽，代表视频帧的帧数。视频也可等价理解为逐帧图片的集合，即，其中为一张长宽分别为的图片。3维矩阵的每个元素（代表各帧灰度图上每个像素的明暗程度）为0到255之间的某一个值，越接近0，像素越黑暗；越接近255，像素越明亮。通常对灰度值预先进行归一化处理（即将矩阵所有元素除以255），可将其近似认为[0,1]区间的某一实数取值，从而方便数据处理。一张彩色图片由R（红），G（绿），B（蓝）三个通道信息构成，每个通道均为同样长宽的一张灰度图。由彩色图片构成的视频即为彩色视频。本问题中，可仅考虑黑白图片构成的视频。在Matlab环境下，视频的读取、播放及相应基本操作程序见附件1。如采用其他编程环境，也可查阅相关资料获得相应操作程序。</p>
<p>题目的监控视频主要由固定位置监控摄像头拍摄，要解决的问题为提取视频前景目标。请研究生通过设计有效的模型与方法，自动从视频中分离前景目标。注意此类视频的特点是相对于前景目标，背景结构较稳定，变化幅度较小，可充分利用该信息实现模型与算法设计。</p>
<p>请你们查阅相关资料和数据，结合视频数据特点，回答下列问题：</p>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a><strong>问题1</strong></h3><p>对一个不包含动态背景、摄像头稳定拍摄时间大约5秒的监控视频，构造提取前景目标（如人、车、动物等）的数学模型，并对该模型设计有效的求解方法，从而实现类似图1的应用效果。（附件2提供了一些符合此类特征的监控视频）</p>
<p><img src="/2017/09/22/review_of_MathModel/pic_1.png" alt=""></p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a><strong>问题2</strong></h3><p>对包含动态背景信息的监控视频（如图2所示），设计有效的前景目标提取方案。（附件2中提供了一些符合此类特征的典型监控视频）</p>
<p><img src="/2017/09/22/review_of_MathModel/pic_2.png" alt=""></p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a><strong>问题3</strong></h3><p>在监控视频中，当监控摄像头发生晃动或偏移时，视频也会发生短暂的抖动现象（该类视频变换在短时间内可近似视为一种线性仿射变换，如旋转、平移、尺度变化等）。对这种类型的视频，如何有效地提取前景目标？（附件2中提供了一些符合此类特征的典型监控视频，其它一些典型视频可从 <a href="http://wordpress-jodoin.dmi.usherb.ca/dataset2014/" target="_blank" rel="external">http://wordpress-jodoin.dmi.usherb.ca/dataset2014/</a> 下载）</p>
<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a><strong>问题4</strong></h3><p>在附件3中提供了8组视频（avi文件与mat文件内容相同）。请利用你们所构造的建模方法，从每组视频中选出包含显著前景目标的视频帧标号，并将其在建模论文正文中独立成段表示。务须注明前景目标是出现于哪一个视频（如Campus视频）的哪些帧（如241-250，421-432帧）。</p>
<h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a><strong>问题5</strong></h3><p>如何通过从不同角度同时拍摄的近似同一地点的多个监控视频中（如图3所示）有效检测和提取视频前景目标？请充分考虑并利用多个角度视频的前景之间（或背景之间）相关性信息（一些典型视频可从<br><a href="http://cvlab.epfl.ch/research/surv/multi-people-tracking" target="_blank" rel="external">http://cvlab.epfl.ch/research/surv/multi-people-tracking</a> 下载）</p>
<p><img src="/2017/09/22/review_of_MathModel/pic_3.png" alt=""></p>
<h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a><strong>问题6</strong></h3><p>利用所获取前景目标信息，能否自动判断监控视频中有无人群短时聚集、人群惊慌逃散、群体规律性变化（如跳舞、列队排练等）、物体爆炸、建筑物倒塌等异常事件？可考虑的特征信息包括前景目标奔跑的线性变化形态特征、前景规律性变化的周期性特征等。尝试对更多的异常事件类型，设计相应的事件检测方案。（请从网络下载包含各种事件的监控视频进行算法验证）</p>
<p>注：强烈建议深刻考虑问题内涵，建造合理、高效的数学模型和求解方法，鼓励进行具有开放思路与创新思维的探索性尝试。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Andrews Sobral &amp; Antoine Vacavant, A comprehensive review of background subtraction algorithms evaluated with synthetic and real videos, Computer Vision and Image Understanding, Volume 122, May 2014, Pages 4-21</p>
<p>[2] B. Lee and M. Hedley, “Background estimation for video surveillance,” IVCNZ02, pp. 315–320, 2002.</p>
<p>[3] C. Stauffer and W. E. L. Grimson, “Adaptive background mixture models for real-time tracking,” in Computer Vision and Pattern Recognition, 1999. IEEE Computer Society Conference on., vol. 2. IEEE, 1999.</p>
<p>[4] E. J. Cand`es, X. Li, Y. Ma, and J. Wright, “Robust principal component analysis?” Journal of the ACM (JACM), vol. 58, no. 3, p. 11, 2011.</p>
<p>[5] D. Meng and F. De la Torre, “Robust matrix factorization with unknown noise,” in IEEE International Conference on Computer Vision, 2013, pp. 1337–1344.</p>
<p>[6] Q. Zhao, D. Meng, Z. Xu,W. Zuo, and L. Zhang, “Robust principal component analysis with complex noise,” in Proceedings of the 31st International Conference on Machine Learning (ICML-14), 2014, pp. 55–63.</p>
<p>[7] Y. Peng, A. Ganesh, J. Wright, W. Xu, and Y. Ma, “RASL: Robust alignment by sparse and low-rank decomposition for linearly correlated images,” Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 34, no. 11, pp. 2233–2246, 2012.</p>
<p>[8] M. Babaee, D. T. Dinh, and G. Rigoll, “A deep convolutional neural network for background subtraction,” arXiv preprint arXiv: 1702.01731, 2017.</p>
<h1 id="思路流程"><a href="#思路流程" class="headerlink" title="思路流程"></a>思路流程</h1><p>不阐述为什么这么做（因为我也不知道为什么），只记录下我所做的工作历程。</p>
<h2 id="BGSLibrary编译安装与BGSlibrary-GUI的下载与使用"><a href="#BGSLibrary编译安装与BGSlibrary-GUI的下载与使用" class="headerlink" title="BGSLibrary编译安装与BGSlibrary GUI的下载与使用"></a>BGSLibrary编译安装与BGSlibrary GUI的下载与使用</h2><p>这部分详情可参考我的博客：<a href="https://qwerty200696.github.io/2017/09/20/BGSlibrary/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/20/BGSlibrary/</a></p>
<h2 id="ViBe算法"><a href="#ViBe算法" class="headerlink" title="ViBe算法"></a>ViBe算法</h2><p>一种像素级视频背景建模或前景检测的算法。</p>
<p>详细地可参考ViBe算法官网主页：<a href="http://www.telecom.ulg.ac.be/research/vibe/" target="_blank" rel="external">ViBe官网链接</a></p>
<p>该官网包含ViBe源码以及可在Windows和Linux中运行的程序。想了解该算法的童鞋可以详细探索该网站。</p>
<p>这篇<a href="http://blog.csdn.net/zouxy09/article/details/9622285" target="_blank" rel="external">CSDN博客</a>介绍的也比较全面，可作参考。</p>
<h2 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h2><p>LK光流法分析及其源码请参考我的这篇文章：<a href="https://qwerty200696.github.io/2017/09/21/optical_flow/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/optical_flow/</a></p>
<h2 id="视频抗抖动算法"><a href="#视频抗抖动算法" class="headerlink" title="视频抗抖动算法"></a>视频抗抖动算法</h2><p>参考链接：<a href="http://nghiaho.com/?p=2093" target="_blank" rel="external">SIMPLE VIDEO STABILIZATION USING OPENCV</a></p>
<p>采用的方法是基于optical flow 光流法。</p>
<p>算法流程：</p>
<p>&emsp;1 使用所有帧中的光流信息来查找从前一帧到当前帧的转换</p>
<p>&emsp;2 累积变换以获得每个帧的x，y，a 的轨迹</p>
<p>&emsp;3 使用滑动平均窗口对轨迹平滑处理</p>
<p>&emsp;4 创建一个新的变换，使得$F_{new}$ = $F_{old}$ + ( $T_{smoothed}$ - $T_{before}$ )</p>
<p>&emsp;5 将新的转换应用到视频中，得到去抖后的视频</p>
<p>其中 dx、dy 为x 和y 方向的流向，da 为抖动中旋转角度的变化量; $F_{new}$、$F_{old}$分别为新的变换与原先的变换，$T_{smoothed}$、$T_{before}$分别为平滑前后的轨迹。</p>
<p><font color="#FF0000"> Camera Jitter 相机抖动</font> 数据集下载：<br><a href="http://wordpress-jodoin.dmi.usherb.ca/dataset2014/" target="_blank" rel="external">http://wordpress-jodoin.dmi.usherb.ca/dataset2014/</a></p>
<h2 id="opencv视频保存方法"><a href="#opencv视频保存方法" class="headerlink" title="opencv视频保存方法"></a>opencv视频保存方法</h2><p>视频保存方法请参考这篇博文：<a href="https://qwerty200696.github.io/2017/09/21/opencv_SaveVideo/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/opencv_SaveVideo/</a></p>
<h2 id="opencv-contrib安装"><a href="#opencv-contrib安装" class="headerlink" title="opencv_contrib安装"></a>opencv_contrib安装</h2><p>opencv_contrib的安装说明可以参考这篇博文<a href="https://qwerty200696.github.io/2017/09/21/opencv_contrib/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/opencv_contrib/</a></p>
<h2 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h2><h3 id="动目标检测"><a href="#动目标检测" class="headerlink" title="动目标检测"></a>动目标检测</h3><p><a href="http://wordpress-jodoin.dmi.usherb.ca/dataset2014/" target="_blank" rel="external">dataset 2014</a> 里面的视频分类详细，很好的数据集。</p>
<h3 id="目标跟踪"><a href="#目标跟踪" class="headerlink" title="目标跟踪"></a>目标跟踪</h3><p><a href="http://www.learnopencv.com/object-tracking-using-opencv-cpp-python/" target="_blank" rel="external">Object Tracking using OpenCV (C++/Python)</a></p>
<p>这个算是做的比较好的了，很有参考价值。</p>
<p>D题问题五给出的网址：<a href="http://cvlab.epfl.ch/research/surv/multi-people-tracking" target="_blank" rel="external">http://cvlab.epfl.ch/research/surv/multi-people-tracking</a></p>
<p>视频流跟踪目标<a href="https://github.com/gnebehay/OpenTLD" target="_blank" rel="external">OpenTLD</a></p>
<p><a href="http://mha.cs.umn.edu/proj_tracking.shtml" target="_blank" rel="external">Real-Time Tracking</a></p>
<h3 id="多角度多目标跟踪"><a href="#多角度多目标跟踪" class="headerlink" title="多角度多目标跟踪"></a>多角度多目标跟踪</h3><p><a href="http://www.pierrebaque.com/page-DeepOcclusion/" target="_blank" rel="external">Deep Occlusion Reasoning for Multi-Camera Multi-Target Detection</a></p>
<p><a href="https://github.com/pierrebaque/DeepOcclusion" target="_blank" rel="external">DeepOcclusion</a></p>
<h3 id="人群异常行为检测"><a href="#人群异常行为检测" class="headerlink" title="人群异常行为检测"></a>人群异常行为检测</h3><p><a href="http://groups.inf.ed.ac.uk/vision/BEHAVEDATA/INTERACTIONS/" target="_blank" rel="external">BEHAVE Interactions Test Case Scenarios</a></p>
<p><a href="http://mha.cs.umn.edu/proj_events.shtml" target="_blank" rel="external">Detection of Events</a></p>
<p>UCF数据集：<a href="http://crcv.ucf.edu/data/crowd.php" target="_blank" rel="external">Crowd Segmentation Data Set</a> 这是正常行为的，没找到不正常行为的。据说有的。</p>
<p><img src="/2017/09/22/review_of_MathModel/UCF.jpg" alt=""></p>
<p>UMN数据集：<a href="http://mha.cs.umn.edu/Movies/Crowd-Activity-All.avi" target="_blank" rel="external">Detection of Unusual Crowd Activity</a></p>
<p><img src="/2017/09/22/review_of_MathModel/UMN.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，花了两天时间稍微记录了一下我自己做的工作吧，算是opencv小白入门记。（之后暂时应该不会研究了，毕竟不是学这个的）</p>
<p>最后附上一个收录计算机视觉题材的地址：<a href="https://github.com/imistyrain/Way4CV" target="_blank" rel="external">百炼成金，计算机视觉修炼之道</a>，想要从事相关研究的童鞋不容错过。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[opencv_contrib安装说明与错误解决方案]]></title>
      <url>/2017/09/21/opencv_contrib/</url>
      <content type="html"><![CDATA[<p>在数模的时候，需要实现目标跟踪，因此需要安装opencv附加库，即opencv_contrib。</p>
<p>没有安装该附加库的时候，会提示如下错误：</p>
<p><img src="/2017/09/21/opencv_contrib/no_tracking.png" alt=""></p>
<a id="more"></a>
<h2 id="opencv-contrib下载"><a href="#opencv-contrib下载" class="headerlink" title="opencv_contrib下载"></a>opencv_contrib下载</h2><p><code>opencv_contrib</code>的项目地址为：<a href="https://github.com/opencv/opencv_contrib" target="_blank" rel="external">https://github.com/opencv/opencv_contrib</a></p>
<p>先将<code>opencv_contrib</code>下载下来，为后续安装做准备。</p>
<p>此外还需要的是<a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv</a>以及<a href="https://cmake.org/download/" target="_blank" rel="external">cmake</a>。</p>
<h2 id="opencv-contrib安装步骤概述"><a href="#opencv-contrib安装步骤概述" class="headerlink" title="opencv_contrib安装步骤概述"></a>opencv_contrib安装步骤概述</h2><h3 id="windows控制台"><a href="#windows控制台" class="headerlink" title="windows控制台"></a>windows控制台</h3><p>依次输入如下命令：</p>
<pre><code>$ cd &lt;opencv_build_directory&gt;
$ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules &lt;opencv_source_directory&gt;
$ make -j5
</code></pre><p>之后会在<code>&lt;opencv_build_directory&gt;</code>目录下生成<code>opencv_contrib</code>库的所有模块。如果不想安装所有的模块，则使用<code>cmake</code>命令的<code>BUILD_opencv_*</code>选项。示例程序如下：</p>
<pre><code>$ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules -DBUILD_opencv_legacy=OFF &lt;opencv_source_directory&gt;
</code></pre><h3 id="GUI图形界面安装"><a href="#GUI图形界面安装" class="headerlink" title="GUI图形界面安装"></a>GUI图形界面安装</h3><ul>
<li>打开<code>cmake-gui</code>；</li>
</ul>
<ul>
<li>选择源码文件夹以及build文件夹；</li>
</ul>
<ul>
<li>点击<code>configue</code>按钮。可以看到opencv build时的一系列参数；</li>
</ul>
<ul>
<li>浏览参数并找到<code>OPENCV_EXTRA_MODULES_PATH</code>，将其路径设为<code>&lt;opencv_contrib&gt;/modules</code>；</li>
</ul>
<p><img src="/2017/09/21/opencv_contrib/extra_path.jpg" alt="extra_path"></p>
<ul>
<li>点击<code>configue</code>按钮，完成后再点击<code>generate</code>按钮。（第一次会询问Makefile的类型）</li>
</ul>
<ul>
<li><p>点击open project，使用你选择的方法来生成<code>opencv core</code>。(上一步是Unix makfile，则相应的make，make install)</p>
</li>
<li><p>在自己的代码/IDE中添加相应模块的连接器标志（linker flags）。比如想使用aruco模块，则需要加上<code>&quot;-lopencv_aruco&quot;</code>。</p>
</li>
</ul>
<blockquote>
<p>上述步骤为该项目英文安装指南对应的翻译。</p>
</blockquote>
<p>图形界面的安装可参考这篇文章：<br><a href="http://blog.csdn.net/cv_jason/article/details/70037545" target="_blank" rel="external">http://blog.csdn.net/cv_jason/article/details/70037545</a></p>
<h2 id="opencv-contrib安装错误解决方案"><a href="#opencv-contrib安装错误解决方案" class="headerlink" title="opencv_contrib安装错误解决方案"></a>opencv_contrib安装错误解决方案</h2><h3 id="cmake出错Failed-to-download"><a href="#cmake出错Failed-to-download" class="headerlink" title="cmake出错Failed to download"></a>cmake出错Failed to download</h3><p>Cmd下输入</p>
<pre><code>wang@wang-PC MINGW64 /d/Program Files/opencv3/build
$ cmake -DOPENCV_EXTRA_MODULES_PATH=&quot;D:\opencv_contrib-master\modules&quot; &quot;D:\Program Files\opencv3\sources&quot;
</code></pre><p>时出现下载错误，如下图所示：</p>
<p><img src="/2017/09/21/opencv_contrib/cmake_error.png" alt=""></p>
<pre><code>CMake Error at D:/Program Files/opencv3/sources/cmake/OpenCVUtils.cmake:1047 (message):
  Failed to download .  Status=
Call Stack (most recent call first):
  D:/opencv_contrib-master/modules/dnn_modern/CMakeLists.txt:18 (ocv_download)
</code></pre><p>即：无法下载对应的模块。</p>
<p>遇到此错误的解决方案为：将以下三处的<code>filename</code>改为<code>PACKAGE</code>。（代码中的<code>PACKAGE</code>原为<code>filename</code>）</p>
<pre><code>D:\opencv\opencv_contrib\modules\dnn_modern\CMakeLists.txt
20行改为
ocv_download(PACKAGE &quot;v1.0.0a3.tar.gz&quot;

D:\opencv\opencv_contrib\modules\xfeatures2d\cmake\download_boostdesc.cmake
22行改为
 ocv_download(PACKAGE ${name_${id}}

D:\opencv\opencv_contrib\modules\xfeatures2d\cmake\download_vgg.cmake
16行改为
ocv_download(PACKAGE ${name_${id}}
</code></pre><p>修改后安装成功，可以在输出中查看具体的安装信息：</p>
<p><img src="/2017/09/21/opencv_contrib/cmake_ok.png" alt=""></p>
<p>从图中可以发现，我所需要的tracking库也已经安装成功了。</p>
<h3 id="没有make指令"><a href="#没有make指令" class="headerlink" title="没有make指令"></a>没有make指令</h3><p>在使用命令行界面安装时，没有最后一步的make指令。</p>
<p>那么只能自己安装了。或者直接用cmake GUI安装。</p>
<p>打开之前<code>opencv_contrib</code>的build文件夹，找到已经生成的opencv项目并打开。</p>
<p>打开VS之后，可以看到完整的OpenCV项目。然后直接编译即可（看个人情况，可自行选择Release或者Debug）。时间相当长。。。</p>
<p>编译成功后，在<code>CMakeTargets</code>中找到<code>INSTALL</code>，然后生成INSTALL，得到我们想要的最终文件。</p>
<h2 id="半永久配置"><a href="#半永久配置" class="headerlink" title="半永久配置"></a>半永久配置</h2><p>上述步骤的确很麻烦，并且非常容易出错。</p>
<p>有热心网友给出了自己配置好的文件，可以半永久配置。读者感兴趣的可以自己尝试下：<a href="http://www.cnblogs.com/wjy-lulu/p/6605306.html" target="_blank" rel="external">http://www.cnblogs.com/wjy-lulu/p/6605306.html</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p><a href="https://stackoverflow.com/questions/28619037/opencv-where-is-tracking-hpp" target="_blank" rel="external">https://stackoverflow.com/questions/28619037/opencv-where-is-tracking-hpp</a></p>
</li>
<li><p><a href="http://blog.csdn.net/qsy2000/article/details/70158537" target="_blank" rel="external">http://blog.csdn.net/qsy2000/article/details/70158537</a></p>
</li>
<li><p><a href="http://blog.csdn.net/cv_jason/article/details/70037545" target="_blank" rel="external">http://blog.csdn.net/cv_jason/article/details/70037545</a></p>
</li>
</ol>
<blockquote>
<p>其实这篇教程写的并不算太详细，cmake GUI可以对照着第三个博客安装。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客使用MathJax并解决markdown渲染冲突问题]]></title>
      <url>/2017/09/21/markdown_mathjax/</url>
      <content type="html"><![CDATA[<p>本文主要介绍如何在Hexo博客中使用Mathjax公式的基本配置方法，Mathjax的基本语法可参见：<a href="http://wangwlj.com/2017/10/08/mathjax_basic/">Mathjax基本语法</a>。</p>
<p>并且解决了Hexo博客在使用过程中，Markdown语法默认渲染效果与Mathjax语法互相冲突的问题。</p>
<a id="more"></a>
<h2 id="利用MathJax来渲染LaTeX数学公式"><a href="#利用MathJax来渲染LaTeX数学公式" class="headerlink" title="利用MathJax来渲染LaTeX数学公式"></a>利用MathJax来渲染LaTeX数学公式</h2><p>hexo主题Next中已经集成了对mathjax的支持。在<code>主题配置文件</code>，<code>blog\themes\next\_config.yml</code>中定位到如下片段:</p>
<pre><code># MathJax Support
mathjax:
  enable: true
  per_page: false
  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML
</code></pre><p>将enable中的false改为true即可。</p>
<p>另外，再安装一个自动部署MathJax的<a href="http://catx.me/2014/03/09/hexo-mathjax-plugin/" target="_blank" rel="external">hexo插件</a> 。安装方式也很简单，在你的博客文件夹下执行：</p>
<pre><code>npm install hexo-math --save
hexo math install
</code></pre><p>然后在新建的博文中写上一个麦克斯韦方程组查看LaTeX效果：</p>
<pre><code>$$
\begin{eqnarray}
\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\
\nabla\cdot\vec{B} &amp;=&amp; 0 \\
\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\
\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)
\end{eqnarray}
$$
</code></pre><p>$$<br>\begin{eqnarray}<br>\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\<br>\nabla\cdot\vec{B} &amp;=&amp; 0 \\<br>\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\<br>\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)<br>\end{eqnarray}<br>$$</p>
<p>这时如果你会发现出了一些问题，原因是hexo先用<code>marked.js</code>渲染，然后再交给<code>MathJax</code>渲染。在<code>marked.js</code>渲染的时候下划线<code>_</code>是被escape掉并且换成了<code>&lt;em&gt;</code>标签，即斜体字，另外LaTeX中的<code>\\</code>也会被转义成一个<code>\</code>，这样会导致<code>MathJax</code>渲染时不认为它是一个换行符了。</p>
<h2 id="mathjax与markdown默认渲染冲突的解决方案"><a href="#mathjax与markdown默认渲染冲突的解决方案" class="headerlink" title="mathjax与markdown默认渲染冲突的解决方案"></a>mathjax与markdown默认渲染冲突的解决方案</h2><p>解决方案为：修改Hexo渲染源码。</p>
<p>这个方法是我目前使用的，相对来说，通用性较高的一种方式。思路就是修改hexo的渲染源码: <code>nodes_modules/lib/marked/lib/marked.js</code>:</p>
<ul>
<li><p>去掉<code>\</code>的额外转义</p>
</li>
<li><p>将em标签对应的符号中，去掉<code>_</code>,因为<code>markdown</code>中有<code>*</code>可以表示斜体，<code>——</code>完全可以去掉。</p>
</li>
</ul>
<p>具体思路参考了使Marked.js与MathJax共存, 打开<code>nodes_modules/marked/lib/marked.js</code>:<br>第一步: 找到下面的代码:</p>
<pre><code>escape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/,
</code></pre><p>改为:</p>
<pre><code>escape: /^\\([`*{}\[\]()# +\-.!_&gt;])/,
</code></pre><p>这样就会去掉\的转义了。<br>第二步: 找到em的符号:</p>
<pre><code>em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
</code></pre><p>改为:</p>
<pre><code>em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
</code></pre><p>去掉<code>_</code>的斜体含义，这样就解决了。为什么说通用性很高，因为我们没有修改文章的内容，可以放到别的引擎下也会顺利渲染。</p>
<blockquote>
<p>这个困扰我许久的问题终于这么解决了。之前一直按照标准mathjax语法写公式，但是有的时候就会无法显示公式。</p>
<p>按照上述修改后，markdown不再处理(公式中的)<code>_</code>以及<code>\</code>。mathjax语法畅行无阻。</p>
</blockquote>
<p>参考资料：</p>
<p><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="external">https://segmentfault.com/a/1190000007261752</a></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> MathJax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LK光流法分析及其源码]]></title>
      <url>/2017/09/21/optical_flow/</url>
      <content type="html"><![CDATA[<h2 id="光流法简介"><a href="#光流法简介" class="headerlink" title="光流法简介"></a>光流法简介</h2><p>光流的概念是Gibson在1950年首先提出来的。它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。</p>
<a id="more"></a>
<p>光流法，是利用目标物体在监控场景中的空间运动，体现在视频图像序列中为不同图像颜色分布变化。导致目标物在监控场景中的空间运动场，在图像中转化为光流场，体现图像中每一个像素点的变化趋势。光流场可视为监控场景中的瞬时速度场。</p>
<p>研究光流场的目的就是为了从图片序列中近似得到不能直接得到的运动场。运动场，其实就是物体在三维真实世界中的运动；光流场，是运动场在二维图像平面上（人的眼睛或者摄像头）的投影。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>光流法的三种计算方法：LK，HS，最常用的还是LK。</p>
<h3 id="Lucas–Kanade算法"><a href="#Lucas–Kanade算法" class="headerlink" title="Lucas–Kanade算法"></a>Lucas–Kanade算法</h3><p>这个算法是最常见，最流行的。它计算两帧在时间t到t+δt之间每个每个像素点位置的移动。由于它是基于图像信号的泰勒级数，这种方法称为差分，这就是对于空间和时间坐标使用偏导数。</p>
<p>图像约束方程，也是光流法的基本方程，可以写为$I(x,y,z,t)=I(x +δx,y+δy,z+δz,t+δt)$</p>
<p>$I(x,y,z,t)$ 为在$(x,y,z)$位置的体素。</p>
<p>我们假设移动足够的小，那么对图像约束方程使用泰勒公式，我们可以得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_1.png" alt=""></p>
<p>H.O.T.指更高阶，在移动足够小的情况下可以忽略。从这个方程中我们可以得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_2.png" alt=""></p>
<p>或者</p>
<p><img src="/2017/09/21/optical_flow/equ_3.png" alt=""></p>
<p>我们得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_4.png" alt=""></p>
<p>Vx ,Vy ,Vz 分别是$I(x,y,z,t)$的光流向量中x，y，z的组成。 $\frac{∂I}{∂x}$, $\frac{∂I}{∂y}$, $\frac{∂I}{∂z}$和 $\frac{∂I}{∂t}$则是图像在$(x,y,z,t)$这一点向相应方向的差分。<br>所以<br>$$I_x V_x + I_y V_y + I_z V_z = −I_t$$<br>写做：</p>
<p><img src="/2017/09/21/optical_flow/equ_5.png" alt=""></p>
<p>这个方程有三个未知量，尚不能被解决，这也就是所谓光流算法的光圈问题。那么要找到光流向量则需要另一套解决的方案。而Lucas-Kanade算法是一个非迭代的算法：<br>假设流(Vx,Vy,Vz)在一个大小为$m*m*m$(m&gt;1)的小窗中是一个常数，那么从像素 $1,2,…,n,n =m^3$ 中可以得到下列一组方程：</p>
<p>$$I_{x1}  V_x + I_{y1}  V_y + I_{z1}  V_z = -I_{t_1}  $$</p>
<p>$$I_{x2}  V_x + I_{y2}  V_y + I_{z2}  V_z = -I_{t_2}  $$</p>
<p>$$ \vdots  $$</p>
<p>$$I_{xn}  V_x + I_{yn}  V_y + I_{zn}  V_z = -I_{t_n}  $$</p>
<p>三个未知数但是有多于三个的方程，这个方程组自然是个超定方程，也就是说方程组内有冗余，方程组可以表示为：</p>
<p><img src="/2017/09/21/optical_flow/equ_6.png" alt=""></p>
<p>记作：</p>
<p>$$A \vec{v} = -b $$</p>
<p>为了解决这个超定问题，我们采用最小二乘法：</p>
<p>$$A^T A \vec{v} = A^T (-b) $$</p>
<p>or</p>
<p>$$ \vec{v} = (A^T A)^{-1}  A^T (-b) $$</p>
<p>得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_7.png" alt=""></p>
<p>其中的求和是从1到n。</p>
<p>另外，由于LK算法假设是小位移，为了解决大位移问题，需要在多层图像缩放金字塔上求解，每一层的求解结果乘以2后加到下一层：</p>
<p><img src="/2017/09/21/optical_flow/LK_ta.png" alt=""></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>C++代码来自于：</p>
<p><a href="http://download.csdn.net/download/crzy_sparrow/4183674" target="_blank" rel="external">http://download.csdn.net/download/crzy_sparrow/4183674</a></p>
<p>有两点修改的地方：</p>
<p>①void handleTrackedPoint(Mat &frame;,Mat &output;)声明过程中循环条件points[i]要改为<code>points[1]</code>；</p>
<p>②新建项目时加上预编译头。</p>
<p>如果出现这个：<br><code>warning:opening fiile(../../modules/highgui/src/cap_ffmpeg_impl.hpp:545)</code><br>注意要把avi格式的视频文件放在debug下，可以用格式工厂转，注意视频编码那里要换成avc</p>
<p>效果：可以检测到运动目标。</p>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/crzy_sparrow/article/details/7407604" target="_blank" rel="external">http://blog.csdn.net/crzy_sparrow/article/details/7407604</a><br><a href="http://blog.csdn.net/u014568921/article/details/46638557" target="_blank" rel="external">http://blog.csdn.net/u014568921/article/details/46638557</a><br><a href="http://www.cnblogs.com/gnuhpc/archive/2012/12/04/2802124.html" target="_blank" rel="external">http://www.cnblogs.com/gnuhpc/archive/2012/12/04/2802124.html</a></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
            <tag> 光流法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[opencv视频保存方法详解]]></title>
      <url>/2017/09/21/opencv_SaveVideo/</url>
      <content type="html"><![CDATA[<p>本文主要介绍Opencv视频保存的详细方法。</p>
<a id="more"></a>
<h2 id="视频保存流程与示例"><a href="#视频保存流程与示例" class="headerlink" title="视频保存流程与示例"></a>视频保存流程与示例</h2><p>视频保存三步走：</p>
<p>一开始（循环外）</p>
<pre><code>VideoWriter outputVideo;
outputVideo.open(&quot;E:\\modeling\\视频\\compare3.avi&quot;, -1, 30, cvSize(cur.rows, cur.cols * 2 + 10),true);
</code></pre><p>接着（循环中）</p>
<pre><code>outputVideo &lt;&lt; canvas; //保存每帧图片到视频
</code></pre><p>最后释放（循环外）</p>
<pre><code>outputVideo.release(); //可以不要
</code></pre><h2 id="视频保存详解"><a href="#视频保存详解" class="headerlink" title="视频保存详解"></a>视频保存详解</h2><p>第一步中：</p>
<p>先定义VideoWriter对象，并指定输出文件。其中，open函数的定义为：</p>
<pre><code>open ( const char* filename, int fourcc, double fps, CvSize frame_size, int is_color=1 );
</code></pre><p>第一个参数filename为输出视频文件名。输出目录要存在，输出文件不存在时会自动创建。目录中注意使用<code>转义字符</code>。</p>
<p>第二个参数fourcc为编码格式。四个字符来表示压缩帧的codec。例如：</p>
<ol>
<li>CV_FOURCC(‘P’,’I’,’M’,’1’) = MPEG-1 codec</li>
<li>CV_FOURCC(‘M’,’J’,’P’,’G’) = motion-jpeg codec</li>
<li>CV_FOURCC(‘M’, ‘P’, ‘4’, ‘2’) = MPEG-4.2 codec</li>
<li>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘3’) = MPEG-4.3 codec</li>
<li>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘X’) = MPEG-4 codec</li>
<li>CV_FOURCC(‘U’, ‘2’, ‘6’, ‘3’) = H263 codec</li>
<li>CV_FOURCC(‘I’, ‘2’, ‘6’, ‘3’) = H263I codec</li>
<li>CV_FOURCC(‘F’, ‘L’, ‘V’, ‘1’) = FLV1 codec</li>
</ol>
<p><strong>若编码器代号为 -1，则运行时会弹出一个编码器选择框。</strong></p>
<p>详细的视频编解码格式可参考：<a href="http://fourcc.org/codecs.php" target="_blank" rel="external">Video Codecs by FOURCC</a></p>
<p>第三个参数fps 被创建视频流的帧率。</p>
<p>第四个参数frame_size 视频流的大小。</p>
<p>第五个参数is_color 如果非零(true)，编码器将希望得到彩色帧并进行编码；否则，是灰度帧（只有在Windows下支持这个标志）。</p>
<h1 id="出错详解"><a href="#出错详解" class="headerlink" title="出错详解"></a>出错详解</h1><p>输出路径不对肯定就没有视频了。此外，容易出现的问题有保存的视频大小为0，保存的视频乱码或打不开。</p>
<h2 id="保存的视频大小为0"><a href="#保存的视频大小为0" class="headerlink" title="保存的视频大小为0"></a>保存的视频大小为0</h2><p>可能的原因有： </p>
<h3 id="编码格式不对"><a href="#编码格式不对" class="headerlink" title="编码格式不对"></a>编码格式不对</h3><p>在open函数中第二个参数是编码格式，一定按照提供的编码格式进行填写，在应用中最好的解决方法是为<strong>-1</strong>。当为-1时，程序对弹出如下对话框供你选择：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4s7muulsj208604f3yp.jpg" alt="video_save"></p>
<p>本人电脑上只有选择<code>全帧（非压缩的）</code>才能正常打开。</p>
<h3 id="帧速率不匹配"><a href="#帧速率不匹配" class="headerlink" title="帧速率不匹配"></a>帧速率不匹配</h3><p>该项会导致视频时间不同。</p>
<h3 id="后缀名不对"><a href="#后缀名不对" class="headerlink" title="后缀名不对"></a>后缀名不对</h3><p> 选择<code>.avi</code>格式没有问题，其它待定。</p>
<h2 id="保存的视频乱码或打不开"><a href="#保存的视频乱码或打不开" class="headerlink" title="保存的视频乱码或打不开"></a>保存的视频乱码或打不开</h2><p>这个情况一般就是编码格式不对造成的，也就是open函数中第二个参数。最好的解决方法是设为<strong>-1</strong>，然后手动选择编解码器。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/polly333/p/5165290.html" target="_blank" rel="external">http://www.cnblogs.com/polly333/p/5165290.html</a></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BGSLibrary编译安装与BGSlibrary GUI的下载与使用]]></title>
      <url>/2017/09/20/BGSlibrary/</url>
      <content type="html"><![CDATA[<p>本文主要介绍BGSLibrary编译安装与BGSlibrary GUI的下载与使用</p>
<a id="more"></a>
<blockquote>
<p>安装前提：需要安装了<code>opencv</code>以及<code>VS</code>，可以参考<a href="http://www.cnblogs.com/linshuhe/p/5764394.html" target="_blank" rel="external">这篇博文</a>，写的很详细。</p>
</blockquote>
<h1 id="BGSLibrary简介"><a href="#BGSLibrary简介" class="headerlink" title="BGSLibrary简介"></a>BGSLibrary简介</h1><p><code>BGSLibrary</code>由<code>Andrews Sobral</code>开发，并提供了一个执行背景减除（BGS）的<code>C++</code>框架。该代码可以在Windows或Linux上运行。</p>
<p>目前，该库提供了35种BGS算法（PBAS算法从BGSLibrary中删除，因为它基于专利算法<code>ViBE</code>）。 几位作者提供了大量的算法。 </p>
<p>源代码可以在<code>GNU GPL v3</code>许可证下获得，图书馆免费，学术目的开源。 任何用户都可以使用SVN客户端下载最新的项目源代码。</p>
<h2 id="BGSLibrary地址"><a href="#BGSLibrary地址" class="headerlink" title="BGSLibrary地址"></a>BGSLibrary地址</h2><p>该项目的github主页地址为：<a href="https://github.com/andrewssobral/bgslibrary" target="_blank" rel="external">github地址</a></p>
<h2 id="详细安装指南（官方修正版）"><a href="#详细安装指南（官方修正版）" class="headerlink" title="详细安装指南（官方修正版）"></a>详细安装指南（官方修正版）</h2><p>在该项目的github主页上可以看到安装指导。本人的电脑配置为VS2015，Opencv3.2.0，所以在github主页上依次点击：</p>
<blockquote>
<p>Installation instructions 中的<code>Windows installation</code> </p>
<p>-&gt;  BGSLibrary with OpenCV 3.2.0 and Visual Studio 2015 from CMAKE (Recommended)</p>
</blockquote>
<p>该界面下，详细的安装步骤（及修正）为：</p>
<ul>
<li><strong>打开</strong><code>windows控制台（cmd）</code></li>
</ul>
<ul>
<li><strong>克隆</strong><code>BGSLibrary库</code>到本地</li>
</ul>
<p>克隆指令为：</p>
<pre><code>git clone https://github.com/andrewssobral/bgslibrary.git
</code></pre><ul>
<li><strong>切换</strong>到<code>bgslibrary/build</code><strong>目录</strong></li>
</ul>
<ul>
<li>设置opencv路径</li>
</ul>
<blockquote>
<pre><code>特别注意：windows环境下没有`setlocal`命令。
</code></pre></blockquote>
<p>所以跳过该步骤，直接进行下一步。</p>
<ul>
<li>调用<strong>cmake命令</strong>安装</li>
</ul>
<p>安装命令为：</p>
<pre><code>cmake -DOpenCV_DIR=%OpenCV_DIR% -G &quot;Visual Studio 14 Win64&quot; ..
</code></pre><p>注意：由于我们没有设置上一步的opencv路径，因此，上述cmake命令中的<code>%OpenCV_DIR%</code>需要用详细路径的形式替换，即直接指定opencv目录。笔者所用的命令为：</p>
<pre><code>cmake -D OpenCV_DIR=&quot;D:\Program Files\opencv3\build&quot; -G &quot;Visual Studio 14 Win64&quot; ..
</code></pre><blockquote>
<p>命令中最后的两个点也是需要的。<code>-D</code>与<code>OpenCV_DIR</code>分开或者合在一起都可以。</p>
<p>上述两步骤的变化是笔者花了不少时间尝试出来的。</p>
</blockquote>
<p><img src="/2017/09/20/BGSlibrary/cmake_success.png" alt="cmake成功截图"></p>
<ul>
<li>将opencv可执行文件目录添加到系统<strong>环境变量</strong>PATH中</li>
</ul>
<p>计算机上右键 – 属性 – 高级系统设置 – 环境变量 – 系统变量中的PATH –添加opencv目录。</p>
<pre><code>D:\Program Files\opencv3\build\x64\vc14\bin;
</code></pre><blockquote>
<p>最后的是英文状态下的分号，表示不同路径间的分隔符。</p>
</blockquote>
<ul>
<li>VS中打开<code>bgs.sln</code>解决方案文件，切换到“<code>RELEASE</code>”模式（并且要注意选择x64而不是x86模式）下，点击“<code>ALL_BUILD</code>”项目开始<strong>生成</strong>。</li>
</ul>
<ul>
<li>安装完成，可以开始跑demo，跑BGSLibrary了。</li>
</ul>
<p>主要有两种方式运行<code>BGSLibrary</code>，第一种是在cmd命令行下，第二种是运行写好的脚本文件。</p>
<h2 id="运行方法一：windows控制台"><a href="#运行方法一：windows控制台" class="headerlink" title="运行方法一：windows控制台"></a>运行方法一：windows控制台</h2><p>在windows控制台（cmd）下运行：</p>
<p> ①用摄像头跑BGSLibrary </p>
<pre><code>C:\bgslibrary&gt;  build\bgslibrary.exe --use_cam --camera=0
</code></pre><p> ②运行dome程序</p>
<pre><code>C:\bgslibrary&gt;  build\bgs_demo.exe dataset/video.avi
</code></pre><p> ③运行demo2程序</p>
<pre><code>C:\bgslibrary&gt;  build\bgs_demo2.exe
</code></pre><blockquote>
<p>注意：此时的目录为bgslibrary根目录。</p>
</blockquote>
<h2 id="运行方法二：直接运行脚本文件"><a href="#运行方法二：直接运行脚本文件" class="headerlink" title="运行方法二：直接运行脚本文件"></a>运行方法二：直接运行脚本文件</h2><p>经过上述的成功生成过程后，可在<code>bgslibrary根目录</code>下找到写好的脚本文件（<code>bat</code>或者<code>sh</code>），直接双击运行即可。如下图所示：</p>
<p><img src="/2017/09/20/BGSlibrary/BGSLibrary_run.png" alt="脚本文件截图"></p>
<h1 id="BGSlibrary-GUI的下载与使用"><a href="#BGSlibrary-GUI的下载与使用" class="headerlink" title="BGSlibrary GUI的下载与使用"></a>BGSlibrary GUI的下载与使用</h1><h2 id="BGSlibrary-GUI简介"><a href="#BGSlibrary-GUI简介" class="headerlink" title="BGSlibrary GUI简介"></a>BGSlibrary GUI简介</h2><p>是否还在为上述繁琐的安装过程而苦恼，那么就快来下载<code>BGSlibrary GUI</code>吧。</p>
<p>BGSlibrary GUI是BGSLibrary的可执行版本，可用于Windows 32位和64位。 对于Linux和Mac用户，可以使用Makefile来编译所有文件并生成可执行示例。</p>
<p>该GUI中集成了37种背景建模算法，可以显示输入视频/图像、基于背景建模得到的前景和背景建模得到的背景图像，还可以显示出每种算法的计算复杂度等等。并且，测试的可以是视频、图片序列以及摄像头输入视频。</p>
<h2 id="下载方式一"><a href="#下载方式一" class="headerlink" title="下载方式一"></a>下载方式一</h2><p>文件名：<code>bgslibrary_x86_v1.9.2_with_mfc_gui_v1.4.2.7z</code></p>
<p>下载地址：<a href="http://download.csdn.net/download/frd2009041510/8691475" target="_blank" rel="external">CSDN</a> (找的网上的，亲测可用)</p>
<p>上传者设置了积分，没有积分的童鞋可以联系我，我私下发给你，或者我看情况可以上传百度云啥的。</p>
<h2 id="下载方式二"><a href="#下载方式二" class="headerlink" title="下载方式二"></a>下载方式二</h2><p>最新版本：<code>BGSLibrary v1.9.1 with MFC GUI v1.4.1 (x86/x64)</code></p>
<p>下载地址：<a href="https://github.com/andrewssobral/bgslibrary/blob/master/binaries/mfc_bgslibrary_x86_v1.4.1.zip" target="_blank" rel="external">GITHUB（bgslibrary/binaries/）</a></p>
<h2 id="BGSlibrary-GUI的使用"><a href="#BGSlibrary-GUI的使用" class="headerlink" title="BGSlibrary GUI的使用"></a>BGSlibrary GUI的使用</h2><p>已经是GUI界面了，所以使用非常简单，在此不再赘述。基本上和编译完成后能实现的功能相同。</p>
<p><img src="/2017/09/20/BGSlibrary/GUI.png" alt="GUI界面截图"></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BP神经网络部分具体的推导]]></title>
      <url>/2017/09/12/BP_derivation/</url>
      <content type="html"><![CDATA[<p>本文介绍了BP网络中的前向传播和反向传播过程的公式与推导，读者可自行揣摩。</p>
<a id="more"></a>
<blockquote>
<p>mathjax公式中不能有多余的{}，否则<code>hexo deploy</code>的时候会出现错误。</p>
</blockquote>
<h2 id="网络结构参数说明"><a href="#网络结构参数说明" class="headerlink" title="网络结构参数说明"></a>网络结构参数说明</h2><h3 id="BP神经网络示意图"><a href="#BP神经网络示意图" class="headerlink" title="BP神经网络示意图"></a><strong>BP神经网络示意图</strong></h3><p><img src="/2017/09/12/BP_derivation/bp_net.png" alt="BP神经网络示意图"></p>
<p>注意，上述层与层之间是全连接的，示意图并没有画全。</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a><strong>网络结构</strong></h3><p>一个输入层，两个隐含层，一个输出层。</p>
<h3 id="参数标记"><a href="#参数标记" class="headerlink" title="参数标记"></a><strong>参数标记</strong></h3><ul>
<li><p>输入层神经元个数n、输出层神经元个数m</p>
</li>
<li><p>两个隐含层神经元个数均为100</p>
</li>
</ul>
<ul>
<li>权值：输入层与第一个隐含层之间的权值为$w_{ij}$，两个隐含层之间的权值为$w_{jk}$，第二个隐含层与输出层之间的权值为$w_{kl}$</li>
</ul>
<ul>
<li>阈值：两个隐含层$a^1_j,a^2_k$，输出层$b_l$</li>
</ul>
<p>其中，$i=1,2,…,n$，$j,k=1,2,…,100$，$l=1,2,…,m$<br>凡是下标含有$i,j,k,l$的，均表示单个神经元。</p>
<h2 id="BP网络推导"><a href="#BP网络推导" class="headerlink" title="BP网络推导"></a>BP网络推导</h2><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>两个隐含层及输出层的输出：</p>
<p>$$H_j^1 = f(\sum_{i=1}^n w_{ij} x_i - a_{j}^1 )\ \ \ j=1,2,…,100$$</p>
<p>$$<br>H_{k}^2 = f(\sum^{100}_{j=1} w_{jk} H^1_{j} - a^2_{k} )\ \ \  k = 1,2, \cdots ,100<br>$$</p>
<p>$$<br>O_l = \sum_{k = 1}^{100} w_{kl}H_{k}^2 - {b_l} \ \ \ l = 1,2, \cdots ,m<br>$$</p>
<h3 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h3><p>此处仅仅是简单相减，可以使用MSE均方误差，有空改。</p>
<p>$$e_l = y_l - O_l\ \ \  l = 1,2, \cdots ,m$$</p>
<p>其中，$y_l$是真实的样本输出。</p>
<h3 id="反向传播的权值更新"><a href="#反向传播的权值更新" class="headerlink" title="反向传播的权值更新"></a>反向传播的权值更新</h3><p>$$\begin{equation}\begin{split}<br>w_{kl} &amp;= w_{kl} - dw_{kl} \\<br>&amp;= w_{kl} - \eta \frac{\partial e_l}{\partial w_{kl}}\\<br>&amp;= w_{kl} + \eta H_k^2 e_l \ \ \ \ \ \  k = 1,2, \cdots ,100 \\<br>\end{split}\end{equation}$$</p>
<p>$$\begin{equation}\begin{split}<br>{w_{jk}}  &amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial w_{jk}} \\<br>&amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial O_l} \frac{\partial O_l}{\partial H_{k}^2} \frac{\partial H_{k}^2}{\partial w_{jk}} \\<br>&amp;= {w_{jk}} - \eta (-e_l)(\sum_{l = 1}^m w_{kl}) (f’_{H_k^2} H_j^1) \\<br>&amp;= {w_{jk}} + \eta f’_{H_k^2} H_j^1 \sum_{l = 1}^m w_{kl}e_l \ \ \ \ \  j = 1,2, \cdots ,100 \\<br>\end{split}\end{equation}$$</p>
<p>$$\begin{equation}\begin{split}<br>{w_{ij}}  &amp;= {w_{ij}} - \eta \frac{\partial e_l}{\partial w_{ij}} \\<br>&amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial O_l} \frac{\partial O_l}{\partial H_{k}^2} \frac{\partial H_{k}^2}{\partial H_{j}^1} \frac{\partial H_{j}^1}{\partial w_{ij}} \\<br>&amp;= {w_{jk}} - \eta (-e_l)(\sum_{l = 1}^m w_{kl}) (f’_{H_k^2} \sum_{k = 1}^{100} w_{jk}) (f’_{H_j^1} x_i) \\<br>&amp;= {w_{ij}} + \eta f’_{H_j^1}{x_i}\sum_{k = 1}^{100} [(\sum_{l = 1}^m w_{kl}e_l)w_{jk}f’_{H_k^2}] \\<br>\ \ \ \  &amp;其中 i = 1,2, \cdots ,n;j = 1,2, \cdots ,100 \\<br>\end{split}\end{equation}$$</p>
<p>这边公式需要自己推一推啦，详细地说明暂时就不多说。<br>还可以简写。有空补。</p>
<h2 id="关于激活函数的说明"><a href="#关于激活函数的说明" class="headerlink" title="关于激活函数的说明"></a>关于激活函数的说明</h2><p>上述公式中，$f’_{H_k^2}$, $f’_{H_j^1}$ 之所以没有代入具体值，是因为这取决与所采用的激活函数。<code>DeepLearnToolBox</code>之BP算法中可采用的激活函数有两种，一是sigmoid函数，二是双曲正切函数。</p>
<h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><p>当激活函数为sigmoid函数$f(x) = \frac{1} { 1 +  e^{-x}  }$时，<strong>sigmoid函数的导数</strong>具有下面的一个性质：</p>
<p>其导数为：</p>
<p>$$\begin{equation}\begin{split}<br>f’(x) &amp;= \frac{e^{ - x}}{(1 + e^{ - x})^2} \\<br>&amp;= \frac{e^{ - x}}{(1 + e^{ - x})}\frac{1}{(1 + e^{ - x})}\\<br>&amp;= (1 - \frac{1}{(1 + e^{-x})})(\frac{1}{(1 + e^{ - x})}) \\<br>&amp;= (1-f(x))f(x)\\<br>\end{split}\end{equation}$$</p>
<p>因此，比如说，在$H^2_K$中对$f$求导，结果为$f’_{H_k^2} = H_k^2(1-H_k^2)$，同理$f’_{H_k^1} = H_k^1(1-H_k^1)$</p>
<h3 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h3><p>激活函数也可以是双曲正切函数$tanhx= \frac{sinhx}{coshx} = \frac{e^x-e^{-x}}{e^x+e^{-x}}$。</p>
<p>双曲正切函数的图形夹在水平直线y=1及y=-1之间，且当x的绝对值很大时，它的图形在第一象限内接近于直线y=1，而在第三象限内接近于直线y=-1。[1]<br>即双曲正切函数的值域是(-1,1)。</p>
<p><img src="/2017/09/12/BP_derivation/tanhx.png" alt="matlab作出的tanhx"></p>
<p><img src="/2017/09/12/BP_derivation/tanx_2.png" alt="matlab作出的tanhx"></p>
<p>tanh(4) = (exp(4)-exp(-4))/(exp(4)+exp(-4))  = 0.9993</p>
<p>超过[-4,4]的范围已经可以看为1了。</p>
<p>双曲正切函数的标准导数公式：</p>
<p>$$ tanh(x) = \frac{1}{cosh(x)^2} = 1- tanh(x)^2 $$</p>
<p>用如下命令作图，并画出导数图像：</p>
<pre><code>plot(x,1-tanh(x).^2)
plot(x,1./cosh(x).^2)
</code></pre><p><img src="/2017/09/12/BP_derivation/tanhx_deri.png" alt="tanhx的真实导数"></p>
<p>代码中给出的导数公式为：</p>
<p>$$f’_{tanhx} = 1.7159 * \frac{2}{3}  (1 -\frac{1}{1.7159^2}tanhx^2) $$</p>
<p>用如下命令<code>plot(x,1.7159*2/3*(1-1/1.7159^2*tanh(x).^2))</code>作图，画出导数图像：</p>
<p><img src="/2017/09/12/BP_derivation/tanhx_deri_2.png" alt="tanhx的逼近导数"></p>
<p>可以看到，总体形状是类似的，但是幅度上还是存在着较大差异。具体缩放的原因还不太清楚。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章只要是基于公式推导BP网络的整体流程。基于代码的实现请参阅： <a href="https://qwerty200696.github.io/2017/09/23/DeepLearnToolBox_BP/" target="_blank" rel="external">DeepLearnToolBox之BP算法</a>。</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建的Github博客之优化]]></title>
      <url>/2017/09/09/blog-opti/</url>
      <content type="html"><![CDATA[<p>本篇教程基于NexT主题的博客配置，实现更换主题、评论、打赏等36项功能，接下来根据这些功能进行分点描述，附上个人博客以供比对参考：<a href="https://qwerty200696.github.io" target="_blank" rel="external">个人博客链接</a>。</p>
<a id="more"></a>
<h1 id="搭建基本Hexo博客"><a href="#搭建基本Hexo博客" class="headerlink" title="搭建基本Hexo博客"></a>搭建基本Hexo博客</h1><p>Hexo博客基本搭建参考：《<a href="https://qwerty200696.github.io/2017/09/08/blog_setup/#more" target="_blank" rel="external">hexo+GitHub博客搭建实战</a>》一文，，笔者按照教程的顺序一步一步来，是没有出现错误的，如果读者们在搭建的时候遇到了问题不知如何解决，笔者会尽自己所能帮助读者，并将遇到的问题及解决方法附在文章下方。</p>
<h1 id="Hexo博客绑定域名"><a href="#Hexo博客绑定域名" class="headerlink" title="Hexo博客绑定域名"></a>Hexo博客绑定域名</h1><p>关于Hexo博客如何绑定自己的域名，详情可参阅《<a href="http://www.jianshu.com/p/cea41e5c9b2a" target="_blank" rel="external">hexo搭建的Github博客绑定域名</a>》一文。</p>
<p>博主按照上述教程，已经成功地绑定域名<a href="http://wangwlj.com">wangwlj.com</a>。</p>
<h1 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h1><p>笔者更换后的主题为NexT，其Github网址为：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> 。首先将NexT的主题源文件下载到本地，使用Git克隆指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<p>下载后，将压缩包解压缩(文件位于指令运行的当前目录)，复制其中名称为<code>next</code>的文件夹到<code>Hexo</code>的主题目录下，主题目录的路径为：</p>
<blockquote>
<p>Hexo博客根目录/themes/</p>
</blockquote>
<p>在Hexo根目录下有一个以<code>_config.yml</code>命名的文件（下称<strong><font color="#000000"><span style="background-color: #ADFF2F;">站点配置文件 </span></font></strong>），用<code>Sublime/NotePad++</code>等文本编辑器打开，在其中找到<code>theme</code>属性，将其由<code>landscape</code>改为<code>next</code>。</p>
<p>然后在Hexo根目录执行部署Hexo指令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清理缓存</span></div><div class="line">hexo clean</div><div class="line"><span class="comment">// 生成文件</span></div><div class="line">hexo generate</div><div class="line"><span class="comment">// 部署</span></div><div class="line">hexo deploy</div></pre></td></tr></table></figure>
<p>便可以在远程的博客上看到修改主题后的样式了。</p>
<h1 id="设置Hexo主题模式"><a href="#设置Hexo主题模式" class="headerlink" title="设置Hexo主题模式"></a>设置Hexo主题模式</h1><p>看到上图，读者可能会产生疑问，为什么自己的主题样式和笔者的不一样，这是因为在Hexo主题中，有四种不同的模式，通过切换模式，让NexT主题显示不一样的样式。</p>
<p>在<code>NexT</code>根目录下有一个同样名称为<code>_config.yml</code>，为了区分<code>hexo</code>根目录下的<code>_config.yml</code>，将前者称为<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，在其中找到scheme属性，如下图所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Schemes</span></div><div class="line"><span class="comment">#scheme: Muse</span></div><div class="line"><span class="comment">#scheme: Mist</span></div><div class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></div><div class="line"><span class="comment">#scheme: Gemini</span></div></pre></td></tr></table></figure>
<p>NexT主题默认使用Muse模式，笔者采用的是Pisces模式，读者可根据自己的喜好，选择其中一种模式。</p>
<h1 id="设置预览摘要"><a href="#设置预览摘要" class="headerlink" title="设置预览摘要"></a>设置预览摘要</h1><p>设置完模式后，读者们会发现，尽管首页显示的是所有文章的列表，但是每一篇文章都显示了所有内容，这样感觉看起来不舒服，这时候可以启用预览摘要模式，在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中找到<code>auto_excerpt</code>属性，将<code>enable</code>设置为<code>true</code> ，将<code>length</code>设置为想要预览到的字数，如下图所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">auto_excerpt:</span></div><div class="line"><span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#将原有的false改为true</span></div><div class="line"><span class="attr">length:</span> <span class="number">300</span>  <span class="comment">#设置预览的字数</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这里说明一下：上述的部署指令中<code>hexo deploy</code>可以换成<code>hexo server</code>，两者的区别在于，前者是将博客部署到<strong>远程</strong>的Github上，而后者是运行在<strong>本地</strong>，通过<code>http://localhost:4000</code>在浏览器中访问。后者是为了调试配置方便而使用，但是最终本地博客还是需要<code>hexo deploy</code>指令将其部署至Github上。</p>
</blockquote>
<h1 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h1><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>目前的评论系统，友言，网易云跟帖都挂了。所以，我最终采用的是来必力。</p>
<p>我新写一篇文章详细介绍了来必力评论系统的实现方法：<a href="http://wangwlj.com/2017/12/18/blog_comment/">hexo博客优化之实现来必力评论功能</a></p>
<h2 id="以下是原文"><a href="#以下是原文" class="headerlink" title="以下是原文"></a>以下是原文</h2><p>NexT目前出到5.1.0版本，功能模块已经相当的丰富。NexT主题集成了评论系统，只需要设置相关的属性即可实现功能，其目前支持<strong>多说、Disqus、Facebook评论、Hyper评论、网页云跟帖</strong>等，其中“多说”是NexT推荐的评论系统，但是多说评论系统不稳定，经常会出现服务异常的问题。</p>
<p><del>笔者采用的是一款名为友言的评论系统，它也是NexT已经集成好的，可以直接拿来用的。下面对其操作进行讲解：</del></p>
<p><del>- <strong>注册友言账号</strong></del></p>
<p><del>打开<a href="http://www.uyan.cc/" target="_blank" rel="external">友言官网</a>，单击“注册”按钮后，按照套路可完成账号注册。</del></p>
<p><del>- <strong>获取uid</strong></del></p>
<p><del>注册完登录后，在首页单击“后台管理”按钮进入后台界面便可看到自己的用户ID，将其复制下来。</del></p>
<p><del>- <strong>设置uid</strong></del></p>
<p><del>打开<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，在其中找到属性<code>youyan_uid</code>，然后在: 后添加之前复制的uid。</del></p>
<p><del>&gt; 提醒一下，<strong>:</strong> 冒号后面一定要有一个空格</del></p>
<p><del>然后部署一下Hexo，可以在本地或远程看到实现的评论功能，如下图所示：</del></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cr4ov1fj20ik0dnaad.jpg" alt="youyan评论界面"></p>
<p><del>&gt; 在笔者配置评论功能的时候，笔者遇到了一个问题：<em>本地博客有评论功能，而远程博客却没有</em> 。折腾了一下午，始终不知道其原因所在。后来，当笔者对博客绑定自己的域名后，发现远程的博客自动出现了评论功能。在此推测为域名的缘故。若没有绑定域名的读者们遇到这个情况，可以放放，先配置其他功能。</del></p>
<h1 id="设置侧边栏显示效果"><a href="#设置侧边栏显示效果" class="headerlink" title="设置侧边栏显示效果"></a>设置侧边栏显示效果</h1><p>在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中，找到<code>sidebar</code>的<code>display</code>属性，<code>display</code>属性有四种显示模式：分别为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">post    <span class="comment">// 默认显示方式</span></div><div class="line">always  <span class="comment">// 一直显示</span></div><div class="line">hide    <span class="comment">// 初始隐藏</span></div><div class="line">remove  <span class="comment">// 移除侧边栏</span></div></pre></td></tr></table></figure>
<p>笔者将其设置为hide模式，读者们可根据个人喜好进行设置。</p>
<h1 id="添加菜单选项"><a href="#添加菜单选项" class="headerlink" title="添加菜单选项"></a>添加菜单选项</h1><p>默认情况下，菜单导航栏有首页、归档、关于三个选项，除此之外笔者还添加了分类、标签和关于。在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中，找到<code>menu</code>属性，并去掉<code>categories、 tags、about</code>的的注释，如下图所示：</p>
<p>然后在Hexo根目录执行指令如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加分类页面</span></div><div class="line">hexo <span class="keyword">new</span> page <span class="string">"categories"</span></div><div class="line"><span class="comment">// 添加标签页面</span></div><div class="line">hexo <span class="keyword">new</span> page <span class="string">"tags"</span></div><div class="line"><span class="comment">// 添加关于页面</span></div><div class="line">hexo <span class="keyword">new</span> page <span class="string">"about"</span></div></pre></td></tr></table></figure>
<p>执行完上述指令后，在Hexo根目录<code>/source/</code>文件夹下创建三个文件夹，命名分别为：<code>categories、tags、about</code>文件夹，在这些文件夹中分别会创建一个以<code>index</code>命名的Markdown文件，对这三个Markdown文件内容进行修改，使之分别为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: categories</div><div class="line">date: <span class="number">2017</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">24</span></div><div class="line">type: <span class="string">"categories"</span></div><div class="line">---</div><div class="line"></div><div class="line">---</div><div class="line">title: 标签</div><div class="line">date: <span class="number">2017</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">17</span>:<span class="number">27</span>:<span class="number">16</span></div><div class="line">type: <span class="string">"tags"</span></div><div class="line">---</div><div class="line"></div><div class="line">---</div><div class="line">title: about</div><div class="line">date: <span class="number">2017</span>-<span class="number">03</span>-<span class="number">12</span> <span class="number">22</span>:<span class="number">07</span>:<span class="number">26</span></div><div class="line">type: <span class="string">"about"</span></div><div class="line">---</div></pre></td></tr></table></figure>
<p>完成文件的修改，然后部署Hexo即可完成菜单选项的添加。</p>
<h1 id="添加阅读次数统计"><a href="#添加阅读次数统计" class="headerlink" title="添加阅读次数统计"></a>添加阅读次数统计</h1><p>注册<code>LeanCloud</code>账号，完成激活；点击左上角的”应用”-“创建新应用”-点击“数据”右边的齿轮–点击创建类class，类名字叫做<code>Counter</code>。</p>
<p>然后，修改<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，找到<code>leancloud_visitors</code>，添加修改：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">leancloud_visitors:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span> <span class="comment">#将原来的false改为true</span></div><div class="line"><span class="attr">  app_id:</span> <span class="comment">#&lt;app_id&gt;</span></div><div class="line"><span class="attr">  app_key:</span> <span class="comment">#&lt;app_key&gt;</span></div></pre></td></tr></table></figure>
<p>从设置中找到相应的id和key：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8crnajqgj21150brt9d.jpg" alt="LeanCloud中的id和key"></p>
<p>然后预览，如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8crxf0wxj20ax02awef.jpg" alt="阅读次数统计效果图"></p>
<h1 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h1><p>笔者希望在个人博客中加入自己的微博、知乎和Github链接以提高访问量，接下来了解一下社交链接如何添加：</p>
<ul>
<li><strong>添加链接及图标</strong></li>
</ul>
<p>在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中找到<code>social</code>属性，在其下方添加社交链接及图标，其格式为：</p>
<pre><code>社交平台名称：链接 || 图标
</code></pre><p>链接的图标全部来自于<a href="http://fontawesome.io/icons/" target="_blank" rel="external">Font Awesome</a></p>
<ul>
<li><strong>个人配置</strong></li>
</ul>
<p>笔者社交链接添加情况如以下代码所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">social:</span></div><div class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/qwerty200696</span> <span class="string">||</span> <span class="string">github</span></div><div class="line"><span class="attr">  E-Mail:</span> <span class="attr">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></div><div class="line">  <span class="string">知乎:</span> <span class="attr">https://www.zhihu.com/people/LijieWang</span> <span class="string">||</span> <span class="string">gratipay</span> </div><div class="line">  <span class="string">微博:</span> <span class="attr">https://weibo.com/3280603012</span> <span class="string">||</span> <span class="string">weibo</span></div><div class="line"><span class="attr">  Google:</span> <span class="attr">https://plus.google.com/yourname</span> <span class="string">||</span> <span class="string">google</span></div><div class="line"><span class="attr">  Twitter:</span> <span class="attr">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">twitter</span></div><div class="line">  <span class="string">FB</span> <span class="attr">Page:</span> <span class="attr">https://www.facebook.com/yourname</span> <span class="string">||</span> <span class="string">facebook</span></div><div class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></div><div class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></div><div class="line"><span class="attr">  YouTube:</span> <span class="attr">https://youtube.com/yourname</span> <span class="string">||</span> <span class="string">youtube</span></div><div class="line"><span class="attr">  Instagram:</span> <span class="attr">https://instagram.com/yourname</span> <span class="string">||</span> <span class="string">instagram</span></div></pre></td></tr></table></figure>
<p>其中，微博有其对应的图标，而知乎在图标库中却没有找到，笔者找了一款<code>gratipay</code>的图标来代替知乎图标。</p>
<blockquote>
<p>如果没有找到指定的图标，将会启用默认的图标。</p>
</blockquote>
<ul>
<li><strong>效果展示</strong></li>
</ul>
<p>配置完成后，具体效果显示如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8csbig53j206m06kglj.jpg" alt="社交链接效果图"></p>
<h1 id="添加友情链接功能"><a href="#添加友情链接功能" class="headerlink" title="添加友情链接功能"></a>添加友情链接功能</h1><p>在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中找到<code>links</code>属性，修改<code>links_title</code>属性的值为“友情链接”（也可以是其他文案），取消注释<code>links:</code>，然后添加上好友的博客名称和博客地址，其格式如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Blog rolls</span></div><div class="line"><span class="attr">links_title:</span> <span class="string">友情链接</span> <span class="comment">#修改名称</span></div><div class="line"><span class="comment">#links_layout: block</span></div><div class="line"><span class="comment">#links_layout: inline</span></div><div class="line"><span class="attr">links:</span> <span class="comment">#该行取消注释</span></div><div class="line">  <span class="string">小草莓:</span> <span class="attr">http://my.csdn.net/qq_31196849</span></div><div class="line"><span class="attr">  qingkong:</span> <span class="attr">http://my.csdn.net/qingkong1994</span></div></pre></td></tr></table></figure>
<p>笔者友情链接出现位置在社交链接的下方，效果如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8csps0fsj206w02x3yb.jpg" alt="友情链接示意图"></p>
<h1 id="设置博文内链接为蓝色"><a href="#设置博文内链接为蓝色" class="headerlink" title="设置博文内链接为蓝色"></a>设置博文内链接为蓝色</h1><ul>
<li><strong>修改原因</strong></li>
</ul>
<p>链接的默认颜色是白色的，和普通字体颜色相同，不容易区分，如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8ct4xtwmj20gb04o0so.jpg" alt="链接的默认颜色"></p>
<ul>
<li><strong>修改方法</strong></li>
</ul>
<p>通过路径：</p>
<blockquote>
<p><code>F:Hexo\themes\next\source\css\_common\components\post\</code></p>
</blockquote>
<p>打开<code>post.styl</code>文件，在文件中添加，如下字段：</p>
<figure class="highlight styl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> a&#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</div><div class="line">  <span class="attribute">border-bottom</span>: none;</div><div class="line">  &amp;:hover &#123;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#0477ab</span>;</div><div class="line">    <span class="attribute">text-decoration</span>: underline;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最好将新添加的内容放在原文件内容的底部，便于查看。</p>
<ul>
<li><strong>效果预览</strong></li>
</ul>
<p>设置完成后部署一下，预览效果如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8ctu9t6cj20bi04ldfs.jpg" alt="链接颜色为蓝色"></p>
<p>图中Git的链接出现的下划线是鼠标悬停时的效果。</p>
<h1 id="设置文章末尾”本文结束”标记"><a href="#设置文章末尾”本文结束”标记" class="headerlink" title="设置文章末尾”本文结束”标记"></a>设置文章末尾”本文结束”标记</h1><p><strong>实现方法</strong></p>
<p>在路径<code>F:\Hexo\themes\next\layout\_macro</code>下，新建一个文件<code>passage-end-tag.swig</code>,文件内容中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</div><div class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</div><div class="line">	------ 本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读 ------&lt;/div&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>代码截图如下(在网站中看到的div标签生效消失了，故此截图)：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cu8oh8tj20go027glj.jpg" alt="passage-end-tag"></p>
<p>这里可以更改字体显示的颜色，大小，以及内容，例如可将本文结束用The Happy Ending代替，并将字体颜色设置为了自己喜欢的#CDBA96，你可以去<a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="external">这里</a>选择自己喜欢的颜色对应的RGB值。</p>
<p>然后在路径<code>\themes\next\layout\_macro\</code>下找到并打开<code>post.swig</code>文件，在 <code>post-body</code> 之后， <code>post-footer</code> 之前添加如下代码（post-footer之前两个DIV）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% if not is_index %&#125;</div><div class="line">  &lt;div&gt;</div><div class="line">	&#123;% include &apos;passage-end-tag.swig&apos; %&#125;</div><div class="line">  &lt;/div&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>具体位置如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cupy37bj20m80fbgml.jpg" alt="post.swig文件中的具体位置"></p>
<p>最后在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中，在末尾添加如下语句：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">passage_end_tag:</span></div><div class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<p><strong>实现效果图</strong></p>
<p>最终实现效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cv2mivvj20i004xjra.jpg" alt="效果图"></p>
<h1 id="显示每篇文章字数"><a href="#显示每篇文章字数" class="headerlink" title="显示每篇文章字数"></a>显示每篇文章字数</h1><p><strong>实现方法</strong></p>
<p>首先安装插件，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-wordcount --save</div></pre></td></tr></table></figure>
<p>然后修改<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，定位到<code>post_wordcount</code>，将<code>wordcount</code>由<code>false</code>改为<code>true</code>即可。</p>
<p><strong>实现效果图</strong></p>
<p>在每篇文章标题下会有如下效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cvh9au0j20id04et8s.jpg" alt="字数统计效果图"></p>
<h1 id="显示站点文章总字数"><a href="#显示站点文章总字数" class="headerlink" title="显示站点文章总字数"></a>显示站点文章总字数</h1><p><strong>实现方法</strong></p>
<p>首先安装插件，插件安装同上（已经“显示每篇文章字数”则忽略这步）。</p>
<p>然后修改<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，定位到<code>post_wordcount</code>，将<code>totalcount</code>由<code>false</code>改为<code>true</code>即可。</p>
<p><strong>实现效果图</strong></p>
<p>在页面最底部会有如下效果：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cvva5exj20bn02bdfq.jpg" alt="字数统计效果图"></p>
<h1 id="文章末尾添加版权说明"><a href="#文章末尾添加版权说明" class="headerlink" title="文章末尾添加版权说明"></a>文章末尾添加版权说明</h1><p>直接修改<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，定位到<code>post_copyright</code>，将<code>enable</code>由<code>false</code>改为<code>true</code>即可。</p>
<p>该字段如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Declare license on posts</span></div><div class="line"><span class="attr">post_copyright:</span></div><div class="line"><span class="attr">  enable:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></div><div class="line"><span class="attr">  license_url:</span> <span class="attr">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></div></pre></td></tr></table></figure>
<p>实现效果如图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cw6hx2jj20i304uaa7.jpg" alt="版权说明效果图"></p>
<h1 id="设置个人头像"><a href="#设置个人头像" class="headerlink" title="设置个人头像"></a>设置个人头像</h1><p>通过上面切换到Pisces发现，自己的头像还是属于匿名状态，因此，我们有必要设置一下自己的头像。</p>
<p><strong>实现方法</strong></p>
<p>在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中找到<code>avatar</code>字段,进行修改:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sidebar Avatar</span></div><div class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></div><div class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></div><div class="line"><span class="attr">avatar:</span> <span class="string">/images/head_icon.jpg</span></div></pre></td></tr></table></figure>
<p>先将<code>avatar</code>字段前的#删除，然后粘贴上头像的目录位置或者链接。</p>
<p>笔者将头像图片保存在了主题目录下的<code>source/images</code>文件夹，也可以存放在站点目录下的<code>source/uploads</code>文件夹。也可以将自己的头像图片，保存在百度网盘或者新浪微盘的某个地方，然后将对应的<code>url</code>地址复制过来，添加在<code>avatar</code>字段后即可。</p>
<p><strong>实现效果图</strong></p>
<p>其效果如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cwfm5kzj206t07gq3n.jpg" alt="头像效果展示"></p>
<p>达到效果后即可部署至远程。</p>
<h1 id="设置头像动态特效"><a href="#设置头像动态特效" class="headerlink" title="设置头像动态特效"></a>设置头像动态特效</h1><p>在路径<code>F:\Hexo\themes\next\layout\_partials</code>找到<code>head.swig</code>文件并打开，在其末尾添加，如下字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/animate.css/3.5.0/animate.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>并在路径<code>themes\next\source\css\_common\components\sidebar\</code>下找到<code>sidebar-author.styl</code>文件并打开，添加如下语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.site-author-image</span>:hover &#123;</div><div class="line">  -webkit-<span class="attribute">animation</span>: jello <span class="number">1s</span>;</div><div class="line">  <span class="attribute">animation</span>: jello <span class="number">1s</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中<code>jello</code>是我选择的动态效果，你可以在<a href="https://daneden.github.io/animate.css/" target="_blank" rel="external">这里</a>找到你喜欢的特效;然后更换上述代码中的<code>jello</code>字段，达到预期效果后，即可部署至远程。</p>
<h1 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h1><p><strong>实现方法</strong></p>
<p>打开<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，找到以下字段，进行相应的修改：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Put your favicon.ico into `hexo-site/source/` directory.</span></div><div class="line"><span class="attr">favicon:</span> <span class="string">/web_icon.jpg</span></div></pre></td></tr></table></figure>
<p>其中，图片<code>web_icon.jpg</code>存放在<code>hexo-site/source/</code>目录下。</p>
<p>然后预览，在自己的博客网站上有这样的图标：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cwvi77uj205a00vq2p.jpg" alt="网站图标展示"></p>
<p>因为我使用了与头像一样的图片，所以图标与头像一样。达到效果后即可部署至远程。</p>
<h1 id="添加留言版块"><a href="#添加留言版块" class="headerlink" title="添加留言版块"></a>添加留言版块</h1><p>我们还可以在菜单栏增加一个”留言板”,让他人可以通过留言板直接给我们留言。</p>
<p><strong>实现方法</strong></p>
<p>在博客目录中，执行以下命令，新建一个页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo n page guestbook</div></pre></td></tr></table></figure>
<p>然后通过路径<code>F:\Hexo\source\guestbook</code>找到并打开<code>guestbook</code>文件夹下的<code>index.md</code>文件，然后再文件中添加以下代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ds-recent-visitors"</span> <span class="attr">data-num-items</span>=<span class="string">"28"</span> <span class="attr">data-avatar-size</span>=<span class="string">"42"</span> <span class="attr">id</span>=<span class="string">"ds-recent-visitors"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后打开<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>，在menu字段下，添加如下字段：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">menu:</span></div><div class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></div><div class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></div><div class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></div><div class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></div><div class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></div><div class="line">  <span class="string">留言板:</span> <span class="string">/guestbook</span> <span class="string">||</span> <span class="string">newspaper-o</span> <span class="comment">#自己添加的字段</span></div></pre></td></tr></table></figure>
<p><code>newspaper-o</code>是留言板的图标，可以在<a href="http://fontawesome.io/icons/" target="_blank" rel="external">这里</a>找到自己喜欢的图标。</p>
<p>笔者采用的youyan评论系统，默认在新建页面上会产生评论板块。效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cx96a8jj20rd0agdgc.jpg" alt="留言板效果图"></p>
<blockquote>
<p>这个效果暂时不稳定，可能是由于笔者暂时还没有绑定域名的关系。</p>
</blockquote>
<h1 id="项目主页添加README"><a href="#项目主页添加README" class="headerlink" title="项目主页添加README"></a>项目主页添加README</h1><p>在建立Github上建立自己的博客仓库的时候，没有生成<code>README</code>文件，这样使得其他人无法知道我们这个仓库是做什么，即我们的这个仓库缺少一个说明文件；但是如果直接使用命令<code>hexo n README</code>，再部署至远程的时候，hexo会将它解析为<code>html</code>文件，这不是我们想要的。</p>
<p><strong>实现方法</strong></p>
<p>因此，解决方式是在路径<code>F:\Hexo\source</code>下手动新建<code>README.mdown</code>注意这里的后缀是<code>.mdown</code>，<code>Mardownpad</code>可以将文件保存为<code>.mdown</code>后缀文件；然后再在这个新建文件中写<code>README</code>即可。再之后<code>hexo g</code>会把它复制到<code>public</code>文件夹，而不会被解析成<code>html</code>文件，发布在博客中。</p>
<p><strong>实现效果图</strong></p>
<p>预览效果，如图：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn90mhdbfdj20fr05zdfr.jpg" alt="README效果图"></p>
<h1 id="实现fork-me-on-github"><a href="#实现fork-me-on-github" class="headerlink" title="实现fork me on github"></a>实现fork me on github</h1><p>在右上角或者左上角实现fork me on github。</p>
<p><strong>实现方法</strong></p>
<p>点击<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="external">这里</a>挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码： </p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cxpybw2j20h305hgm2.jpg" alt="fork me代码图"></p>
<p>然后粘贴刚才复制的代码到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>标签改为你的<code>github</code>地址：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cxz9ckqj20p104sdg4.jpg" alt="fork me具体位置"></p>
<p><strong>实现效果图</strong></p>
<p>实现效果图如下（右上角）：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cyazkhlj214d08ngmq.jpg" alt="fork me效果图"></p>
<h1 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h1><p><strong>实现方法</strong></p>
<p>打开浏览器，输入如下网址</p>
<blockquote>
<p><a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="external">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</a></p>
</blockquote>
<p>然后将里面的代码copy一下，新建<code>love.js</code>文件并且将代码复制进去，然后保存。将<code>love.js</code>文件放到路径<code>/themes/next/source/js/src</code>里面，然后打开<code>\themes\next\layout\_layout.swig</code>文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>实现效果图</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cyov4svg201u0363z5.gif" alt="love效果图"></p>
<h1 id="修改文章底部的-号标签"><a href="#修改文章底部的-号标签" class="headerlink" title="修改文章底部的#号标签"></a>修改文章底部的#号标签</h1><p><strong>实现方法</strong></p>
<p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将其中的 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<p><strong>实现效果图</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8cz284l5j206b01kq2p.jpg" alt="新标签符号图"></p>
<h1 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h1><p><strong>实现方法</strong></p>
<p>在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中，定位到如下部分：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Canvas-nest</span></div><div class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment"># three_waves</span></div><div class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment"># canvas_lines</span></div><div class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment"># canvas_sphere</span></div><div class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment"># Only fit scheme Pisces</span></div><div class="line"><span class="comment"># Canvas-ribbon</span></div><div class="line"><span class="attr">canvas_ribbon:</span> <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>这是已经集成好的几个动态效果，笔者采用的是canvas_nest，读者可依次体验(将false改为true)，选择最喜欢的动态背景。</p>
<p><strong>实现效果图</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8czckum6g20cy05576m.gif" alt="动态背景效果图"></p>
<h1 id="代码块样式自定义"><a href="#代码块样式自定义" class="headerlink" title="代码块样式自定义"></a>代码块样式自定义</h1><p><strong>实现方法</strong></p>
<p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：(颜色可以自己定义)<br><figure class="highlight styl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Custom styles.</span></div><div class="line"><span class="selector-tag">code</span> &#123;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#ff7600</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#fbf7f8</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 大代码块的自定义样式</span></div><div class="line"><span class="selector-class">.highlight</span>, pre &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.highlight</span>, <span class="selector-tag">code</span>, pre &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d6d6d6</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>实现效果图</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8czmxoksj20i9084q3b.jpg" alt="代码块样式效果图"></p>
<h1 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h1><p><strong>实现方法</strong></p>
<p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,在以下位置插入这样一段代码：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8czy6aiuj20u00n2q6m.jpg" alt="文章加密访问"></p>
<p>代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">    (function()&#123;</span></div><div class="line"><span class="undefined">        if('&#123;&#123; page.password &#125;&#125;')&#123;</span></div><div class="line"><span class="undefined">            if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123;</span></div><div class="line"><span class="undefined">                alert('密码错误！');</span></div><div class="line"><span class="undefined">                history.back();</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">    &#125;)();</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在文章上写成类似这样：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8d0be2a3j20k00c60tn.jpg" alt="文章加密访问"></p>
<p><strong>实现效果图</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8d0lzv0kg20we0ehnh7.gif" alt="文章加密访问"></p>
<h1 id="添加jiathis分享"><a href="#添加jiathis分享" class="headerlink" title="添加jiathis分享"></a>添加jiathis分享</h1><p><strong>实现方法</strong></p>
<p>在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中，jiathis为true，就行了，代码如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Share</span></div><div class="line"><span class="comment"># This plugin is more useful in China, make sure you known how to use it.</span></div><div class="line"><span class="comment"># And you can find the use guide at official webiste: http://www.jiathis.com/.</span></div><div class="line"><span class="comment"># Warning: JiaThis does not support https.</span></div><div class="line"><span class="attr">jiathis:</span> <span class="literal">true</span></div><div class="line">  <span class="comment">##uid: Get this uid from http://www.jiathis.com/</span></div><div class="line"><span class="comment">#add_this_id:</span></div></pre></td></tr></table></figure>
<p><strong>实现效果图</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8d0xekdpj20i60cut9b.jpg" alt="分享效果图"></p>
<h1 id="自定义鼠标样式"><a href="#自定义鼠标样式" class="headerlink" title="自定义鼠标样式"></a>自定义鼠标样式</h1><p><strong>实现方法</strong></p>
<p>打开<code>themes/next/source/css/_custom/custom.styl</code>,在里面写下如下代码<br><figure class="highlight styl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 鼠标样式</span></div><div class="line">  * &#123;</div><div class="line">      <span class="attribute">cursor</span>: url(<span class="string">"http://om8u46rmb.bkt.clouddn.com/sword2.ico"</span>),auto!important</div><div class="line">  &#125;</div><div class="line">  :active &#123;</div><div class="line">      <span class="attribute">cursor</span>: url(<span class="string">"http://om8u46rmb.bkt.clouddn.com/sword1.ico"</span>),auto!important</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>url</code> 里面必须是 <code>ico</code> 图片，<code>ico</code>图片可以上传到网上，然后获取外链，复制到 <code>url</code> 里就行了</p>
<h1 id="支持mathjax公式"><a href="#支持mathjax公式" class="headerlink" title="支持mathjax公式"></a>支持mathjax公式</h1><p>看到网上说明安装hexo-math工具，或者其他的一系列教程，如<a href="http://cn.clanzd.com/mathjax-for-hexo.html" target="_blank" rel="external">这个</a>。</p>
<p>其实在目前的hexo/NexT主题已经集成了mathjax，所以不需要那么麻烦的设置了。</p>
<p><strong>实现方法</strong></p>
<p>在<strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>中，定位到mathjax，将后面的选项为true，就行了。</p>
<p>另外，虽然这样设置了，但是在编写的时候还会出现mathjax与markdown默认渲染不兼容的问题，导致有时候公式一复杂就显示不出来。</p>
<p>解决上述问题的方法请参照我写的另一片博客：<a href="https://qwerty200696.github.io/2017/09/21/markdown_mathjax/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/markdown_mathjax/</a></p>
<h1 id="修改字体颜色-大小-背景色"><a href="#修改字体颜色-大小-背景色" class="headerlink" title="修改字体颜色/大小/背景色"></a>修改字体颜色/大小/背景色</h1><p>比如说，想在文章中对某一部分的文字进行强调（改变大小，颜色），该操作具体说明如下：</p>
<p>如果想自定义字体大小以及颜色，可以直接在 Markdown 文档中使用 html 语法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">4</span> &gt;</span> 这里输入文字，自定义字体大小 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#FF0000"</span>&gt;</span> 这里输入文字，自定义字体颜色<span class="tag">&lt;/<span class="name">font</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: #ff6600;"</span>&gt;</span>这里输入文字，自定义字体背景色<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#000000"</span> <span class="attr">size</span>=<span class="string">4</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: #ADFF2F;"</span>&gt;</span>这是综合起来的效果 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"#FFFFFF"</span> <span class="attr">size</span>=<span class="string">4</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"background-color: #68228B;"</span>&gt;</span>这是综合起来的效果2 <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中<code>#FF0000</code>为RGB颜色代码，读者可去<a href="http://www.114la.com/other/rgb.htm" target="_blank" rel="external">RGB颜色查询对照表网站</a>查找自己喜欢的颜色。</p>
<p>若想在RGB颜色值与十六进制颜色码之间相互转化，可查看<a href="http://www.sioe.cn/yingyong/yanse-rgb-16/" target="_blank" rel="external">该网站</a>。</p>
<p>效果如下：</p>
<p><font size="4"> 这里输入文字，自定义字体大小 </font></p>
<p><font color="#FF0000"> 这里输入文字，自定义字体颜色</font><br><span style="background-color: #ff6600;">这里输入文字，自定义字体背景色</span></p>
<p><font color="#000000" size="4"><span style="background-color: #ADFF2F;">这是综合起来的效果 </span></font></p>
<p><font color="#FFFFFF" size="4"><span style="background-color: #68228B;">这是综合起来的效果2 </span></font></p>
<h1 id="实现首行缩进"><a href="#实现首行缩进" class="headerlink" title="实现首行缩进"></a>实现首行缩进</h1><p>由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，因此想要实现行缩进需要加上相应的代码，如下。</p>
<p>在需要缩进行的开头处，先输入下面的代码，然后紧跟着输入文本即可。分号也不要漏掉。 </p>
<p>直接写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">半方大的空白`&amp;ensp;`或`&amp;#8194`;</div><div class="line">全方大的空白`&amp;emsp;`或`&amp;#8195`;</div><div class="line">不断行的空白格`&amp;nbsp;`或`&amp;#160`;</div></pre></td></tr></table></figure></p>
<p>亲测可行。</p>
<h1 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h1><h2 id="方法1：html代码"><a href="#方法1：html代码" class="headerlink" title="方法1：html代码"></a>方法1：html代码</h2><p>插入表格的代码是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered table-striped table-condensed"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>雾霾<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>暴雨<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果为：</p>
<table class="table table-bordered table-striped table-condensed"><br>    <tr><br>        <td>北京</td><br>    <td>雾霾</td><br>    </tr><br>    <tr><br>        <td>深圳</td><br>    <td>暴雨</td><br>    </tr><br></table>  

<p>可以看到上面多出了很多空行，所以我一般采用第二种方法，如下：</p>
<h2 id="方法二：markdown代码"><a href="#方法二：markdown代码" class="headerlink" title="方法二：markdown代码"></a>方法二：markdown代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|函数名|功能|</div><div class="line">|----|----|</div><div class="line">|max|求最大值|</div><div class="line">|min|求最小值|</div></pre></td></tr></table></figure>
<p>效果如下：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>max</td>
<td>求最大值</td>
</tr>
<tr>
<td>min</td>
<td>求最小值</td>
</tr>
</tbody>
</table>
<h1 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h1><h2 id="安装-hexo-generator-feed-插件"><a href="#安装-hexo-generator-feed-插件" class="headerlink" title="安装 hexo-generator-feed 插件"></a>安装 hexo-generator-feed 插件</h2><p>RSS需要有一个Feed链接，而这个链接需要靠<code>hexo-generator-feed</code>插件来生成，所以第一步需要添加插件，在<strong>Hexo根目录</strong>执行安装指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure></p>
<h2 id="配置feed信息"><a href="#配置feed信息" class="headerlink" title="配置feed信息"></a>配置feed信息</h2><p>在<strong><font color="#000000"><span style="background-color: #ADFF2F;">站点配置文件 </span></font></strong>中追加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">feed:</div><div class="line">  type: rss2</div><div class="line">  path: rss2.xml</div><div class="line">  limit: 10</div><div class="line">  hub:</div><div class="line">  content: &apos;true&apos;</div></pre></td></tr></table></figure></p>
<p>feed属性下的各个子属性的含义借用feed官方英文解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">type - Feed type. (atom/rss2)</div><div class="line">path - Feed path. (Default: atom.xml/rss2.xml)</div><div class="line">limit - Maximum number of posts in the feed (Use 0 or false to show all posts)</div><div class="line">hub - URL of the PubSubHubbub hubs (Leave it empty if you don&apos;t use it)</div><div class="line">content - (optional) set to &apos;true&apos; to include the contents of the entire post in the feed.</div></pre></td></tr></table></figure></p>
<p>至此RSS功能大功告成，部署至远程后，会发现RSS已经自动出现，效果图如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8d5gxm6fj207m0cajsb.jpg" alt=""></p>
<h2 id="手机端订阅图"><a href="#手机端订阅图" class="headerlink" title="手机端订阅图"></a>手机端订阅图</h2><p>手机端订阅效果展示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8d605gtoj20ku112dgj.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8d68a0c8j20ku112abz.jpg" alt=""></p>
<h1 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h1><p>笔者采用的是local search。<br>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-searchdb --save</div></pre></td></tr></table></figure></p>
<p>编辑 <strong><font color="#000000"><span style="background-color: #ADFF2F;">站点配置文件 </span></font></strong>（站点根目录下），新增以下内容到任意位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div><div class="line">  format: html</div><div class="line">  limit: 10000</div></pre></td></tr></table></figure></p>
<p>编辑 <strong><font color="#FFFFFF"><span style="background-color: #68228B;">主题配置文件 </span></font></strong>（主题目录下），启用本地搜索功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Local search</div><div class="line">local_search:</div><div class="line">  enable: true</div></pre></td></tr></table></figure></p>
<p>之后部署到远程即可。</p>
<h1 id="Hexo博客提交百度和Google收录"><a href="#Hexo博客提交百度和Google收录" class="headerlink" title="Hexo博客提交百度和Google收录"></a>Hexo博客提交百度和Google收录</h1><p>这篇文章写得很详细，我就不详细说了：<br><a href="https://www.jianshu.com/p/8c0707ce5da4" target="_blank" rel="external">Hexo博客收录百度和谷歌-基于Next主题</a></p>
<h1 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h1><p>参考这篇文章：<a href="http://blog.csdn.net/lcyaiym/article/details/76796545" target="_blank" rel="external">hexo的next主题打赏</a></p>
<h1 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h1><p>这篇文章提供了新工具，很方便：<a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决Hexo置顶问题</a></p>
<p>目前按照上述方法，安装新工具之后，只需要在需要置顶文章上面加上<code>top: true</code>字段即可。</p>
<p>比如说置顶这篇文章：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: hexo搭建的Github博客之优化</div><div class="line">date: 2017-09-09 10:27:20</div><div class="line">categories: 博客搭建系列</div><div class="line">tags:</div><div class="line">	- 博客</div><div class="line">top: true</div><div class="line">---</div></pre></td></tr></table></figure>
<p><em>目前有个困惑就是，如何加上置顶的标签。（置顶的文章并没有主动显示“我是被置顶上来的”)</em></p>
<p><del>也参考这篇文章：<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">解决Hexo博客文章置顶问题</a></del></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><p><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="external">【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能</a></p>
</li>
<li><p><a href="https://tzkang.github.io/2016/10/17/2016-10-17/#more" target="_blank" rel="external">GitHub+Hexo+NexT搭建个人博客</a></p>
</li>
<li><p><a href="http://blog.csdn.net/com_ma/article/details/76039859" target="_blank" rel="external">hexo博客的背景设置</a></p>
</li>
<li><p><a href="http://bbs.csdn.net/topics/310228143" target="_blank" rel="external">html设置字体背景色的标签或代码</a></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> GitHub </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+GitHub博客搭建实战]]></title>
      <url>/2017/09/08/blog_setup/</url>
      <content type="html"><![CDATA[<p>我的个人博客链接：<a href="http://wangwlj.com">wangwlj.com</a></p>
<p>想要搭建类似的博客吗？</p>
<p>如果是，那就赶快点进来吧～～</p>
<p>手把手教学，现在开始！！</p>
<p>PS: 将会在个人博客持续更新，本文链接：<a href="http://wangwlj.com/2017/09/08/blog_setup/">hexo+GitHub博客搭建实战</a>。</p>
<a id="more"></a>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>为什么自己搭建博客，知乎不行吗？<br>可以看看<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">刘未鹏 | Mind Hacks</a>，前些天发布了某篇文章应该是被人举报了，结果知乎就删了。有自己的博客自由，自在。更多请看<a href="https://www.zhihu.com/question/19916345" target="_blank" rel="external">为什么要自建博客？</a></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>1、安装 Node.js: <a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a></p>
<p>2、安装 Git: <a href="https://github.com/waylau/git-for-win" target="_blank" rel="external">https://github.com/waylau/git-for-win</a></p>
<p>详细Git教程可参考廖雪峰老师的教程： <code>https://github.com/waylau/git-for-win</code>。（本篇教程中无须观看也可完成搭建）</p>
<p>3、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，名称和邮箱是Github上的。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bw2kfvbj20gj0agt97.jpg" alt="Git Bash界面与指令"></p>
<p>4、安装 Hexo。所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<p>这一步如果出错，可到文末的“出错汇总”查看解决方法。</p>
<p>至此，本地环境已经搭建完成。</p>
<h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>首先注册、登录 <a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
<p>记住自己的<code>Username</code>（很重要）</p>
<p>然后右上角选择 <code>Create a new repository</code>： <a href="https://github.com/new" target="_blank" rel="external">https://github.com/new</a><br>如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bxjgd4vj20km0grmyu.jpg" alt="githhub创建仓库截图"></p>
<p>其中仓库名称<code>Repository name</code>一项填写格式为：<code>yourname.github.io</code>(<code>yourname</code>与你的注册用户名一致,这个就是你博客的域名了)</p>
<p>仓库创建完成后，开始生成添加秘钥。</p>
<p>在终端（cmd）输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</div></pre></td></tr></table></figure>
<p>一路Enter过来就好，待秘钥生成完毕，会得到两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>，用带格式的记事本打开<code>id_rsa.pub</code>，<code>Ctrl + a</code>复制里面的所有内容，然后进入<br><a href="https://github.com/settings/ssh" target="_blank" rel="external">https://github.com/settings/ssh</a> </p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bxz4vt3j20k80addg2.jpg" alt="githhub输入秘钥"></p>
<p>将复制的内容粘贴到Key的输入框，<code>Title</code>的内容可以随意（比如<code>ubuntu home</code>），点击<code>Add SSH key</code>按钮即可。</p>
<p>若没有配置<code>GitHub</code>，就执行第三步（初始化博客），会出现如下错误：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bykyejxj20fx03nwej.jpg" alt="初始化错误"></p>
<h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>在电脑F盘（自己随意）目录下新建文件夹 test，进入test，按住Shift键点击鼠标右键，点击“在此处打开命令窗口”：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bywmdufj207p0iit9b.jpg" alt="右键选择菜单"></p>
<p>输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init blog</div></pre></td></tr></table></figure></p>
<p>稍微等待下，速度有点慢。成功提示：</p>
<blockquote>
<p>INFO  Start blogging with Hexo!</p>
</blockquote>
<p>因为你初始化hexo 之后source目录下自带一篇<code>hello world</code>文章, 所以直接执行下方命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo generate</div><div class="line"><span class="meta">#</span> 启动本地服务器</div><div class="line"><span class="meta">$</span> hexo server</div><div class="line"><span class="meta">#</span> 在浏览器输入 http://localhost:4000/就可以看见网页和模板了</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure></p>
<p>访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>，便可以看到网站初步的模样，不要激动，我们还要把网页发布到Github上去。</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bz9225lj20wd0ky459.jpg" alt="localhost上的网站初步形状"></p>
<h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><p>在<code>blog</code>目录下，用<code>sublime/notepad++</code>等文本编辑器打开<code>_config.yml</code>文件，修改参数信息</p>
<blockquote>
<p>特别提醒，在每个参数的：后都需要有一个空格</p>
</blockquote>
<h3 id="修改网站相关信息"><a href="#修改网站相关信息" class="headerlink" title="修改网站相关信息"></a>修改网站相关信息</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">title:</span> <span class="string">wangwlj的博客</span></div><div class="line"><span class="attr">subtitle:</span> <span class="string">积跬步以至千里！</span></div><div class="line"><span class="attr">description:</span> <span class="string">网页描述</span></div><div class="line"><span class="attr">author:</span> <span class="string">wangwlj</span></div><div class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></div><div class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></div></pre></td></tr></table></figure>
<p><code>language</code>和<code>timezone</code>都是有输入规范的，详细可参考 <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes" target="_blank" rel="external">语言规范</a>和<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="external">时区规范</a>。</p>
<h3 id="配置部署"><a href="#配置部署" class="headerlink" title="配置部署"></a>配置部署</h3><p>代码中的<code>qwerty200696</code>，修改成自己的。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">deploy:</span></div><div class="line"><span class="attr">  type:</span> <span class="string">git</span></div><div class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/qwerty200696/qwerty200696.github.io</span></div><div class="line"><span class="attr">  branch:</span> <span class="string">master</span></div></pre></td></tr></table></figure>
<p>其中<code>repo</code>项是之前<code>Github</code>上创建好的仓库的地址，可以通过如下图所示的方式得到：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bznd2k9j20rx0fx0vp.jpg" alt="repo地址"></p>
<p>branch是项目的分支，我们默认用主分支<code>master</code>。</p>
<p>此外，可将<code>_config.yml</code>中的<code>repo</code>修改为如下标准格式：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">repo:</span> <span class="attr">https://用户名:密码@github.com/用户名/用户名.github.io.git</span></div></pre></td></tr></table></figure></p>
<p>这样做的好处就是每次<code>hexo deploy</code>提交时不需要输入账号密码。</p>
<h3 id="配置统一资源定位符"><a href="#配置统一资源定位符" class="headerlink" title="配置统一资源定位符"></a>配置统一资源定位符</h3><p>如果有个人域名的话可以设置，否则跳过即可。如果是<code>github.io</code>的网址，也是可以填上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url: https://qwerty200696.github.io</div></pre></td></tr></table></figure>
<p>对于<code>root</code>（根目录）、<code>permalink</code>（永久链接）、<code>permalink_defaults</code>（默认永久链接）等其他信息保持默认。</p>
<h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>1.新建一篇博文，在CMD中输入:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> hexo new "我的测试文章"</div><div class="line"></div><div class="line">INFO  Created: F:\test\blog\source\_posts\我的测试文章.md</div></pre></td></tr></table></figure>
<p>2.根据上述提示路径找到该文章，打开，使用<code>Markdown</code>语法编辑文章。</p>
<p>该语法介绍可以查看：<a href="https://zhangslob.github.io/2017/02/26/%E5%88%A9%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">markdown语法</a></p>
<p>在文章的一开始处，可以按如下格式添加文章标题，日期，分类、标签以及描述等。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">title:</span> <span class="string">title</span> <span class="comment">#文章標題</span></div><div class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-09</span><span class="bullet">-08</span> <span class="number">23</span><span class="string">:47:44</span> <span class="comment">#文章生成時間</span></div><div class="line"><span class="attr">categories:</span> <span class="string">"Hexo教程"</span> <span class="comment">#文章分類目錄 可以省略</span></div><div class="line"><span class="attr">tags:</span> <span class="comment">#文章標籤 可以省略</span></div><div class="line"><span class="bullet">     -</span> <span class="string">标签1</span></div><div class="line"><span class="bullet">     -</span> <span class="string">标签2</span></div><div class="line"><span class="attr"> description:</span> <span class="comment">#你對本頁的描述 可以省略</span></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure>
<p>3.接着输入如下的一系列(三个)命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">F:\test\blog</div><div class="line"><span class="meta">$</span> hexo clean</div><div class="line">INFO  Deleted database.</div><div class="line">INFO  Deleted public folder.</div><div class="line"></div><div class="line">F:\test\blog</div><div class="line"><span class="meta">$</span> hexo generate</div><div class="line">INFO  Start processing</div><div class="line">INFO  Files loaded in 1.48 s</div><div class="line"><span class="meta">#</span>省略</div><div class="line">INFO  29 files generated in 4.27 s</div><div class="line"></div><div class="line"><span class="meta">$</span> hexo server</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure></p>
<p>打开<code>http://localhost:4000/</code>，可以在本地预览网站的初步样子。</p>
<p>最后一步，发布到远程，执行<code>hexo deploy</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">F:\test\blog</div><div class="line"><span class="meta">$</span> hexo deploy</div><div class="line">INFO  Deploying: git</div><div class="line">INFO  Clearing .deploy_git folder...</div><div class="line">INFO  Copying files from public folder...</div><div class="line"><span class="meta">#</span>省略</div></pre></td></tr></table></figure></p>
<p>执行<code>hexo deploy</code>时如果出现错误，请到文末查看具体解决方案。</p>
<p>正常情况下，会跳出Github登录，直接登录；如果没有问题，在浏览器输入博客地址： <code>qwerty200696.github.io</code>。</p>
<p>然后就可以看到已经有内容了。（有可能稍有延迟）</p>
<h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>经过上面的配置后，发现上传的博客文章里面的本地图片居然显示不来（没有同步上传）。</p>
<p>于是，找到解决方案：</p>
<p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件</p>
<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成<code>md</code>博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>
<p>4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="string">你想输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</div></pre></td></tr></table></figure></p>
<p>注意： <code>xxxx</code>是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入<code>xxxx</code>这个文件夹内就好了，很像引用相对路径。</p>
<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
<p>6.<code>hexo s</code>，运行本地服务器，打开<code>http://localhost:4000/</code>，可实时查看修改情况。</p>
<p>7.<code>hexo d</code>，同步到github。</p>
<p>参考自：<a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="external">hexo生成博文插入图片</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发布文章的步骤：</p>
<p>1、<code>hexo new</code> 创建文章(当然也可以通过其他方式创建Markdown文件)</p>
<p>2、<code>Markdown</code>语法编辑文章</p>
<p>3、部署（所有打开CMD都是在blog目录下）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</div><div class="line">hexo generate #生成</div><div class="line">hexo server #启动服务预览，非必要，可本地浏览网页</div><div class="line">hexo deploy #部署发布</div></pre></td></tr></table></figure></p>
<p>部分命令可以简写。简写Tips：</p>
<ol>
<li><p>hexo n “我的博客” == hexo new “我的博客” #新建文章</p>
</li>
<li><p>hexo p == hexo publish</p>
</li>
<li><p>hexo g == hexo generate # 生成</p>
</li>
<li><p>hexo s == hexo server # 启动服务预览</p>
</li>
<li><p>hexo d == hexo deploy # 部署</p>
</li>
</ol>
<font color="AA00AA" size="4"><strong>到此为止，相信你已经对博客的整体流程有了一定的把握，想要对博客进一步优化吗？</strong></font>

<p><strong><font color="AA00AA" size="4">请进入博客优化篇：</font><a href="http://wangwlj.com/2017/09/09/blog-opti/">hexo搭建的Github博客之优化</a></strong></p>
<h2 id="出错汇总"><a href="#出错汇总" class="headerlink" title="出错汇总"></a>出错汇总</h2><h3 id="安装hexo时出错"><a href="#安装hexo时出错" class="headerlink" title="安装hexo时出错"></a>安装hexo时出错</h3><blockquote>
<p><code>unable to verify the first certificate</code>（无法验证第一证书）</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bweqsz3j20i4071mxd.jpg" alt="安装hexo出错截图"></p>
<p>查找到解决方案：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bwppyngj20kr0d3wf4.jpg" alt="解决方案截图-推荐方案一"></p>
<p>参考网址：<a href="http://www.zhimengzhe.com/Javascriptjiaocheng/243010.html" title="npm报错" target="_blank" rel="external">npm报错</a></p>
<p>依据解决方案所述，在命令行输入如下命令，来取消ssl验证：</p>
<pre><code>npm config set strict-ssl false
</code></pre><p>之后安装就会成功了，显示如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8bx52zhoj20it0cagmp.jpg" alt="hexo安装成功"></p>
<h3 id="hexo-deploy出错之一"><a href="#hexo-deploy出错之一" class="headerlink" title="hexo deploy出错之一"></a><code>hexo deploy</code>出错之一</h3><pre><code>deploy not found： git
</code></pre><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8c064618j20at01da9u.jpg" alt="deploy not found： git"></p>
<p>解决方案：执行如下语句后， 再部署即可：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>参考自：<a href="https://www.v2ex.com/t/175940" target="_blank" rel="external">https://www.v2ex.com/t/175940</a></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8c0km2e4j20hi07smxf.jpg" alt="错误一修正"></p>
<h3 id="hexo-deploy出错之二"><a href="#hexo-deploy出错之二" class="headerlink" title="hexo deploy出错之二"></a><code>hexo deploy</code>出错之二</h3><p>安装完成之后的第x天，同步文章到<code>github</code>时，即运行如下命令：</p>
<pre><code>hexo deploy
</code></pre><p>居然出现了如下的错误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fatal: unable to access 'https://username:password@github.com/username/username.github.io.git/': SSL certificate problem: unable to get local issuer certificate</div><div class="line">FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</div><div class="line">Error: fatal: unable to access 'https://username:password@github.com/username/username.github.io.git/': SSL certificate problem: unable to get local issuer certificate</div><div class="line"></div><div class="line">    at ChildProcess.&lt;anonymous&gt; (D:\test\blog2\node_modules\hexo-util\lib\spawn.js:37:17)</div><div class="line">    at emitTwo (events.js:106:13)</div><div class="line">    at ChildProcess.emit (events.js:191:7)</div><div class="line">    at ChildProcess.cp.emit (D:\test\blog2\node_modules\cross-spawn\lib\enoent.js:40:29)</div><div class="line">    at maybeClose (internal/child_process.js:920:16)</div><div class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:230:5)</div></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8c2f3kldj20gj09twfi.jpg" alt="SSL错误"></p>
<p>解决方法：执行如下语句：</p>
<pre><code>$ git config --global http.sslVerify false
</code></pre><p>参考自：<a href="http://windigniter.com/itblog/detail/2015/06/git-ssl-certificate-problem" target="_blank" rel="external">git获取代码提示SSL certificate problem: unable to get local issuer certificate</a></p>
<p>参考自： <a href="http://blog.csdn.net/w20101310/article/details/52796721?locationNum=6&amp;fps=1" target="_blank" rel="external">hexo提交报错 unable to access</a></p>
<p>之后再次运行发布指令，终于成功：</p>
<pre><code>hexo deploy
</code></pre><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn8c2r8p66j20g608mt9g.jpg" alt="SSL错误解决"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://zhangslob.github.io/2017/02/28/%E6%95%99%E4%BD%A0%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8CHexo-Github/" target="_blank" rel="external">教你免费搭建个人博客，Hexo&amp;Github</a></li>
<li><a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="external">hexo生成博文插入图片</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> GitHub </tag>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows下TensorFlow完整安装流程及出错解决方案]]></title>
      <url>/2017/09/07/TensorFlow_setup/</url>
      <content type="html"><![CDATA[<p>本文分为如下几大步骤：</p>
<ul>
<li>安装python及环境变量配置</li>
<li>安装cuda/cndnn</li>
<li>安装TensorFlow</li>
<li>测试是否成功</li>
</ul>
<a id="more"></a>
<h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><h3 id="通过Pip在Windows上安装Python"><a href="#通过Pip在Windows上安装Python" class="headerlink" title="通过Pip在Windows上安装Python"></a>通过Pip在Windows上安装Python</h3><p><code>TensorFlow</code>在<code>Windows</code>上只支持64位<code>Python3.5</code>，可以通过<a href="https://www.python.org/downloads/release/python-352/" title="Python 3.5.2" target="_blank" rel="external">Python 3.5 from python.org</a> 下载并安装<code>Python3.5.2</code>（注意选择正确的操作系统）。</p>
<p>或者通过<a href="https://www.python.org/downloads/" title="python下载" target="_blank" rel="external">https://www.python.org/downloads/</a>选择3.5的任意版本。</p>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>上一步安装时，如果勾选了“自动配置环境变量”操作，即：在<code>cmd</code>中输入<code>pip</code>，如果找到了该命令，则可省去该步骤。</p>
<p>若在<code>cmd</code>中输入<code>pip</code>找不到该命令，则需要将<code>Python</code>安装路径下“<code>%安装路径%\Scripts</code>”添加到Path下；再到cmd中输入pip看到若干命令提示，则代表<code>python</code>安装成功（<code>Python</code>安装包自带<code>pip</code>）。“开始”-&gt;“所有程序”，也可以找到<code>Python</code>终端。</p>
<p>参考自：<a href="http://blog.csdn.net/include1224/article/details/53452824" title="原生Windows安装TensorFlow 0.12方法" target="_blank" rel="external">http://blog.csdn.net/include1224/article/details/53452824</a></p>
<h2 id="cuda以及cudnn的安装"><a href="#cuda以及cudnn的安装" class="headerlink" title="cuda以及cudnn的安装"></a>cuda以及cudnn的安装</h2><p><code>TensorFlow</code>分为<code>CPU</code>版和<code>GPU</code>版，如果你打算安装<code>GPU</code>版，请先安装如下两个驱动：</p>
<p>1、CUDA安装：<code>https://developer.nvidia.com/cuda-downloads</code></p>
<p><img src="/2017/09/07/TensorFlow_setup/cuda_download.png" alt="cuda截图"></p>
<p>2、CuDNN安装：<code>https://developer.nvidia.com/cudnn</code>（要注册Nvidia用户，并加入CuDNN开发组，填若干问卷就可以下载了）选择下载版本时要注意和Cuda版本匹配。</p>
<p>我的账户是<strong>qq邮箱</strong>。</p>
<p>解压后（三个目录，分别是：bin、include、lib），覆盖至CUDA的安装目录下。例如：</p>
<pre><code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\
</code></pre><h2 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h2><p>我安装的是GPU版本。</p>
<p><code>windows</code>不支持<code>pip</code>在线安装。即不支持：<code>pip install tensorflow-gpu</code>该命令。</p>
<p>两种方法安装<code>tensorflow</code>：</p>
<h3 id="手动下载tensorflow-gpu版本文件："><a href="#手动下载tensorflow-gpu版本文件：" class="headerlink" title="手动下载tensorflow gpu版本文件："></a>手动下载tensorflow gpu版本文件：</h3><p><code>tensorflow_gpu-0.12.0rc0-cp35-cp35m-win_amd64.whl</code><br>下载网址：<a href="https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl" title="tensorflow下载网址" target="_blank" rel="external">https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl</a></p>
<p>下载完成后，打开cmd，切换到安装文件目录，输入: </p>
<pre><code>pip install tensorflow_gpu-0.12.0rc0-cp35-cp35m-win_amd64.whl
</code></pre><p>即可成功安装。</p>
<p><img src="/2017/09/07/TensorFlow_setup/tensorflow_setup.png" alt="tensorflow安装"></p>
<h3 id="输入pip命令"><a href="#输入pip命令" class="headerlink" title="输入pip命令"></a>输入pip命令</h3><pre><code>pip install --upgrade https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl
</code></pre><p>参考自tensorflow官网：<a href="https://www.tensorflow.org/versions/r0.12/get_started/os_setup#pip_installation_on_windows" title="tensorflow官网" target="_blank" rel="external">https://www.tensorflow.org/versions/r0.12/get_started/os_setup#pip_installation_on_windows</a></p>
<p>mac和linux可另行参考网上教程。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试是否安装成功。</p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><pre><code>import tensorflow as tf
</code></pre><p>导入tensorflow时出现错误：</p>
<pre><code>“Couldn&apos;t open CUDA library cudnn64_5.dll”
</code></pre><p><img src="/2017/09/07/TensorFlow_setup/error_1.png" alt="测试"></p>
<p>找到解决方案：<br>安装时没有注意cudnn版本要求，下载安装了cudnnv6.0，安装完后自己查找文件，只有cudnn64_6.dll，没有cudnn64_5.dll。</p>
<p><img src="/2017/09/07/TensorFlow_setup/error_1_1.png" alt="测试"></p>
<p>解决方案为将cudnnV6.0替换为cudnnV5.1即可。</p>
<p>即重新下载cudnn5.1版本。 <a href="https://developer.nvidia.com/rdp/cudnn-download" title="cudnn下载地址" target="_blank" rel="external">https://developer.nvidia.com/rdp/cudnn-download</a></p>
<p><img src="/2017/09/07/TensorFlow_setup/error_1_2.png" alt="测试"></p>
<p>解决方案来自：<a href="http://blog.csdn.net/suo_ivy/article/details/70445103" title="TensorFlow “Couldn&#39;t open CUDA library cudnn64_5.dll”" target="_blank" rel="external">http://blog.csdn.net/suo_ivy/article/details/70445103</a></p>
<p>替换完成后，该错误消失。</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p><img src="/2017/09/07/TensorFlow_setup/error_2.png" alt="测试"></p>
<p>执行<code>tf.Session()</code>的时候，出现如下提示：</p>
<pre><code>Could not identify NUMA node of /job:localhost/replica:0/task:0/gpu:0, defaulting to 0.  Your kernel may not have been built with NUMA support.`
</code></pre><p>不过这并不影响最终结果的执行。（只是个警告）</p>
<p><img src="/2017/09/07/TensorFlow_setup/error_2_1.png" alt="测试"></p>
<p>网上找到相关说明： <a href="http://blog.csdn.net/baixiaozhe/article/details/54598346" title="NUMA support" target="_blank" rel="external">http://blog.csdn.net/baixiaozhe/article/details/54598346</a><br>可供参考一下。<br>大体上的意思是：只要我们不是使用多GPU，这个警告应该是可以忽略的，所以我们目前也不需要担心了。</p>
<p>至此，tensorflow 测试完成，并成功运行了测试样例。</p>
<p>(optional) 测试程序源码</p>
<p>哈哈，是不是迫不及待想用TensorFlow来实现具体的神经网络算法呢？</p>
<p>那就请查看<code>TensorFlow</code>系列的下一篇文章：<a href="http://wangwlj.com/2017/12/28/tensorflow_base/">TensorFlow基础篇与搭建深层神经网络</a>。</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
