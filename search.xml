<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重新回归个人网站的简短说明]]></title>
    <url>%2F2021%2F01%2F16%2Fpersnal_note_im_back%2F</url>
    <content type="text"><![CDATA[看着博客上的最后一篇博文时间，停留在2018年4月5日。其实网站我自己偶尔也会上来看一看，那为什么一直没有更新呢？ 一方面是之后的很长一段时间，当时的Ubuntu系统不再了，而我的windows系统中死活安装不上hexo，所以一再搁置。 自从工作了之后，有了Ubuntu系统，可是不知道为什么也装不了hexo，一再搁置。目前写这篇文章的时候，用的是MacBook Pro，其实发现hexo在MBP上可用已经是好几个月前的事情了，之所以拖到现在才恢复更新，其实也有好几点原因。 首先，懒。懒字当头，无需过多解释=。=其次，工作与休闲的平衡。不知不觉工作也有了一年又半载。上班时间是不太可能搞这个的，回到家一般懒得再看电脑了，即使看电脑也是看电影之类的。最后，其实现在能够更新上这篇，还是因为万网域名到期的缘故。正好是周六，续费了一下域名后，这才有动力顺手试了一下hexo好不好用。 所以博客发布长久看来，也依赖于机器与博客网站的文件。即：需要一台电脑支持hexo、连接github并可以发布文章；还依赖于网站的整体项目文件，如果不小心丢失了文件的话，那就惨了。虽然github上也有xxx.github.io的备份，但是和本地的项目还是有区别的。 絮絮叨叨地说了这么多，以后会尽量更新多更新吧。另外在顺便简单介绍一下今后的博文方向。目前工作主要集中于图像处理方面，主要涉及到一些目标检测算法。除了算法方向的更新，可能也会有一些随笔、摄影作品分享之类的。应该也会同步在知乎上，欢迎关注。]]></content>
      <categories>
        <category>Photogragh</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现全排列 —— Leetcode(46)]]></title>
    <url>%2F2018%2F04%2F05%2Fleetcode_46_permutation%2F</url>
    <content type="text"><![CDATA[Vinales, Cuba, by Sam Bark. 题目：全排列Given a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations:12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 来源： https://leetcode.com/problems/permutations/description/ 解法一：C++ STL1234567891011class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; sort(nums.begin(), nums.end()); do &#123; ans.push_back(nums); &#125; while(next_permutation(nums.begin(), nums.end())); return ans; &#125;&#125;; 解法二：backtracking123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; permutation(nums, 0, ans); return ans; &#125; void permutation(vector&lt;int&gt;&amp; nums, int begin, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123; if (begin &gt;= nums.size()) &#123; ans.push_back(nums); return; &#125; for (int i = begin; i &lt; nums.size(); ++i) &#123; swap(nums[i], nums[begin]); permutation(nums, begin + 1, ans); // swap(nums[i], nums[begin]); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试题：区域染色问题]]></title>
    <url>%2F2018%2F04%2F05%2Fcoding_dye_problem_2%2F</url>
    <content type="text"><![CDATA[New York, United States, by Matt Lamers 题目给定五种不同颜色，求使得相邻区域颜色不重复的画法有多少种？ 不要求使用所有颜色。 解答按照字母顺序依次填充。A：5选1B：4选1C：3选1D：2选1A/B/C/D两两相邻，所以共计占用了四种不同的颜色。 现在看E，只与A/C相关，即E可填充的颜色有三种：B的颜色，D的颜色，以及暂未出现的颜色，记为X。当E填充颜色为B的颜色时，F则不能填充ABD的颜色，即可选颜色为CX两种；当E填充颜色为D的颜色时，F则不能填充AD的颜色，即可选颜色为BCX三种；当E填充颜色为X的颜色时，F则不能填充ADX的颜色，即可选颜色为BC两种； 综上，共有 5x4x3x2x(2+3+2) = 840种。 假设此时需要使用全部五种颜色，则有多少种方法呢？重复上面的思路：现在看E，只与A/C相关，即E可填充的颜色有三种：B的颜色，D的颜色，以及暂未出现的颜色，记为X。当E填充颜色为B的颜色时，F则不能填充ABD的颜色，即可选颜色为CX两种，由于需要使用全部颜色，则只能选X一种；当E填充颜色为D的颜色时，F则不能填充AD的颜色，即可选颜色为BCX三种，由于需要使用全部颜色，则只能选X一种；当E填充颜色为X的颜色时，F则不能填充ADX的颜色，即可选颜色为BC两种； 综上，共有 5x4x3x2x(1+1+2) = 480种。 如果扩展到N中颜色呢？不要求使用所有颜色。重复上面的思路： 按照字母顺序依次填充。A：n选1B：(n-1)选1C：(n-2)选1D：(n-3)选1A/B/C/D两两相邻，所以共计占用了四种不同的颜色。 现在看E，只与A/C相关，即E可填充的颜色有三种：B的颜色，D的颜色，以及暂未出现的颜色，记为X。当E填充颜色为B的颜色时，F则不能填充ABD的颜色，即可选颜色为CX 共(n-3)种；当E填充颜色为D的颜色时，F则不能填充AD的颜色，即可选颜色为BCX共(n-2)种；当E填充颜色为（n-4）种X中任一颜色时，F则不能填充ADX(特定的一种)的颜色，即可选颜色为BCX(n-4-1)共(n-3)种； 综上，共有 nx(n-1)x(n-2)x(n-3)x((n-3)+(n-2)+(n-4)x(n-3)) = n(n-1)(n-2)(n-3)((n-3)x(n-3)+(n-2))种。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络常考面试题十则]]></title>
    <url>%2F2018%2F03%2F21%2Fnetwork_top_ten_questions%2F</url>
    <content type="text"><![CDATA[1. OSI，TCP/IP，五层协议的体系结构，以及各层协议OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 每一层的协议如下： 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包Packet） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 2. IP地址的分类12345A类地址：以0开头， 第一个字节范围：1~127（1.0.0.0 - 127.255.255.255）；B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）E类地址：保留 其中A、B、C是基本类，D、E类作为多播和保留使用。 以下是留用的内部私有地址：123A类 10.0.0.0--10.255.255.255B类 172.16.0.0--172.31.255.255C类 192.168.0.0--192.168.255.255 IP地址与子网掩码相与得到网络号：12345ip : 192.168.2.110&amp;Submask : 255.255.255.0----------------------------网络号 ：192.168.2.0 注: 主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255） 3. ARP是地址解析协议，简单语言解释一下工作原理。答: 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 广播发送ARP请求，单播发送ARP响应。 4. 各种协议的介绍答:ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用UDP协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 5. 描述RARP协议答:RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 6. TCP三次握手和四次挥手的全过程三次握手 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 四次挥手与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 7. 在浏览器中输入www.baidu.com 后执行的全部过程 1、客户端浏览器通过DNS解析到www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。 2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 事件顺序：(1) 浏览器获取输入的域名www.baidu.com(2) 浏览器向DNS请求解析www.baidu.com的IP地址(3) 域名系统DNS解析出百度服务器的IP地址(4) 浏览器与该服务器建立TCP连接(默认端口号80)(5) 浏览器发出HTTP请求，请求百度首页(6) 服务器通过HTTP响应把首页文件发送给浏览器(7) TCP连接释放(8) 浏览器将首页文件进行解析，并将Web页显示给用户。 涉及到的协议：(1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务)(2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)(3) 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址) 8. TCP和UDP的区别？答:TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 TCP对应的协议和UDP对应的协议TCP对应的协议：（1） FTP：定义了文件传输协议，使用21端口。（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。UDP对应的协议：（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 DNS域名系统，简单描述其工作原理。答:当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。 当一个应用进程需要把某个域名解析为IP地址时，该应用进程就会调用解析程序，并成为一个DNS用户，把待解析的域名放在DNS请求报文中，以UDP数据报的形式发送给本地域名服务器，本地域名服务器查找到相应域名的IP地址后，就将该域名的IP地址信息放入应答报文中返回给客户进程，如果本地域名服务器没有直接查找到对应的IP地址，则向根域名服务器发出迭代查询，再将查询到的IP地址信息回传给客户程序。 9. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。 10. 交换机、路由器、网关的概念，各自的用途1）交换机在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。交换机被广泛应用于二层网络交换，俗称“二层交换机”。交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 2）路由器路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 3）网关网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。]]></content>
      <categories>
        <category>Basic Knowledge</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西瓜书《机器学习》学习笔记(6)：支持向量机]]></title>
    <url>%2F2018%2F03%2F21%2FML_chap06_SVM%2F</url>
    <content type="text"><![CDATA[章节目录 间隔与支持向量 对偶问题 核函数 软间隔与正则化 支持向量回归 核方法 支持向量机，因其英文名为support vector machine，故一般简称SVM，通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。 （一）间隔与支持向量给定训练样本D={(x1, y1), (x2, y2), …,(xm, ym)}, yi∈{-1, +1}，分类学习最基本的想法就是基于训练集D在样本空间找到一个划分超平面： 在样本空间中，划分超平面可通过如下线性方程来描述， 假设超平面（w，b）能将训练样本正确分类，即对于(xi, yi)∈D，令， 距离超平面最近的这几个训练样本点称为“支持向量”（support vector），两个异类支持向量到超平面的距离之和为， 称为“间隔”（margin）。找到“最大间隔”（maximum margin）的划分超平面，就是支持向量机（Support Vector Machine，简称SVM）的基本型。 目标函数： 由于求$||w||^{-1}$的最大值相当于求$||w||^2$的最小值，所以上述目标函数等价于（w由分母变成分子，从而也有原来的max问题变为min问题，很明显，两者问题等价）： 因为现在的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题。 补充：函数间隔与几何间隔在超平面w*x+b=0确定的情况下，|w*x+b|能够表示点x到距离超平面的远近，而通过观察w*x+b的符号与类标记y的符号是否一致可判断分类是否正确，所以，可以用(y*(w*x+b))的正负性来判定或表示分类的正确性。于此，我们便引出了函数间隔（functional margin）的概念。 定义函数间隔为： 而超平面(w，b)关于T中所有样本点(xi，yi)的函数间隔最小值（其中，x是特征，y是结果标签，i表示第i个样本），便为超平面(w, b)关于训练数据集T的函数间隔：$$\hat\gamma= \text{min} \hat\gamma_i\; (i=1，…n)$$ 但这样定义的函数间隔有问题，即如果成比例的改变w和b（如将它们改成2w和2b），则函数间隔的值f(x)却变成了原来的2倍（虽然此时超平面没有改变），所以只有函数间隔还远远不够。 事实上，我们可以对法向量w加些约束条件，从而引出真正定义点到超平面的距离–几何间隔（geometrical margin）的概念。 假定对于一个点x ，令其垂直投影到超平面上的对应点为 $x_0$ ，$w$ 是垂直于超平面的一个向量，为样本x到超平面的距离，如下图所示： 根据平面几何知识，有:$$x=x_0 +\gamma \frac w{||w||} $$ 其中||w||为w的二阶范数（范数是一个类似于模的表示长度的概念），$\frac w{||w||}$是单位向量（一个向量除以它的模称之为单位向量）。 又由于$w_0$是超平面上的点，满足$w^Tx+b=0 $ ，代入超平面的方程，可得$w^Tx_0+b=0 $ ，即$w^Tx_0=-b $ 。 随即让此式$x=x_0 +\gamma \frac w{||w||} $的两边同时乘以$w^T$，再根据$w^Tx_0=-b $和$w^Tw=||w||^2$，即可算出：$$\gamma = \frac {$w^Tx+b}{||w||} = \frac {f(x)}{||w||} $$ 为了得到$\gamma$的绝对值，令$\gamma$乘上对应的类别y，即可得出几何间隔（用$\hat\gamma$表示）的定义： $$\hat\gamma = y \gamma = \frac {\hat\gamma}{||w||} $$ 从上述函数间隔和几何间隔的定义可以看出：几何间隔就是函数间隔除以||w||，而且函数间隔y*(wx+b) = y*f(x)实际上就是|f(x)|，只是人为定义的一个间隔度量，而几何间隔|f(x)|/||w||才是直观上的点到超平面的距离。 （二）对偶问题我们对SVM基本型求解是一个凸二次规划（convex quadratic programming）问题，能直接用现成的优化计算包求解，但我们可以有更高效的办法。即对SVM的基本型使用拉格朗日算子法得到其“对偶问题”（dual problem）。 支持向量机的一个重要性质：训练完成后，大部分的训练样本都不需要保留，最终模型仅与支持向量有关。 KKT条件一般地，一个最优化数学模型能够表示成下列标准形式： 其中，f(x)是需要最小化的函数，h(x)是等式约束，g(x)是不等式约束，p和q分别为等式约束和不等式约束的数量。 同时，得明白以下两点： 凸优化的概念：$\mathcal{X} \subset \mathbb{R}^n$ 为一凸集， $f:\mathcal{X}\to \mathbb{R}$ 为一凸函数。凸优化就是要找出一点 $x^\ast \in \mathcal{X}$ ，使得每一 $x \in \mathcal{X} $满足$ f(x^\ast)\le f(x)$ 。 KKT条件的意义：它是一个非线性规划（Nonlinear Programming）问题能有最优化解法的必要和充分条件。 经过论证，我们这里的问题是满足 KKT 条件的（首先已经满足Slater条件，再者f和gi也都是可微的，即L对w和b都可导），因此现在我们便转化为求解第二个问题。 也就是说，原始问题通过满足KKT条件，已经转化成了对偶问题。而求解这个对偶学习问题，分为3个步骤：首先要让L(w，b，a) 关于 w 和 b 最小化，然后求对的极大，最后利用SMO算法求解对偶问题中的拉格朗日乘子。 （三）核函数在现实任务中，原始样本空间内也许并不存在一个能正确划分两类样本的超平面。对这样的问题，可以将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分。如下图： 幸运的是，如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分。令Φ(x)表示将x映射后的特征向量，于是，在特征空间中划分超平面所对应的模型可表示为， $$f(x) = w^T \phi(x) +b $$ 其对偶问题是， 求解设计到计算：$$\phi(x_i)^T \phi(x_j) $$ ，这是样本xi与xj映射到特征空间之后的内积。由于特征空间的维数可能很高，甚至可能到无穷维，因此直接计算通常是困难的。为了避开这个障碍，可以假设这样一个函数: 即xi与xj在特征空间的内积等于他们原始样本空间通过函数k(. , .)计算的结果。有了这样的函数，我们就不必直接计算高维甚至无穷维特征空间中的内积。这里的函数k(. , .)就是“核函数”（kernel function）。 “核函数选择”是支持向量机的最大变数。常用的核函数有: 此外，还可以通过函数的组合得到。 核函数的选择是支持向量机的最大变数。这方面有一些基本的经验。如文本分类通常采用线性核，情况不明时可先尝试高斯核。 补充：核函数的本质简要概括下，即以下三点： 实际中，我们会经常遇到线性不可分的样例，此时，我们的常用做法是把样例特征映射到高维空间中去(映射到高维空间后，相关特征便被分开了，也就达到了分类的目的)； 但进一步，如果凡是遇到线性不可分的样例，一律映射到高维空间，那么这个维度大小是会高到可怕的(如19维乃至无穷维的例子)。那咋办呢？ 此时，核函数就隆重登场了，核函数的价值在于它虽然也是将特征进行从低维到高维的转换，但核函数绝就绝在它事先在低维上进行计算，而将实质上的分类效果表现在了高维上，也就避免了直接在高维空间中的复杂计算。 举例说明下核函数解决非线性问题的直观效果$ ^{3}$。 假设现在你是一个农场主，圈养了一批羊群，但为预防狼群袭击羊群，你需要搭建一个篱笆来把羊群围起来。但是篱笆应该建在哪里呢？你很可能需要依据牛群和狼群的位置建立一个“分类器”，比较下图这几种不同的分类器，我们可以看到SVM完成了一个很完美的解决方案。 （四）软间隔与正则化在前面的讨论中，我们一直假定训练样本在训练空间或特征空间中是线性可分的，即存在一个超平面将不同类的样本完全划分开。然而，在现实任务中往往很难确定合适的核函数使得训练样本在特征空间中线性可分。 缓解该问题的一个办法是允许支持向量机在一些样本上出错。为此引入了“软间隔”（soft margin）的概念，如下图所示： 具体来说，前面介绍的支持向量机形式是要求所有样本均满足约束，即所有样本必须划分正确，这称为“硬间隔”（hard margin），而软间隔则是允许这样的样本不满足约束。 原来的约束条件为： 现在考虑到outlier（偏离正常位置很远的数据点）问题，约束条件变成了： 其中$\xi_i \geq 0$ 称为松弛变量 (slack variable) ，对应数据点$x_i$允许偏离的 functional margin 的量。 所以，我们在原来的目标函数$\text{min} \frac 12 ||w||^2 $后面加上一项，使得这些$\xi_i $的总和也要最小： $$\text{min} \frac 12 ||w||^2+ C \sum^{n}_{i=1} \xi_i $$ 其中C是一个参数，用于控制目标函数中两项（“寻找 margin 最大的超平面”和“保证数据点偏差量最小”）之间的权重。 完整的目标函数为： 三种常用的替代损失函数(surrogate loss)： hinge损失: $l_{hinge}(z) = max(1, 1-z)$ 指数损失(exponential loss)：$l_{exp}(z) = exp(-z)$ 对率损失(logistic losss)：$l_{log}(z) = log(1+exp(-z))$ 至此可以做个小结，不准确的说，SVM它本质上即是一个分类方法，用w^T+b定义分类函数，于是求w、b，为寻最大间隔，引出1/2||w||^2，继而引入拉格朗日因子，化为对拉格朗日乘子a的求解（求解过程中会涉及到一系列最优化或凸二次规划等问题），如此，求w.b与求a等价，而a的求解可以用一种快速学习算法SMO，至于核函数，是为处理非线性情况，若直接映射到高维计算恐维度爆炸，故在低维计算，等效高维表现。 （五）支持向量回归对样本（x，y），传统回归模型通常直接基于模型输出f(x)与真实输出y之间的差别来计算损失，当切仅当f(x)与y完全相同时，损失才为零。于此不同，支持向量回归（Support Vector Regression，简称SVR）假设我们能容忍f(x)与y之间最多有ε的偏差，即仅当f(x)与y之间的差别绝对值大于ε时才计算损失。如下图所示， （六）核方法根据“表示定理”，对于一般的损失函数和正则化项（不要求是凸函数），优化问题的最优解都可表示为核函数的线性组合。这显示出核函数的巨大威力。人们发展出一系列基于核函数的学习方法，统称为“核方法”（kernel methods）。最常见的，是通过“核化”（即引入核函数）来将线性学习器拓展为非线性学习器。 参考资料 西瓜书《机器学习》 《机器学习》笔记-支持向量机（6） 支持向量机通俗导论（理解SVM的三层境界）【很详细，推荐阅读】]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(11) 第十三章 红黑树]]></title>
    <url>%2F2018%2F03%2F20%2Falgorithm_tutorial_chapter_13%2F</url>
    <content type="text"><![CDATA[红黑树简介红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。 在C++ STL中，很多部分(目前包括set, multiset, map, multimap)应用了红黑树的变体(SGI STL中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。 红黑树的性质红黑树的5个性质： 每个结点要么是红的要么是黑的。 根结点是黑的。 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。 如果一个结点是红的，那么它的两个儿子都是黑的。 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 旋转操作当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。 树的旋转分为左旋和右旋，下面借助图来介绍一下左旋和右旋这两种操作。 如上图所示，当在某个结点pivot上，做左旋操作时，我们假设它的右孩子y不是NIL[T]，pivot可以为任何不是NIL[T]的左子结点。左旋以pivot到Y之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的左孩子b则成为pivot的右孩子。 12345678910111213LeftRoate(T, x) y ← x.right //定义y：y是x的右孩子 x.right ← y.left //y的左孩子成为x的右孩子 if y.left ≠ T.nil y.left.p ← x y.p ← x.p //x的父结点成为y的父结点 if x.p = T.nil then T.root ← y else if x = x.p.left then x.p.left ← y else x.p.right ← y y.left ← x //x作为y的左孩子 x.p ← y 左旋之后，privot变成了y的左节点。右旋之后，y变成privot的右节点。【互逆的过程】 2.右旋12345678910111213RIGHT-ROTATE(T,x) y &lt;- left[x] left[x] &lt;- right[y] if right[y] != nil[T] then p[right[y]] &lt;- x p[y] &lt;- p[x] if p[x] = nil[T] then root[T] &lt;- y else if x = right[p[x]] then right[p[x]] &lt;- y else left[p[x]] &lt;- y right[y] &lt;- x p[x] &lt;- y 右旋中的x，对应于上图右侧的Y。 右旋与左旋差不多，再此不做详细介绍。左右旋也是相互对称的，只要理解其中一种旋转就可以了。 树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。 插入操作首先以二叉查找树的方法增加结点并标记它为红色。（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑结点，这个是很难调整的。但是设为红色结点后，可能会导致出现两个连续红色结点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。）下面要进行什么操作取决于其他临近结点的颜色。 设要插入的结点为N，N的父结点标为P，N的叔父结点标为U，N的祖父结点标为G。（即P和U是G的孩子结点）。图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含（imply）的。 情形1. 新结点N位于树的根上，没有父结点。（插入树的第一个结点） 在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑结点数目增加一，性质5符合。 情形2. 父结点P是黑色，则整棵树不必调整便是红黑树。新结点是红色的，所以性质4没有失效。尽管新结点N有两个黑色叶子子结点；但由于新结点N是红色，通过它的每个子结点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色结点，性质5也未受到威胁。 情形3. 父结点P是红色（祖父结点G一定为黑色），叔父结点U也是红色。则我们可以将P，U重绘为黑色并重绘祖父结点G为红色（用来保持性质5）。但是，红色的祖父结点G可能是根结点，这就违反了性质2，也有可能祖父结点G的父结点是红色的，这就违反了性质4。为了解决这个问题，在祖父结点G上递归调整颜色。 （此时新插入结点N做为P的左子结点或右子结点都属于情形3，这里仅显示N做为P左子的情形） 情形4. 父结点P是红色（祖父结点G一定为黑色），叔父结点U是黑色或缺少，并且新结点N是左孩子。则针对祖父结点G进行一次右旋转；在旋转产生的树中，以前的父结点P现在是新结点N和以前的祖父结点G的父结点。以前的祖父结点G是黑色，切换以前的父结点P和祖父结点G的颜色，结果的树满足性质4，5。 （此时P为祖父结点G的左子结点或右子结点都属于情形4，这里仅显示P为G左子的情形） 情形5. 父结点P是红色（祖父结点G一定为黑色），叔父结点U是黑色或缺少，并且新结点N是右孩子。则针对父结点P进行一次左旋转调换新结点N和P的角色，接着按情形4进行处理。 删除操作首先以二叉查找树的方法找到要删除的结点，如果需要删除的结点有两个非叶子的孩子结点，那么问题可以转化成删除的结点最多有一个非叶子的孩子结点。（对于二叉查找树，在删除带有两个非叶子儿子的结点的时候，要么找到它的前驱（左子树中的最大元素）、要么找到后继（右子树中的最小元素），并把它的值拷贝到要删除的结点中。接着删除前驱（或后继），注意前驱（后继）的非叶子孩子结点数必定少于2。因为拷贝前驱（后继）值时不违反任何性质，所以上面的问题转化成立）。 如果被删除的结点没有非叶子的孩子，那么直接删除，然后用一个叶子结点代替它的位置，不用作其它树调整。 下面只讨论删除的结点只有一个非叶子结点孩子的情况。如果删除的是一个红色节点，它的父亲和孩子一定是黑色的，所以我们可以简单的用它的黑色儿子替换它，并不会破坏红黑树的性质。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。 需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为S。在下面的示意图中，我们使用P称呼N的父亲，SL 称呼S的左儿子，SR 称呼S的右儿子。 情形1. N是新的根。在这种情形下，从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。 情形2. S是红色（N的父亲P是黑色）。在N的父亲P上做左旋转，把 S 转换成N的祖父，接着对调新的父亲P和新的祖父S的颜色。完成这两个操作后，N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），接下去按情形4、情形5或情形6来处理。 情形3. S和S的儿子都是黑色，N的父亲P是黑色。简单的重绘S为红色。结果是通过S的所有路径，都少了一个黑色节点，因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。 情形4. S和S的儿子都是黑色，N的父亲P是红色。简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。 情形5. S是黑色，S的左儿子是红色，S的右儿子是黑色。在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。接着交换S和它的新父亲的颜色，所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，它的右儿子是红色的，所以我们进入了情形4。 情形6. S是黑色，S的右儿子是红色。在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。 参考 算法导论 红黑树 教你初步了解红黑树]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题：不用加减乘除做加法]]></title>
    <url>%2F2018%2F03%2F16%2Fcoding_offer46_sum1toN%2F</url>
    <content type="text"><![CDATA[四种解法，只有想不到，没有做不到！！ 题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 四种解法，只有想不到，没有做不到！！ 解法一：短路求值12345678class Solution &#123;public: int Sum_Solution(int n) &#123; int ans = n; ans &amp;&amp; (ans += Sum_Solution(n - 1)); return ans; &#125;&#125;; 解法二：利用异常用异常退出递归。12345678910111213141516//用异常退出递归public class Solution &#123; public int Sum_Solution(int n) &#123; return sum(n); &#125; int sum(int n)&#123; try&#123; int i = 1%n; return n+sum(n-1); &#125; catch(Exception e)&#123; return 0; &#125; &#125;&#125; 解法三：乘法-&gt;sizeof用公式是不可以的，公式里有乘法！！实现乘法可以用sizeof多维数组，两行代码就可以： 1234567class Solution &#123;public: int Sum_Solution(int n) &#123; bool a[n][n+1]; return sizeof(a)&gt;&gt;1; &#125;&#125;; 解法四：乘法-&gt;快速模乘马客(Mark)：我就猜到大家都是用 &amp;&amp; 的短路原则的，这样复杂是O(n)的。我来一个复杂度32的，可以说O(logM)吧，M是数值大小，对于int也可以说是O(1)吧虽然常数有点大。 原理就是，类似快速幂，俗称快速模乘。 a * b可以这样算：123456res = 0while(a)&#123; if(a &amp; 1) res += b; a &gt;&gt;= 1; b &lt;&lt;= 1; &#125; 原理是把a拆成2的幂的和，a = 2^e0 + 2^e1 + 2^e2....那么 a * b = (2^e0 + 2^e1 + 2^e2+...) * b = b * 2^e0 + b * 2^e1 + b * 2^e2 + ... = (b &lt;&lt; e0) + (b &lt;&lt; e1) + .... 也就是看成了二进制的相乘。可以写成如下代码【然而用了while】123456789101112131415class Solution &#123;public: int Sum_Solution(int n) &#123; // res = (n+1)xn/2 int a = n, b = n + 1, ans = 0; while(a) &#123; if(a &amp; 1) &#123; ans += b; &#125; a &gt;&gt;= 1; b &lt;&lt;= 1; &#125; return ans &gt;&gt; 1; &#125;&#125;; 由于不能使用while语句，所以符合题意的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//奇数返回0xffffffff，否则0#define f(x) ((((x) &amp; 1) &lt;&lt; 31) &gt;&gt; 31)class Solution &#123;public: int Sum_Solution(int n) &#123; int a = n, b = n + 1, s = 0; //复制32次。。 s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; s += b &amp; f(a); a &gt;&gt;= 1; b &lt;&lt;= 1; return s &gt;&gt; 1; &#125;&#125;;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常见面试题整理]]></title>
    <url>%2F2018%2F03%2F16%2FCPP_review_reproduce%2F</url>
    <content type="text"><![CDATA[有那么一些零碎的小知识点，偶尔很迷惑，偶尔被忽略，偶然却发现它们很重要，这段时间正好在温习这些，就整理在这里，一起学习一起提高！后面还会继续补充。 本文转载自：http://www.cnblogs.com/webary/p/4754522.html 我自己也有整理，不过是思维导图的形式，有机会再一起放出来吧。 1.面向对象的特性 封装、继承、多态。 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。（优点：可以隐藏实现细节，使得代码模块化） 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。（优点：可以扩展已存在的代码模块（类）） 多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。虽然针对不同对象的具体操作不同，但通过一个公共的类，这些操作可以通过相同的方式被调用。 多态实现的两种方式：父类指针指向子类对象 或 将一个基类的引用类型赋值为它的派生类实例。（重要：虚函数 + 指针或引用） 构造函数、复制构造函数、析构函数、赋值运算符不能被继承。 2.堆和栈 从内存角度来说：栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变变量的值等，其操作方式类似于数据结构中的栈，可静态亦可动态分配。 堆区（heap）一般由程序员分配释放，若程序员不释放，可能造成内存泄漏，程序结束时可能由OS回收。只可动态分配，分配方式类似于链表。 从数据结构角度来说：堆可以被看成是一棵树，如：堆排序。 而栈是一种先进后出的数据结构。 3.malloc和new 1.malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。但它们都可用于申请动态内存和释放内存。 2.对于非内部数据类型的对象而言，用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free，因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，和一个能完成清理与释放内存工作的运算符delete。 3.new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void*指针。new delete在实现上其实调用了malloc,free函数。 4.new 建立的是一个对象；malloc分配的是一块内存。 4.虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数 虚函数表：类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。 编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的每个虚函数占据虚函数表中的一块。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。 在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 -&gt;有虚函数或虚继承的类实例化后的对象大小至少为4字节（确切的说是一个指针的字节数；说至少是因为还要加上其他非静态数据成员，还要考虑对齐问题）；没有虚函数和虚继承的类实例化后的对象大小至少为1字节（没有非静态数据成员的情况下也要有1个字节来记录它的地址）。 有纯虚函数的类为抽象类，不能定义抽象类的对象，它的子类要么实现它所有的纯虚函数变为一个普通类，要么还是一个抽象类。 特别的： （1）当存在类继承并且析构函数中有必须要进行的操作时（如需要释放某些资源，或执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄露或达不到预期结果； （2）内联函数不能为虚函数：内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开； （3）构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数； （4）静态成员函数不能为虚函数：静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的。 更多关于虚函数的细节，请移步博文：关于C++虚函数表的那些事儿 5.面向对象的多态、多态的实现机制，多态的例子 见知识点4 6.对一个类求sizeof需要考虑的内容 见知识点4。同时，对于一个结构体和一个类执行sizeof()运算时情况比较复杂，详细分析请移步另一篇博文struct/class等内存字节对齐问题详解 7.重载和重写（覆盖） 方法的重写Overriding和重载Overloading是多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同；如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同。 8.“引用”与多态的关系? 引用是除指针外另一个实现多态的方式。这意味着，一个基类的引用可以指向它的派生类实例。例：123 Class A; Class B : Class A&#123;…&#125;; B b; A&amp; ref = b; 9.计算机加载程序包括哪几个区？ 一个由C/C++编译的程序占用的内存分为以下几个部分： （1）栈区（stack）:—由编译器自动分配释放，存放函数的参数值，局部变量的值等。可静态也可动态分配。其操作方式类似于数据结构中的栈。 （2）堆区（heap）:一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。动态分配。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 （3）全局区（静态区）:—程序结束后由系统释放，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域；未初始化的全局变量和静态变量在相邻的另一块区域(BSS，Block Started by Symbol)，在程序执行之前BSS段会自动清0。 （4）文字常量区:—程序结束后由系统释放，常量字符串就是放在这里的。 （5）程序代码区:—存放函数体的二进制代码。 10.派生类中构造函数与析构函数，调用顺序 构造函数的调用顺序总是如下： 1.基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。 2.成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。如果有的成员不是类对象，而是基本类型，则初始化顺序按照声明的顺序来确定，而不是在初始化列表中的顺序。 3.派生类构造函数。 析构函数正好和构造函数相反。 11.extern “C”的作用 extern &quot;C&quot;实现C++与C及其它语言的混合编程，是用在C和C++之间的桥梁。之所以需要这个桥梁是因为C编译器编译函数时不带函数的类型信息，只包含函数符号名字；而C++编译器为了实现函数重载，编译时会带上函数的类型信息，如他把上面的a函数可能编译成_a_float这样的符号为了实现重载。 extern &quot;C&quot;的惯用法： 在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：123 extern "C"&#123; #include "cExample.h" &#125; 而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern &quot;C&quot;声明，在.c文件中包含了extern &quot;C&quot;时会出现编译语法错误。 extern本身作为关键字修饰变量（函数）时声明该变量（函数）是外部变量（函数），通常全局变量在头文件中用这种方式声明，在对应源文件中定义，来防止重定义的错误。 12.析构函数、构造函数能不能被继承 见知识点1 13.C++为什么用模板类，为什么用泛型 通过泛型可以定义类型安全的数据结构（类型安全），而无须使用实际的数据类型（可扩展）。这能够显著提高性能并得到更高质量的代码（高性能），因为您可以重用数据处理算法，而无须复制类型特定的代码（可重用）。 14.结构体内存对齐，与什么有关（CPU） 在系统默认的对齐方式下：每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，且最终占用字节数为成员类型中最大占用字节数的整数倍。 详细分析见博客：struct/class等内存字节对齐问题详解 为什么要对齐？当CPU访问正确对齐的数据时，它的运行效率最高，当数据大小的数据模数的内存地址是0时，数据是对齐的。例如：WORD值应该是总是从被2除尽的地址开始，而DWORD值应该总是从被4除尽的地址开始，数据对齐不是内存结构的一部分，而是CPU结构的一部分。当CPU试图读取的数值没有正确的对齐时，CPU可以执行两种操作之一：产生一个异常条件；执行多次对齐的内存访问，以便读取完整的未对齐数据，若多次执行内存访问，应用程序的运行速度就会慢。 15.指针和引用 1.指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。 2.指针可以有多级，但是引用只能是一级； 3.指针的值可以为空，也可能指向一个不确定的内存空间，但是引用的值不能为空，并且引用在定义的时候必须初始化为特定对象；（因此引用更安全） 4.指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变引用对象了； 5.sizeof引用得到的是所指向的变量(对象)的大小，而sizeof指针得到的是指针本身的大小； 6.指针和引用的自增(++)运算意义不一样； 16.static关键字作用 在C语言中，关键字static有三个明显的作用： 1)在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持上一次的值不变，即只初始化一次（该变量存放在静态变量区，而不是栈区）。 2)在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外访问。（注：模块可以理解为文件） 3)在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 【补充】《C和指针》中说static有两层含义：指明存储属性；改变链接属性。 具体解释：（1）全局变量（包括函数）加上static关键字后，链接属性变为internal，也就是将他们限定在了本作用域内；（2）局部变量加上static关键字后，存储属性变为静态存储，不存储在栈区，下一次将保持上一次的尾值。 除此之外，C++中还有新用法： 4)在类中的static成员变量意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见； 5)在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量(当然，可以通过传递一个对象来访问其成员)。 17.虚表，基类的虚表是什么样的，派生类虚表 （1）单继承情况 （2）多重继承（无虚函数覆盖） （3）多重继承（有虚函数覆盖） 详细的内容参考博文：关于C++虚函数表的那些事儿 18.volatile volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。 当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。 volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样一来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。 19.#define与const的区别 • define不会做类型检查（容易出错），const拥有类型，会执行相应的类型检查 • define仅仅是宏替换，不占用内存，而const会占用内存 • const内存效率更高，编译器可能将const变量保存在符号表中，而不会分配存储空间，这使得它成 为一个编译期间的常量，没有存储和读取的操作 当使用#define定义一个简单的函数时，强烈建议使用内联函数替换！ 20.C++中的强制类型转换 • reinterpret_cast: 转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型,反之亦 然. 这个操作符能够在非相关的类型之间转换. 操作结果只是简单的从一个指针到别的指针的值的 二进制拷贝. 在类型之间指向的内容不做任何类型的检查和转换?1234class A&#123;&#125;; class B&#123;&#125;; A* a = new A;B* b = reinterpret_cast(a); • static_cast: 允许执行任意的隐式转换和相反转换动作（即使它是不允许隐式的）,例如：应用到类 的指针上, 意思是说它允许子类类型的指针转换为父类类型的指针(这是一个有效的隐式转换), 同 时, 也能够执行相反动作: 转换父类为它的子类1234class Base &#123;&#125;; class Derive:public Base&#123;&#125;; Base* a = new Base; Derive *b = static_cast(a); • dynamic_cast: 只用于对象的指针和引用. 当用于多态类型时，它允许任意的隐式类型转换以及相 反过程. 不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程）,dynamic_cast 会检查操作是否有效. 也就是说, 它会检查转换是否会返回一个被请求的有效的完整对象。检测在 运行时进行. 如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL. 对于引用 类型，会抛出bad_cast异常。 • const_cast: 这个转换类型操纵传递对象的const属性，或者是设置或者是移除,例如：123class C&#123;&#125;; const C* a = new C; C *b = const_cast(a); 21.析构函数中抛出异常时概括性总结 （1） C++中析构函数的执行不应该抛出异常； （2） 假如析构函数中抛出了异常，那么系统将变得非常危险，也许很长时间什么错误也不会发生；但也许系统有时就会莫名奇妙地崩溃而退出了，而且什么迹象也没有； （3） 当在某一个析构函数中会有一些可能（哪怕是一点点可能）发生异常时，那么就必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外，即在析构函数内部写出完整的throw…catch()块。 22.C++11新特性 Lambda、变参模板、auto、decltype、constexpr、智能指针、列表初始化、正则表达式、线程库、静态断言、委托构造。 weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。 使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。 weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr.]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统常见面试题整理]]></title>
    <url>%2F2018%2F03%2F16%2Foperating_system_review_reproduce%2F</url>
    <content type="text"><![CDATA[有那么一些零碎的小知识点，偶尔很迷惑，偶尔被忽略，偶然却发现它们很重要，也是各大笔试和面试高频出现考点。这段时间正好在温习这些，就整理在这里，一起学习一起提高！后面还会继续补充。 本文转载自一个很不错的博客：http://www.cnblogs.com/webary/p/4782903.html 我自己也有整理，不过是思维导图的形式，有机会再一起放出来吧。 1.进程和线程 线程是指进程内的一个执行单元,也是进程内的可调度实体. 与进程的区别: (1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间(也有少量自己的地址空间);而进程有自己独立的地址空间(多个进程之间一般不会共享地址空间); (2)资源拥有:进程是资源拥有的单位,同一个进程内的线程共享进程的资源 (3)线程是处理器调度和分派的基本单位. (4)二者均可并发执行.多线程程序的并发性高。 (5)进程的切换代价远高于线程，同步和通信的实现也比线程复杂。 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，需要用多线程。 2.Unix和windows进程间通信的主要方式 linux系统IPC： 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 命名管道 (named pipe) ： 命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 信号量( semophore )： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号 ( sinal )：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 windows系统IPC： 剪贴板(Clipboard)：当用户在应用程序中执行剪切或复制操作时，应用程序将选定的数据以一个或多个标准或应用程序定义的格式放在剪贴板中。 WM_COPYDATA消息：当一个应用向另一个应用传送数据时，发送方只需使用调用SendMessage函数， 接收方只需像处理其它消息那样处理WM_COPYDATA消息，这样收发双方就实现了数据共享，它在底层实际上是通过文件映射来实现的。 文件映射(File Mapping )：使进程把文件内容当作进程地址区间一块内存那样来对待。只需简单的指针操作就可读取和修改文件的内容。 允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针，通过使用这些指针，不同进程就可以读写文件的内容，实现了对文件中数据的共享。 共享内存(Shared Memory)是文件映射的一种特殊情况进程在创建文件映射对象时用0xFFFFFFFF来代替文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。由于共享内存是用 文件映射实现的， 所以它也有较好的安全性，也只能运行于同一计算机上的进程之间。 动态数据交换(DDE)：是使用共享内存在应用程序之间进行数据交换的一种进程间通信形式。应用程序可以使用DDE进行一次性数据传输，也可以当出现新数据时， 通过发送更新值在应用程序间动态交换数据。DDE和剪贴板一样既支持标准数据格式(如文本、位图等)，又可以支持自己定义的数据格式。但它们的数据传输机制却不同，一个明显区别是剪贴板操作几乎总是用作对用户指定操作的一次性应答，如从菜单中选择Paste命令。尽管DDE也可以由用户启动，但它继续发挥作用一般不必用户进一步干预。可以发生在单机或网络中不同计算机的应用程序之间。 邮件槽(Mailslot)：提供进程间单向通信能力，任何进程都能建立邮件槽成为邮件槽服务器。其它进程称为邮件槽客户，可以通过邮件槽的名字给邮件槽服务器进程发送消息。进来的消息一直放在邮件槽中，直到服务器进程读取它为止。一个进程既可以是邮件槽服务器也可以是邮件槽客户，因此可建立多个 邮件槽实现进程间的双向通信。 管道( pipe )：同上linux系统 &amp; 命名管道 套接字（Sockets ）：同上linux系统 3.死锁 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的僵局，若无外力作用，它们都将无法推进下去。 产生死锁的四个必要条件： 1.互斥条件：一段时间内某资源只由一个进程占有。 2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 3.不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 预防死锁：需要打破必要条件的2，3，4中之一，由于施加的限制条件较严格，可能导致系统资源利用率和系统吞吐量降低。 避免死锁：施加的限制条件较弱，使系统一直处于安全状态。比如银行家算法。 检测死锁：资源分配图、死锁定理。 解除死锁：剥夺起源、撤销进程。 4.windows下什么线程优先级最高 SetThreadPriority 设置指定线程的优先级： BOOL SetThreadPriority(HANDLE hThread, int nPriority); 参数说明： hThread 要设置的线程句柄 nPriority 优先级别参数 可设置为一下参数 THREAD_PRIORITY_ABOVE_NORMAL 比一般优先级高一个等级 THREAD_PRIORITY_BELOW_NORMAL 比一般低一个等级 THREAD_PRIORITY_HIGHEST 比一般高2个等级（最高） THREAD_PRIORITY_IDLE 空闲 THREAD_PRIORITY_LOWEST 比一般低2个等级（最低） THREAD_PRIORITY_NORMAL 一般等级 THREAD_PRIORITY_TIME_CRITICAL 实时 5.linux下fork函数 在fork()的调用处，创建一个子进程，并将整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区等。fork调用仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值： （1）在父进程中，fork返回新创建子进程的进程ID； （2）在子进程中，fork返回0； （3）如果出现错误，fork返回一个负值； 在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。 fork出错可能有两种原因： 1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。 2）系统内存不足，这时errno的值被设置为ENOMEM。 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。 1234567891011121314#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main()&#123; int i=0; for(i=0;i&lt;3;i++) &#123; pid_t fpid = fork(); if(fpid==0) printf("son\n"); else printf("father\n"); &#125; return 0;&#125; 对于这种N次循环的情况，执行printf函数的次数为2*（2^N-1）次，创建的子进程数为2^N-1个。输出中没有换行时缓冲区也会被复制，参见：http://www.oschina.net/question/195301_62902 6.程序什么时候使用多线程好，什么时候单线程效率高 1．耗时的操作使用线程，提高应用程序响应速度 2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求 3．多CPU系统中，使用线程提高CPU利用率 4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。其他情况都使用单线程。 7.线程间通信 互锁函数、临界段、内核对象（事件对象、互斥对象、信号量） 8.进程状态转换 在操作系统中，进程一般有三种基本状态：运行状态，就绪状态和等待状态。 1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态； 2）执行——等待：正在执行的进程因发生某等待事件而无法执行，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 3）等待——就绪：处于等待状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态； 4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。 9.内存地址：虚拟地址-线性地址-物理地址的区别与联系 x86平台下的系统采用分段机制与分页机制对地址进行转换，其中分段机制把一个虚拟地址转换成线性地址；分页机制把一个线性地址转换成物理地址。 参考资料：《计算机操作系统（第三版）》，西安电子科技大学出版社，汤小丹等 linux中fork（）函数详解（原创！！实例讲解） 一个fork的面试题]]></content>
      <categories>
        <category>Basic Knowledge</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题：旋转数组的最小数字]]></title>
    <url>%2F2018%2F03%2F06%2Fcoding_offer08_findMinNumberInRotateArray%2F</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组(如{1,2,3,4,5})的一个旋转(如{3,4,5,1,2})，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 简而言之，输入的是旋转后的数组，输出数组的最小数字。 最简单的方法当然是从头到尾查找一遍就知道最小数字了，复杂度为$O(n)$，不过这并不是能让面试官满意的答案。 需要结合旋转数组的特性来分析。 分析这是一道二分查找的变形的题目。 旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素 注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。 思路： （1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。 但是如果不是旋转，第一个元素肯定小于最后一个元素。 （2）找到数组的中间元素。 中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。 移动之后，第一个指针仍然位于前面的递增数组中。 中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。 移动之后，第二个指针仍然位于后面的递增数组中。 这样可以缩小寻找的范围。 （3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。 最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。 也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。 此时的解法答案如下：12345678910111213141516171819202122class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int size = rotateArray.size(); if(0 == size) &#123; return 0; &#125; int low = 0, high = size - 1, mid; while((high - low) &gt; 1) &#123; mid = low + ((high - low) &gt;&gt; 1); if(rotateArray[mid] &gt; rotateArray[0]) //位于左半递增数组上 low = mid; else if(rotateArray[mid] &lt; rotateArray[size - 1]) &#123; high = mid; &#125; &#125; return rotateArray[high]; &#125;&#125;; 到目前为止以上思路很好的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。 因此这一道题目比上一道题目多了些特殊情况： 我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。 这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。 第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。 因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。 也就无法移动指针来缩小查找的范围。 因此只能按照正常的顺序来遍历查找最小的元素。 再次放上最终版本的代码。基本上考虑了所有的情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int MinInOrder(vector&lt;int&gt; rotateArray) &#123; int size = rotateArray.size(); int min = 0x7fffffff; for(auto i = rotateArray.begin(); i != rotateArray.end(); ++i) &#123; if(min &gt; *i) &#123; min = *i; &#125; &#125; return min;&#125;class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int size = rotateArray.size(); if(0 == size) &#123; return 0; &#125; int low = 0, high = size - 1, mid; if(rotateArray[low] &lt; rotateArray[high]) &#123; //翻转了0个或者翻转全部 return rotateArray[low]; &#125; while((high - low) &gt; 1) &#123; mid = low + ((high - low) &gt;&gt; 1); if(rotateArray[mid] == rotateArray[0] &amp;&amp; rotateArray[mid] == rotateArray[size - 1]) //三个数字都相同，这一种情况比较特殊。 return MinInOrder(rotateArray); else if(rotateArray[mid] &gt;= rotateArray[0]) //位于左半递增数组上 low = mid; else if(rotateArray[mid] &lt;= rotateArray[size - 1]) &#123; high = mid; &#125; &#125; return rotateArray[high]; &#125;&#125;;int main() &#123; Solution *s = new Solution(); cout &lt;&lt; s-&gt;minNumberInRotateArray(vector&lt;int&gt;&#123;3,4,5,1,2&#125;) &lt;&lt; endl; cout &lt;&lt; s-&gt;minNumberInRotateArray(vector&lt;int&gt;&#123;1,2,3,4,5&#125;) &lt;&lt; endl; cout &lt;&lt; s-&gt;minNumberInRotateArray(vector&lt;int&gt;&#123;1,1,1,0,1&#125;) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题：斐波那契数列]]></title>
    <url>%2F2018%2F03%2F06%2Fcoding_offer09_Fibonacci%2F</url>
    <content type="text"><![CDATA[题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39 题目链接：https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3 分析给出解法，详细分析见后面：1234567891011121314151617181920212223242526272829class Solution &#123;public: int Fibonacci(int n) &#123; /* 方法一：时间花费950ms，接近一秒了。。。 */ //if(n &lt;= 0 ) // return 0; //else if (n == 1) // return 1; //return Fibonacci(n - 1) + Fibonacci(n -2); //方法二： if(n &lt;= 0 ) return 0; else if (n == 1) return 1; int i = 2; int ans_i = 0, ans_i_1 = 1, ans_i_2 = 0; while(n &gt;= i)&#123; ans_i = ans_i_1 + ans_i_2; ans_i_2 = ans_i_1; ans_i_1 = ans_i; ++i; &#125; return ans_i; &#125;&#125;; 这个题可以说是迭代（Iteration） VS 递归（Recursion），f(n) = f(n-1) + f(n-2)，第一眼看就是递归啊，简直完美的递归环境，递归肯定很爽，这样想着关键代码两三行就搞定了，注意这题的n是从0开始的：12if(n&lt;=1) return n;else return Fibonacci(n-1)+Fibonacci(n-2); 然而并没有什么用，测试用例里肯定准备着一个超大的n来让Stack Overflow，为什么会溢出？因为重复计算，而且重复的情况还很严重，举个小点的例子，n=4，看看程序怎么跑的：123Fibonacci(4) = Fibonacci(3) + Fibonacci(2); = Fibonacci(2) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0); = Fibonacci(1) + Fibonacci(0) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0); 由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。 那么如何求解呢，动态规划似乎不错，关于动态规划三个条件：最优子结构、无后效性、子问题重叠这些就不谈了，因为理(wo)论(ye)性(bu)太(tai)强(dong)了。 下例是一个简单的动态规划，以一定的空间代价避免代价更大的重复计算的栈空间浪费：12345678910if(n&lt;=1)&#123; return n;&#125;int[] record = new int[n+1];record[0] = 0;record[1] = 1;for(int i=2;i&lt;=n;i++)&#123; record[i] = record[i-1] + record[i-2];&#125;return record[n]; 虽然看起来很蠢，空间浪费了sizeof(int)*(n-1)，但是对于那个超大n的测试用例应该是可以通过了，时间复杂度也达到了O(n)。那能不能把“优雅”的递归和动态规划结合起来呢？递归的优点在于便于理解和编码，而重复计算的关键原因在于代码里直接就“递”进去然后等着“归”了，所以避免重复的关键在于对子问题是否已经得出解的判断，即：1234567891011121314public static int[] record = null;public int Fibonacci(int n)&#123; if(n&lt;=1)&#123; return n; &#125; if(null == record)&#123; record = new int[n+1]; &#125; if(0!=record[n-2] &amp;&amp; 0!=record[n-1])&#123; record[n] = record[n-2] + record[n-1]; &#125; else &#123; return Fibonacci(n-2) + Fibonacci(n-1); &#125;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题：从1到n整数中1出现的次数]]></title>
    <url>%2F2018%2F03%2F06%2Fcoding_offer32_1toN%2F</url>
    <content type="text"><![CDATA[题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 额，题目的意思实际上是求出从1到n整数中1出现的次数。 链接：https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6 题目分析设N = abcde ,其中abcde分别为十进制中各位上的数字。如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。 ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，…，11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。 ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,2100~2199，，….，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。 ③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，…，11100~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。 这题没看题解之前真是一脸懵逼，找规律真是不太容易啊。 至此，就可以写代码了，为了加深理解，我再通过表格的形式叙述一下算法流程。以21345为例，列表如下： i(当前位) n/i/10(前面的数) n/i%10(当前位的值) n%i(后面的数) 当前位1的个数 1（个位） 2134 5 0 (2134+1)x1=2135 10（十位） 213 4 5 (213+1)x10=2140 100（百位） 21 3 45 (21+1)x100=2200 1000 2 1 345 2x1000+345+1 = 2346 10000 0 2 1345 (0+1)x10000=10000 综合起来最终结果就是18821. 12345678910111213141516171819202122232425public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0;//1的个数 int i = 1;//当前位 int current = 0,after = 0,before = 0; while((n/i)!= 0)&#123; current = (n/i)%10; //高位数字 before = n/(i*10); //当前位数字 after = n-(n/i)*i; //低位数字 //如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数 if (current == 0) count += before*i; //如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1 else if(current == 1) count += before * i + after + 1; //如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数 else&#123; count += (before + 1) * i; &#125; //前移一位 i = i*10; &#125; return count; &#125;&#125; 上面看懂了之后，再来看这个解法，也很容易。其实思路是一样的，只不过代码更加简洁了。12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; //主要思路：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析 //根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i //当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1 //当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1 //当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30） //综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1 //之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1) int count=0; long long i=1; for(i=1;i&lt;=n;i*=10) &#123; //i表示当前分析的是哪一个数位 int a = n/i,b = n%i; count=count+(a+8)/10*i+(a%10==1)*(b+1); &#125; return count; &#125;&#125;;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题：用两个栈实现队列]]></title>
    <url>%2F2018%2F03%2F06%2Fcoding_offer07_stack2queue%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 C++版本的初始代码为：123456789101112131415class Solution&#123;public: void push(int node) &#123; &#125; int pop() &#123; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 思路分析用两个栈实现一个队列的功能?要求给出算法和思路!&lt;分析&gt;： 入队：将元素进栈A出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。 换个说法：栈A用来作入队列；栈B用来出队列，当栈B为空时，栈A全部出栈到栈B,栈B再出栈（即出队列）。 本地测试的完整C++程序：【添加了一个打印函数】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if(stack2.size() &lt;= 0) &#123; while (stack1.size() &gt; 0) &#123; int data = stack1.top(); stack1.pop(); stack2.push(data); &#125; &#125; if(stack2.size() == 0) cout &lt;&lt; "error" &lt;&lt; endl; //throw new exception("queue is empty"); int head = stack2.top(); stack2.pop(); return head; &#125; int show_value()&#123; int count = 0; int data; while (stack2.size() &gt; 0) &#123; data = stack2.top(); cout &lt;&lt; data &lt;&lt; " "; stack2.pop(); stack1.push(data); ++count; &#125; while (stack1.size() &gt; 0) &#123; data = stack1.top(); stack1.pop(); stack2.push(data); &#125; // stack2中只返回原先就在stack1中的值。 while (stack2.size() &gt; count) &#123; data = stack2.top(); cout &lt;&lt; data &lt;&lt; " "; stack2.pop(); stack1.push(data); &#125; if (stack2.size() != count ) cout &lt;&lt; "error:" &lt;&lt; stack2.size() &lt;&lt; " != " &lt;&lt; count; cout &lt;&lt; endl; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;;int main() &#123; Solution *s = new Solution(); s-&gt;push(5); s-&gt;push(4); s-&gt;push(3); s-&gt;push(2); s-&gt;pop(); s-&gt;push(1); s-&gt;push(0); s-&gt;push(-1); s-&gt;pop(); s-&gt;push(-2); // 打印出队列的值。 s-&gt;show_value(); return 0;&#125; 此外，还可以思考一下： 用两个队列实现一个栈的功能?要求给出算法和思路!&lt;分析&gt;： 入栈：将元素进队列A出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素 以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列依次放入队列A中。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题：重建二叉树]]></title>
    <url>%2F2018%2F03%2F05%2Fcoding_offer06_reconstractBinaryTree%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路分析根节点肯定是前序遍历的第一个数。找到中序遍历根节点所在位置。对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边。利用上述这点，对二叉树节点进行归并。取出前序和中序遍历根节点左边和右边的子树递归，再对其进行上述所有步骤（递归），即再区分子树的左、右子子数，直到叶节点。 Python的解法简洁明了。123456789101112131415161718# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if not pre or not tin: return None root = TreeNode(pre.pop(0)) index = tin.index(root.val) root.left = self.reConstructBinaryTree(pre, tin[:index]) root.right = self.reConstructBinaryTree(pre, tin[index + 1:]) return root 这是C++的解法，一样的思路。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* 先序遍历第一个位置肯定是根节点node， 中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组 另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组 把四个数组找出来，分左右递归调用即可。*/ class Solution &#123; public: struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; in) &#123; int in_size = in.size(); if(in_size == 0) return NULL; vector&lt;int&gt; pre_left, pre_right, in_left, in_right; //创建根节点，根节点肯定是前序遍历的第一个数 int val = pre[0]; TreeNode* node = new TreeNode(val);//root node is the first element in pre //找到中序遍历根节点所在位置,存放于变量p中 int p = 0; for(p; p &lt; in_size; ++p)&#123; if(in[p] == val) //Find the root position in in break; &#125; //对二叉树节点进行归并 for(int i = 0; i &lt; in_size; ++i)&#123; if(i &lt; p)&#123; in_left.push_back(in[i]);//Construct the left pre and in pre_left.push_back(pre[i+1]); &#125; else if(i &gt; p)&#123; in_right.push_back(in[i]);//Construct the right pre and in pre_right.push_back(pre[i]); &#125; &#125; //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点 node-&gt;left = reConstructBinaryTree(pre_left, in_left); node-&gt;right = reConstructBinaryTree(pre_right, in_right); return node; &#125;&#125;;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer面试题：二维数组中的查找]]></title>
    <url>%2F2018%2F03%2F05%2Fcoding_offer03_findInArray%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法从右上角（或者左下角）的元素开始查找。 矩阵是有序的，有：从右上角来看，向左数字递减，向下数字递增，因此从右上角开始查找，当要查找数字比右上角数字大时，下移；要查找数字比右上角数字小时，左移。从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时，右移；要查找数字比左下角数字小时，上移。 代码以右上角为例。12345678910111213141516171819202122232425bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; bool found = false; if(array.empty()) return false; int rows = array.size(); int cols = array[0].size(); if(rows &gt; 0 &amp;&amp; cols &gt; 0) &#123; int row = 0; int col = cols - 1; while (row &lt; rows &amp;&amp; col &gt;= 0) &#123; if (array[row][col] == target) &#123; found = true; break; &#125; else if (array[row][col] &gt; target) --col; else ++row; &#125; &#125; return found;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程题：扇形染色问题]]></title>
    <url>%2F2018%2F03%2F05%2Fcoding_dye_problem%2F</url>
    <content type="text"><![CDATA[染色问题将一个圆形等分成N个小扇形,将这些扇形标记为1,2,3,…,N。现在使用M种颜色对每个扇形进行涂色，每个扇形涂一种颜色，且相邻的扇形颜色不同。 求：有多少种涂色方法。备注：1，不考虑数值越界。2，N&gt;=1，M&gt;=3; 分析【分析】设$a(n) $为符合要求的对n个扇形的涂色方法。对扇形1有m种涂色方法，扇形2有m－1种涂色方法，扇形3也有m－1种涂色方法，扇形n也有m－1种涂色方法。于是，共有$m\times (m-1)^{n-1} $种不同的涂色方法。但是，$a(n)\neq m\times (m-1)^{n-1} $，因为这种涂色方法可能出现1与n着色相同的情形，这是不符合题意的，因此，答案应从$m\times (m-1)^{n-1} $中减去这些不符合题意的涂色方法。 那么，这些不符合题意的涂色方法，又怎样计算呢？这时，把1与n看作一个扇形，其涂色方法相当于用m种颜色对n－1个扇形涂色（这种转换思维相当巧妙），不同的涂色方法有$a(n-1)$种，于是，有：$$a(n)= m\times (m-1)^{n-1} - a(n-1)\cdots \cdots (n≥3) $$其中，$a(3)=m(m-1)(m-2) $，上式是数列的递推公式，可推导出$a(n)$的通项公式(感谢wysrc评论提醒！)：$$a(n)= (m-1)^{n} + (-1)^n (m-1)\cdots \cdots (n≥3) $$ 实现我们根据递推公式，采用递归法实现计算。123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int color(int m, int n)&#123; if (n == 1)&#123; return m; &#125; else if (n == 2)&#123; return m * (m - 1); &#125; //else if (n == 3)&#123; // return m * (m - 1) * (m - 2); //&#125; return m * pow(m - 1, n - 1) - color(m, n - 1);&#125;int main() &#123; cout &lt;&lt; color(3, 4) &lt;&lt; " " &lt;&lt; color(4, 3) &lt;&lt; " " &lt;&lt; color(4, 3) &lt;&lt; endl; return 0;&#125; 当然也可以直接根据通项公式来编程。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西瓜书《机器学习》学习笔记(4)：聚类]]></title>
    <url>%2F2018%2F03%2F04%2FML_chap9_clustering%2F</url>
    <content type="text"><![CDATA[章节目录 聚类任务 性能度量 距离计算 原型聚类 密度聚类 层次聚类 （一）聚类任务在无监督学习中（unsupervised learning）中，训练样本的标记信息是未知的，目标是通过对无标记的训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础。此类学习任务中研究最多、应用最广的是“聚类”（clustering）。 聚类试图将数据集中的样本划分为若干通常是不相交的子集，每个子集称为一个“簇”（cluster）。 聚类既能作为一个单独的过程，用于找寻数据内的分布结构，也可作为分类等其他学习任务的前驱过程。 （二）性能度量聚类性能度量亦称聚类“有效性指标”（validity index）。与监督学习中的性能度量作用相似。对聚类结果，我们需通过某种性能度量来评估其好坏；另一方面，若明确了最终将要使用的性能度量，则可直接将其作为聚类过程的优化目标，从而更好地得到符合要求的聚类结果。 聚类是将样本集D划分为若干不相交的子集，即样本簇。直观上看，我们希望“物以类聚”，即同一簇的样本尽可能彼此相似，不同簇的样本尽可能不同。换言之，聚类结果的“簇内相似度”（intra-cluster similarity）高且“簇间相似度”（inter-cluster similarity）低。聚类性能度量大致有两类： “外部指标”（external index）将聚类结果与某个“参考模型”（reference model）进行比较； 常用的聚类性能度量外部指标有： Jaccard系数（Jaccard Coefficient，简称 JC） FM指数（Fowlkes and Mallows Index，简称FMI） Rand指数（Rand Index，简称RI） “内部指标”（internal index）直接考察聚类结果而不利用任何参考模型；常用的聚类性能度量内部指标有： DB指数（Davies-Bouldin Index，简称DBI） Dunn指数（Dunn Index，简称DI） （三）距离计算给定样本$x_i=(x_{i1}, x_{i2},\cdots ,x_{in})$，与$x_j=(x_{j1}, x_{j2},\cdots,x_{jn})$，最常用的是”闵可夫斯基距离“（Minkowski distance）， p=2时，闵可夫斯基距离即欧氏距离（Euclidean distance）， p=1时，闵可夫斯基距离即曼哈顿距离（Manhattan distance）， 上面的距离计算式都是事先定义好的，但在不少现实任务中，有必要基于数据样本来确定合适的距离计算式，这可通过”距离度量学习“（distance metric learning）来实现。 （四）原型聚类原型聚类亦称”基于原型的聚类“（prototype-based clustering），此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式，将产生不同的算法。 1. k均值算法给定样本集$D={x_1，x_2，…，x_m}$，”k均值“（k-means）算法针对聚类所得簇划分$C={C_1，C_2，…，C_k}$最小化平方误差： 其中: x是簇$C_i$的均值向量。直观来看，上面式子在一定程度上刻画了簇内样本围绕簇均值向量的紧密程度，E值越小则簇内样本相似度越高。 2. 学习向量量化与k均值算法类似，“学习向量量化”（Learning Vector Quantization，简称LVQ）也是试图找到一组原型向量来刻画聚类结构，但与一般的聚类算法不同的是，LVQ假设数据样本带有类别标记，学习过程用样本的这些监督信息来辅助聚类。 3. 高斯混合聚类与k均值、LVQ用原型向量来刻画聚类结构不同，高斯混合（Mixture-of-Gaussian）聚类采用概率模型来表达聚类原型。 （五）密度聚类密度聚类亦称“基于密度的聚类”（density-based clustering），此类算法假设聚类结构能通过样本分布的紧密程度确定。通常情况下，密度聚类算法从样本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。DBSCAN是一种著名的密度聚类算法。 （六）层次聚类层次聚类（hierarchical clustering）试图在不同层次对数据集进行划分，从而形成树形的聚类结构。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略。AGNES是一种采用自底向上聚合策略的层次聚类算法。 参考资料 西瓜书《机器学习》 《机器学习》笔记-聚类（9）]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西瓜书《机器学习》学习笔记(3)：集成学习]]></title>
    <url>%2F2018%2F03%2F04%2FML_chap08_EnsembleLearning%2F</url>
    <content type="text"><![CDATA[章节目录 个体与集成 Boosting Bagging与随机森林 集合策略 多样性 （一）个体与集成集成学习（ensemble learning）的一般结构：先产生一组“个体学习器”（individual learner），再用某种策略将他们结合起来，如下图所示， 个体学习器通常由一个现有的学习算法从训练数据产生： 只包含同种类型的个体学习器，这样的集成是“同质”的（homogeneous）。同质集成中的个体学习器亦称为”基学习器“（base learning），相应的学习算法称为”基学习算法“（base learning algorithm）。 集成也可包含不同类型的个体学习器，这样集成是”异质“的（heterogeneous）。相应的个体学习器，常称为”组件学习器“（component learning）或直接称为个体学习器。 在一般的经验中，如果把好坏不等的东西掺到一起，那么通常结果会是比坏的好一些，比好的要坏一些。集成学习把多个学习器结合起来，如何能获得比最好的单一学习器更好的性能呢？ 考虑一个简单的例子：在二分类任务中，假定三个分类器在三个测试样本的表现如下图所示， 其中，√表示分类正确，x表示分类错误，集成学习的结果通过投票法（voting）产生，即“少数服从多数”。这个简单的例子显示出：要获得好的集成，个体学习器应“好而不同”。个体学习器要有一定的“准确性”，即学习器不能太坏，而且要有“多样性”（diversity），即学习器之间有差异。事实上，如何产生并结合“好而不同”的个体学习器，恰是集成学习研究的核心。根据个体学习器的生成方式，目前集成学习的方法大致可分为两大类： 个体学习器间存在强依赖关系、必须串行生成的序列化方法，代表是Boosting； 个体学习器间不存在强依赖关系、可同时生成的并行化方法，代表是Baggig和“随机森林”（Random Forest）； （二）BoostingBoosting是一族可将弱学习器提升为强学习器的算法。这族算法的工作机制类似：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续收到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直到基学习器数目达到事先指定的值T，最终将这T个学习器进行加权结合。Boosting族算法最著名的代表是AdaBoost。AdaBoost有多种推导方式，比较容易理解的是基于“加性模型”（additive model）即基学习器线性组合， 来最小化指数损失函数（exponential loss function）： boosting中的Adaboost算法的详细推导过程——P172：略复杂，有空再看。 （三）Bagging与随机森林欲得到泛化性能强的集成，集成中的个体学习器应尽可能独立。虽然“独立”在显示任务中无法做到，但可以设法使基学习器尽可能具有较大差异。给定一个训练数据集，一种可能的做法是对训练样本进行采样，产生若干个不同的子集，再从每个数据子集中训练出一个基学习器。这样，由于训练数据不同，我们获得的基学习器可望具有比较大的差异。然而，为获得更好的集成，我们还同时希望个体学习器不能太差。如果采样出的每个子集都完全不同，则每个基学习器只用到了一小部分训练数据，甚至不足进行有效学习，这显然无法确保产生出比较好的基学习器。为考虑这个问题，我们可考虑使用相互有交叠的采样子集。 1. BaggingBagging是并行式集成学习方法最著名的代表，从名字即可看出，它直接基于前面介绍过的自助采样法（bootstrap sampling）。 从偏差-方差分解角度看，Bagging主要关注降低方差。 2. 随机森林随机森林（Random Forest，简称RF）是Bagging的一个扩展变体。RF在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。随机森林对Bagging只做了小改动，但是与Bagging中基学习器的“多样性”仅通过样本扰动（通过对初始训练集采样）而来不同，随机森林中基学习器多样性不仅来自样本扰动，还来自属性扰动，这就使得最终集成的泛化性能可通过个体学习器之间的差异度的增加而进一步提升。 （四）组合策略学习器结合可能从三个方面带来好处： 从统计的方面看，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能因误选而导致泛化性能不佳，结合多个学习器减小这一风险； 从计算的方面来看，学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能很糟，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险； 从表示的方面来看，某些但学习器则肯定无效，而通过结合多个学习器，由于响应的假设空间有所扩大，有可能学得更好的近似。 直观的示意图如下所示： 集成学习常见策略有： 平均法：简单平均法和加权平均法。 投票法：绝对多数投票法；相对多数投票法；加权投票法 学习法：初级学习器+次级学习器 （五）多样性误差-分歧分解欲构建泛化能力强的集成，个体学习器应“好而不同”，其中，“误差-分歧分解”（error-ambiguity decomposition）是一个简单的理论分析方法。但该推导过程只适用于回归学习，难以直接推广到分类学习任务中。 多样性度量多样性度量（diversity measure）是用于度量集成中个体分类器的多样性，即估算个体学习器的多样化程度。常用的多样性度量包括： 不合度量（disagreement measure） 相关系数（correlation coefficient） Q-统计量（Q-statistics） k-统计量（k-statistics） 多样性增强在集成学习中需有效地生成多样性大的个体学习器。与简单地直接用初始数据训练出个体学习器相比，一般思路是在学习过程中引入随机性，常见的做法主要有， 数据样本扰动：数据样本扰动基于采样法。 输入属性扰动：随机子空间算法。 输出表示扰动：翻转法（随机改变一些训练样本的标记）；输出调制法（将分类输出转化为回归输出后构建学习器）… 算法参数扰动：负相关法；单一学习器通常需要交叉验证等来确定参数值。 参考资料 西瓜书《机器学习》 《机器学习》笔记-集成学习（8）]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络学习笔记：(三)传输层]]></title>
    <url>%2F2018%2F03%2F01%2Fnetwork_03_transmission_layer%2F</url>
    <content type="text"><![CDATA[本文是计算机网络课程传输层部分的笔记。 传输层两个协议简介传输层有两个协议：TCP和UDP。 TCP：传输控制协议(Transmission Control Protocol)。文件分段传输，需要建立会话，可靠传输；流量控制功能 UDP：用户数据报协议(User Data Protocol) 一个数据包就能够完成数据通信，不分段；不需要建立会话，不需要流量控制；不可靠传输。 查看会话：netstat -n查看是哪个进程创建的会话：netstat -nb 举例场景：DNS域名解析：使用UDP协议；QQ聊天：聊天记录 使用UDP协议；QQ传文件：TCP协议；发送邮件：可能很大需要分段，因此TCP协议；FTP下载文件：TCP屏幕广播 多播：UDP 传输层协议和应用层协议之间的关系http = tcp + 80https = tcp +443rdp = tcp +3389ftp = tcp + 21访问共享文件夹=tcp + 445SMTP【发送】 = TCP + 25POP3【接收】 = TCP + 110Telnet = TCP + 23SQL = TCP +1433DNS = UDP +53 服务和应用层协议之间的关系服务是由端口决定的。服务是启动状态才侦听端口。网卡是大门，网卡设置安全，只允许80端口【Web服务】。只允许特定服务的端口。 服务使用TCP或者UDP的端口侦听客户端请求。 客户端使用IP地址定位服务器，使用目标端口定位服务。可以在服务器网卡上设置只开放必要的端口，实现服务器的网络安全。 如何在Windows上安装服务自带Telnet远程登录。远程桌面服务。DNS服务Web服务SMTP服务POP3服务 如何查看服务侦听的端口netstat -an查看服务器上侦听的窗口。netstat -n查看建立的会话netstat -nb查看建立会话的进程telnet 192.168.80.100 3389 测试远程计算机某个端口是否打开。 如何更改服务使用的默认端口 迷惑入侵者，使系统更加安全。 如何设置Windows网络安全只开特定服务端口：本地连接属性——TCP/IP协议属性——高级——选项——属性 传输层功能和端口范围传输层功能：为相互通信的应用程序/应用进程提供了端到端的逻辑通信。（网络层是为主机之间提供了逻辑通信）。传输层要对收到的报文进行差错校验。传输层提供面向连接和无连接的服务。 传输层端口：16位端口号进行标志，标志本计算机应用层中的各进程。端口号只具有本地意义，本地不冲突即可。 熟知端口：数值一般为0-10231234567FTP：21TELNET：23SMTP：25DNS：53HTTP：80Https：443RDP：3389 登记端口号：数值为1024~49151客户端口号：数值为49152-65535 UDP协议UDP的主要特点：UDP是无连接的，即发送数据之前不需要建立连接。UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。UDP面向报文，没有拥塞控制，很适合多媒体通信的要求。UDP支持一对一、一对多、多对一和多对多的交互通信。UDP的首部开销小，只有8个字节。 传输控制协议TCP概述TCP是面向连接的传输层协议。TCP把连接作为最基本的抽象。 TCP提供可靠交付的服务。 TCP提供全双工通信。 面向字节流。8bit = 1byte 每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的(一对一)。TCP连接的端点叫做套接字(socket)。端口号拼接到IP地址即构成了套接字。套接字 socket = (IP地址：端口号) 每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：TCP连接::={socket1, socket2} = {(IP1:port1),(IP2:port2)} TCP如何实现可靠传输可靠传输的工作原理————停止等待协议 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。 这种可靠传输协议常称为自动重传请求(Automatic Repeat reQuest)。 ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。 停止等待协议优点是简单，缺点是信道利用率太低。 流水线传输：发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的利用率。 连续ARQ协议：发送方维持发送窗口（发送窗口是5），滑动窗口。 累积确认。 TCP如何实现流量控制接收端告诉发送端接收窗口有多大来实现流量控制。 TCP协议如何避免网络拥塞暂无 TCP报文段的首部格式首部字节一般是固定部分的20个字节，还有长度可变的选项。 TCP报文段首部 含义 源端口 目标端口 序号 第一个字节是整个文章的第几个字节。 确认号 收到数据包后，让继续发的号 数据偏移 占4位；记录第多少个字节是数据。十进制最大为15，代表最大15x4=60个字节。 URG 设为1时代表紧急，发送端不排队，提前传走。 ACK 确认号 PSH push，设为1代表接收端不排队，直接交给应用程序 RST reset，表明TCP会话出现严重错误，需要重新连接。 SYN 同步，SYN攻击：伪造不存在的IP地址。land攻击：源地址和目的地址同一个。 FIN 数据传完了，最后释放连接。 窗口 假设客户端接收缓存为65535字节，服务器就设置发送缓存65535字节(不能超过)，反向同样也需要协商 检验和 紧急指针 URG=1时才起作用。指明紧急数据结束的位置。 选项(长度可变) 可以规定最大数据报的长度MSS，是否支持选择性确认SACK，时间戳 填充 凑够四个字节整数倍 三个建立会话的数据包。MSS=1460数据包最大字节 TCP如何实现可靠传输1.以字节为单位的滑动窗口技术 发送窗口由接收窗口大小来决定的。 超时重传时间的选择$$新的RTTs = (1-\alpha)\times (旧的RTTs) + \alpha \times (新的RTT样本)$$ RFC2988推荐的$\alpha$值为1/8。 TCP的传输连接管理传输连接有三个阶段，即：连接建立、数据传送和连接释放。 三次握手建立TCP连接SYN=1，ACK=0，seq=xSYN=1，ACK=1，seq=y，ack=x+1ACK=1，seq=x+1，ack=y+1 连接释放]]></content>
      <categories>
        <category>Basic Knowledge</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络学习笔记：(二)网络层]]></title>
    <url>%2F2018%2F02%2F28%2Fnetwork_02_network_layer%2F</url>
    <content type="text"><![CDATA[本文是计算机网络课程网络层部分的笔记。 由于是备战面试，因此跳过了物理层和数据链路层，下面只对上述两层简单回顾一下，对上述两层感兴趣的同学可以去原视频观看。 物理层和数据链路层简述物理层：1.网络设备的机械特性，电气特性，功能特性，过程特性2数据通信的基础知识：数字知识，模拟知识3频分多路复用4时分多路复用 数据链路层：1.封装成帧2透明封装【转义字符】3无差错接收【差错校验】4点到点线路的数据链路层 PPP5广播信道的数据链路层 CSMA/CD6以太网 集线器，网桥，交换机100M，1000M以太网 网络层提供的服务网络层的功能：负责在不同网络之间尽力转发数据包，基于数据包的IP地址转发。 如果丢了，不负责数据重传，也不负责顺序。 实现网络层功能的设备就是路由器。路由器只关心IP地址，选择下一跳在哪。 网络设备和OSI参考模型关系计算机通信的过程是什么？ 1应用程序准备要传送的文件；2传输层，将文件分段，并且编号；3网络层给每一段加上IP地址【目的地址与源地址】【数据包】4数据链路层：【数据帧】使用自己的子网掩码判断自己地址在哪个网段；使用自己的子网掩码判断目标地址在哪个网段。加上物理层的地址两种情况：①同一个网段：ARP协议广播解析目标IP地址的MAC地址②不是一个网段：FCS帧检验序列5物理层传输二进制。【比特流】 集线器：增强信号交换机：存储转发【链路层，两层设备】路由器：接收比特流，根据数据包选择路径。【网络层设备，三层设备】 病毒是应用程序，路由器，交换机，集线器等都不会中病毒。 网络层协议在TCP/IP协议族中，属于网络层的协议有：IP/ARP/ICMP与IGMP协议。 ARP协议：（Address Resolution Protocol）数据通信之前的操作。将IP地址通过广播，【广播不能跨网段】，目标MAC地址是FF-FF-FF-FF-FF-FF，解析目标IP地址的MAC地址。 ARP的功能：利用网络层地址(IP地址)，来取得对应的链路层地址(MAC地址)。 Mac地址就是在媒体接入层上使用的地址，通俗点说就是网卡的物理地址。现在的Mac地址一般都采用6字节48bit。 扫描本网段的IP地址 cmd下的命令gpedit.msc 组策略编辑器——脚本（启动/关机）arp -a本地链接——修复 清除缓存 使用ICMP协议的命令——Ping和pathpingICMP(Internet Control Message Protocol)：Internet控制消息协议。该协议是TCP/IP协议集中的一个子协议，属于网络层协议，主要用于在主机和路由器之间传递控制信息，包括报告错误，交换首先控制和状态信息等。 当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。我们可以通过Ping命令发送ICMP回应请求消息并且记录收到ICMP回应回复消息，通过这些消息来对网络或主机的故障提供参考依据。 Ping命令底层就是ICMP协议。 Ping time 查看延迟。其中的TTL是生存时间，可以判断系统。Linux是64，windows是128，Unix是255。Ping 8.8.8.8 -t 一直ping下去Ping 8.8.8.8 -l 2000 指定ping时数据包的大小。Ping 8.8.8.8 -i 2 更改数据包TTL时间，能够跟踪数据包途径的路由器信息。 ping 估算网络状况。 pathping 跟踪数据包路径，计算丢包情况【功能更强】 tracert 10.7.1.53 在Windows上跟踪数据包路径的命令，不计算丢包情况。traceroute 10.7.1.53 在路由器上跟踪数据包路径的命令 Ping命令能够产生流量，但不是应用程序。是网络层的程序。不需要应用程序支持。 IGMP——网络组播管理协议点到点通信：每个人都可以自由调节进度广播：一个网段中实现。跨不了路由器。组播 = 多播，相当于频道。 IP数据报的结构一个IP数据报由首部和数据两部分组成。 首部的前一部分是固定长度，共20个字节，是所有IP数据包必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 数据包最大1500-20=1480字节，超过就要分片了。 IP数据包首部格式 含义 版本 占4位，用来标识TCP/IP协议的版本 v4 v6 首部长度 占4位，一般是20个字节，可变长度一般不用。 区分服务 占8位，用来获得更好的服务。区分服务DS(Differentiated Services)QoS 总长度 占16位，总长度指首部和数据之和的长度，单位为字节。数据报的最大长度为2^16-1=65535字节。最大传送单元MTU(Maximum Transfer Unit)，当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的MTU值。 标识(identification) 占16位，数据包分片后，便于重组 标志(flag) 表示是否完整。占3位，目前只有前两位有意义。标志字段的最低位是MF(More Fragment)。MF=1表示后面“还有分片”，MF=0表示最后一个分片。标志字段中间的以为是DF(Dont Fragment)。只有当DF=0时才允许分片。【没有分片的时候为010】 片偏移 占13位，片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。数据第一个字节是整个数据包的第多少个字节 生存时间 占8位，TTL(Time To Live)，防止路由环路时永不消失。Linux=64; Windows=128; Unix=255;据此可粗略估计系统 协议号 占8位，用来标识用哪个协议来处理。ICMP=1；IGMP=2；TCP=6；UDP=17；IPv6=41；OSPF=89 首部检验和 占16位，只校验数据报的首部，不检验数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化），不检验数据部分可减少计算的工作量。 源地址 占32位 目的地址 占32位 可选字段 长度可变，很少使用。IPv6没有可变部分。 IP协议让路由器自动学习路由表的协议就是IP协议。 RIP、OSPF静态路由和动态路由（网络规模大时采用）。 网络畅通的条件————数据包有去有回。 路由器必须知道到目的地址网段的下一跳是谁。目的地址无法到达【路由表】；请求超时【有可能是无网关设置】。 静态路由：需要管理员gei告诉路由器所有没有直连的网络(如何转发)下一跳给谁。静态路由的缺点：适合于小规模的网络，不能自动调整路由【以适应网络的变化】。 动态路由：RIP协议：周期性地广播路由表，选择最佳路径的标准是跳数，30秒更新一下路由信息。最大跳数为15跳。]]></content>
      <categories>
        <category>Basic Knowledge</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络学习笔记：(一)概述]]></title>
    <url>%2F2018%2F02%2F27%2Fnetwork_01_overview%2F</url>
    <content type="text"><![CDATA[本文是计算机网络课程概述部分的笔记。 IP地址、域名地址与URLIP地址域名地址域名服务器(DNS,Domain Name Server)：提供IP地址和域名之间的转换服务的服务器。 统一资源定位器(URL，Uniform Resource Locator)由三部分组成：1传输协议：//主机IP地址或域名地址/资源所在路径和文件名 标识Internet网上资源位置的三种方式：1.IP地址2.域名地址3.URL 路由器的IP地址一般为192.168.0.1，最后一位一般是1. Internet的工作原理TCP/IP数据包。发送文件时，TCP先把该文件分成一个个小数据包，并加上一个特定的信息（可以看成是装箱单），以便接收方的机器确认传输是正确无误的，然后IP再在数据包上标上地址信息，形成可在Internet上传输的TCP/IP数据包。 使用TCP/IP传送数据：当TCP/IP数据包到达目的地后，计算机首先去掉地址标志，利用TCP的装箱单检查数据在传输中是否有损失，如果接收方发现有损坏的数据包，就要求发送端重新发送被损坏的数据包，确认无误后再将各个数据包重新组合成原文件。 Internet通过TCP/IP协议这一网上的“世界语”和IP地址实现了它的全球通信的功能。 TCP/IP协议家族12345IP：Internet Protocol UDP： RTP，traceroute TCP HTTP，FTP，ssh ISO/OSI网络模型 7个网络层(Layer)： Layer 1: Physical - cables (物理层) Layer 2: Data Link - ethernet (数据链路层) Layer 3: Network - IP (网络层) Layer 4: Transport - TCP/UDP (传输层) Layer 5: Session (会话层) Layer 6: Presentation (表示层) Layer 7: Application (应用层) 应用层：所有能产生网络流量的程序【最抽象的层次，最接近软件的层次】表示层：在传输之前是否进行加密 或 压缩处理 二进制 ASCII。【传输前的处理，开发人员处理的事情，不是网络人员。】【出现乱码就是表示层】会话层：建立会话 【查看木马 netstat -n/ netstat -nb】传输层：可靠传输，流量控制【处理速度】，不可靠传输【解析DNS】。网络层： 负责选择最佳路径，规划IP地址【IPv4 v6的改变只会影响网络层】数据链路层：帧的开始和结束 实现透明传输 差错校验【形象的比喻：老式的电话交换机，美女接话员，接线。通讯链路的搭建。】物理层：接口标准 电气标准 如何在物理链路上传输更快的速度。【最底层】 层次的关系。由底层构造出更高层。 OSI模型对网络排错的指导物理层故障：查看连接状态，查看发送和接收的数据包。具体如：网线接口，水晶头故障【物理层，发送有包，接收没包】 数据链路层故障：1.笔记本：一个教室可以上网，另一个不可以。原因：Mac地址冲突【改注册表】2.ADSL欠费，网络不通属于数据链路层；3.网速协商不一致【一般是自动协商】4.vlan【虚拟局域网】接入错误的vlan 网络层故障：配置错误、配置错误的IP地址、子网掩码、网关【选路径】；路由器上没有到达目标网络的路由 应用层故障：应用程序配置错误； OSI参考模型和网络安全1.物理层安全【用不到的网线拔掉】2.数据链路层安全： ADSL 账号密码；数据链路层安全 VLAN，交换机端口绑定MAC地址3.网络层安全：在路由器上使用ACL控制数据包流量4.应用层安全：开发的应用程序没有漏洞 OSI参考模型和TCP/IP协议数据封装的过程： 计算机在接收到数据帧后，需要去掉为了传输而添加的附加信息，这称为解封装。上述封装操作的逆过程。 客户进程和服务器进程使用TCP/IP协议进行通信： 计算机网络的性能 速率：主机在数字信道【一个发送端到一个接收端】上传送数据位数的速率，也称为data rate或bit rate，单位是b/s, kb/s, Mb/s, Gb/s 带宽：数字信道传送的最高数据率 吞吐量：单位时间内通过某个网络的数据量。【总的流量】 时延：【延迟】 时延带宽积【数据量】 往返时间：RTT(Round-Trip Time)，从发送方发送数据开始，到发送方收到接收方确认【可以使用Ping命令测试，Ping网关】 利用率：信道利用率=有数据通过时间/(有+无)数据通过时间网络利用率：信道利用率加权平均值。]]></content>
      <categories>
        <category>Basic Knowledge</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(十一)关联容器]]></title>
    <url>%2F2018%2F02%2F26%2FCPP_11%2F</url>
    <content type="text"><![CDATA[11.1 使用关联容器关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。 关联容器类型 关联容器类型 含义 按关键字有序保存元素 map 关联数组，保存关键字-值对 set 关键字即值，即只保存关键字的容器 multimap 关键字可重复出现的map multiset 关键字可重复出现的set 无序集合 unordered_map 用哈希函数组织的map unordered_set 用哈希函数组织的set unordered_multimap 哈希组织的map；关键字可以重复出现 unordered_multiset 哈希组织的set；关键字可以重复出现 map是关键字-值对的集合，因此map类型被称为关联数组(associative array)。set就是关键字的简单集合。当想知道一个值是否存在的时候，set是最有用的。 1234567891011121314151617181920212223242526272829303132//chap11_1_word_count_exclude_some_words.cpp#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;/* *统计每个单词在输入中出现的次数。 *Linux g++ 5.4.0 编译通过。 *命令： * g++ -std=c++11 chap11_1_word_count_exclude_some_words.cpp * ./a.out */int main() &#123; map&lt;string, size_t&gt; word_count; //对关联容器的元素进行列表初始化 set&lt;string&gt; exclude = &#123;"The", "But", "And", "Or", "An", "A", "the", "but", "and", "or", "an", "a"&#125;; string word; //在新的一行按CTRL+Z（或者LINUX类系统中按CTRL+D）即可终止循环。 while(cin &gt;&gt; word) &#123; //find调用返回一个迭代器，只统计不在exclude中的单词。 if(exclude.find(word) == exclude.end()) ++word_count[word]; &#125; for(const auto &amp;w : word_count) &#123; cout &lt;&lt; w.first &lt;&lt; " occur " &lt;&lt; w.second &lt;&lt; ((w.second &gt; 1) ? " times" : " time") &lt;&lt; endl; &#125; return 0;&#125; 练习11.4统计每个单词在输入中出现的次数。要求：忽略标点符号且大小写无关。1234567891011121314151617181920212223242526272829303132333435363738394041//chap11_exersize_4.cpp#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;using namespace std;/* *统计每个单词在输入中出现的次数。[忽略标点符号且大小写无关] *Linux g++ 5.4.0 编译通过。 *命令： * g++ -std=c++11 chap11_exersize_4.cpp * ./a.out */int main() &#123; map&lt;string, size_t&gt; word_count; //对关联容器的元素进行列表初始化 set&lt;string&gt; exclude = &#123;"The", "But", "And", "Or", "An", "A", "the", "but", "and", "or", "an", "a"&#125;; string word; //在新的一行按CTRL+Z（或者LINUX类系统中按CTRL+D）即可终止循环。 while(cin &gt;&gt; word) &#123; //将字母统一转化为小写形式 for(auto &amp;ch : word) &#123; ch = tolower(ch); //针对每一字母 &#125; //删去标点 word.erase(remove_if(word.begin(), word.end(), static_cast&lt;int(*)(int)&gt;(&amp;ispunct)), word.end()); //find调用返回一个迭代器，只统计不在exclude中的单词。 if(exclude.find(word) == exclude.end()) ++word_count[word]; &#125; for(const auto &amp;w : word_count) &#123; cout &lt;&lt; w.first &lt;&lt; " occur " &lt;&lt; w.second &lt;&lt; ((w.second &gt; 1) ? " times" : " time") &lt;&lt; endl; &#125; return 0;&#125; 11.2 关联容器概述关联容器都支持普通容器操作。关联容器不支持顺序容器的位置相关的操作，原因是关联容器中元素都是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。 pair标准库类型，位于头文件utility中。 12345678910111213141516#include&lt;utility&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;// error: in C++98 ‘p’ must be initialized by constructor, not by ‘&#123;...&#125;’// command:// g++ chap11_2_pair.cpp -std=c++11// ./a.outint main()&#123; string s = "hello"; //初始化方式有很多，这是列表初始化 pair&lt;string,size_t&gt; p = &#123;s, s.size()&#125;; cout &lt;&lt; "The size of string \""&lt;&lt; p.first &lt;&lt; "\" is " &lt;&lt; p.second &lt;&lt; "." &lt;&lt; endl; return 0;&#125; 11.3 关联容器操作关联容器额外的类型别名 关联容器额外的类型别名 含义 key_type 此容器类型的关键字类型 mapped_type 每个关键字关联的类型：只适用于map value_type 对于set，与key_type相同，对于map，为pair&lt;const key_type,mapped_type&gt; 关联容器insert操作 关联容器额外的类型别名 含义 c.insert(v) c.elmpace(args) v是value_type类型对象；args用来构造一个元素。对于map和set，只有当元素关键字不在c中才插入(或构造)元素。函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否是否成功的bool值。对于multimap和multiset，总会插入(或构造)给定元素，并返回一个指向新元素的迭代器。 c.insert(b,e) c.insert(il) b和e是迭代器，表示一个c::value_type类型值的范围；il是这种值的花括号列表。函数返回void。对于map和set，只插入关键字不在c中的元素。对于multimap和multiset，则会插入范围中的每个元素。 c.insert(p,v) c.insert(p,args) 类似insert(v)(或emplace(args))，但迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。 map和unordered_map的下标操作 map和unordered_map的下标操作 含义 c[k] 返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化 c.at[k] 访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常 在一个关联容器中查找元素 关联容器中查找元素 含义 lower_bound和upper_bound 不适用于无序容器。 下标和at操作只适用于 非const的map和unordered_map c.find(k) 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器 c.count(k) 返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0和1 c.lower_bound(k) 返回一个迭代器，指向第一个关键字不小于k的元素 c.upper_bound(k) 返回一个迭代器，指向第一个关键字大于k的元素 c.equal_range(k) 返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end() 11.4 无序容器无序容器管理操作 关联容器中查找元素 含义 桶接口 c.bucket_count() 正在使用的桶的数目 c.max_bucket_count() 容器能容纳的最多的桶的数量 c.bucket_size() 第n个桶中有多少个元素 c.bucket(k) 关键字为k的元素在哪个桶中 桶迭代 local_iterator 可以用来访问桶中元素的迭代器类型 const_local_iterator 桶迭代器的const版本 c.begin(n),c.end(n) 桶n的首元素迭代器和尾后迭代器 c.cbegin(n),c.cend(n) 与前两个函数类似，但返回const_local_iterator 哈希策略 c.load_factor() 每个桶的平均元素数量，返回float值 c.max_load_factor() c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得load_factor&lt;=max_load_factor c.rehash(n) 重组存储，使得bucket_count&gt;=n且bucket_count&gt;size/max_load_factor c.reserve(n) 重组存储，使得c可以保存n个元素且不必rehash 术语表关联容器：associative container无序容器：unordered container哈希函数：hash function 参考资料c++ 去除字符串中的空格和标点符号 （remove_if 函数的用法）《C++primer(第五版)》学习之路-第十一章：关联容器]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(10) 第十二章 二叉搜索树]]></title>
    <url>%2F2018%2F02%2F02%2Falgorithm_tutorial_chapter_12%2F</url>
    <content type="text"><![CDATA[二叉搜索树概述搜索树数据结构支持许多动态集合操作：SEARCH、MINIMUM、MAXIMUM、PREDECESSOR、SUCCESSOR、INSERT与DELETE。 上述基本操作花费的时间与这棵树的高度成正比。 定义与性质（1）设x为二叉查找树中的一个结点，若y是x左子树中的一个结点，则key[y] &lt;= key[x]；若y是x右子树中的一个结点，则key[x]&lt;=key[y]（2）二叉查找树上执行的基本操作的时间与树的高度成正比。 结构每个节点就是一个对象，包含：关键字key，卫星数据data，以及三个属性：分别指向父、左右孩子的指针p,left, right 在二叉查找树上的操作查找一个关键字：SEARCH(x, k)求最小关键字：MINIMUM(x)求最大关键字：MAXIMUM(x)求前驱：PREDECESSOR(x)求后继：SUCCESSOR(x)插入一个结点：INSERT(T, z)删除一个结点：DELETE(z) 二叉查找树的应用1.遍历：中序遍历、先序遍历、后序遍历【根关键字遍历的先后顺序】 2.查找：查找包含某个关键字的结点，查找关键字最大或最小的结点、查找某个结点的前驱或后继 12.1-2二叉搜索树的性质与最小堆的性质有什么不同？ 二叉搜索树：左子树关键字&lt;=根结点关键字&lt;=右子树关键字 最小堆：左子树关键字&gt;=根结点关键字 &amp;&amp; 右子树关键字&gt;=根结点关键字 不能，因为一个结点的的左子树与右子树的关键字大小没有关系 12.1-3 遍历的非递归实现给出一个非递归的中序树遍历算法。(提示：有两种方法，在较容易的方法中，可以采用栈作为辅助数据结构；较复杂的方法中，不采用栈结构，但假设可以测试两个指针是否相等)。 中根遍历要求顺序是左根右，借助栈s实现。先将根root入栈，接着从根root开始查找最左的子孩子结点直到为空为止，然后将空节点出栈，再将左子树节点出栈遍历，然后判断该左子树的右子树节点入栈。循环此过程，直到栈为空为止。此时需要注意的是入栈过程中空结点也入栈了，用以判断左孩子是否结束和左孩子是否有右孩子结点。123456789101112131415161718192021222324//中序遍历非递归过程void BST_Tree::Inorder_Iterative_Traverse(BST_Node *root)&#123; //用C++STL——栈stack实现 if (root == NULL) return; //空树 stack&lt;BST_Node *&gt;s; s.push(root); while (!s.empty()) &#123; BST_Node *p = s.top(); while(p != NULL) //直到左节点为空，即最小元素 &#123; s.push(p-&gt;left); p = s.top(); &#125; s.pop(); //空结点出栈 if(!s.empty()) &#123; p = s.top(); cout &lt;&lt; p-&gt;key &lt;&lt; " "; s.pop(); s.push(p-&gt;right); //右子树结点入栈（不一定有右节点，可以压入NULL &#125; &#125; cout &lt;&lt; endl;&#125; 一个更加简洁的写法：123456789101112131415161718192021//中序遍历非递归过程——简洁版void BST_Tree::Inorder_Iterative_Traverse_2(BST_Node *root)&#123; //用C++STL——栈stack实现 stack&lt;BST_Node *&gt;s; BST_Node *p = root; while (p || !s.empty()) &#123; if(p != NULL) //左节点入栈 &#123; s.push(p); //压入值非空 p = p-&gt;left; &#125; else &#123; //出栈遍历 p = s.top(); cout &lt;&lt; p-&gt;key &lt;&lt; " "; s.pop(); p = p-&gt;right; &#125; &#125; cout &lt;&lt; endl;&#125; 查询二叉搜索树查找任一节点伪码：12345678910111213TREE-SEARCH(x, k) if x == NIL or k == x.key return x if k &lt; x.key return TREE-SEARCH(x.left, k) else return TREE-SEARCH(x.right, k)INTERATIVE-TREE-SEARCH(x, k) while x != NIL and k != x.key if k &lt; x.key x = x.left else x = x.right return x 运行时间为$O(h)$，h为树的高度。 最大关键字元素和最小关键字元素根据二叉查找树的特征，很容易查找出最大和最小关键字。查找二叉树中的最小关键字：从根结点开始，沿着各个节点的left指针查找下去，直到遇到NULL时结束。如果一个结点x无左子树，则以x为根的子树中，最小关键字就是key[x]。查找二叉树中的最大关键字：从根结点开始，沿着各个结点的right指针查找下去，直到遇到NULL时结束。 书中给出了查找最大最小关键字的伪代码： 123456789TREE-MINIMUM(x) while x.left != NIL x = x.left return x TREE-MAXIMUM(x) while x.right != NIL x = x.right return x 均能在$O(h)$时间内执行完。 后继与前驱伪码：12345678TREE-SUCCESSOR(x) if x.right != NIL return TREE-MINIMUM(x.right) y = x.p while y != NIL and x == y.right x = y y = y.p return y x.p 指向双亲。 右侧为空，则向上搜索。 在一颗高度为h的二叉搜索树上，动态集合上的操作SEARCH、MINIMUM、MAXIMUM、SUCCESSOR 和PREDECEDOR可以在$O(h)$时间内完成。 插入和删除插入伪码：1234567891011121314TREE-INSERT(T,z) y = NIL x = T.root while x != NIL y = x if z.key &lt; x.key x = x.left else x = x.right z.p = y if y == NIL T.root = z # tree T is empty else if z.key &lt; y.key y.left = z else y.right = z 从树根开始，指针x记录了一条向下的简单路径，直到查找到要替换为输入项z的NIL。NIL占据的位置就是z放置的位置。上述过程保持遍历指针(trailing pointer)y作为x的双亲，找到NIL时需要直到z属于哪个节点。 该过程可以在$O(h)$时间内完成。 删除从二叉查找树中删除给定的结点z，分以下情况讨论： 如果z没有左孩子，那么用右孩子来替换z 如果z有且仅有一个左孩子，那么用其左孩子替换z 否则，z既有左孩子又有右孩子，此时我们查找z 的后继y，这个后继位于z的右子树中并且没有左孩子。则将y移出原来的位置进行拼接，并替换数中的z。 如果y是z的右孩子，那么用y替换z，并且仅留下y的右孩子。 伪码：12345678910111213141516171819202122TRANSPLANT(T,u,v) if u.p == NIL T.root = v else if u == u.p.left u.p.left = v else u.p.right = v if v != NIl v.p = u.p TREE-DELETE(T,z) if z.left == NIL TRANSPLANT(T,z,z.right) else if z.right == NIL TRANSPLANT(T,z,z.left) else y = TREE-MINIMUM(z.right) if y.p != z TRANSPLANT(T,y,y.right) # 删除y y.right = z.right y.right.p = y TRANSPLANT(T,z,y) y.left = z.left y.left.p = y 定理12.3 在一颗高度为h的二叉搜索树上，实现动态集合操作INSERT和DELETE的运行时间均为$O(h)$。 随机构建二叉搜索树二叉查找树各种操作时间均是$O(h)$，构建二叉查找树时，一般只用插入函数，这样便于分析，如果按严格增长顺序插入，那么构造出来的树就是一个高度为n-1的链。另一方面练习B.5-4说明了h≥lgn.这里我特别证明下。 证明：一个有n个结点的非空二叉树的高度至少为lgn。 对于一个高度为h的二叉树总结点数至多为n≤2^h-1(等于的情况就是完全二叉树)，所以给这个不等式适当变型得：h≥lg(n+1)≥lgn,所以对于n个结点的数高度至少为lgn。虽然没有用归纳法，但是这种方法感觉简单易懂。 定理12.4 一棵有n个不同关键字的随机构建二叉搜索树(random built binary search tree)的期望高度为O(lgn)。 参考资料 算法导论 第三版 中文版 算法导论第十二(12)章 二叉查找树 算法导论 第12章 二叉查找树 《算法导论》第12章 二叉查找树 二叉树的递归与非递归实现 对于二叉树三种非递归遍历方式的理解]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摄影 | 152年一遇的月全食]]></title>
    <url>%2F2018%2F02%2F01%2Fphoto_total_lunar_eclipse%2F</url>
    <content type="text"><![CDATA[2018年01月31日晚上（也就是昨天）的月全食据说是152年一遇的月全食。 大概是今天看到了如下这张图片之后，想着自己也可以弄一张类似的照片。 于是便有了封面图的诞生。 这应该是第三次拍摄月亮了。 第一次是一个偶然的白天，晴空万里，一抬头居然发现了月亮。 第二次，是2016年11月14日出现了超级大月亮，当时也拍摄了几张照片，顺便也附带上。 第三次就是昨天晚上的月全食啦。就以封面图结束吧。以后等照片多了，说不定就弄个照片墙～]]></content>
      <categories>
        <category>Photograph</category>
      </categories>
      <tags>
        <tag>Photograph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(9) 第十一章 散列表]]></title>
    <url>%2F2018%2F01%2F30%2Falgorithm_tutorial_chapter_11%2F</url>
    <content type="text"><![CDATA[直接寻址表(direct-address table)缺点：如果全域U很大，分配直接寻址表T也不太现实；另一方面，实际存储的关键字集合K相对于U来说可能很小，导致浪费空间。 散列表综述散列表（hash table，也叫哈希表），支持INSERT、SEARCH、DELETE操作。 散列表可以使得在表小的情况下仍能够保存数据，并且能够在常数时间O(1)内完成查询。为什么是常数时间呢？因为我们不需要比较，不需要遍历查找，只要计算出地址，有待查询的值那么就找到了；没有，那么表中就不存在。 把关键字k映射到槽h(k)上的过程称为散列。h表示散列函数(hash function)，由关键字k计算出槽(slot)的位置。 多个关键字映射到同一个数组下标位置(槽)称为碰撞（或冲突，collision）。 好的散列函数应使每个关键字都等可能地散列到m个槽位中。 链接法解决冲突链接法：把散列到同一个槽的所有元素都放在一个链表中。槽中存放指向该槽的所有元素的链表的表头；如果不存在这样的元素，则槽中为NIL。 链接法散列的分析一个存放n个元素的、具有m个槽位的散列表T，其装载因子(load factor)为：$\alpha = \frac nm$，表示一个链的平均存储元素数。 简单均匀散列(simple uniform hashing)：一个给定元素，等可能地散列到m个槽位中的任意一个上，且与其他元素被散列到什么位置无关。 在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次不成功查找的平均时间为$\Theta(1+\alpha)$，一次成功查找所需的平均时间也为$\Theta(1+\alpha)$ 当散列表的槽数与表中元素个数成正比，则有$n= \text{O}(m)$，查找需要常数时间$\text{O}(1)$。当链表为双向链表时，插入和删除的最坏情况也是$\text{O}(1)$。 Hash函数（11.3，P147）我们如何设计一个好的Hash函数（哈希函数，散列函数）？本节介绍了三种设计哈希函数的方法：除法散列、乘法散列和全域散列。 好的哈希函数的特点这里有两个要点： 一个好的哈希函数应该能够将关键字均匀的分配到哈希表T中； 而关键字的分布率不应该影响这种均匀性。 除法散列法定义hash函数为 $h(k) = k \;\text{mod}\; m$ m取值的原则就是m选为质数且不能太接近2或者10的幂次。 原因：键值的低位可能具有某种分布规律，如果选择2或者10的幂次容易出现冲突。比如$2^r$，关键字只会考虑二进制的低r位；十进制类似。 乘法散列法乘法散列法的公式为：$h(k) = m(kA\; \text{mod}\; 1) $ 其中，$0&lt;A&lt;1$。 一般的实现方法如下：假设计算机字长是w位，限制A是形如$A =\frac {s}{2^w}$的分数，整数s取值范围为$0&lt; s &lt;2^w $。用整数$s=A\cdot 2^w$乘上k，其结果是2w位的值$r_1 2^w + r_0 $ A的取值理想情况为$ A \approx \sqrt 5-1 = 0.6180339887\cdots $。（这不就是黄金分割率么……）根据A的取值计算s的值。 乘法散列法的优点是m的取值不是很关键，一般取为m=2^r。 11.3-4考虑一个大小为m=1000的散列表和一个对应的散列函数h(k)=m(kAmod1),其中A=(√5-1)/2,试计算关键字61,62,63,64和65被映射到位置。 直接根据公式计算，实现代码如下：1234567891011121314151617#include &lt;iostream&gt; #include &lt;math.h&gt; using namespace std; const double A=(sqrt(5)-1)/2.0; int hash(int k,int m) &#123; double x=(A*k-(int)(A*k))*m; return x; &#125; void main() &#123; int k; while (cin&gt;&gt;k) &#123; cout&lt;&lt;"Hash["&lt;&lt;k&lt;&lt;"]="&lt;&lt;hash(k,1000)&lt;&lt;endl; &#125; &#125; 开放寻址法开放寻址法是另一种解决冲突的方法。 开放寻址法的特点：装载因子不会超过1；不用指针就可以计算出槽的序列。 插入元素的过程叫做探查(probe)：连续地检查散列表，直到找到一个空槽来放置待插入的关键字为止。检查顺序依赖于待插入的关键字 开放寻址法的散列函数有第二个参数：探查序号。 插入元素的伪码：12345678910HASH-INSERT(T,k) i = 0 repeat j = h(k, i) if T[j] = NIL T[j] = k return j else i = i + 1 util i == m error &quot;hash table overflow&quot; 查找元素的伪码：（由于是依次插入，因此可以依次查找；有个前提：关键字不会被删除）123456789HASH-SEARCH(T,k) i = 0 repeat j = h(k, i) if T[j] = K return j else i = i + 1 util T[j] == NIl or i == m return NIL 在开放寻址法中，删除操作比较困难，但也有解决办法，在必须删除关键字的应用中，往往采用链接法解决碰撞。 三种探查技术三种探查技术来计算探查序列： 1)线性探查：$$h(k,i)=(h’(k)+i)\text{mod}\; m,\; i=0,1,\cdots,m-1$$线性探查存在问题：一次群集(primary clustering)。 2)二次探查：$$h(k,i)=(h’(k)+c_1i+c_2i^2)\text{mod}\; m, \; i=0,1,\cdots,m-1$$二次探查存在问题：二次群集(secondary clustering)。二次探查与线性探查都是初始位置决定了探查序列，且只有m个探查序列被使用到。 3)双重探查：$$h(k,i)=(h_1(k)+ih_2(k))\text{mod}\; m, \; i=0,1,\cdots,m-1 $$双重探查要求值$h_2(k)$与表的大小m互素。一种简便的方法是：m取2的幂，$h_2(k)$只产生奇数；或者m为素数，h2总是返回比m小的正整数。 由于每一对可能的$ (h_1(k), h_2(k))$都会产生一个不同的探查序列，因此双重散列法用到了$\Theta(m^2) $种探查序列。 双重散列的例子：$$h_1(k) = k \;\text{mod}\; m ,\;h_2(k) = 1+(k\; \text{mod} \;m’) $$取m为素数，$m’ $略小于m（比如，m-1） 开放寻址散列的分析： 定理11.6 给定一个装载因子a=n/m&lt;1的开放寻址散列表，假设散列是均匀的，在一次不成功的查找中，期望的探查数至多为1/(1-a).。 不成功的查找即：最后一次查找为NIL，且前面的Hash table查找都是被占用但是不包含所查的关键字。因此，可以推论插入的期望值，即：插入前需要做一次不成功的查找。 推论11.7 均匀散列，平均情况下，向一个装载因子为a的开放寻址散列表中插入一个元素时，至多需要做1/(1-a)次探查。 查找的过程和插入类似，假设待查找的关键字k的插入位置为i，则，根据推论11.7，有探查的期望次数至多为$1/(1-i/m) = m/(m - i)$。对散列表的所有n个关键字求平均，则得到一次成功查找的探查期望次数：$$\begin{align}\frac 1 n \sum_{i = 0}^{n-1} \frac {m}{m-i}&amp; = \frac mn \sum_{i = 0}^{n-1}\frac {1}{m-i} =\frac 1\alpha \sum_{k = m-n+1}^{n} \frac 1k \leqslant\frac 1 \alpha \int_{m-n}^{m}\frac 1x dx\\&amp; =\frac 1\alpha ln \frac m{m-n} = \frac 1a ln\frac1{1-a}\end{align}$$ 因此得到定理11.8： 定理11.8 给定一个装载因子为a&lt;1的开放寻址散列表，假设散列是均匀的，一次成功查找中的期望探查数至多为(1/a)ln(1/(1-a)). 11.4-1考虑将关键字10,22,31,4,15,28,17,88,59用开放寻址法插入到一个长度为m=11的散列表中，主散列函数为h&#39;(k)=k mod m.说明用线性探查，二次探查(c1=1,c2=3)以及双重散列h2(k)=1+(k mod (m-1))将这些关键字插入散列表的结果。 C++实现代码：Introduction_to_Algorithms/Part_3/Chap_11/hash_table.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;cstring&gt; // for memsetusing namespace std; #define Null -1#define DELETED -2/* * 算法导论习题11.4-1 开放寻址法实现散列表。 * 顺便也实现了搜索与删除。 * * Linux下g++5.4.0编译通过。 * 命令： * $ g++ -o hash_table.out hash_table.cpp -std=c++11 * $ ./hash_table.out */const int m = 11; //槽位数量const int c1 = 1;const int c2 = 3;void Print(int *T)&#123; int i; for(i = 0; i &lt; m; i++) cout &lt;&lt; T[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125;int h(int k) &#123; return k % m;&#125;// 线性探查int linear_probing(int key, int i) &#123; return (key + i) % m;&#125;//二次探查int quadratic_probing(int key, int i) &#123; return (key + c1 * i + c2 * i * i) % m;&#125;//双重散列int double_hashing(int key, int i) &#123; return (key + i * (1 + key % (m - 1))) % m;&#125;using PF = int (*) (int, int); //函数指针PF hash_functions[3] = &#123;linear_probing, quadratic_probing, double_hashing&#125;;// 判断探查的状态：当槽为空或者已到末尾时，为Truebool probe_state(int T[], int j) &#123; return T[j] == Null || T[j] == DELETED || T[j] == 0;&#125;int hash_insert(int T[], int key, PF hash_function) &#123; int k = key; int i = 0; do &#123; int j = hash_function(k, i); //这里通过函数指针，可以在调用时选择线性、二次及双重探查。关于函数指针的简单介绍，可以查看http://wangwlj.com/2018/01/06/CPP_06/ if (probe_state(T, j)) &#123; T[j] = k; return j; &#125; else ++i; &#125; while (i != m); cerr &lt;&lt; "hash table overflow" &lt;&lt; endl;&#125;int hash_search(int T[], int k, PF hash_function) &#123; int i = 0, j = 0; do &#123; j = hash_function(k, i); //这里可以替换成二次，双重探查。插入，查找，删除函数同时被替换 if (T[j] == k) &#123; return j; &#125; else ++i; &#125; while (!probe_state(T, j)); return Null;&#125;void hash_delete(int T[], int k, PF hash_function) &#123; int j = hash_search(T, k, hash_function); //首先先找到该关键字k if (j != Null) &#123; T[j] = DELETED; //如果找到了，那么设置其为空。 cout &lt;&lt; "关键字：" &lt;&lt; k &lt;&lt; " 删除成功！" &lt;&lt; endl; &#125; else cout &lt;&lt; "待删除的数据不在表中！" &lt;&lt; endl; &#125;int main() &#123; int key[9] = &#123;10, 22, 31, 4, 15, 28, 17, 88, 59&#125;; static int T[11]; for (int i = 0; i &lt; 3; ++i) &#123; memset(T, 0, sizeof(T)); // 初始化T为全零 for (int j = 0; j &lt; 9; ++j) &#123; hash_insert(T, key[j], hash_functions[i]); &#125; Print(T); cout &lt;&lt; "搜索关键字：88，返回结果：" &lt;&lt; hash_search(T, 88, hash_functions[i]) &lt;&lt; endl; hash_delete(T, 88, hash_functions[i]); cout &lt;&lt; "删除 88 之后元素为："; Print(T); cout &lt;&lt; endl; &#125; return 0;&#125; 参考资料 算法导论 第三版 中文版 算法导论第十一(11)章散列(Hash)表 算法导论-第11章-散列表 C++ Primer学习笔记：(六)函数]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(8) 第十章 基本数据结构]]></title>
    <url>%2F2018%2F01%2F27%2Falgorithm_tutorial_chapter_10%2F</url>
    <content type="text"><![CDATA[本章介绍几种基本的结构：栈、队列、链表和有根树。 栈和队列（10.1，P129）栈和队列都是动态集合。 栈stack概念定义：栈采用先进后出策略（LIFO）。基本操作是压入（PUSH）和弹出（POP）。如果s.top=0，表示栈空，如果试图对空栈进行POP操作会发生下溢（underflow）。如果s.top&gt;n,表示栈满，如果进行PUSH操作会发生上溢（overflow）。 栈的Python实现代码链接：Introduction_to_Algorihtms/stack_my.py 队列queue概念定义：队列采用先进先出策略（FIFO）。基本操作是入队（enqueue）和出队（dequeue）。如果head=tail，表示队列为空，如果试图对空队列进行enqueue操作会发生下溢（underflow）。如果head=tail+1,表示队列满，如果进行dequeue操作会发生上溢（overflow）。 队列的Python实现：Introduction_to_Algorihtms/queue_my.py 链表（10.2，P131）链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。 双向链表(doubly linked list)的每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个(前一个)结点地址的指针域。 未排序双向链表的Python实现代码：Introduction_to_Algorihtms/list_my.py 指针和对象的实现（10.3，P134）当有些语言不支持指针和对象数据类型时，我们可以用数组和数组下标构造对象和指针。这种链表称为静态链表。 对象的多数组表示用三个数组next key prev 分别表示链表的后继/数据/前驱。多数组表示只能表示同构对象（所有对象有相同的属性）。而单数组表示可以表示异构对象（比如对象具有不同的长度）。 对象的单数组表示用一个数组即可表示双链表，这种表示法比较灵活，因为它允许不同长度的对象存储于同一数组中。一般地我们考虑的数据结构多是由同构的元素构成，因此采用对象的多数组表示法足够满足我们的需求。 对象的分配与释放把自由(free)对象保存在一个单链表中，称为自由表(free list)。 自由表只使用next数组，该数组只存储链表中的next指针。自由表的头存储在全局变量free中。 自由表的实现类似与栈：下一个被分配的对象就是最后被释放的对象（后进先出）。 有根树的表示（10.4，P137）用链式结构表示有根树。 二叉树二叉树T具有三个属性：p，left，right分别存放指向父节点、左孩子节点和右孩子节点的指针。如果x.p=NIL，则x是根节点。属性T.root指向整棵树T的根节点。 更多关于二叉树的内容将在第12章中介绍。本次就暂不实现二叉树。 分支无限制的有根树两种表示方法。一种是将left，right扩展为$child_1,\cdots,child_k$，这种方法的缺点是若k很大，但是多数节点只有少量的孩子，则会浪费大量存储空间。 第二种方法是左孩子右兄弟表示法(left-child,right-sibling representation)。每个节点除了父节点指针p，还有两个指针:x.left-child表示节点x最左边的孩子节点；x.right-sibling表示右侧相邻的兄弟节点。 参考资料1.算法导论 中文 第三版2.算法导论第十章基本数据结构]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(7) 第八章 线性排序算法]]></title>
    <url>%2F2018%2F01%2F27%2Falgorithm_tutorial_chapter_8%2F</url>
    <content type="text"><![CDATA[任何比较排序在最坏情况下都要经过$\Theta(n\text{lg}n)$次比较。 本文介绍三种线性时间排序的算法：计数排序，基数排序以及桶排序。因此，这些都不属于比较排序。 本文所有实现代码均已放在GitHub上，欢迎查看：GitHub链接 本章概述非比较排序指使用一些非比较的操作来确定排序顺序的排序算法，对于非比较排序，下界O(nlgn)不适用。 计数排序是稳定排序，若n个数据的取值范围是[0..k]，则运行时间为O(n+k)，运行空间是O(n+k) 基数排序也是稳定排序，需要另一个稳定排序作为基础，若n个d位数，每一位有k种取值可能，所用的稳定排序运行时间为O(n+k)，则基数排序的时间是O(d(n+k)) 桶排序也是稳定排序，当输入数据符合均匀分布时，桶排序可以以线性时间运行。所设所有元素均匀分布在区间[0,1)上，把区间[0,1)划分成n个相同大小的子区间（桶），对各个桶中的数进行排序，把依次把各桶中的元素列出来。 计数排序（8.2，P108）计数排序(counting sort)是使用输入元素的实际值来确定其在数组中的位置。 计数排序的一个重要特性就是它是稳定的：即对于相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。 计数排序的伪代码：12345678910COUNTING_SORT(A,B,k) for i=0 to k do C[i] = 0 for j=1 to length(A) do C[A[j]] = C[A[j]]+1 //C[i]中包含等于元素i的个数 for i=1 to k do C[i] = C[i] + C[i-1] //C[i]中包含小于等于元素i的个数 for j=length[A] downto 1 do B[C[A[j]]] = A[j] C[A[j]] = C[A[j]] -1 计数排序的Python实现：123456789101112131415161718192021222324252627# Author：wangwlj# 计数排序def counting_sort(A): k = max(A) # k is max of A C = [] for i in range(0, k + 1): C.append(0) for j in range(0, len(A)): C[A[j]] = C[A[j]] + 1 for i in range(1, k + 1): C[i] = C[i] + C[i - 1] B = [] # output for i in range(0, len(A)): B.append(0) for j in range(len(A) - 1, -1, -1): # m = A[j],n = C[m],k = B[n - 1] # for test B[C[A[j]] - 1] = A[j] # B[n] start from 0, so need -1 C[A[j]] = C[A[j]] - 1 return Bif __name__ == "__main__": A = [2, 5, 3, 0, 2, 3, 0, 3] B = counting_sort(A) for i in range(0, len(B)): print(B[i], end=" ") 练习8.2-3在COUNTING_SORT过程中，第四个for循环为什么是for j=length[A] downto 1，而不是for j=1 to length[A]？ 为了保证算法是稳定的。由于是从前往后计数排序，两个数相同的时候，计数值较大的数对应于数组中靠后的元素，所以在输出时需要逆序。 基数排序（8.3，P110）基数排序(radix sort)按有效位从低到高依次排序。 伪代码如下：123RADIX_SORT(A,d） for i=1 to d use a stable sort to sort array A on digit i 基数排序一般采用计数排序作为中间稳定排序。 基数排序的python实现请参阅下面的练习题8.3-4。 练习8.3-1说明RADIX-SORT在如下英文单词上的操作过程：1234 A = &#123;COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX&#125; ==&gt; A = &#123;SEA, TEA, MOB, TAB, DOG, RUG, DIG, BIG, BAR, EAR, TAR, COW, ROW, NOW, BOX, FOX&#125; ==&gt; A = &#123;TAB, BAR, EAR, TAR, SEA, TEA, DIG, BIG, MOB, DOG, COW, ROW, NOW, BOX, FOX, RUB&#125; ==&gt; A = &#123;BAR, BIG, BOX, COW, DIG, DOG, EAR, FOX, MOB, NOW, ROW, TAB, TAR, TEA, SEA, RUB&#125; 练习8.3-4题目：在O(n)时间内对[0..n^3-1]之间的n个整数排序。 思路：把整数转换为n进制再排序，每个数有三位，每位的取值范围是[0..n-1]，再进行基数排序 实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import randomn = 5base_k = 5 # bask could be any number. In test 8.3-4 is 5(equal to n)d = 3 # 8.3-4def stable_sort(A, index): # similar with counting sort, C = [] # C：统计每位数上可能出现的k个数的次数 for i in range(0, base_k + 1): # the number is in range of base_k（k） C.append(0) for j in range(0, len(A)): # 统计当前位上的数出现的次数 num = int(A[j] % pow(base_k, index) / pow(base_k, index - 1)) # the base number # print(A[j], ' 当前位编号：', index, '当前值：', num, ) # for test C[num] = C[num] + 1 # the count of the base number (C - num) for i in range(1, base_k + 1): C[i] = C[i] + C[i - 1] B = [] # output for i in range(0, len(A)): B.append(0) for j in range(len(A) - 1, -1, -1): num = int(A[j] % pow(base_k, index) / pow(base_k, index - 1)) B[C[num] - 1] = A[j] # B[n] start from 0, so need -1 C[num] = C[num] - 1 return Bdef radix_sort(A): for i in range(1, d + 1): A = stable_sort(A, i) # for i in range(0, len(A)): # print(A[i], end=' ') return Aif __name__ == "__main__": # A = [114, 18, 35, 74, 36] A = [] for i in range(0, n): A.append(random.randint(0, pow(n, 3))) for i in range(0, len(A)): print(A[i], end=' ') print('\n') A = radix_sort(A) print('After radix_sort：') for i in range(0, len(A)): print(A[i], end=' ') 桶排序（8.4，P112）桶排序(bucket sort)假设输入数据服从均匀分布，平均情况下它的时间代价为$\text{O}_n$，与计数排序类似，因为对输入数据做了某种假设，桶排序的速度也很快。具体来说，计数排序假设输入数据都属于一个小区间的整数，而桶排序则假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。 参考资料1.算法导论 中文 第三版2.算法导论 第8章 线性时间排序这个包含习题答案，很不错3.算法导论8.3-44.MIT算法导论-第五讲-线性时间排序]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据结构之链表]]></title>
    <url>%2F2018%2F01%2F26%2Fpython_linkedlist%2F</url>
    <content type="text"><![CDATA[主要实现了链表的三个功能：链表的查找、插入与删除。 最近在看《算法导论》，看到第十章——基本数据结构中，提到了链表，于是用Python进行了实现。算法导论中只给出了三个操作：链表的查找、插入与删除。于是，暂时也只实现了这三个。 下面进行简要的介绍： 我们首先定义一个节点的类，用来存储链表中的每个节点。每个节点都有三个属性：节点存储的元素值，指向上一个节点的指针以及指向下一个节点的指针。12345678class Node: # 链表的每个节点 def __init__(self, value=None, _prev=None, _next=None): self.value = value self.prev = _prev self.next = _next def __str__(self): # 在print时默认返回value return str(self.value) 其中，__str__函数使得在print一个Node对象的时候打印其value值。 接着我们定义链表类List。Python中list是一个关键字，表示序列，故避免重复，也可以把链表叫做LinkedList。123class List: def __init__(self): self.head = None # init as a empty list 上述初始化函数中的self.head = None将链表初始化为空链表。 接着分别实现搜索、插入和删除三个功能。可以对照着书中的伪码1234567891011121314151617181920212223def search(self, key): x = self.head while x.next is not None and x.value != key: x = x.next return xdef insert(self, x): # 插入节点x作为新的头节点 x.next = self.head if self.head is not None: self.head.prev = x self.head = x x.prev = Nonedef delete(self, x): # x is in list and known (can use search to find) if x.prev is not None: x.prev.next = x.next else: self.head = x.next if x.next is not None: x.next.prev = x.prev 下面的这个show_value函数是为了依次打印链表的元素，不是必须的，可以跳过。__str__与Node中的类似，实现了可以直接打印一个List的对象。12345678910111213def show_value(self): # 依次打印链表的值 x = self.head print("The List Value is:", end=' ') while x is not None: print(x.value, end=' ') x = x.next print() return 'show_value'def __str__(self): # 支持直接print一个List的对象 return self.show_value() + " in List" 最后是主函数，对上述实现进行简单的测试。123456789101112131415161718192021if __name__ == "__main__": l = List() l.insert(Node(5)) l.insert(Node(4)) l.insert(Node(3)) n = l.search(5) print("search value: ", n.value, n.prev, n.next, "\nhead: ", l.head.value, l.head.prev, l.head.next) l.delete(n) print("head: ", l.head.value, l.head.prev, l.head.next) l.insert(Node(6)) # always insert as head. l.insert(Node(7)) l.insert(Node(8)) l.show_value() n = l.search(7) print("search value:", n, n.prev, n.next, "\nhead:", l.head, l.head.prev, l.head.next) l.delete(l.search(6)) print(l) 完整的代码放在Github上了，仅供参考。链接为：Introduction_to_Algorihtms/list_my.py]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(十)泛型算法]]></title>
    <url>%2F2018%2F01%2F20%2FCPP_10%2F</url>
    <content type="text"><![CDATA[标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多数都独立于任何特定的容器。这些算法是通用的(generic，或称泛型的)：可以用于不同类型的容器或者元素。算法通过在迭代器上进行操作来实现类型无关。 算法不直接改变所操作序列的大小。它们会将一个元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。虽然算法不能向序列添加元素，但是插入迭代器可以做到。 概述（10.1，P336）顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或者尾元素之后位置的迭代器。 标准库定义了大约100个类型无关的对序列进行操作的算法。序列可以是标准库类型中的元素、一个内置数组或者是（例如）通过读写一个流来生成的。 大多数算法都定义在头文件algorithm中。标准库还在文件numeric中定义了一组数值泛型算法。 初识泛型算法（10.2，P338）accumulate：定义在头文件numeric中。作用是对范围求和。 euqal：定义在头文件algorithm中。作用是判断给定两个区间是否相等。假定第二个序列至少与第一个序列一样长。 fill：定义在头文件algorithm中。作用是对给定区间全部赋予某值。 fill_n：定义在头文件algorithm中。作用是对给定迭代器后的n个元素赋予某值。 back_inserter：定义在头文件iterator中。得到指向容器尾部的迭代器。 重排容器元素的算法1234vector&lt;string&gt; words = &#123;"the", "quick", "red", "fox","red", "the","slow"&#125;;sort(words.begin(),words.end());auto end_unique = unique(words.begin(),words.end());words.erase(end_unique,words.end()); 消除重复单词的程序：使用到了下面这三个算法： sort：定义在头文件algorithm中。对指定区间排序； unique：定义在头文件algorithm中。“消除”重复项，返回指向不重复值范围末尾的迭代器； erase：容器操作，而不是算法。删除指定范围内的元素。 定制操作（10.3）向算法传递函数（10.3.1）谓词(predicate)是一个可调用的表达式，其返回结果是一个能用作条件的值。谓词分为：一元谓词和二元谓词。几元谓词接受几元参数。 使用谓词的排序版本：1234567891011121314vector&lt;string&gt; words = &#123;"the", "quick", "red", "fox","red", "the","slow"&#125;;cout &lt;&lt; "Before: ";for(auto iter = words.begin();iter != words.end(); ++iter)&#123; cout &lt;&lt; *iter &lt;&lt; " "; &#125;cout &lt;&lt; endl;sort(words.begin(),words.end(), isShorter); //使用谓词进行排序cout &lt;&lt; "After sort: "; for(const auto &amp;s: words)&#123; cout &lt;&lt; s &lt;&lt; " "; &#125;cout &lt;&lt; endl; 结果为：12Before: the quick red fox red the slow After sort: the red fox red the slow quick 可以看到三个字母的都在最前面，接着是长度为4,然后是长度为5的。 有时候我们希望长度相同的元素按照字典进行排序，此时可用stable_sort算法。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool isShorter(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125;void elimDups(vector&lt;string&gt; &amp;words)&#123; //按字典顺序排序 sort(words.begin(),words.end()); auto end_unique = unique(words.begin(),words.end()); words.erase(end_unique,words.end());&#125;int main()&#123; vector&lt;string&gt; words = &#123;"the", "quick", "red", "fox","red", "the","slow", "seen"&#125;; elimDups(words); stable_sort(words.begin(), words.end(), isShorter); cout &lt;&lt; "After stable_sort: "; for(const auto &amp;s: words)&#123; cout &lt;&lt; s &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 输出为： After sort: fox red the seen slow quick lambda表达式(10.3.2，P345)可调用对象：对于一个对象或一个表达式，如果可以对其使用调用运算符，则称为可调用的；可调用的对象有：函数、函数指针、重载函数调用运算符的类和lambda表达式。 lambda表达式形式：1[capture list](parameter list)-&gt;return type&#123;function body&#125;; capture list是一个lambda所在函数中定义的局部变量的列表（通常为空）；return type、parameter list和function body分别表示返回类型、参数列表和函数体。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool isShorter(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt; s2.size();&#125;void elimDups(vector&lt;string&gt; &amp;words)&#123; //按字典顺序排序 sort(words.begin(),words.end()); auto end_unique = unique(words.begin(),words.end()); words.erase(end_unique,words.end());&#125;void biggies(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz)&#123; // 将words按字典序排序，删除重复单词 elimDups(words); // 按长度排序，长度相同的单词维持字典序 stable_sort(words.begin(), words.end(), isShorter); // 获取一个迭代器，指向第一个满足size()&gt;=sz的元素 auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a)&#123; return a.size() &gt;= sz; &#125;); // 计算满足size&gt;=sz元素的数目 auto count = words.end() - wc; cout &lt;&lt; count &lt;&lt; " " &lt;&lt; ( (count&gt;1) ? "word" : "words" ) &lt;&lt; " of length " &lt;&lt; sz &lt;&lt; " or longer" &lt;&lt; endl; //打印长度大于等于给定值的单词，每个单词后面接一个空格 for_each(wc,words.end(),[](const string &amp;a)&#123; cout &lt;&lt; a &lt;&lt; " "; &#125;); cout &lt;&lt; endl;&#125;int main()&#123; vector&lt;string&gt; words = &#123;"the", "quick", "red", "fox","red", "the","slow", "seen"&#125;; biggies(words,4); return 0;&#125; lambda捕获与返回（10.3.3，P349）捕获方式分为显式捕获、隐式捕获与混合使用。 显式捕获分为值捕获与引用捕获。值捕获：与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是在调用时拷贝。 隐式捕获：在捕获列表写一个&amp;（引用捕获）或者=（值捕获）。 混合使用隐式捕获和显式捕获：捕获列表第一个元素必须是一个&amp;或=，并且显式捕获的变量必须采用与隐式捕获不同的方式。 参数绑定（10.3.4，P354）标准库bind函数：定义在头文件：functional；它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。 调用bind的形式： auto newCallable=bind(callable, arg_list); newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。arg_list中的参数可能包含形如_n的名字，_1是newCallable的第一个参数,_2为第二个参数，依次类推。 _n参数在命名空间placeholders中，需要如下声明：1using namespace std::placeholders; bind拷贝参数而不能拷贝ostream。我们可以使用ref函数。 函数ref返回一个对象，包含给定引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。 再探迭代器（10.4）标准库在头文件iterator中定义了几种迭代器： 插入迭代器：这些迭代器被绑定到一个容器上，可用来向容器插入元素。 流迭代器：这些迭代器被绑定到输入或输出流上，可用来遍历所有关联的IO流。 反向迭代器：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。 移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们。 插入迭代器（10.4.1，P358） 插入器的三种类型 back_inserter 创建一个使用push_back的迭代器 front_inserter 创建一个使用push_front的迭代器 inserter 创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将插入到给定迭代器所表示的元素之前。 练习10.28：分别使用上述三种插入迭代器将vector的内容拷贝到容器中。12345678910vector&lt;int&gt; v;for (int i= 1; i&lt;=9; ++i)&#123; v.push_back(i);&#125;deque&lt;int&gt; di, dbi, dfi;copy(v.begin(), v.end(), inserter(di, di.begin())); // 接收两个参数copy(v.begin(), v.end(), back_inserter(dbi));copy(v.begin(), v.end(), front_inserter(dfi)); 三个插入器的最终结果为：123inserter:1 2 3 4 5 6 7 8 9 back_inserter:1 2 3 4 5 6 7 8 9 front_inserter:9 8 7 6 5 4 3 2 1 iostream迭代器istream_iterator操作 istream_iterator操作 含义 istream_iterator&lt;T&gt; in(is) in从输入流is读取类型为T的值 istream_iterator&lt;T&gt; end; 读取类型为T的值的istream_iterator迭代器，表示尾后位置 （默认初始化） in1 == in2 in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同 in1 != in2 的输入，则两者相等 *in 返回从流中读取的值 in-&gt;mem 与(*in).mem的含义相同 ++in,in++ 使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值 计算从标准输入的值的和：12istream_iterator&lt;int&gt; in_iter(cin), eof;cout &lt;&lt; "sum is: " &lt;&lt; accumulate(in_iter, eof, 0) &lt;&lt; endl; ostream_iterator操作 ostream_iterator操作 含义 ostream_iterator&lt;T&gt; out(os); out将类型为T的值写到输出流os中 ostream_iterator&lt;T&gt; out(os,d); out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组 out = val; 用&lt;&lt;运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容。 *out,++out,out++; 这些运算符是存在的，但不对out做任何事情。每个运算符都返回out 使用流迭代器输出vector的内容：123vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;;ostream_iterator&lt;int&gt; out_iter(cout, " ");copy(v.begin(),v.end(),out_iter); 反向迭代器（10.4.3，P363）sort函数正向与逆序排序：1234567891011121314151617vector&lt;int&gt; v&#123;3,5,1,7,4,6,2,9,8&#125;;sort(v.begin(),v.end());cout &lt;&lt; "After sort: ";for(auto i = v.begin(); i != v.end(); ++i)&#123; cout &lt;&lt; *i &lt;&lt; " " ;&#125;cout &lt;&lt; endl;sort(v.rbegin(),v.rend());cout &lt;&lt; "After reverse sort: ";for(auto i = v.begin(); i != v.end(); ++i)&#123; cout &lt;&lt; *i &lt;&lt; " " ;&#125;cout &lt;&lt; endl; 输出结果为：12After sort: 1 2 3 4 5 6 7 8 9 After reverse sort: 9 8 7 6 5 4 3 2 1 使用反向迭代器逆序打印一个vector(练习10.34)：1234567vector&lt;int&gt; v&#123;3,5,1,7,4,6,2,9,8&#125;;cout &lt;&lt;"逆序打印：";for(auto i = v.crbegin(); i != v.crend(); ++i)&#123; cout &lt;&lt; *i &lt;&lt; " " ;&#125;cout &lt;&lt; endl; 输出结果为： 逆序打印：8 9 2 6 4 7 1 5 3 使用find在一个int的list中查找最后一个值为0的元素（练习10.36）：12345678910111213141516171819list&lt;int&gt; v&#123;3,5,1,0,7,4,0,6,2,9,8&#125;;auto it = find(v.cbegin(),v.cend(),0);auto itr = find(v.crbegin(),v.crend(),0);cout &lt;&lt; "迭代器的指向位置： " &lt;&lt; *it &lt;&lt; *itr &lt;&lt;*(itr.base()) &lt;&lt; endl; cout &lt;&lt; "After find: " ;for(auto i = it; i != v.cend(); ++i)&#123; cout &lt;&lt; *i &lt;&lt; " " ;&#125;cout &lt;&lt; endl;cout &lt;&lt; "After reverse find: " ;for(auto i = itr.base(); i != v.cend(); ++i)&#123; cout &lt;&lt; *i &lt;&lt; " " ;&#125;cout &lt;&lt; endl; 输出为：123迭代器的指向位置： 006After find: 0 7 4 0 6 2 9 8 After reverse find: 6 2 9 8 泛型算法结构（10.5）迭代器类别 迭代器类别 输入迭代器 只读，不写；单遍扫描，只能递增 输出迭代器 只写，不读；单遍扫描，只能递增 前向迭代器 可读写，多遍扫描，只能递增 双向迭代器 可读写，多遍扫描，可递增递减 随机访问迭代器 可读写，多遍扫描，支持全部迭代器运算 算法形参模式4种算法形参模式：1234alg(beg,end,other args);alg(beg,end,dest,other args);alg(beg,end,beg2,other args);alg(beg,end,beg2,end2,other args); 其中，alg是算法的名字，beg和end是算法所操作的输入范围。dest、beg2和end2，都是迭代器参数。dest参数表示算法可以写入的目的位置的迭代器，算法假定：不管写入多少个元素都是安全的。 算法命名规范一些算法使用重载参数形式传递一个谓词。 _if版本的算法：接受一个元素值的算法通常有一个接受谓词版本的算法，加上后缀_if 区分拷贝元素的版本和不拷贝元素的版本：重排元素的算法通常直接写回给定的输入序列，也可以将元素写到一个指定的输出目的的位置，此类算法在名字后面加上_copy 特定容器算法（10.6）list和forward_list成员函数版本的算法 list和forward_list成员函数版本的算法 含义 lst.merga(lst2) lst.megra(lst2,comp) 将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。在合并之后，lst2变成空。第一个版本使用&lt;运算符；第二个版本使用给定的比较操作。 lst.remove(val) lst.remove_if(pred) 调用erase删除掉与给定值相等(==)或令一元谓词为真的每个元素 lst.reverse() 反转lst中元素的顺序 lst.sort() lst.sort(comp) 使用&lt;或给定比较操作排序元素 lst.unique() lst.unique(pred) 调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定的二元谓词 list和forward_list的splice成员函数的参数 lst.splice(args)或flst.splice_after(args) 含义 (p,lst2) p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或flst相同，且不能是同一个链表。 (p,lst2,p2) p2是一个指向lst2中位置的有效迭代器。将p2指向的元素移动到lst中，或将p2之后的元素移动到flst中。lst2可以是与lst或flst相同的链表。 (p,lst2,b,e) b和e必须表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或flst。lst2与lst(或flst)可以是相同的链表，但p不能指向给定范围中元素。 术语表泛型算法：generic algorithm谓词：predicate一元谓词：unary predicate二元谓词：binary predicate 参考资料 C++ Primer 中文第五版 C++primer第五版第十章学习笔记 《C++primer(第五版)》学习之路-第十章：泛型算法]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(九)顺序容器]]></title>
    <url>%2F2018%2F01%2F18%2FCPP_09%2F</url>
    <content type="text"><![CDATA[本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。 元素在顺序容器中的位置与其加入容器时的位置相对应。 标准库还定义了几种关联容器（第11章），关联容器中元素的位置由元素相关联的关键字决定。 顺序容器有：vector、deque、list、forward_list、array与string。容器适配器有：stack、queue与priority_queue。 顺序容器概述（9.1，P292） 顺序容器类型 含义 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快 list 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快 forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 array 固定大小数组。支持快速随机访问。不能添加或删除元素。 string 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。 以下是一些选择容器的基本原则： ⑴.除非你有很好的理由选择其他容器，否则应使用vector ⑵.如果你的程序有很多小的元素，且额外开销很重要，则不要使用list或forward_list ⑶.如果程序要求随机访问元素，应使用vector或deque ⑷.如果程序需要在中间位置插入或删除元素，应使用list或forward_list ⑸.如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque ⑹.如果程序只有在读取输入时才需要再容器中间位置插入元素，随后需要随机访问元素，则 –首先，确定是否真的需要再容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。 –如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。 容器库概览（9.2，P294）本节介绍对所有容器都适用的操作。 容器操作表 类型别名 iterator 此容器类型的迭代器类型 const_iterator 可以读取元素，但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能容器的大小 different_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型；与value_type含义相同 const_reference 元素的const左值类型 构造函数 C c; 默认构造函数，构造空容器 C c1(c2); 构造c2的拷贝c1 C c(b,e); 构造c，将迭代器b和e指定范围内的元素拷贝到c(array不支持) C c{a,b,c…}; 列表初始化c 赋值与swap c1 = c2 将c1中的元素替换为c2中元素 c1 = {a,b,c..} 将c1中的元素替换为列表中的元素 a.swap(b) 交换a和b的元素 swap(a,b) 与a.swap(b)等价 大小 c.size() c中元素的数目（不支持forward_list） c.max_size() c可保存的的最大元素数目 c.empty() 若c中存储了元素，返回false，否则返回true 添加/删除元素（不适用于array） 注：在不同容器中，这些操作的接口都不同 c.insert(args) 将args中的元素拷贝进c c.emplace(inits) 使用inits构造c中的一个元素 c.erase(args) 删除args指定的元素 c.clear() 删除c中的所有元素，返回void 关系运算符 ==,!= 所有容器都支持相等（不等）操作 &lt;,&lt;=,&gt;,&gt;= 关系运算符(无序关联容器不支持) 获取迭代器 c.begin(),c.end() 返回指向c的首元素和尾元素之后位置的迭代器 c.cbegin(),c.cend() 返回const_iterator 反向容器的额外成员 reverse_iterator 按逆序寻址元素的迭代器 const_reverse_iterator 不能修改元素的逆序迭代器 c.rbegin(),c.rend() 返回指向c的尾元素和首元素之前位置的迭代器 c.crbegin(),c.crend() 返回const_reverse_iterator 迭代器迭代器范围(iterator range)：[begin,end)，左闭合区间(left-inclusive interval) 迭代器的运算符（表3.6，P96） 迭代器的运算符 含义 *iter 返回迭代器所指元素的引用 iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem ++iter 令iter指示容器中的下一个元素 ++iter 令iter指示容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等（指向同一个位置则相等，包括尾后） iter1 != iter2 判断两个迭代器是否不相等（指向同一个位置则相等，包括尾后） 1234while(begin != end)&#123; *begin = val; ++begin;&#125; 如果begin与end相等，则范围为空；如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素；我们可以对begin递增若干次，使得begin==end。 容器类型成员容器定义和初始化(9.2.4，P299) 容器定义和初始化 C c 默认构造函数。如果C是一个array，则c中元素按默认方式初始化，否则c为空 C c1(c2) 与 C c1 = c2 c1初始化为c2的拷贝。c1和c2必须是相同类型。 C c{a,b,c...}与C c = {a,b,c..} c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素数目必须等于或少于array的大小，任何遗漏的元素都进行值初始化。 C c(b,e) c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容（对array不适用） C seq(n) seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的 C seq(n,t) seq包含n个初始化为值t的元素 $\color{red}{\heartsuit}$ 只有顺序容器（不包括array）的构造函数才能接受大小参数。关联容器并不支持。【上表中的倒数两个】 $\color{red}{\heartsuit}$ 当一个容器初始化为另一个容器的拷贝时，两个容器的容器类型必须相同。 标准库array的大小也是类型的一部分。定义一个array时，除了指定元素类型，还需要指定容器大小。12array&lt;int,42&gt;array&lt;string,10&gt;::size_type i; 赋值与swap(9.2.5，P302)赋值、交换以及assign： 容器赋值运算 c1 = c2 将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型 c = {a,b,c..} 将c1中元素替换为初始化列表中元素的拷贝 swap(c1,c2)与c1.swap(c2)等价 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多。 assign操作不适用于关联容器和array seq.assign(b,e) 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 seq.assign(il) 将seq中的元素替换为初始化列表il中的元素 seq.assign(n,t) 将seq中的元素替换为n个值为t的元素 $\color{red}{\heartsuit}$ 使用assign：允许我们使用不同但相容的类型赋值。 除了array外，swap不对任何元素进行拷贝、删除或者插入操作，因此可以保证常数时间内完成。与其它容器不同，swap两个array会真正交换它们的元素。指针和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应的元素的值进行了交换。 除了string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。特殊的，对一个string 调用swap会导致迭代器和指针失效。 forward_list支持max_size和empty，但不支持size。其它每个容器都有三个有关大小的操作。 顺序容器操作(9.3，P305)向顺序容器中添加元素 向顺序容器添加元素的操作 含义 c.push_back(t) 在c的尾部创建一个值为t或由args创建的元素，返回void c.emplace_back(args) c.push_front(t) 在c的头部创建一个值为t或由args创建的元素。返回void c.emplace_front(args) c.insert(p,t) 在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加元素的迭 c.emplace(p,args) 代器。 c.insert(p,n,t) 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p c.insert(p,b,e) 将迭代器b和e指定的范围内的元素插入迭代器p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回p c.insert(p,il) il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p 添加元素操作 描述 vector list forward_list array deque push_back/emplace_back 尾部添加元素 ok ok 不支持 不支持 ok push_front/emplace_front 首部添加元素 不支持 ok OK 不支持 ok insert(p, t)/insert(p, n, t)/insert(p, b, e)/insert(p, {…}) 在指定p位置之前插入元素 ok ok 有自己专用版本 不支持 ok emplace 插入元素 ok ok 有自己专用版本 不支持 ok 添加元素会改变容器的大小，array不支持这些操作。forward_list有自己专有版本的insert和emplace。forward_list不支持push_back和emplace_back。 vector和string不支持push_front和emplace_front。将元素insert插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。 emplace函数直接在容器中构造函数，传递给emplace函数的参数必须与元素类型相匹配。 访问元素(9.3.2，P309) 访问元素的操作 含义 c.back() 返回c中尾元素的引用。若c为空，函数行为未定义 c.front() 返回c中首元素的引用。若c为空，函数行为未定义 c[n] 返回c中下标为n的元素的引用，n是一个无符号的整数。若n&gt;=c.size()，则函数行为未定义。 c.at(n) 返回下标为n的元素的引用。如果下标越界，则抛出一out_of_range异常。 at和下标操作只适用于string,vector,deque和array。back不适用于forward_list。123456789if(!c.empty())&#123; c.front() = 42; auto &amp;v = c.back(); // 获得指向最后一个元素的引用 v = 1024; auto v2 = c.back(); // v2不是引用，只是c.back()的一个拷贝 v2 = 0; // 没有改变c中的元素 cout &lt;&lt; "v: "&lt;&lt; v &lt;&lt;" v2: " &lt;&lt; v2 &lt;&lt; endl;&#125; 如果希望下标是合法的，可以使用at函数；如果下标越界，则抛出一个out_of_range异常。 删除元素（9.3.3，P311）这些操作会改变容器大小，所以不适用于array；forward_list有特殊版本的erase；forward_list不支持pop_back；vector和string不支持pop_front。 删除元素操作 含义 c.pop_back() 删除c中尾元素。若c为空，则函数行为未定义。函数返回void c.pop_front() 删除c中首元素。若c为空，则函数行为未定义。函数返回void c.erase(p) 删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后(off_the_end)迭代器。若p是尾后迭代器，则函数行为未定义。 c.erase(b,e) 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器 c.clear() 删除c中所有元素。返回void 删除一个list中的所有奇数：12345678910#include&lt;list&gt;list&lt;int&gt; lst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;auto it = lst.begin();while(it != lst.end())&#123; if(*it % 2) // 如果是奇数 it = lst.erase(it); //删除此元素，返回下一个元素 else ++it; // 递增&#125; 特殊的forward_list操作 在forward_list中插入或删除元素的操作 含义 lst.before_begin() 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。 lst.cbefore_begin() cbefore_begin()返回一个const_iterator lst.insert_after(p,t) 在迭代器p之后的位置插入元素，t是一个对象 lst.insert_after(p,n,t) t是一个对象，n是数量 lst.insert_after(p,b,e) b和e是表示范围的一对迭代器(b和e不能指向lst内) lst.insert_after(p,il) il是一个花括号列表。 insert_after小结 返回一个指向最后一个插入的元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义 emplace_after(p,args) 使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义。 lst.earse_after(p) 删除p指向的位置之后的元素，或删除从b之后直到(但不包含)e之间的元素。返回一个 lst.earse_after(b,e) 指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义。 删除一个forward_list中的所有奇数：12345678910forward_list&lt;int&gt; flst = &#123;0,1,2,3,4,5,6,7,8,9&#125;;auto curr = flst.begin();auto prev = flst.before_begin();while(curr != flst.end())&#123; if(*curr % 2) curr = flst.erase_after(prev); else prev = curr++; //或者 prev=curr; curr++; //或者 prev++;curr++; &#125; 改变容器大小（9.3.5，P314） 顺序容器大小操作 含义 c.resize(n) 调整c的大小为n个元素。若n&lt;c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 c.resize(n,t) 调整c的大小为n个元素。任何新添加的元素都初始化为值t。 resize不适用于array。resize用来增大或者缩小容器。 容器操作可能使迭代器失效向容器添加元素之后： ⑴.如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未被重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。 ⑵.对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。 ⑶.对于list和forward_list，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。 当我们删除一个元素后： ⑴.对于list和forward_list，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。 ⑵.对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。 ⑶.对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍然有效。 注：当我们删除元素时，尾后迭代器总是会失效。 $\color{red}{\heartsuit}$ 由于向迭代器添加元素和从迭代器删除元素的代码可能会使得迭代器失效，因此必须保证每次改变容器的操作之后都能正确地重新定位迭代器。 $\color{red}{\heartsuit}$ 添加或删除元素的循环过程必须反复调用end，而不能在循环之前保存end返回的迭代器。 vector是如何增长的（9.4，P317）1.容器大小管理操作 shrink_to_fit只使用于vector、string和deque；capacity和reserve只适用于vector和string 容器大小管理操作 含义 c.shrink_to_fit() 请将capacity()减少为与size()相同大小 c.capacity() 不重新分配内存空间的话，c可以保存多少元素 c.reserve(n) 分配至少能容纳n个元素的内存空间 2.当添加的数超出了vector原本分配的最大容量，vector的实现采用的策略是在每次需要分配新内存空间时将当前容量翻倍。 程序测试： 12345vector&lt;int&gt; vec; for(auto i = 0; i &lt;= 33; ++i)&#123; cout &lt;&lt; "size: "&lt;&lt; vec.size() &lt;&lt;"capacity: "&lt;&lt; vec.capacity() &lt;&lt; endl; vec.push_back(i); &#125; 额外的string操作（9.5，P320）构造string的其他方法 构造string的其他方法 含义 string s(cp,n) s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符。 string s(s2,pos2) s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义 string s(s2,pos2,len2) s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符。 子字符串操作s.substr(pos,n)：返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size()-pos，即拷贝从pos开始的所有字符。 改变string的其他方法 修改string的操作 含义 s.insert(pos,args) 在pos之前插入args指定的字符。pos可以是一个下标或一个迭代器。接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。 s.earse(pos,len) 删除从位置pos开始的len个字符。如果len被省略，则删除从pos开始直至s末尾的所有字符。返回一个指向s的引用。 s.assign(args) 将s中的字符替换为args指定的字符。返回一个指向s的引用 s.append(args) 将args追加到s。返回一个指向s的引用 s.replace(range,args) 删除s中范围range内的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用 string搜索操作（9.5.3，P325）string类提供了6个不同的搜索函数，每个函数都有4个重载版本。 每个搜索操作都会返回一个string::size_type值，表示匹配发生位置的下标。 如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义成一个const string::size_type类型，并初始化为-1。 string搜索函数返回string::size_type值，该类型时一个unsigned类型，因此我们应该尽量不要使用带符号类型来保存这些返回值。 string搜索操作 含义 s.find(args) 查找s中args第一次出现的位置 s.rfind(args) 查找s中args最后一次出现的位置 s.find_first_of(args) 在s中查找args中任何一个字符第一次出现的位置 s.find_last_of(args) 在s中查找args中任何一个字符最后第一次出现的位置 s.find_first_not_of(args) 在s中查找第一个不在args中的字符 s.find_last_not_of(args) 在s中查找最后一个不在args中的字符 args的形式 含义 c,pos 从s中位置pos开始查找字符c。pos默认为0 s2,pos 从s中位置pos开始查找字符串s2。pos默认为0 cp,pos 从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认为0 cp,pos,n 从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值 字符串比较函数(9.5.4，P327) s.compare(args)中args形式 含义 s2 比较s和s2 pos1,n1,s2 将s中从pos1开始的n1个字符与s2比较 pos1,n1,s2,pos2,n2 将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较 cp 比较s与cp指向的以空字符结尾的字符数组 pos1,n1,cp 将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较 pos1,n1,cp,n2 将s中从pos1开始的n1个字符与cp指向的地址开始的n2个字符进行比较 string和数值之间的转换(9.5.5，P327)string参数中第一个非空白符必须是符号(+或-)或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小数点开头，并可有包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，string参数可以包含字母字符，对应大于数字9的数 如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常。如果转换得到的数值无法用任何类型表示，则抛出一个out_of_range异常 string和数值之间的转换 含义 to_string(val) 一组重载函数，返回数值val的string表示。val可以是任何算术类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string。与往常一样，小整型会被提升。 stoi(s,p,b) 返回s的起始子串(表示整数内容)的数值，返回值类型分别是int,long,unsigned long,long long, stol(s,p,b) unsigned long long。b表示转换所用的基数，默认值是10。p是size_t指针，用来保存s中第一个 stoul(s,p,b) 非数值字符下标，p默认为0，即函数不保存下标。 stoll(s,p,b) stoull(s,p,b) stof(s,p) 返回s的起始子串(表示浮点数内容)的数值，返回值类型分别是float,double或long double。参数 stod(s,p) p的作用于整数转换函数中一样 stold(s,p) 容器适配器（9.6，P329）标准库定义了三个顺序容器适配器：stack、queue和priority_queue。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list）。 所有容器适配器都支持的操作和类型： 容器适配器都支持的操作和类型 含义 size_type 一种类型，足以保存当前类型的最大对象的大小 value_type 元素类型 container_type 实现适配器的底层容器类型 A a; 创建一个名为a的空适配器 A a(c); 创建一个名为a的适配器，带有容器c的一个拷贝 关系运算符 每个适配器都支持所有关系运算符:==,!=,&lt;,&lt;=,&gt;,&gt;=，这些运算符返回底层容器的比较结果 a.empty() 若a包含任何元素，返回false，否则返回true a.size() 返回a中元素数目 swap(a,b) 交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同 a.swap(b) 栈适配器的其他操作 栈适配器的其他操作 含义 s.pop() 删除栈顶元素，但不返回该元素值 s.push(item) 创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造 s.emplace(args) s.top() 返回栈顶元素，但不将元素弹出栈 queue和priority_queue的其他操作 queue和priority_queue的其他操作 含义 q.pop() 返回queue的首元素或priority_queue的最高优先级元素，但不删除此元素 q.front() 返回首元素，但不删除此元素 q.back() 返回尾元素，但不删除此元素，只适用于queue q.top() 返回优先级最高的元素，但不删除此元素，只适用于priority_queue q.push(item) 在queue末尾或priority_queue中恰当的位置创建一个元素，其值为item，或者有args构造 q.emplace(args) 术语表适配器：adaptor容器：container迭代器范围：iterator range首前迭代器： off-the-beginning iterator尾后迭代器： off-the-end iterator顺序容器： sequential container左闭合区间： left-inclusive interval 参考资料 C++ Primer 中文第五版 C++primer第五版第九章学习笔记 《C++primer(第五版)》学习之路-第九章：顺序容器]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(八)IO类]]></title>
    <url>%2F2018%2F01%2F17%2FCPP_08%2F</url>
    <content type="text"><![CDATA[C++使用标准库类来处理面向流的输入和输出： iostream处理控制台IO fstream处理命名文件IO stringstream完成内存string的IO 类fstream和stringstream都继承自iostream。 IO类头文件iostream包含所有i/o流所需的基本信息，并定义有四个标准i/o流对象： cin：标准输入流对象（与标准输入设备连接） cout ：标准输出流（与标准输出设备连接） cerr ：非缓冲的标准错误流（默认设备为显示器） clog ：经缓冲的标准错误流（默认设备为打印机） IO对象没有拷贝或者赋值。 条件状态(P8.1.1，P279)IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态(condition state)。 条件状态 含义 strm::iostate 由各个iostream类定义，用于定义条件状态 strm::badbit strm::iostate类型的值，用于指出被破坏的流 strm::failbit strm::iostate类型的值，用于指出失败的IO操作 strm::eofbit strm::iostate类型的值，用于指出流已经到达文件的结束符 s.eof() 如果设置了流s的eofbit值，该函数返回true s.bad() 如果设置了流s的badbit值，该函数返回true s.fail() 如果设置了流s的failbit值，该函数返回true s.good() 如果流s处于有效状态，该函数返回true s.clear() 清空流s的所有状态，并设为true s.clear(flag) 给流s的某个条件状态位设置为true。flag，类型是strm::iostate s.setstate(flag) 给流s的添加指定条件。flag，类型是strm::iostate s.rdstate() 返回流s的当前条件，返回值类型是strm::iostate 刷新输出缓冲区endl 操纵符，用于输出一个换行符并刷新缓冲区。flush操纵符，用于刷新流，但不在输出中添加任何字符。ends操作符，这个操纵符在缓冲区中插入空字符null，然后刷新它。 如果程序崩溃（异常终止），输出缓冲区不会刷新。 文件输入输出(8.2，P283)12345ifstream in(ifile); //构建一个ifstream并打开给定文件ofstream out; //输出文件流，没有与任何文件关联out.open(iflie +".copy"); //打开指定的文件if(out) //检查open是否成功 文件模式(8.2.2，P286)文件模式有：in, out, app（append的缩写，追加模式，写操作前定位到文件末尾）, ate, trunk（截断文件）, binary。 保留ofstream打开的文件中已有数据的唯一方法：显式地指定app或in模式。 string流(8.3，P287)标准库定义了三种类型的字符串流：istringstream，由istream派生而来，提供读string的功能。ostringstream，由ostream派生而来，提供写string的功能。stringstream，由iostream派生而来，提供读写string的功能。 stringstream 特定的操作： stringstream 特有的操作 含义 sstream strm; strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型 sstream strm(s); strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explict的。 strm.str() 返回strm所保存的string的拷贝 strm.str(s) 将string s拷贝到strm中。返回void 术语表继承： inheritance条件状态： condition state文件模式： file mode文件流： file stream字符串流： string stream 参考资料 C++ Primer 中文第五版 C++primer第五版第八章学习笔记 《C++primer(第五版)》学习之路-第八章：IO库]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(七)类]]></title>
    <url>%2F2018%2F01%2F16%2FCPP_07%2F</url>
    <content type="text"><![CDATA[类是数据的抽象(data abstraction)和封装(encapsulation)。数据抽象是一种将接口(interface)和实现(implemention)分离的设计技术。接口是指用户可以对类使用的操作集。实现包括类的数据成员和接口函数体。封装使得类的使用者不必关注类内部是如何实现的，因为这些是类的设计者需要关注的。 定义抽象数据类型类的定义和声明类由类成员组成。类成员包括属性，字段，成员函数，构造函数，析构函数等组成。 类设计应该遵从抽象封装性。 类抽象性指对于类的使用者来说只需知道类接口即可使用类功能。类的具体实现由设计者负责。即使某个功能发生了变更但由于使用者是以接口方式调用类所以用户代码无需做任何修改。 类封装性指类用户只需知道类的功能无需了解具体实现。实现代码对用户来说不可见。 C++类没有访问级别限制，定义类时不能用public 或 private 做修饰。类成员有访问级别，可以定义 public protect private。 this指针每一个类的内部都有一个隐含的this指针，该参数是由系统负责维护。它的类型是CLASSTYPE *const this;，即指向某个类的const指针。所以this指针在初始化以后就不能改变。系统使用this指针来指明函数使用的是哪个实例的数据成员。 在调用成员函数时，系统会自动传递类实例的地址给this指针：12CLASSTYPE exm; exm.func(); 可以将该函数调用理解为：CLASSTYPE::func(&amp;exm); const成员函数在调用成员函数时，会传递类实例的地址给this指针。如果该实例是const对象，那么非const指针是无法指向const对象的。可以在函数参数列表后加上const来表明是const成员函数。 因此，this也是指向常量的指针。 类的作用域与成员函数编译器分两步处理类： 首先编译成员的声明， 然后编译成员函数体。 因此，成员函数体可以随意使用类中的其他成员。（不管定义先后） 在类的外部定义成员函数123456double Sales_data::avg_price() const&#123; if(units_old) return revenue/units_old; else return 0;&#125; 定义一个返回this对象的函数12345Sales_data &amp; Sales_data::combine(const Sales_data &amp;rhs) const&#123; units_old += rhs.units_old; //把rhs的成员加到this对象上 revenue += rhs.revenue; return *this; //返回调用该函数的对象&#125; 因此，执行total.combine(trans)语句时，是更新了变量total的值。 引用类型返回左值。return *this;解引用this指针获得执行该函数的对象，也就是返回total的引用。 定义类相关的非成员函数(7.1.3,P234)类的辅助函数，比如add，read和print等。概念上属于类的接口的组成部分，但实际上不属于类本身。 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中。 构造函数(7.1.4，P235)构造函数(constructor)是特殊的成员函数。在类对象定义时被调用。不能通过定义的类对象调用构造函数，构造函数可以定义多个或者说构造函数允许重载。 如果没有定义任何构造函数，系统就会给类分配一个无参的默认构造函数(default constructor)，类只要定义了一个构造函数，编译器也不会再生成默认构造函数。只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。 定义类对象时不能写成 Sales_item myobj();，编译器会理解成：一个返回 Sales_item 类型叫 myobj的函数声明。 正确写法是去掉后面的括号。 构造函数不允许定义成 const，这样定义会产生语法错误： Sales_item() const {}; 构造函数在执行时会做类数据成员的初始化工作。从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。 不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。 构造函数初始值列表12345678910111213Sales_data&#123;//新增的构造函数Sales_data() = default;Sales_data(const std::string &amp;s): bookNo(s) &#123;&#125;Sales_data(const std::string &amp;s, unsighed n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;//之前已有的其他成员std::string isbn() const &#123; return bookNo; &#125;Sales_data&amp; combine(const Sales_data&amp;);std::string bookNo;unsigned units_old = 0;double revenue = 0.0;&#125; 上述代码中，= default要求编译器生成默认构造函数。Sales_data(const std::string &amp;s, unsighed n, double p): bookNo(s), units_sold(n), revenue(p*n) {}中的冒号和花括号之间的部分叫做构造函数初始值列表(constractor initialize list)。 如果编译器不支持类内初始值，那么所有构造函数都应该显式地初始化每个内置类型的成员。 当然也可以在类外定义构造函数。 拷贝、赋值和析构(7.1.5，P239)尽管编译器能为我们合成拷贝、赋值和析构的操作，但某些情况下可能无法正常工作。如分配和管理动态内存的类（13.1.4, P447）。 访问控制与封装(7.2，P240)访问说明符(access specifiers)：加强类的封装性： public：在整个程序内可被访问； private：可以被类的成员函数访问。 使用class和struct唯一的区别就是默认的访问权限：struct默认是public，class默认是private。 友元(7.2.1，P241)友元(friend)：friend关键字，允许其他类或者函数访问类的私有成员。 类的其他特性(7.3，P243)可变数据成员(mutable data member)：永远不会是const，即使是const对象的成员。 类内初始值：必须以符号=或者花括号。 返回*this的成员函数(7.3.2，P246)返回值是调用对象的引用，返回引用的函数是左值的，意味着这些函数返回对象本身。 如果返回类型不是引用，则返回的是*this的副本。 类的作用域(7.4，P253)编译器处理完全部声明后，才会处理成员函数的定义。 构造函数再探(7.5，P257)成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。 委托构造函数(7.5.2，P261)委托构造函数(delegating constructor)：使用使用所属类的其他构造函数执行自己的初始化过程。成员初始值列表唯一，是类名本身。 explicit：抑制构造函数定义的隐式转换，只对一个实参的构造函数有效。且只能在类内声明的时候采用explicit关键字。 字面值常量类：constexpr 类的静态成员(7.6，P269)一般来说，我们不能在类内初始化静态成员。相反，必须在类的外部定义和初始化每个静态成员。 定义并且初始化一个静态成员：1double Account::interestRate = initRate(); 定义静态数据成员的方式和在类外定义成员函数差不多。 只有字面值常量类型constexpr的静态成员可以在类内，且初始值必须是常量表达式。 如果类内部声明提供了初始值，则外部定义时不能提供初始值。 静态数据成员可以是不完全类型，如类类型；非静态成员只能是类的指针或者引用。 术语表class 关键字： class keyword构造函数： constructor构造函数初始值列表： constructor initializer list类的作用域： class scope委托构造函数： delegating constructor显示构造函数： explicit constructor接口：interface数据抽象：data abstraction可变数据成员： mutable data member友元： friend 参考 C++ Primer 中文第五版 C++primer第五版第七章学习笔记]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断int是否为3的幂—— Leetcode(326)]]></title>
    <url>%2F2018%2F01%2F13%2Fleetcode_326_power_of_3%2F</url>
    <content type="text"><![CDATA[leetcode链接：326. Power of Three Given an integer, write a function to determine if it is a power of three. Follow up:Could you do it without using any loop / recursion? 一般的通用解法：1234567891011class Solution &#123;public: bool isPowerOfThree(int n) &#123; while (n &gt;= 3 )&#123; if(n % 3 != 0) return false; n /= 3; &#125; return n&gt;0 &amp;&amp; n != 2; &#125;&#125;; 上述可以通过，但是题目说最好尝试一下非循环或者递归的解法。 我感觉此类方法就是有点取巧了。如，找出int范围内最大的3的倍数，所以任何3的倍数n都可以被其整除。 1234567891011class Solution &#123;public: bool isPowerOfThree(int n) &#123; //方法2 const int maxint = 0x7fffffff; //假设3^k 是int范围内最大的3的幂 int k = int(log(maxint) / log(3)); int max_power_3 = pow(3,k); return n&gt;0 &amp;&amp; max_power_3 % n ==0; &#125;&#125;; 或者将上述代码压缩到一行：1return n&gt;0 &amp;&amp; int(pow(3,int(log(0x7fffffff) / log(3)))) % n == 0; pow函数在头文件math.h中。 同类题： 231. Power of Two 326. Power of Three 342. Power of Four]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断int是否为4的幂—— Leetcode(342)]]></title>
    <url>%2F2018%2F01%2F13%2Fleetcode_342_power_of_4%2F</url>
    <content type="text"><![CDATA[leetcode链接：342. Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example:Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 判断一个数是不是4的幂。还是使用二进制。在判断2的幂的基础上添加条件。如：16(10000)是，8(1000)不是；可以与0x55(01010101)取并集即可。(即判断1的位数是不是在奇数位)123456class Solution &#123;public: bool isPowerOfFour(int n) &#123; return n&gt;0 &amp;&amp; ((n &amp; (n-1)) == 0) &amp;&amp; (n &amp; 0x55555555); &#125;&#125;; 另一种思路的解法为：1return n&gt;0 &amp;&amp; ((n &amp; (n-1)) == 0) &amp;&amp; (（(n-1) %3 == 0); 先直觉上检验一下，发现的确是这样：$4 -1 = 3,16 - 1 = 15, 64 -1 = 63$，都是3的倍数。因此$(4^n - 1) % 3 == 0$是成立的。 下面给出简短证明：$$4^n -1 = 2^{2n}-1 = (2^n+1)(2^n-1)$$我们知道：$2^n+1$、$2^n$与$2^n-1$是三个连续数，其中必有一个为3的倍数，而且$2^n$必然不是3的倍数，因此，$2^n+1$与$2^n-1$中必有一个为3的倍数。也就是$4^n -1$必为3的倍数。 同类题： 231. Power of Two 326. Power of Three 342. Power of Four]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断int是否为2的幂—— Leetcode(231)]]></title>
    <url>%2F2018%2F01%2F13%2Fleetcode_231_power_of_2%2F</url>
    <content type="text"><![CDATA[leetcode链接：231. Power of Two Given an integer, write a function to determine if it is a power of two. 出错样例：1Input: -16 Expected: false // 就是没有考虑负数。 C++实现： 123456789101112131415class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if(n &lt;= 0) return false; while(n != 2 &amp;&amp; n &gt; 2)&#123; if(n%2 != 0) return false; else n /= 2; &#125; return true; &#125;&#125;; 上述一个常规的做法：连续除。 此外，我们考虑到2的幂的二进制只有最高位为1，其余都为0，此时利用这个特点可以写出如下的代码：12345678910class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if(n &lt;= 0) return false; return (n &amp;(n-1) )== 0; //或者一句话表示，如下： //return n&gt;0 &amp;&amp; (n &amp;(n-1) )== 0; &#125;&#125;; n &amp; (n-1)==0 会被当作：n &amp; ((n-1)==0)，故需要加上括号写为：(n &amp;(n-1) )== 0。 例如：8的二进制1000,7的二进制0111，取并集为0。 同类题： 231. Power of Two 326. Power of Three 342. Power of Four]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门使用指南]]></title>
    <url>%2F2018%2F01%2F13%2FGit_usage%2F</url>
    <content type="text"><![CDATA[Git简介下面是摘自官网的一段话： Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 简而言之，Git是一个优秀的分布式版本管理软件。 安装打开Git官网：git-scm.com，下载并安装。Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装。 安装完成后，windows打开git-bash，linux直接打开terminal。 初始化配置配置用户信息（和Github上一致）：用户名和邮箱地址：12git config --global user.name "qwerty200696"git config --global user.email "wang@126.com" 如果之前已经配置好了，可以使用如下命令查看： 12git config user.namegit config user.email 还可以配置颜色和行尾。不同平台的行尾是有显著区别的。 1234git config --global core.autocrlf truegit config --global core.autocrlf inputgit config --global color.ui auto 其他配置：配置的级别分为：global 、local与system三种级别，local会覆盖global。就像面向对象的继承那样，最近的是最有效的，也就是local。 init&amp;add——开始与添加选择需要版本控制的文件夹，打开终端(linux)或者Git Bash(windows)。 初始化Git：1git init 最好的方法是在开始一个项目之前，通过git init xxx来新建一个项目目录xxx。git会自动创建该xxx目录。 假设文件夹下存在需要版本管理的文件，使用如下命令查看是否已经被管理： 1git status 添加需要管理的文件：12git add 1.py # 某个具体的文件git add . # 添加文件夹下所有的文件 可以在目录下创建一个名为.gitignore的文件，在其中输入需要忽略的文件。 commit——提交修改1git commit -m &quot;first commit&quot; 修改内容之后，使用commit提交。 1git log log命令可以查看每次的更改。 目前都是在本地化的版本管理。 diff——显示不同现在假设你修改了一个文件，但是过去了一段时间后忘记修改在什么地方了，此时你需要“diff”。1234567git diff # 文件的最新改动git diff --staged # 已经暂存的和最近历史的改动。git diff HEAD # HEAD提交历史中，最近一次的别名，最新的修改与最近历史的改动。跳过了暂存的修改，直接与最近一次提交的比较。git diff --color-words # 只对修改的地方用不同颜色标记，而不是整行。git diff --word-diff # 对长行的小改动更加清晰明了。git diff --stat # 极简输出，只输出改动的文件，阻止其他输出。 log——查看修改log是一个非常强大的明了，不仅可以查看提交的历史记录，而且是了解仓库的进展、提交的内容以及文件的好帮手。123456git loggit log --oneline # 更常用！git log --stat #可以查看修改的文件。git log --patch # 可以查看文件中具体的修改内容。git log --graph --all --decorate --oneline # z展示每次提交的一行概括。 remove——删除文件删除文件。两种方式，一种是git rm，一种是git add git rm 用来删除一个文件；并且会自动暂存修改。 此外，如果用rm删除了一个文件，可以使用git rm再次暂存修改。 现实情况中，往往会有很多文件被删除了，不可能通过命令行一个个修改。1Git add -u . # 注意，最后的dot不能省略哦，表示当前目录 改命令会遍历文件夹，并且查找出所有删除的文件，并且暂存。 有时候只是想要从git中删除，但是本地文件不删除，使用如下命令：1git rm --cached xxx_file 你是真的想在所有历史记录中删除这个文件的记录吗？这是另一个主题中会讲。或者你是不想要某个文件被追踪，之后也是这样，那么可以使用git ignore文件，在之后也会介绍。 move——移动文件 移动文件。1git mv xxx_file otherPath/xxx.file 1git add -A . 找出所有的移动过的文件。（包括修改之后移动的文件） 追踪移动过的文件的历史：123git log -- path/file # 只会追踪到该目录下的历史，历史会终止在移动的时候。git log --stat -M --follow -- path/file # 跨目录追踪历史，文件在移动过程中也追踪。 在移动文件之后，commit给我们一个数字来告诉我们文件在移动前后的相似度。Git提供的默认阈值是50%的相似度，超过50%，在移动前后就会继续追踪该文件。 ignore——忽略文件可以在目录/子目录下创建一个名为.gitignore的文件，在其中输入需要忽略的文件/文件夹。 只能对当前目录的文件/文件夹进行忽略。 可以使用匹配符，在当前目录/子目录都有效。 子目录中，需要路径优先级？？也可以使用“！”反忽略某一个特定的文件。注释行用“#”号开头。 查看忽略了的文件：123git ls-files --others --ignored --exclude-standard ## 查看忽略的文件git ls-files --ignored --exclude-standard 为什么我感觉不需要加上 --others也可以。而且第二个命令更靠谱。 以上述的第一个命令为主。如果你感觉第一个命令不行的话，那是因为在某些文件先前已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。git清除本地缓存命令如下：【参考资料二】123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos; 关于ignore规则的详细介绍，可参考这篇博文，写得很详细。 branch——开始新分支创建与删除123git branch newBranchName ## 创键分支git branch -d existedBranchname ## 删除分支，没有合并的话会出错git branch -D existedBranchname ## 删除分支，强制删除 switch——切换分支1git checkout existedBranchname checkout的其他用法最主要的作用就是切换分支，上面已经讲过了。12git branchgit status 都可以查看目前处于那个分支上面。 撤销内容：1git checkout -- filename.txt 会清理掉最后一次commit的内容。 1git checkout -b newBranchName 一步到位，既创建了一个新的branch，也转移到了新的branch。 如果在使用checkout命令的时候，不小心将头指针分离了，如下所示：1234wangwlj@myUbuntu:~/文档/py_prog/py3_prog$ git branch -a* （头指针分离于 ee74fc7） master program 当我们发现头指针游离于分支之外的时候，不要惊慌，再次git checkout program切换到已经存在的分支即可。 merge——分支合并12git checkout master ## 切换到主分支git merge branchNeedToMerge ## 将分支branchNeedToMerge的修改合并到master merge冲突的解决merge冲突：两个文件都有变化，Git无法确定该怎么合并。该如何解决呢？ 先用git status查看是哪个文件冲突 ，然后用编辑器打开，进行修改。 先查找&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD标志，表明是当前branch上的内容，直到=======标志结束。在=======标志的下方，直到&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchNeedToMerge标志结束，是另一个分支的内容。 找到位置后，需要手动地解决冲突：编辑文件，删去冲突的标签，决定该删去或保留哪些内容，保存即可。最后重新add、commit提交。 abort——放弃冲突放弃这个冲突（不重要），从上次commit开始，并且清除暂存区。1git merge --abort squash压缩12git merge --squash branchNeedToMergegit commit -m &quot;some message&quot; 意思是 你在分支branchNeedToMerge里面做了很多次commit修改，但是修改很零碎；在master分支里只想要一次commit就更新到branchNeedToMerge分支的进度。此时就可以使用--squash参数。 判断是否使用--squash选项最根本的标准是，待合并分支上的历史是否有意义。 关于--squash 参数的举例可参考这篇文章。 -d 删除分支1git branch -d branchNeedToMerge NetworkRemotes1git remote add origin &lt;server&gt; &lt;server&gt;是远程服务器的地址、目的地的url。 小技巧：仓库地址的格式写为：https://用户名:密码@github.com/用户名/xxx.git，可以免去每次都输入用户名以及密码的麻烦！！（最好在个人电脑中这样使用，因为每次push都会显示用户名密码。） 如果输错了或者忘记了也不要紧，可以输入如下命令重新设置：12345git remote set-url origin &lt;new-server&gt;上述对应的是第一种用法：git remote set-url [--push] &lt;名称&gt; &lt;新的地址&gt; [&lt;旧的地址&gt;]此外还有：git remote set-url --add &lt;名称&gt; &lt;新的地址&gt;以及：git remote set-url --delete &lt;名称&gt; &lt;地址&gt; 查看远程的地址有哪些：1git remote -v 最后删除远端地址：1git remote rm origin fetch/pull/push123git fetch origingit pull origingit push origin fetch:去github.com上面下载信息，放在远程追踪分支。，pull：与fetch非常像，下载下来放到远程，并且合并到本地。push：电脑上完成了工作，发送到github上面。 fork/pull requestsfork:拷贝到自己的仓库进行修改，最好新建分支。pull requests:对他人的代码进行修改，提意见 reset——重置reset有三个等级，默认的是mixed，除此之外还有soft与hard。 123git reset --soft HEAD~5 # 选择需要重置commit的次数git statusgit commit -m&quot;new message&quot; # 重新提交 reset在对仓库历史提交的处理上比较有用，当然也是一个危险的命令啦。 checkout可以做类似的事情，checkout更加关注的是一个目录或者文件级别的精度。也就是说，可以把某个文件拉回到几次提交之前的状态。 reflog包括reset做的那些不可恢复的操作，reflog都有记录。但默认提供的是30天的保存时间。 1git reflog 也可以图形化查看历史：1gitk --all `git reflog | cut c1-7`&amp; reflog让我们有动力地去多做commit，commit了就有保障了。 参考资料 忽略特殊文件 Git中.gitignore文件不起作用的解决 GitHub&amp;Git入门基础 Git教程]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下必备软件及安装总结]]></title>
    <url>%2F2018%2F01%2F13%2Fubuntu_software_summary%2F</url>
    <content type="text"><![CDATA[安装ubuntu本文以Ubuntu 16.04为例。 制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。 安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将/home分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。 给出几个参考链接： 用UltraISO制作Ubuntu16.04 U盘启动盘 怎样安装 Windows 7 与 Linux 的双系统？双系统是比较特殊的，双系统可以，单系统也没问题。 软件安装前的设置假设现在已经有了一个全新的Ubuntu系统，此时你需要先换源。 换源系统自带的源速度不快，因此考虑换成国内源。笔者采用的是阿里云的源，还是不错的。 ubuntu16.04换源 Ubuntu16.04常用源 主文件夹下的中文目录改为英文目录 可选项。主文件夹下的中文目录名其实也不错。 Linux下使用命令行是很正常的事情，cd ~/桌面 需要切换输入法，可能会显得不那么流畅，因此，可以考虑将主文件夹下的中文目录设置为英文。 参考这篇文章：将Ubuntu主文件夹里的中文文件夹名称改成英文 我采用的是第一种方法。换了之后建议重启一下。 笔者不是一开始就改的，所以导致换目录名后出现了一系列问题。一开始就换会比较好。 Updating安装必备软件在对Ubuntu换源之后，就可以开始安装一些必备而的软件了。Ubuntu下软件的安装都不难，可以根据需求选择安装相应的软件。 1. 搜狗输入法输入法必备，放在第一个吧。 下载安装官网下载linux版本的dev包：pinyin.sogou.com/linux进入下载目录，在终端执行安装1$ sudo dpkg -i sogoupinyin_2.2.0.0102_amd64.deb 安装过程会出现 依赖关系问题（未安装成功，依赖库不全），不要担心，接着执行下面的命令就可以了： 1$sudo apt-get install -f 等待完成后，搜狗拼音输入法就安装好了。 上述两条命令都是常用命令，需要记住。 系统配置 下面对输入法进行系统配置，具体流程如下： 桌面右上角面板的开关机的按钮，选择系统设置； 进入系统设置后，点击语言支持，键盘输入方式系统中选择 fcitx； 注销系统用户，重新登陆进入桌面后看看，熟悉的搜狗输入法出现了吧。 参考自：ubuntu安装配置搜狗拼音输入法 2. 网易云音乐网易云音乐，大家都知道的，无需过多介绍，虽然现在由于版权问题好多歌曲都下架了，不过Linux下的网易云做得非常好。 只需要简单地下载、安装即可。具体请参考：ubuntu16.04安装网易云音乐 别人写得很详细的教程，我就只放链接了。 3. chrome浏览器Linux下谷歌浏览器是必备的。 安装谷歌浏览器，只需要三行代码：打开终端，输入1cd /tmp 对于谷歌Chrome32位版本，使用如下链接：1wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb 对于64位版本可以使用如下链接下载：1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载完后，运行如下命令安装。1sudo dpkg -i google-chrome*; sudo apt-get -f install 然后，就可以去搜索使用了。是不是很方便？ 参考自：安装谷歌Chrome浏览器 4. Guake Terminal (optional)安装流程Guake Terminal顾名思义，是一个终端。功能只有一个, 按 F12 时从屏幕顶部 嗖! 地下来一个。 可到官网：guake-project.org 查看详细说明。 12345$ git clone https://github.com/Guake/guake.git$ cd guake# For Ubuntu user, we have a script that does all these steps for you. Use:$ ./dev.sh 如果上述第三条命令出错的话，请尝试以下命令：1./dev.sh --install 期间，会自动安装一些库，如git之类的。 设置与自启动安装完成后，可以在终端输入guake查看效果，输入guake --preferences进行相关的配置。guake启动后，按下F12显示终端，再按F12消失。可以设置焦点失去时隐藏，这样就不用反复点F12了。 自启动设置： 点击最左上角的Dash图标(用于查找文件与程序的nage)，输入启动二字查看搜索结果，点击“启动应用程序”，按下图设置： 5. 思维导图xmindxmind和MindManager都是优秀的思维导图软件，linux下只有xmind。 具体的安装步骤： 1、去官网下载http://www.xmind.net/download/linux/ 2、下载完后解压，进入解压后目录，在命令行输入sudo ./setup，这个是用来安装软件相关的依赖；然后进入xmind_amd64（64位系统）或者xmind_i386(32位系统) 3、在目录中直接双击XMind文件，或者在命令行中输入 sudo ./XMind。这样XMind就可以直接运行。由于XMInd8的ubuntu版本是用JAVA来开发的，所以可以直接打开，无需安装。 参考自：ubuntu16.04安装xmind8 6. pycharm需要使用Python的话可以考虑安装Pycharm。 下载打开pycharm官网 下载linux版本的pycharm。 解压打开刚才下载的目录。右击文件，点击提取到此处（这与Windows的解压是一个意思） 安装解压完成后，打开刚才解压好的文件夹，然后再打开bin目录。 在文件夹空白处右击，在此处打开终端然后输入：sh ./pycharm.sh 回车 接着就打开了pycharm。 如果你需要导入之前安装版本的设置的话，可以选择第一个选项；如果没有的话，默认不导入设置就可以了。 点击同意，然后激活pycharm就可以使用了。 详情可参考：Ubuntu系统安装PyCharm教程（详细图文） 另附：学生可以免费注册pycharm，学生版也可以使用专业版的pycharm，没有什么区别。 7. WPS下载与安装进入WPS官网下载deb包：http://linux.wps.cn/ 安装，打开终端： 12cd 下载sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb 解决打开WPS时出现的系统缺失字体问题下载wps_symbol_fonts.zip: https://pan.baidu.com/s/1eS6xIzo 将wps_symbol_fonts.zip解压1cd wps_symbol_fontsls 将目录中所有文件复制到/usr/share/fonts下： 1sudo cp mtextra.ttf symbol.ttf WEBDINGS.TTF wingding.ttf WINGDNG2.ttf WINGDNG3.ttf /usr/share/fonts 重新打开WPS，问题解决。 删除libreOffice (optional)另外，安装完WPS后就没有必要保留libreOffice 卸载libreOffice： 1sudo apt-get remove libreoffice-common 顺便把Amazon链接删除了吧： 1234567891011 sudo apt-get remove unity-webapps-common sudo apt autoremove``` 参考自：[Ubuntu16.04安装wps并解决系统缺失字体问题](https://www.cnblogs.com/liutongqing/p/6388160.html)### 8. 图片编辑工具GIMP`GIMP`虽然不能完全替代`PS`，但是也能弥补一下。系统默认源中已经包含了GIMP，不需要使用PPA这些。安装： sudo apt-get install gimp 12345678910111213141516171819202122232425启动：通过Dash搜索`GIMP`即可。或者命令行输入GIMP也行。参考：- https://www.gimp.org/downloads/- https://www.cnblogs.com/EasonJim/p/7121885.html### 9. indicator-sysmonitor先看一下效果图：![1](http://ww1.sinaimg.cn/large/c38a0784ly1fndxu83315j20fr02zglt.jpg)图中的“CPU，温度，内存”部分就是该软件的作用了。想要安装可参考：[Ubuntu 16.04安装indicator-sysmonitor实现导航条显示上下行网速/CPU/内存使用率](http://www.cnblogs.com/EasonJim/p/7130171.html)### 10. 主题管理工具unity tweak tool主题管理工具`unity tweak tool`1, 添加源 sudo add-apt-repository ppa:freyja-dev/unity-tweak-tool-dailysudo apt-get update12,安装 sudo apt-get install unity-tweak-tool13,卸载 sudo apt-get remove unity-tweak-tool12345678910111213144,搜索`unity tweak tool`运行5,若出现以下问题，终端输入`sudo apt-get install unity-webapps-service `即可![](http://ww1.sinaimg.cn/large/c38a0784ly1fne74thxbkj20j006ojrk.jpg)### 11. docky经常使用Mac者的福音。实现效果如下图：![](http://ww1.sinaimg.cn/large/c38a0784ly1fne792nqnfj20jj032mzj.jpg)一句话安装： sudo apt install ducky1234567891011121314151617181920使用方法：- 删除图标：拖到回收站上面就可以。- 添加图标：打开程序的时候会自动加载到docky中，此时右键选择锁定。图标模糊：下载高清图标，替换掉。具体可查看知乎问题“Docky中程序的图标太模糊，如何替换Docky中程序的图标？”的[回答](https://www.zhihu.com/question/22892627/answer/64026877)。### 12. teamviewer`teamviewer`的作用：与其他主机互传文件或者控制远程主机。安装过程如下：1、下载安装程序(32位和64位Ubuntu通用)https://www.teamviewer.com/zhcn/download/linux/选择下载对应版本。2、在终端中执行如下命令进行安装 sudo dpkg -i teamviewer_i386.deb 13、使用如下命令处理依赖问题 sudo apt-get install –f 12345678910参考链接：[Ubuntu 16中如何安装TeamViewer 12](http://blog.csdn.net/zuochao_2013/article/details/53671245)使用部分不难，简单易上手。可以注册一个`teamview`账号，还是很方便的。### 13. 截图工具shutter`shutter`安装可参考：[ubuntu 安装截图工具 Shutter，并设置快捷键 Ctrl+Alt+A](http://blog.csdn.net/hanshileiai/article/details/46843713)其实`ubuntu`有自带的截图工具，不支持修改文件而已。 printscreen -- 全屏 alt + printscreen -- 当前活动截图 shift + printscreen -- 自选矩形截图 123456789101112131415161718192021自带的截图工具配合第八个软件GIMP一起使用，也还是不错的。### 14. Markdown编辑器 我选择的是[Moeditor](https://github.com/Moeditor/Moeditor)。类似的`markdown`编辑器还有：[Atom](https://atom.io/) (Github出品)，Vim+Markdown，[Remarkable - Linux](https://remarkableapp.github.io/linux.html) （据说有点小bug），[Haroopad - The Next Document processor based on Markdown](http://pad.haroopress.com/user.html) ，[typora.io](https://www.typora.io/#linux) ， SublimeText3+插件，[StackEdit](https://stackedit.io/) (网页版)，[小书匠markdown编辑器](http://markdown.xiaoshujiang.com/) ，马克飞象，VS Code，reText等等。`Moeditor`下载地址：https://github.com/Moeditor/Moeditor/releases安装： `sudo dpkg -i xxxx.deb`使用： 简单易上手。简洁。右上角分别为：最小化和全屏。菜单在左下角（新建，保存，另存为之类的）和右下角（切换编辑模式）。### 15. shadowsocks算是必备的吧。科研(?)利器。#### 安装软件ubuntu16.04 直接一句话安装： sudo apt install shadowsocks1234提示需要安装一些依赖库，选择`yes`即可。我们可以在`/home/wangwlj/` 下新建个文件`shadowsocks.json` (`wangwlj`是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样： { “server”:”11.22.33.44”, “server_port”:50003, “local_port”:1080, “password”:”123456”, “timeout”:600, “method”:”aes-256-cfb”} 上面的各项参数含义如下：server 你服务端的IPservier_port 你服务端的端口local_port 本地端口，一般默认1080passwd ss服务端设置的密码timeout 超时设置 和服务端一样method 加密方法 和服务端一样``` 确定上面的配置文件没有问题，然后我们就可以在终端输入sslocal -c /home/wangwlj/shadowsocks.json 回车运行。如果没有问题的话，下面会是这样… chrome插件SwithyOmega配置这里就不详写了，看这篇，写的很详细：ubuntu使用shadowsocks 还是简要附上几点吧。 新建一个模式，代理服务器，代理协议SOCKS5，代理服务器127.0.0.1，端口1080 auto switch中，上述模式对应的是：(按照规则列表匹配请求)使用shadowsocks访问的规则列表：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt，其余情况为直接访问。 PS：windows下的chrome插件SwithyOmega的配置与Ubuntu一样。 Updating将在个人博客中持续更新…… 为了查找安装方便，所有参考链接均在对应位置处，就不放在最后了。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(6) 第七章 快速排序]]></title>
    <url>%2F2018%2F01%2F11%2Falgorithm_tutorial_chapter_7%2F</url>
    <content type="text"><![CDATA[快速排序简介快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子很小，快排可以说是最快的排序算法，并非浪得虚名。另外它还是原址排序。 快速排序是基于分治模式的： 分解：数组A【p..r】被划分成两个（可能空）子数组A【p..q-1】和A【q+1..r】，使得A【p..q-1】中的每个元素都小于等于A(q)，而且，小于等于A【q+1..r】中的元素。计算下标q也是划分过程中的一部分。 解决：通过递归调用快速排序，对子数组A【p..q-1】和A【q+1..r】排序。 合并：因为两个子数组是原址排序的，将它们的合并不需要操作：整个数组A【p..r】已排序。 快排的伪码： 其中对数组的划分：Partition是快排算法的关键，，它对子数组A【p..r】进行原址重排）。 快速排序Python实现123456789101112131415161718192021def PARTITION(A, p, r): x = A[r] i = p - 1 for j in range(p, r): # not r-1, but r if A[j] &lt; x: i = i + 1 A[i], A[j] = A[j], A[i] A[r], A[i + 1] = A[i + 1], A[r] return i + 1def QUICKSORT(A, p, r): if p &lt; r: q = PARTITION(A, p, r) QUICKSORT(A, p, q - 1) QUICKSORT(A, q + 1, r)if __name__ == "__main__": A = [2, 8, 7, 1, 3, 5, 6, 4] QUICKSORT(A, 0, len(A) - 1) # all start from 0 for i in range(0, len(A)): print(A[i], end=" ") 快速排序性能分析当数据量很小的时候，大概就十来个元素的小型序列，快排的优势并不明显，甚至比插入排序慢。但是一旦数据多，它的优势就充分发挥出来了。 举一个例子，C++ STL 中的sort函数，就充分发挥了快排的优势，并且取长补短，在数据量大时采用QuickSort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免QuickSort递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，还会改用HeapSort(堆排序，第六章刚讲)。所以说，C++的“混合兵种”sort的性能肯定会比C的qsort好。 快排的运行时间与Partition的划分有关： 最坏情况是输入的数组已经完全排好序，那么每次划分的左、右两个区域分别为n-1和0，效率为$O( n^2 )$. 而对于其他常数比例划分，哪怕是左右按9:1的比例划分，效果都是和在正中间划分一样快的（算法导论上有详细分析） 即，任何一种按照常数比例进行划分，总运行时间都是$\text{O}(n \text{lg} n)$。 快速排序的随机化版本随机抽样(random sampling):从$A[p..r]$中随机选一个元素作为主元，而不是始终采用$A[r]$作为主元。 随机化的快排的伪码如下： Python实现：12345678910111213141516171819202122232425262728293031import randomdef PARTITION(A, p, r): x = A[r] i = p - 1 for j in range(p, r): # not r-1, but r if A[j] &lt; x: i = i + 1 A[i], A[j] = A[j], A[i] A[r], A[i + 1] = A[i + 1], A[r] return i + 1def RANDOMIZED_PARTITION(A, p, r): rand_i = random.random() # print(round(a *(r - p)) + p) rand_i = round(rand_i * (r - p) + p) # 区间的计算需要注意，否则不对 A[rand_i], A[r] = A[r], A[rand_i] return PARTITION(A, p, r)def RANDOMIZED_QUICKSORT(A, p, r): if p &lt; r: q = RANDOMIZED_PARTITION(A, p, r) RANDOMIZED_QUICKSORT(A, p, q - 1) RANDOMIZED_QUICKSORT(A, q + 1, r)if __name__ == "__main__": A = [2, 8, 7, 1, 3, 5, 6, 4] RANDOMIZED_QUICKSORT(A, 0, len(A) - 1) # all start from 0 for i in range(0, len(A)): print(A[i], end=" ") 参考 算法导论 中文 第三版 【算法导论】排序 （三）：快速排序 深入分析 Python random() 函数]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>快速排序</tag>
        <tag>quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(5) 第六章 堆排序]]></title>
    <url>%2F2018%2F01%2F09%2Falgorithm_tutorial_chapter_6%2F</url>
    <content type="text"><![CDATA[在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。 空间原址性(in place)：仅有常数个元素需要在排序过程中存储在数组之外。 堆(6.1, P84)堆，也叫 二叉堆，是一个数组，可以看作近似的完全二叉树，树的每个节点对应数组一个元素。 表示堆的数组A包括两个属性：A.length给出数组元素的个数；A.heap-size给出有多少个元素存储在该数组中。即heap-size是数组的有效元素。 给定下标i，很容易计算其父节点、左节点和右节点：123456def PARENT(i): return i / 2def LEFT(i): return 2 * idef RIGHT(i): return 2 * i + 1 这三个函数通常以宏或者内联函数的方式实现。 二叉堆分为两种形式：最大堆和最小堆。最大堆满足：A[PARENT(i)] ≥ A[i] ，即：某个节点的值最多与其父节点一样大；最小堆满足：A[PARENT(i)] ≤ A[i]。 堆排序算法采用的是最大堆。最小堆通常用于构造优先队列。 堆的高度为：$Θ(lgn)$ 维持堆的性质（6.2，P86）MAX-HEAPIFY：输入为一个数组A和一个下标i，A[i]有可能小于其孩子，通过让A[i]在数组中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质。 该函数伪码表示为： 算法图示： Python实现为：1234567891011121314def MAX_HEAPIFY(A, i): l = LEFT(i) r = RIGHT(i) largest = -1 if l &lt;= len(A) and A[l - 1] &gt; A[i - 1]: largest = l else: largest = i if r &lt;= len(A) and A[r - 1] &gt; A[largest - 1]: largest = r if largest != i: A[i - 1], A[largest - 1] = A[largest - 1], A[i - 1] MAX_HEAPIFY(A, largest) 每个孩子的子树最多为2n/3（不太理解这句话？？）。所以，在最差情况下（最底层恰好半满）运行时间为：$$T(n) = T(2n/3)+ \Theta(1)$$上述递归式的解为：$T(n) = \text{O} (\text{lg}n)$ 建堆(6.3, P87)子数组元素$A[ (\lfloor n/2\rfloor +1),\cdots,n]$是树中的所有叶节点。BUILD_MAX_HEAP从非叶节点开始一直循环到根节点。 Python实现为：12345from math import floordef BUILD_MAX_HEAP(A): heap_size = len(A) for i in range(int(floor(heap_size / 2)), 0, -1): MAX_HEAPIFY(A, i) BUILD_MAX_HEAP 的时间复杂度为$T(n) = \text{O}(n)$ 堆排序算法(6.4，P89)伪代码： Python实现：1234567def HEAPSORT(A): BUILD_MAX_HEAP(A) heap_size = len(A) for i in range(len(A), 1, -1): A[1 - 1], A[i - 1] = A[i - 1], A[1 - 1] # exchage A[i] with A[1] heap_size = heap_size - 1 MAX_HEAPIFY(A, 1, heap_size) HEAPSORT过程的时间复杂度为：$\text{O}(n\text{lg}n)$，因为BUILD_MAX_HEAP的时间复杂度为$\text{O}(n)$，n-1次调用MAX_HEAPIFY，每次时间为$\text{O}(\text{lg}n)$。 堆排序的Python完整实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from math import floordef PARENT(i): return i / 2def LEFT(i): return 2 * idef RIGHT(i): return 2 * i + 1def MAX_HEAPIFY(A, i, size): l = LEFT(i) r = RIGHT(i) largest = -1 if l &lt;= size and A[l - 1] &gt; A[i - 1]: largest = l else: largest = i if r &lt;= size and A[r - 1] &gt; A[largest - 1]: largest = r if largest != i: A[i - 1], A[largest - 1] = A[largest - 1], A[i - 1] MAX_HEAPIFY(A, largest, size) def BUILD_MAX_HEAP(A): heap_size = len(A) for i in range(int(floor(heap_size / 2)), 0, -1): MAX_HEAPIFY(A, i, heap_size) def HEAPSORT(A): BUILD_MAX_HEAP(A) heap_size = len(A) for i in range(len(A), 1, -1): A[1 - 1], A[i - 1] = A[i - 1], A[1 - 1] # exchage A[i] with A[1] heap_size = heap_size - 1 MAX_HEAPIFY(A, 1, heap_size)if __name__ == "__main__": # A = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1] # MAX_HEAPIFY(A, 2) # for i in range(0, len(A)): # print(A[i], end=" ") # A = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7] # BUILD_MAX_HEAP(A) # for i in range(0, len(A)): # print(A[i], end=" ") A = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7] HEAPSORT(A) for i in range(0, len(A)): print(A[i], end=" ") 优先队列(6.5，P90)优先队列：是一种用来维护由一组元素构成的集合S的数据结果，其中的每个元素都有一个相关的值，称为关键字。优先队列也有两种形式：最大优先队列和最小优先队列。 最大优先队列的应用：共享计算机系统的作业调度。最小优先队列被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生事件作为关键词。 优先队列可以用堆来实现。优先队列的元素对应应用程序的对象，堆中每个元素存储对象的句柄(handle)。 最大优先队列支持： 对最大优先队列进行插入，MaxHeapInsert； 返回最大优先队列的最大值，HeapMax； 去掉最大值并且返回该值，HeapExtractMax； 将第x个元素的值改为k，其中k&gt;=x的原来的值，HeapIncreaseKey； 123456789101112def HEAP_MAXIMUM(A): return A[1]def HEAP_EXTRACT_MAX(A, heap_size): if heap_size &lt; 1: print("ERROR!! Heap underflow!!") return -1 max_A = A[1 - 1] A[1 - 1] = A[heap_size - 1] heap_size = heap_size - 1 MAX_HEAPIFY(A, 1, heap_size) return max_A HeapExtractMax的操作复杂度为$\text{O}(\text{lg}n)$（也就是MAX_HEAPIFY的复杂度）。 最大优先队列的Python完整实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def PARENT(i): return i / 2def LEFT(i): return 2 * idef RIGHT(i): return 2 * i + 1def MAX_HEAPIFY(A, i, heap_size): l = LEFT(i) r = RIGHT(i) largest = -1 if l &lt;= heap_size and A[l - 1] &gt; A[i - 1]: largest = l else: largest = i if r &lt;= heap_size and A[r - 1] &gt; A[largest - 1]: largest = r if largest != i: A[i - 1], A[largest - 1] = A[largest - 1], A[i - 1] MAX_HEAPIFY(A, largest, heap_size)def HEAP_MAXIMUM(A): return A[1]def HEAP_EXTRACT_MAX(A, heap_size): if heap_size &lt; 1: print("ERROR!! Heap underflow!!") return -1 max_A = A[1 - 1] A[1 - 1] = A[heap_size - 1] heap_size = heap_size - 1 MAX_HEAPIFY(A, 1, heap_size) return max_Adef HEAP_INCREASE_KEY(A, i, key): if key &lt; A[i - 1]: print("ERROR!! New key is smaller than current key!!!") return A[i - 1] = key while i &gt; 1 and A[int(PARENT(i) - 1)] &lt; A[int(i - 1)]: A[int(PARENT(i) - 1)], A[int(i - 1)] = A[int(i - 1)], A[int(PARENT(i) - 1)] i = PARENT(i)def MAX_HEAP_INSERT(A, key): MAX_INT = 0x7fffffff heap_size = len(A) + 1 A.append(- MAX_INT) # 尾部追加元素 HEAP_INCREASE_KEY(A, heap_size, key)if __name__ == "__main__": A = [16, 14, 10, 8, 7, 9, 3, 2, 4, 1] MAX_HEAP_INSERT(A, 9) # 调用的数值都是从1开始。 for i in range(0, len(A)): print(A[i], end=" ") 算法基本思想：在末尾新插入一个元素，按照最大堆的要求排列好就行。 参考资料 算法导论 中文 第三版 算法导论 第六章：堆排序 最大优先队列–【算法导论】]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>堆排序</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动手实现atoi函数—— Leetcode(8)]]></title>
    <url>%2F2018%2F01%2F09%2Fleetcode_8%2F</url>
    <content type="text"><![CDATA[题目链接：8. String to Integer (atoi) Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. 题目实现将string转化为int的atoi函数。这题需要充分考虑各种不规范输入的情况，主要有以下几种情况： 忽略前面的所有空格直到非空格出现。从该字符开始，有可能是正负号，然后紧跟着一系列数字。 在数字的尾部有可能有一些无关的附加字符，也需要忽略它们。 如果第一个非空格字符不是有效数（即不是+-或者数字），则返回0。 如果string为空，或者仅有空格，则返回0。 如果最终结果超过int的范围，则返回int的最大/最小值。 提供几个测试样例：123456//Input:&quot;2147483648&quot; Expected:2147483647 //溢出的情况//Input:&quot;+&quot; Expected:0 //不合法的情况 //Input:&quot;+-2&quot; Expected:0 //不合法的情况 // Input: &quot; 123&quot; //有空格的情况// Input:&quot;-123&quot; //有负数的情况// Input:&quot;+123&quot; //有+号的情况 解法先给出我自己折腾的一个解法：1234567891011121314151617181920212223242526272829303132int my_atoi(string str)&#123; const int INT_MAX = 0x7fffffff; const int INT_MIN = 0x80000000; int len = str.size(); int index = 0; while(str[index] == ' ' &amp;&amp; index &lt; len)&#123; index ++; // 跳过空格 &#125; int sign = 1; //符号位 long l = 0; for(int i=index; i&lt; len; ++i)&#123; if(str[i] == '-' || str[i] == '+') if('0'&lt;= str[i+1] &amp;&amp; str[i+1] &lt;= '9') sign = (str[i] == '-')? -1 : 1; else return 0; else if('0'&lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; l = l * 10 + (str[i] - '0'); // 字符0对应的10进制为48，可以直接减去48 if(l * sign &gt; INT_MAX)&#123; return INT_MAX; &#125; else if (l * sign &lt; INT_MIN)&#123; return INT_MIN; &#125; &#125; else break; &#125; return l * sign;&#125; 主要思路就是：从左向右，先忽略空格；然后空格之后第一位有三种可能： 如果是“+-”号，则第二位必须是数字才记上正负号，否则返回0； 如果是数字，直到遇到非数字结束； 如果不是上述情况，则返回0。 这边再给出一个简洁的写法，具体思路类似。123456789101112131415161718int my_atoi(string str)&#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;=str.size();) &#123; i = str.find_first_not_of(' '); if(str[i] == '-' || str[i] == '+') indicator = (str[i++] == '-')? -1 : 1; while('0'&lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; result = result*10 + (str[i++]-'0'); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; 注：原先for(int i = 0; i&lt;=str.size();)中并不包含等号，会导致空串时无返回值的错误。因此加上等于号。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客彻底解决置顶问题]]></title>
    <url>%2F2018%2F01%2F09%2Fblog_pin_post%2F</url>
    <content type="text"><![CDATA[博文置顶一种方法是手动对相关文件进行修改，具体可参考这篇文章。 另一种方法就是，目前已经有修改后支持置顶的仓库，可以直接用以下命令安装。 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章的Front-matter中加上top: true即可。比如下面这篇文章： 123456---title: hexo+GitHub博客搭建实战date: 2017-09-08 12:00:25categories: 博客搭建系列top: true--- 到目前为止，置顶功能已经可以实现了。所有相关博文到这边就结束了。 不过置顶的文章显示在最上面之后，如果没有明确的置顶标志，是不是感觉有点怪怪的呢？ 设置置顶标志打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，插入如下代码：12345&#123;% if post.top %&#125; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125; 效果展示： 参考资料 解决Hexo博客文章置顶问题 解决Hexo置顶问题 Hexo主题的数据封装，样式渲染和扩展实例]]></content>
      <categories>
        <category>博客搭建系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>置顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(3) 第四章 分治策略]]></title>
    <url>%2F2018%2F01%2F08%2Falgorithm_tutorial_chapter_4%2F</url>
    <content type="text"><![CDATA[本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法，最后介绍了主方法。 分治策略简介分治策略在每层递归时都有三个步骤： 分解原问题为若干子问题；子问题的形式与原问题一样，只是规模更小。 解决这些子问题，递归地求解各子问题。如果子问题的规模足够小，则停止递归，直接求解。 合并这些子问题的解成原问题的解。 递归情况(recursive case)基本情况(base case)：子问题足够小的时候，递归已经“触底”时。 递归式：我们用递归式描述了MERGE-SORT过程的最坏情况运行时间$T(n)$：$$T(n) = \begin{cases} \Theta(1) &amp; 若n=1 \\ 2T(n/2)+f(n) &amp; 若n&gt;1\\ \end{cases}$$求解递归式的方法：代入法（猜测）；递归树法；主方法。本书使用主方法。 主方法可求解形如下面公式的递归式的界：$$T(n) = aT(n/b)+f(n)$$其中，$a\geqslant 1,b&gt;1,f(n)$是一个给定的函数。 递归式的技术细节 忽略递归式声明和求解的一些细节，如MERGE-SORT的最坏情况运行时间准确的递归式为： $$T(n) = \begin{cases} \Theta(1) &amp; 若n=1 \\ T(\lceil n/2\rceil )+T(\lfloor n/2\rfloor )+\Theta(n) &amp; 若n&gt;1\\ \end{cases}$$ 边界条件是我们通常忽略的细节。 当声明、求解递归式时，我们常常忽略向下取整、向上取整及边界条件。 本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法。 最大子数组问题(4.1，P38)问题买股票（低价买入，高价卖出）。给定一段时间，选取最大收益。 问题变换不关注每天的价格，而是关注每日价格变化。那么问题就转化为寻求价格变化数组A的最大非空连续子数组。称这样的连续子数组为最大子数组。 使用分治策略的求解方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env python3# -*- coding: utf-8 -*-# MAX = 1 &lt;&lt; 31import mathdef find_max_crossing_subarray(A, low, mid, high): max_left = mid max_right = mid left_sum = 0 # original version init with -max, now is zero,because minimum is zero all_sum = 0 for i in range(mid - 1, low - 1, -1): # 左边不经过mid all_sum += A[i] if all_sum &gt; left_sum: left_sum = all_sum max_left = i right_sum = A[mid] # original version init with -max, now is A[mid],because A[mid] must be included. all_sum = 0 for i in range(mid, high + 1): all_sum += A[i] if all_sum &gt; right_sum: right_sum = all_sum max_right = i # print([low, mid, high], [max_left, max_right, left_sum + right_sum]) return [max_left, max_right, left_sum + right_sum]def find_maximum_subarray(A, low, high): if high == low: return [low, high, A[low]] else: mid = math.floor((low + high) / 2) left_low, left_high, left_sum = find_maximum_subarray(A, low, mid) right_low, right_high, right_sum = find_maximum_subarray(A, mid + 1, high) cross_low, cross_high, cross_sum = find_max_crossing_subarray(A, low, mid, high) if left_sum &gt;= right_sum and left_sum &gt;= cross_sum: return [left_low, left_high, left_sum] elif right_sum &gt;= left_sum and right_sum &gt;= cross_sum: return [right_low, right_high, right_sum] else: return [cross_low, cross_high, cross_sum]if __name__ == "__main__": A = [1, -3, 7, -1, 4, -1, -5, 3, -1, 3, -5, 9] # A = [1, -3, 7, -5, -4, -1, -9, -3, 1, -3, -5, -9] # print(find_max_crossing_subarray(A, 0, 6, len(A) - 1)) print(find_maximum_subarray(A, 0, len(A) - 1)) 分治算法的分析假设问题规模为2的幂，这样所有问题的规模都是整数。 在find_maximum_subarray函数中，需要求解两个子问题——左数组和右数组(分别为5/6行)，每个子问题的运行时间为$T(n/2)$，两个子问题加起来就是$2T(n/2)$。第7行，find_max_crossing_subarray函数求解跨越中点的子数组，花费线性的时间，为$\Theta (n)$。 总的运行时间递归式为：$$T(n) = \begin{cases}\Theta (1) &amp; if\ \ n=1\\2T(n/2)+\Theta (n) &amp; if\ \ n&gt;1\end{cases}$$与鬼归并排序的递归式相同。在4.5节用主方法求解该递归式，其解为$T(n) =\Theta (n\ \text{lg}n) $。 线性复杂度的解法–习题4.1-5(P42)主要思想：从左到右处理，记录目前为止已经处理的最大子数组。非递归、线性复杂度。 从左到右累加，如果当前子数组的累加和小于零，则意味着最大子数组(maximun subarray)肯定不包括该子数组，所以果断舍弃，重新开始累加。 该解法的python实现：12345678910111213141516171819def find_maximum_subarray(A): j = 0 max_sum = 0 left = -1 cur_left = 0 right = -1 sum = 0 for j in range(0, len(A)): sum = sum + A[j] if sum &gt; max_sum: max_sum = sum left = cur_left right = j elif sum &lt; 0: sum = 0 cur_left = j + 1 if max_sum &gt; 0: return left, right, max_sum return None 矩阵乘法的Strassen算法(4.2，P43)若$A=(a_{ij}),B=(b_{ij})$是$nxn$的方阵，则对$i,j=1,2,\cdots ,n$,定义矩阵乘积$C=A\cdot B$中的$c_{ij}$为：$$c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}$$ 写成程序，是一个三重循环，因此，复杂度为$\Theta (n^3)$。 123456789def SQUARE_MATRIX_MULTIPLY(A, B): assert(len(A) == len(B)) n = len(A) C = [[0 for col in range(n)] for row in range(n)] for i in range(0, n): for j in range(0, n): for k in range(0, n): C[i][j]= C[i][j] + A[i][k]*B[k][j] return C 一个简单的分治算法(4.2，P43)假定三个矩阵均为$n\times n$矩阵，其中n为2的幂。在每个分解步骤中，$n\times n$矩阵都被划分为4个$n/2 \times n/2$的子矩阵，如下：$$A = \begin{bmatrix}A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}\end{bmatrix},B = \begin{bmatrix}B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}\end{bmatrix},C = \begin{bmatrix}C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}\end{bmatrix}$$因此，公式$C=A\cdot B$改写成：$$\begin{bmatrix}C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}\end{bmatrix}= \begin{bmatrix}A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}\end{bmatrix} \cdot\begin{bmatrix}B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}\end{bmatrix}$$等价于：$$\begin{matrix}C_{11} = A_{11}\cdot B_{11} + A_{12}\cdot B_{21} \\C_{12} = A_{11}\cdot B_{12} + A_{12}\cdot B_{22} \\C_{21} = A_{21}\cdot B_{11} + A_{22}\cdot B_{21} \\C_{22} = A_{21}\cdot B_{12} + A_{22}\cdot B_{22}\end{matrix}$$ 该简单分治算法的总运行时间递归式为：$$T(n) = \begin{cases}\Theta (1) &amp; if\ \ n=1\\8T(n/2)+\Theta (n^2) &amp; if\ \ n&gt;1\end{cases}$$ Strassen 方法(4.2，P45)为减小时间复杂度，采用Strassen 法，其原理仍将讲矩阵A,B,C划分成n/2 x n/2 ,然后按如下计算： 即：先创建10个矩阵$S_1,\cdots,S_{10} $，由于进行了10次$n/2\times n/2$矩阵的加减法，所以该步骤花费$\Theta(n^2)$时间。 接着，递归地计算七次$n/2\times n/2$矩阵的乘法，即计算$P_1,\cdots,P_{7}$矩阵。 最后计算结果矩阵C的子矩阵$C_{11},C_{12},C_{21},C_{22}$。 其时间复杂度为： $$T(n)= \begin{cases}\Theta (1) &amp; if\ \ n=1\\7T(n/2)+\Theta (n^2) &amp; if\ \ n&gt;1\end{cases}$$ 利用4.5节的主方法，可以求出上述的解为：$$T(n)= \Theta(n^{\text{lg}7}) $$ 用主方法求解递归式(4.5，P53)主方法依赖于主定理。 主定理令$a\geqslant 1$和$b&gt;1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：$$T(n)= aT(n/b)+f(n)$$ 其中，我们将$n/b$解释为$\lfloor n/b \rfloor$或$\lceil n/b \rceil$。那么$T(n)$有如下的渐近界： 若对某个常数$\epsilon &gt; 0$有$f(n) = \text{O}(n^{\text{log}_ba - \epsilon})$，则$T(n)=\Theta(n^{\text{log}_ba} )$ 若$f(n) = \Theta(n^{\text{log}_ba})$，则$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$ 若对某个常数$\epsilon &gt; 0$有$f(n) = \Omega(n^{\text{log}_ba + \epsilon})$，且对某个常数$c&lt;1$和所有足够大的n有$aT(n/b)\leqslant cf(n)$，则$T(n)=\Theta(f(n) )$ 以上就是主定理的完整叙述。 解释：我们将函数$f(n)$和$n^{\text{log}_ba}$进行比较。直觉上，两个函数较大者决定了递归式的解。情况1表示：函数$n^{log_ba}$更大，则解为$T(n)=\Theta(n^{\text{log}_ba} )$；情况3表示：函数$f(n)$更大，则解为$T(n)=\Theta(f(n) )$。情况2表示：当两个函数大小相当，则乘上一个对数因子，解为$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$。 上述的大于/小于都是多项式意义上的，也就是渐近小于(大于)。每种情况之间都有一定的间隙。若$f(n)$落在间隙中，就不能使用主方法。 使用主方法使用主方法，只需要确定主定理的哪种情况成立，即可以得到解。 下面举几个例子。 $$T(n)= 9T(n/3)+n$$上式中，$a=9,b=3,f(n) = n$，因此，$n^{\text{log}_ba} =n^{\text{log}_39} = \Theta(n^2) $。由于$f(n) = \text{O}(n^{\text{log}_39 - \epsilon})$，其中$\epsilon = 1$，所以应用主定理的情况1，从而得到$T(n) = \Theta(n^2) $ $$T(n)= T(2n/3)+1$$上式中，$a=1,b=3/2,f(n) = 1$，因此，$n^{\text{log}_ba} =n^{\text{log}_{3/2}1} =n^0 = 1 $，由于$f(n) = \Theta(n^{\text{log}_ba}) = \Theta (1)$，所以，适用于情况二，从而得到最终解为$T(n) = \Theta(\text{lg} n ) $ 归并排序和最大子数组方法的运行时间的递归式：$$ T(n)= 2T(n/2)+\Theta(n)$$同理，$n^{\text{log}_ba} =n^{\text{log}_{2}2} =n $， 由于$f(n) = \Theta(n)$，所以应用情况2，得到解$T(n) = \Theta(n\text{lg} n ) $ 矩阵乘法的第一个分治算法的运行时间：$$ T(n)= 8T(n/2)+\Theta(n^2)$$上式，有：$n^{\text{log}_ba} =n^{\text{log}_{2}8} =n^3 $，$n^3$多项式意义上大于$f(n)$，因此应用情况1，解为$T(n) = \Theta(n^3) $ 矩阵乘法的Strassen算法运行时间：$$ T(n)= 7T(n/2)+\Theta(n^2)$$上式中，有$n^{\text{log}_ba} =n^{\text{log}_{2}7} = n^{\text{lg}7}$，由于$2.80&lt;lg7&lt;2.81$，对$\epsilon = 0.8$，有$f(n) = \text{O}(n^{\text{lg}7-\epsilon})$，故应用情况1，得到：$T(n) = \Theta(n^{\text{lg}7}) $ 参考资料 算法导论 中文版 原书第三版 算法导论 第四章：分治法(二) 算法导论课后习题解析 第四章 上]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>分治</tag>
        <tag>最大子数组</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断回文数（三种解法）—— Leetcode(9)]]></title>
    <url>%2F2018%2F01%2F08%2FLeetcode_9%2F</url>
    <content type="text"><![CDATA[Leetcode链接：9. Palindrome Number Palindrome Number，即判断是否为回文数，并且题目要求不能使用额外的空间。即，不能使用回文串的方法。 在本题中，负数不作为回文数考虑范围之内，但是输入依然可能为负，此时直接返回false即可。 首先，一种容易想到的方法是：将整个数取反后看和原来的数是否相同。 12345678910111213141516171819class Solution &#123; public: bool isPalindrome(int x) &#123; if (x&lt;0) return false; long long int sum =0; long long int origin = x; while(x) &#123; int num = x %10; sum = sum*10 + num; x/=10; &#125; if(sum == origin) return true; else return false; &#125; &#125;; 我采用另外一种方法：根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。 12345678910111213141516class Solution &#123;public: bool isPalindrome(int x) &#123; // 负数肯定不是，以及首尾不对称的非0数 if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) return false; int rev = 0; while ( x &gt; rev)&#123; rev = rev * 10 + x % 10; //将低位一半的数取反。 x = int (x / 10); &#125; //有rev &gt;= x， 奇数情况下需要除去10 return x == rev || x == int(rev/10); &#125;&#125;; 还有另外一种解法：类似与采用两个指针。在循环体中，不断地比较第i位和倒数第i位，直到遇到最中间的1个数字(输入为奇数个数字)或者遇到最中间的2个数字(输入为偶数个数字)时结束。 123456789101112131415bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int div = 1; while (x / div &gt;= 10) &#123; div *= 10; &#125; while (x != 0) &#123; int l = x / div; int r = x % 10; if (l != r) return false; x = (x % div) / 10; //去掉两边的数 div /= 100; &#125; return true; &#125; 参考链接： LeetCode(9)PalindromeNumber leetcode9]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(六)函数]]></title>
    <url>%2F2018%2F01%2F06%2FCPP_06%2F</url>
    <content type="text"><![CDATA[第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。本章内容包括： 函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。 函数重载,重载可以使函数接受不同种类或者数量不同的参数。 函数指针，指向函数的一类特殊指针。 函数基础（P182，6.1）123456789void func(int a, char c) // 形参 &#123; &#125; int main() &#123; func(1, 'a'); // 实参，与形参的类型、数量相匹配 return 0; &#125; 在调用函数时，第一步编译器会隐式的定义并初始化它的形参。比如一个函数void f(int a);，形参int a会被用户传入的实参初始化，此时形参是实参的一个副本。当有多个形参时，形参对应的实参的求值顺序是不一定的。实参的类型必须和形参的类型一致或能转化为形参声明的类型。 函数可以返回空值。返回函数指针和数组的特殊函数类型将在之后提到。 局部静态对象（P185，6.1.1）一个对象的名字有作用域，对象本身也有生命周期。名字的作用域是我们可以通过名字访问对象的的区间。相对的，生命周期是指对象的产生和销毁的过程。 定义在所有函数外部的变量叫做全局变量，在整个程序的执行过程中一直存在。这种对象在程序启动时被创建，直到程序结束才会被销毁。 定义在函数体内的对象或者函数的形参都是局部变量。当函数执行路径经过该对象的定义语句时才会自动开始创建该对象，在对应的块结束时，这个对象会被销毁。 有时候我们有必要使局部变量的生命周期贯穿函数调用及之后的时间，所以我们可以将局部对象定义成static对象，定义语句形如static int a=1;，这样我们就可以在程序的别的地方（只要是在这个static对象的作用域内访问它）操作这个局部静态对象。 在一个程序中多次定义局部静态对象仍然是不被允许的。但是当一个函数里的对象被定义为局部静态对象，多次调用这个函数并不会重置这个局部静态对象的值。它自己会记得上一次被函数调用之后的值并继承这个值，不被第二次函数调用的变量定义初始化，这就是它静态的特性。 局部静态变量若没有显式的初始化，则执行值初始化，内置类型的局部静态变量初始化为0。 函数声明（P186，6.1.2）函数声明要在使用这个函数之前。规范的形式是通常放在头文件里。函数声明可以不写形参的名字，只写形参的类型。 函数声明也称作函数原型(function prototype)。1234567891011121314151617181920// 函数的声明，必须要写在函数第一次被调用之前。 // 这部分的代码可放到头文件中，用的时候include进来就可以了(分离式编译) int func(char, int); // 只要函数在被调用前声明了，那函数的定义可以写在声明之后的任意的位置， // 如这里的func就可以在声明之后、main函数之前定义； // 如果func没有在调用前声明，则必须要在被调用前定义(相当于把main函数后面的func那段代码放在这里实现) int main() &#123; return func('a', '1'); // 函数的调用，虽然func在main后定义，但是因为之前对func进行了声明，所以编译器知道这个函数的三要素是啥 &#125; /* * 函数的定义的参数列表中各参数的类型、数量以及位置等需要和声明时的相匹配 */ int func(char c, int i) &#123; // do something return 0; &#125; 传引用调用（P189，6.2.2）当函数的形参是一个引用类型的时候，在使用函数时，这个函数的引用形参就绑定在了传入的实参上，这种函数调用就叫做传引用调用。在函数涉及到一些比较大的类型对象作为参数的时候，通常地我们使用传引用调用，这样就可以避免实参初始化形参带来的拷贝。在C语言里经常传入指针避免拷贝，在C++里，一般使用引用。 大多数情况下函数只能有一个返回值，因此在我们需要的时候，我们可以传一个额外的引用的参数在函数里面。这样函数体内就可以改变引用的值进而改变函数外部被引用连接的对象的值，从而返回多个数值。 const形参和实参（ P190，6.2.2）函数形参的类型也可以是带const的类型。 顶层const作用于对象本身（离对象最近的const），实参初始化形参的时候会忽略掉顶层const。即形参的顶层const被忽略掉了。 12void fcn(const int i); //fcn 能读取i，但不能向i写值。void fcn(int i); //错误，重复定义了fcn(int)。 因为顶层const被忽略掉了，所以第二个fcn是错误的。 形参的初始化方式与变量的初始化方式一样。先回顾一下变量的初始化：12345678int i = 42;const int *cp = &amp;i; //正确，但是cp不能改变iconst int &amp;r = i; //正确，但是r不能改变iconst int &amp;r2 = 42; //正确，参见P55。int *p = cp; //错误，p的类型和cp的类型不匹配int &amp;r3 = r; //r3的类型和r的类型不匹配int &amp;4 = 42; //错误，不能用字面值常量初始化一个非常量引用（参见P45） 将同样的初始化规则应用到参数传递上：12345678910int i = 0;const int ci = i;string::size_type ctr = 0;reset(&amp;i); //调用形参类型是int *的函数reset(&amp;ci); //错误：不能用指向const int对象的指针初始化int *reset(i); //调用形参类型是int &amp;的函数reset(ci); //错误：不能把普通引用绑定到const对象ci上reset(42); //错误：不能把普通引用绑定到字面值上reset(ctr); //错误：类型不匹配，ctr是无符号类型 我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。 当我们接受函数的参数是为了完成比较或者判断等操作，而不需要改变参数的值，我们应该使用带const的参数来确保参数不会被更改。另外，const类型的形参能比普通类型的形参接受更多种类的参数。比如void fn(const string&amp;);这个函数，字符串字面值是const char [ ]类型，因此fn这个函数接受字符串字面值。但是如果声明成了void fn(string&amp;);，那么这个函数就没有办法接受字符串字面值（类似：“string”这样的值就是字符串字面值）。另外，带const的形参也接受带底层const的对象。 传递数组作为参数（P193，6.2.4）又是我们想要向函数传递一个数组，但是数组是不可拷贝的，因此我们不能够通过值传递的方式传递一个数组到函数里，另外，如果数组的内容很大，传递数组的每个元素会带来不必要的拷贝。 以下的方法都基于或类似传递数组的指针。一维数组的指针指向数组的第一个元素。我们可以声明类似如下的形式传递一个数组指针到函数:123void pri(int*);void pri(int []);void pri(int [10]); 这三者是等价的。传递之后形参的类型都是int *类型。 但是正因为数组的信息是以指针的形式传递给函数的，所以函数只得到一个地址，并不知道数组的大小，因此也就很容易访问到未定义的内存区域，因此在传递数组指针的基础上，我们可以通过手动标志数组大小等方法保证函数访问的内存是合法的不越界的。因此衍生出以下几种方法。 第一种方法：在数组的末尾加标记。这种方法类似于C风格字符串，末尾会自动加’\0’来告诉大家这个字符串结束了。在数组末尾加特殊的标记来使数组不越界是简单易用的方法。 第二种方法：使用标准库规范中的begin和end函数。头文件iterator里有针对数组的begin和end函数，返回数组的首指针和尾后指针，指针指向数组元素的类型，这种方法也可以检测越界。 第三种方法：传递一个表示数组大小的参数。这样构建函数时就知道数组有多大了。如print(j, end(j)-begin(j)); 第四种方法：传递数组的引用。除了使用指针，我们还可以使用引用来得到一个完整数组的引用（别名）。声明格式类似下面这种：void fx(int (&amp;arr)[10]);，这里形参的名字是arr，arr前面的&amp;符号代表它是引用类型，引用了一个实参数组，这个数组必须只有10个元素（因为arr后面的[10]也是构成引用声明的必要部分。） 注意void fx(int &amp;arr[10]);这个去掉括号的写法是错误的，不存在引用的数组。 传递多维数组：有时我们也需要向一个函数传递多维数组。多维数组的实质是数组的数组，一维数组的名是指向数组元素的指针，二维数组是指向数组元素的指针的指针。因此想要一个函数传递多维数组的形参声明如下：void fx(int (*arr)[10]);这时arr指向有10个int型元素的数组。当我们把arr+1，它就又指向了新的10个元素，因此arr相当于二维数组的数组名（两者都是指向包含的一维数组首元素的指针）。 也可以用int arr[][10]代替int (*arr)[10]，因为它们是等价的，都是二维数组名。用int arr[][10]这种方式定义形参时，要标出除了第一个维度以外的每个维度。（假设有一个数组int b[2][3]，就说明b有两列，每列3个元素，这里的2就是第一个维度。指向一维数组的指针不关心在这个维度上有几个元素，因此忽略）。 main函数的命令行选项（P196，6.2.5）最开始我们使用UNIX或LINUX系统编程时经常使用没有图形界面的编译器来把写好的代码编译成obj文件，这时候我们使用命令行来编译一份源代码文件，我们需要在终端里输入类似“prog -d -o oflie data0”的命令行来进行命令行控制。 现在我们看到的main函数一般都是int main()，括号里面什么也不写，我们也可以给main传递上述的那个命令行参数。形如：int main(int argc,char *argv[])。 main可以什么参数也不接受，也可以接受一个int和一个指向字符串的指针这两个参数。main没有第三种形式了。 int argc是表示后面的argv一共指向几个字符串用的。char *argv[]里面的每一个字符串都顺序对应着命令行的参数。这些参数的字符串数组的第一个元素应该是可执行文件的名字或者空参数，最后一个字符串的值必须为0。12345678//对于命令”prog -d -o oflie data0“：argc = 5;argv[0] = "prog";argv[1] = "-d";argv[2] = "-o";argv[3] = "0file";argv[4] = "data0";argv[5] = 0; 有关命令行的更多选项和argv参数的具体用法，可以参照对应的编译器文档。 含有可变形参的函数（P197，6.2.6）到现在我们定义的函数都是固定参数的，但是有时候我们无法预知向函数传递几个参数，又想使用一个函数接受这种变化，我们就可以使用C++指定的两种方法来定义含有可变形参的函数。 第一种方法是当参数个数不一定，但是参数类型都相同时，我们可以传递一个initializer_list参数。这是标准库设施中的一部分。 第二种方法在当我们想传递不确定个数的不同类型的实参时要使用的技术：可变参数模板。这个16章才介绍。 其实还有一种方法使函数接受多种形参，不过这种方法多用于和C语言旧代码对接时使用。这个方法用省略符来传递可变数量的形参。 常见的应用场景：日志的打印 initializer_list（P197，6.2.6）下面是关于定义可变形参函数的第一种方法——initializer_list参数的介绍： initializer_list类似vector，是一种容器，接纳一种同样类型的元素。initializer_list定义在同名的&lt;initializer_list &gt;中，我们可以把任意数量，同样类型的参数传递给这个容器使函数能够处理多个元素。 initializer_list支持的操作包括：123456initializer_list&lt;容器内元素的类型名&gt; 容器名 //默认初始化一个 initializer_list空容器initializer_list&lt;容器内元素的类型名&gt; 容器名&#123;元素值1，元素值2，元素值2...&#125; //大括号初始化initializer_list 容器名1（已被定义的initializer_list 容器的容器名2 ）//使容器1的内容和容器二一致，两个容器共享容器二里面的元素。不会形成拷贝，（也可以用initializer_list 容器名1=initializer_list 容器名2）initializer_list 容器名.size() //元素数量initializer_list 容器名.begin() //指向首元素的迭代器initializer_list 容器名.end() //尾后迭代器 initializer_list里面元素的值永远是常量不能被更改，如果里面的元素是指针或引用，这个元素的属性将被自动加上底层const。当我们声明一个接受 initializer_list类型的函数 void fa(initializer_list&lt;int&gt; list1);的时候，我们需要使用大括号来调用这个函数，形如fa({2,3,4});这样我们就向initializer_list传递了一个值的序列。我们也可以声明void fa(string b,initializer_list&lt;int&gt; list1);这种函数。 省略符形参（P199，6.2.6）下面是关于定义可变形参函数的第三种方法——省略符形参的介绍。 省略符形参有下列两种形式：12void foo ( parm_list , ...); void foo ( ... ); 第一种形式为特定数目的形参提供了声明。在这种情况下，当函数被调用时，对于与显示声明的形参相对应的实参进行类型检查，而对于与省略符对应的实参则暂停类型检查。在第一种形式中，形参声明后面的逗号是可选的。如果没有逗号，相应地，就变成了第二种情况。 省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类型的对象在传递给省略符形参时都无法正确拷贝。（感慨：所以说有什么用？还是用intializer_list吧？） 你可以传递任意数量的参数给省略符形参。要注意省略号的优先级别最低，所以在函数解析时，只有当其它所有的函数都无法调用时，编译器才会考虑调用省略号函数的。(optional)首先，如果要用省略符的方式处理不定参数的函数要包含头文件：#include &lt;stdarg.h&gt; （C语言中）或者#include &lt;cstdarg&gt;（C++中）。 然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。用省略符处理不定参数的函数基于C语言的方法，在C++中不建议使用。（使用了C语言标准库功能varargs）。 返回值（P202，6.3）在void返回值的语句最后会隐式地有return;语句，这时函数什么也不返回。 不要返回局部对象的引用或指针。 函数可以返回一个非常量引用作为左值。也可以返回一个花括号括起来的列表，来初始化vector等类型。 1234vector&lt;string&gt; test() &#123; return &#123;"hello", "world"&#125;; &#125; main函数的return语句可以不写，编译器会带为隐式补充。 main 函数不能调用自己。 返回数组指针（P205，6.3.3）虽然我们不能直接让函数返回一个数组，但是我们可以设定函数返回一个指针的类型。函数会返回数组的指针。返回数组指针的函数定义语句如下所示：1数组元素类型 （*函数名 （参数列表））[ 数组大小 ] 当然，返回一个临时量或者局部对象的引用/指针都是错误的行为，如果你在函数里普通地定义了一个数组，那么这个数组的生命周期在函数返回时就结束了，会被内存中释放，因此可能需要用static使这个数组静态。静态对象只是延长了对象的生命周期，但是无论如何在函数内部定义的对象在外部都无法访问，除非使用返回指针的方法。 一条double (*func(int a))[10]这种语句来说明函数接受一个int a形参并且返回一个带有10个元素的double数组，这种语句在写法上比较乱，因此C++11提供了尾置返回的方法让程序员不必要非要迁就编译器的理解能力，上一条语句等价于这样：auto func(int a)-&gt;double(*)[10]我们使用-&gt;符号把返回值类型的描述放在了参数列表后面并和函数声明分离开让函数看起来不那么乱。 我们也可以使用decltype语句返回数组指针。decltype后面的括号可以括起一个现有的数组推导数组类型。我们再手动加*得到数组指针类型的返回值。在已有int a[10];的情况下，我们可以使用decltype(a) *fn(int b)这种形式定义一个返回指向数组的指针的返回值类型。 函数重载（P207，6.4）我们可以定义一组功能类似，函数名一致，但是接受的参数类型或数量不同的函数。定义多个这种函数就叫做函数重载。函数重载可以提供给我们用一个函数名处理多种参数形式的情况。 定义重载函数要能重传入的参数里区别出实质不同的重载函数，如函数A的定义为int fa(const int a);和函数B int fa(int b);这两个函数函数名一样，形参类型不同，但仍然无法作为重载函数。因为我们传入一个int值时，fa不知道应该执行第一种还是第二种。所以只有参数顶层const属性不同的几个函数不是重载函数。 形参相同，但返回类型不同的函数也不能构成重载。 当然，对于底层const，比如参数列表为const int *a的函数和参数列表为int a的函数能被看出不同，因为对于一个传入的const常量指针，这个实参只能初始化const int *a，不能被初始化int a。当同时有这两种形式的重载函数时，当传入一个非常量，IDE会优先选择为它匹配形参为int a版本的普通变量形参函数。 形参是某种类型的引用或指针，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载。（此时的const是底层的） const_cast和函数（P209，6.4）这里主要介绍const_cast类型强制转换是如何在函数中被使用的。在第四章(4.11.3, P145)第一次接触const_cast的时候我们提到过这个常被用于函数里。这里我们就看看怎么使用。 之前说过，向函数传递参数时最好传递const型参数使其能够接受多种参数，这里我们可以在函数体内使用const再把参数变回普通的变量，这样就可以返回一个非const值了。 重载和作用域（P210，6.4）声明变量时，变量的作用域就在块里，声明函数也一样，而且里层的作用域会隐藏外部的作用域。例子如下：1234567&#123; int a=0; //这里是a的外层作用域 &#123; double a=1.2; //外边已经有a了，这里又声明了一个a，因此这个a的作用域覆盖了前面的int a； cout&lt;&lt;a&lt;&lt;endl; //输出的会是1.2 &#125;&#125; 函数声明也一样，12345678&#123; int fa(int b); //这里是函数fa的外层作用域 double fa(double b); //重载了函数fa使它能够接受double &#123; double fa(string &amp; c); //外边已经有fa了，这里又声明了一个fa，因此这个fa的作用域覆盖了前面的; fa(2.3); //错误，原型为double fa(double b)的函数声明作用域被double fa(string &amp; c);覆盖，匹配不到函数 &#125;&#125; C++中，名字查找发生在类型检查之前。 特殊用途语言特性（6.5）默认实参（P211，6.5.1）有时候一些函数我们每次调用它总会向它传递一些特殊的值。我们可以声明带有默认实参的函数。默认实参如果没有明确说明，默认实参会被自动当做函数的初始值传递进去。形如int fn(int a,int b=2,double c=3.3)这样定义函数头的方式就给了b和c默认的实参，注意，当一个形参被给了默认实参，它后面的所有参数都要有默认实参才行。 当我们想使用默认实参的时候，只要调用函数的时候使用这种对应的实参就行了，默认实参会用来填补缺少的尾部实参，上面的定义的函数如果这么调用：fn(1,2);，double c的值会被自动设为3.3。书写这种函数时要尽量保证要经常用到的默认实参放在参数列表的更后面一点，这样才合理。 可以只在函数声明里标注默认实参不在函数定义里这样写，结果仍然将是正确的。void fn(int = 1, int = 2, int =3);这种函数声明语句省略了形参的名字，不过也是可以的。 通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。 局部变量不能做默认实参，默认实参的定义在函数体之外。另外，默认实参是可以在名字的作用域内通过名字更改的。 内联函数（P213，6.5.2）有时我们要频繁调用一个优化规模小，流程直接，频繁被调用的函数，定义函数时我们可以在返回值类型前面加上关键字inline使它成为内联函数，减少运行时的开销。 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。 constexpr函数（P214，6.5.2）这是一种能够被用在常量表达式的函数，但是函数的返回值类型和形参类型必须都是字面值。函数体中必须有且只有一条return语句，constexpr函数被隐式的指定为内联函数。const函数中也可以有类型别名，使用作用域声明等不执行操作的其他语句。这里没有赋值，没有构建对象。同时constexpr可以返回计算后的结果。如constexpr int fn(int a){return a+22;}，这条定义是正确的，前提是调用函数这个函数fn时，传入的实参是一个常量。比如fn(3);123456constexpr new_sz() &#123; return 42; &#125;constexpr size_t scale(size_t cnt) &#123; return new_sz() * cnt; &#125;int arr[scale(2)]; //正确，scale(2)是常量表达式int i=2;int a2[scale(i)]; //错误，scale(i)不是常量表达式 内联函数和constexpr函数通常定义在头文件中。 调试帮助（P215，6.5.3）程序员在写程序时可能涉及到一些调试中的代码，这些代码只在开发程序时使用，当即将发布程序的时候，要暂时屏蔽掉正在调试中的代码。C++提供了assert和NDEBUG两个预处理功能屏蔽测试代码。 assert预处理宏assert这个宏定义在cassert头文件中，assert使用一个表达式作为它的条件，形如assert(expr);首先对expr或者表达式求值，如果结果为真（非0），那么assert什么都不做。如果结果为假(表达式值为0)，那么assert输出信息并且终止程序的执行。 assert经常用于处理不能发生的条件，如果你写了一段代码，代码没测试越界，你就可以用assert，当它越界了我们就结束程序的执行。 NDEBUG预处理变量NDEBUG宏定义可以影响assert的行为，这个默认是没被定义的。当我们宏定义了NDEBUG，就屏蔽掉了assert的功能。 可以使用NDEBUG编写自己的调试代码。 此外，IDE还提供了__FILE__(这里是两个英文下划线，这个存放文件名) 、__func__（这个存放所在的函数名) 、 __LINE__（这个存放所在的行数) 、__TIME__（这个存放调试的时间) 、 __DATE__（这个存放调试的日期) 这五种静态数组来提供错误信息。 函数匹配（P217，6.6）程序员定义重载函数之后就可以使用它们了，挑选到底使用哪个版本的函数是一个过程，这个过程叫做函数匹配。 函数匹配的第一步是在调用时先找与与调用函数同名的函数名。且调用点在函数作用域内。这一步筛选出的函数叫做候选函数。 函数匹配的第二步是从候选函数中选择出能够被本次函数调用的实参传入的函数，函数名一致的前提下还要求函数的形参个数和实参一致，实参能够转化成（或者就是）形参规定的类型。这一步筛选出的函数叫做可行函数。 寻找最佳匹配。当有int fn(int a);和int fn(double a,double b=1.0)时，我们调用函数fn形如fn(3.4);显然这两种函数都是可行函数，这是我们再寻找最佳的匹配，因为fn(3.4);对应fn(double,double=1.0);的话无需转化，因此是最佳匹配。当有多个最佳匹配的时候函数将停止调用。 为了划分最佳匹配的各种情况，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示： 精确匹配：精确匹配可以包含以下情况：数组名转化成数组指针的匹配，函数类型转换成函数指针的匹配，实参类型与形参类型相同。另外，像实参添加顶层const或者忽略实参赋值给形参的顶层const也属于精确匹配。 通过指针的转换把非常量指针转换成常量指针。 通过类型提升实现的匹配。 通过算数类型转换或指针转换实现的匹配 通过类类型转换实现匹配（类类型转换还没有讲） 要注意小整数字面值会被自动转换成int，而带小数点的字面值会被默认转换成doube。 函数指针（P221，6.7）声明一条函数指针的语句如下: int (*PtrOfFunc)(参数列表)，其中PtrOfFunc就是指向函数的指针。我们可以把函数名赋值给定义的函数指针的名字。 *PtrOfFunc两端 的括号不能少。 返回函数指针的形参定义为double(*fn(int a)) (int d,char b);这里声明的函数是fn，函数的形参是int a，返回值是函数指针类型的，返回的函数指针对应的函数的返回类型是double，参数是int d,char b。 和处理数组一样，我们也可以使用尾置返回来返回一个函数指针，尾置返回函数指针的声明是auto fn(int a)-&gt;double (*)(int d,char b);尾置返回适合用来返回复杂的类型比如数组，函数指针等等。 遇到double(*fn(int a)) (int d,char b);这种复杂的表达式，应该以定义的变量名为中心，从里往外一层层往外扩展。这个函数的定义语句里面，fn就是其中的变量名，看它右侧，有（int a）,这（int a）是一个形参列表。因此得出结论fn的本质是一个函数，再看左侧，*代表这个函数返回一个指针，这个指针的类型在更外层（double (*) (int d,char b)）型。 当然这种声明/定义容易让人心累，所以这种情况下使用auto fn(int a)-&gt;double (*)(int d,char b)是不错的选择。如果这样还是觉得太长了，可以使用typdef，USING等重命名语句加上decltype推导。比如tpyedef double func (int d,char b);这样的语句之后，func就是一个函数类型。 也可以使用tpyedef decltype(fn) func2;这条语句等价于上面的语句。对于using语句，using Func2 = double (int d,char b);即可。可见typedef和using的替换原则是不同的，在涉及到复杂类型的时候，类似数组，函数指针，tpyedef的替换名要和被替换的类型一起被声明。 123456789using F = int(int*, int); //F是函数类型，不是指针using PF = int (*) (int *, int); // PF是指针类型PF f1(int); //正确，PF是指向函数的指针，f1返回指向函数的指针。F f1(int); //错误，F是函数类型，f1不能返回一个函数F *f1(int); //正确，显式地指定返回类型是指向函数的指针。// 当然也可以使用下面的形式直接声明f1int (*f1(int))(int *, int); 术语表(P225)1.函数 function2.形参 parameter3.调用运算符（一个动作） call operator4.实参 argument5.主调函数 calling function6.被调函数 called function7.生命周期 lifetime8.局部变量 local variable9.自动对象 automatic object10.局部静态对象 local static object11.函数原型 function prototype12.分离式编译 separate compilation13.可执行文件 executable file14.引用传递 passed by reference15.传引用调用 called by reference16.值传递 passed by value17.传值调用 called by value18.重载 overloaded19.函数匹配 function matching20.重载确定 overloaded resolution21.最佳匹配 best match22.二义性调用 ambiguous call23.默认实参 default argument24.预处理宏 preprocessor marco25.候选函数 candidate function26.可行函数 viable function27.递归循环 recursion loop28.递归函数 recursive function29.尾置返回类型 trailing return type 参考资料 C++ Primer 中文版 第5版 C++primer第五版第六章学习笔记 C++Primer第5版学习笔记（六）]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(四/五)表达式和语句]]></title>
    <url>%2F2018%2F01%2F05%2FCPP_04_05%2F</url>
    <content type="text"><![CDATA[第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成： 表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。 各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。 类型转换，包括隐式和显式两种转换的规则。 表达式基础表达式的基本概念(P120，4.1.1)表达式由一个或者多个运算对象组成，多个对象组成表达式时，对象之间用运算符连接形成复杂表达式。 运算符中，需要两个对象和运算符连接形成表达式的这种运算符叫做二元（双目，二目）运算符。 分析一个表达式，必须先了解运算对象的含义、运算符的优先级(precedence)、结合律(associativity)和运算符的求值顺序(order of evaluation)。 对于含有子表达式的复杂表达式，应该按照求值顺序，看看应该先求哪一个子表达式的值。 对于不那么复杂的子表达式，应该按照优先级，查看表达式中的每个操作数（对象）应该先跟那一个运算符在一起运算。 如果有优先级相同的运算符同时在同一个运算对象左右，应该按照结合律选定结合顺序是从右向左还是从左向右计算表达式的值。 左值和右值(P121，4.1.1)起源：左值和右值原来是C语言中的概念，特指赋值运算符左右两段的表达式。C语言中，能放在赋值运算符左侧被赋值的对象就是左值，反过来在赋值运算符右侧的对象就是右值。C++中的这两个概念的词义发生了改变。 概述：可以暂时概述一下C++中左值和右值的概念。从性质上来看，当一个对象做右值时，我们使用的是这个对象的内容（值）；当一个对象做左值时，我们使用的是它对象的身份（在内存中的位置）。 应用：表达式中有的位置需要的是左值，有的位置需要的是右值。表达式的值本身也有左右的分别。赋值运算符中左侧操作数和表达式结果都是左值。取地址符的操作对象是左值，得到的是右值。解引用、下标运算符的求值结果是左值。decltype作用于表达式时，如果表达式的结果是一个左值，decltype会返回一个引用类型。 优先级和结合律（P122，4.1.2）1.优先级 复杂表达式中一个运算对象连接多个不同运算符时，哪个运算符优先级高，就先计算哪个运算符和对象作用后的值。 2.结合律 复杂表达式中一个运算对象连接多个优先级相同的运算符时，根据这一优先级对应的结合律，按从右至左或者从左至右的顺序计算表达式的值。 如3+2*4-7；这个表达式是一个复杂表达式，因为表达式里*号优先级比较高，所以先计算2*4，得到3+8-7；得到的新表达式更简洁了，只剩下+-两个符号，这两个符号优先级相同，因此查看这个优先级对应的结合律可知这一级别的符号满足左结合性。因此从左向右计算，得到11-7；进一步得到结果4。 括号无视优先级和结合律，可以考虑多使用括号。 求值顺序（P123，4.1.3）一个表达式里如果运算对象都是函数返回的，都需要计算求值才知道对象的状态，函数调用符号优先级一致，中间隔着几个优先级低的其他符号连接操作对象，比如int a=f()+g();，这时候是函数f()先被调用还是g()先被调用呢？答案是未定义。C++语法没有规定这种情况应该谁先谁后。 就像下面的表达式++i+i++这个表达式中，优先级最高的表达式++i和i++中间隔着优先级低的运算符+，关于++i先计算还是i++先计算，这是未定义的，而因为这个表达式先计算++i或先计算i++的结果不同，所以这条表达式是错误的。一个变量如果在同一个表达式里被多次改变，这个表达式的求值顺序又不一定，就会出现二义性。应该避免这样的写法。 目前只有四种运算符明确规定了求值顺序。 逻辑运算符&amp;&amp;和||(P126)：这两个运算符先计算左边操作数的值。 条件运算符?:(P137)：条件运算符先计算？前的表达式，并求值，之后对视情况对：左右侧的表达式求值。 逗号运算符，(P140) ：这个运算符的求值顺序是从左至右。 处理复合表达式的两点建议：①拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求；②如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。 关于运算符，左值和右值的归纳本章各种运算符形成的表达式所返回的值的属性和运算符需要的操作数的属性如下： 算数/逻辑/位运算符： 操作对象和结果都是右值 赋值运算符：左侧的操作对象必须是可以修改的左值，右侧的操作对象是右值，返回一个左值。 递增/递减运算符： 前置版本的++/–返回左值，后置版本的++/–返回右值。操作对象都必须是左值。 箭头成员访问运算符： 作用于指针，表达式结果是一个左值。 点成员访问运算符: 这个成员所属的对象是左值，结果就是左值；这个成员所属的对象是右值，结果就是右值。 条件运算符： 条件运算符的三个表达式都是左值或者都能转化成左值类型时，结果为左值；否则是右值。 算术运算符(P124, 4.2)除法和取模的结果 （P125，4.2）两个非浮点型变量/字面值相除，结果还是原来的类型，不会有原来操作数是整数，运算之后结果是小数的情况。C++11中， 对于除运算符，结果向零取整（直接切掉小数部分，得到的数就是结果）。对于取模运算符，结果的符号和被除数的符号一致。（之前的语法标准里除法的结果可以选择是否向零取整，求模（模就是余数）运算可选符号） (-m)/n = -(m/n); m/(-n) = -(m/n);m%(-n) = m%n; (-m)%n = -(m%n); 成员访问运算符(P133, 4.6)点运算符和箭头运算符都可以获取类对象的一个成员，ptr-&gt;mem 等价于 (*ptr).mem。 解引用运算符的优先级低于点运算符，所以(*ptr).mem中的括号不能省略，否则出错。 条件运算符(P134, 4.7)条件运算符的格式：1cond?expr1:expr2 条件运算符允许嵌套。 位运算符（P136，4.8）bitset的标准库类型可以表示任意大小的二进制位集合。 关于符号位没有明确的规定，因此强烈建议仅将位运算符用于处理无符号类型。 左移运算符移动二进制数后会在右侧插入零，右移运算符在处理有符号类型的操作数（尤其是带负号的）时具体行为由环境决定。 运算符 功能 ～ 位求反 &lt;&lt; 左移 &gt;&gt; 右移 &amp; 位与 ^ 位异或 &#124; 位或 【写博客相关】表格中竖号的打法：&amp;#124;，或者中文格式的丨（输入法输入“shu”查找） 移位运算符（也叫IO运算符）满足左结合律。 sizeof运算符（P139，4.9）sizeof运算符有两种用法：12sizeof(type)sizeof expr 第一种是sizeof后面直接加一条表达式语句；第二种形如sizeof (类型名)；第二种形式后会得到该类对象所占空间的大小。第一种形式中，如果表达式是指针类型，sizeof运算符会返回指针本身的大小。当有一个类名叫data，类中有一个成员叫做student时，可以使用作用域标识符和sizeof联动，使用sizeof(data::student);就可以计算出student占字节数。 隐式类型转换（P141，4.11）概述：在C++中，一些类型可以按照一定规则互相转换，很多时候语境中需要使用两个或多个相同的类型才能继续运算。因此这时一种类型的值会被自动转换成另一个类型的值。这个过程就是隐式转换，其中算术隐式转换较为常见。 主要的隐式转换发生的情况： 大多数表达式中，比int小的类型会被提升为int型。 在条件中，非布尔值要转化成布尔值。 在初始化和赋值语句中，赋值符号的右侧对象的类型转换成左侧对象的类型进行运算。 算术/关系运算中对象有有多种类型的，转化成同一类型。 形参转化为实参的类型（第六章）。 数组名会被转换为指针。 0，nullptr会转为任何类型的指针。任何类型的指针都可以转化为（const）void *类型。 算数转换时发生隐式转换的补充：在算术运算符的作用下，不同的操作数要转换成同一个类型才能够进行计算。以i+a；这个表达式举例，了解算术转换的方式。 首先，当i和a的类型占字节比int小，如char、short，把他们转换为int型。如果他们原来类型的最大值在当前系统里大于int型最大值，则转化成unsigned int型。 之后，如果i和a的类型相同，结束算数隐式转换，若i和a的类型不同，把占字节少的类型的对象转成占字节多的类型的对象。 如果占字节多的带符号类型的最大值小于占字节少的带转换对象的最大值，带符号类型将被转换为无符号类型。 显式转换（P144，4.11.3）显式转换就是强制类型转换(cast)。 一个命名的强制类型转换具有以下形式：cast-name&lt;要转换成的类型&gt; （被转换的值）；其中，cast-name是四种强制类型转换：static_cast、dynamic_cast、const_cast和reinterpret_cast之中的一种。 static_cast用于常见的强制类型转换。只要两个类型有关联，比如浮点数类型和整数类型，整数类型和布尔值类型，布尔值类型和指针类型，就可以使用static_cast。只是不能转换常量const到变量。 const_cast用于去掉（或者加上）对象的底层const，要转换的类型和转换的类型都必须是指针或者引用类型。常用于将在第六章介绍的函数重载。当然，这个重载只能针对指针或者引用类型。 reinterpret_cast依赖机器，是强行改变一个类型到另外一个不相干的类型。 dynamic_cast支持运行时类型识别，在19章(P730)将会提到。 建议：避免强制类型转换。 运算符优先级列表的规律（P147,4.12）优先级和结合性是第四章的重要内容，因此第四章之后给出了完整的优先级和结合性的参考表。这里是有一定的规律的。 首先优先级最高的运算符都有这样的属性：单独拿出这个运算符左面的操作数和右面的操作数都没有意义。即运算符本身是连接两个名字组合一个概念的连接器。比如优先级最高的运算符::（作用域运算符），优先级比较高的点运算符（成员选择）下标运算符[]。 比连接不同名字形成概念的这种运算符稍微低一级别的就是计算对象本身的运算符，比如++，–，类型转换，位求反，逻辑非，解引用，取地址，求类型占的字节数这些运算符大多都是单目元素符，他们的运算目的一般是根据操作数本身的属性进行计算或者改变操作数本身。 算术运算符。 逻辑运算符。 条件运算符。 赋值运算符 。 复合赋值，抛出异常，逗号运算符等。 术语表(P149)1.运算对象 operand2.结果 result3.一元运算符 unary operator4.二元运算符 binary operator5.优先级 precedence6.结合律 associativity7.求值顺序 order of evaluation8.提升 promoted9.重载运算符 overloaded operator10.右值 rvalue11.左值 lvalue12.复合表达式 compound expression13.短路求值 short-circuit evaluation14.高位 high order position15.逗号运算符 comma operator16.相互转换 conversion17.隐式转换 implicit conversion18.算术转换 arithmetic conversion19.整型提升 intergral promotion20.运算对象 operand 语句简介第五章是和语句有关的知识，语句也是C++的重要组分，本章由三部分组成： 语句的概念，包括简单语句和语句作用域的概念。 条件/循环/跳转语句,条件语句主要包括if/else语句、switc语句和？：表达式条件语句；循环语句则是for语句和while语句；跳转语句包括continue、break和goto语句。 try/throw和异常处理，包括异常处理的使用方法。 语句作用域（P155，5.2）用花括号括起来的块就是作用域的标志。在作用域中定义的对象只在作用域中起作用。块之外是没法访问和控制块内部的变量的。 尤其是在switch语句中，switch的执行过程可能跨过一些标签，当标签里声明并定义了一个对象，这个对象的作用域就延伸到了所有case标签里，如果case 1定义了int a；switch执行了case2，这时这个我们不想执行的语句却产生了自己的作用域，这显然是不行的。因此可以在case标签后使用大括号形成块，这样就不会出现作用域的问题。 goto也一样不能向前（代码的后几行）跳过对象的定义。不允许跨过变量的定义到达变量的作用域内。但是goto语句可以向后（代码的前几行）跳过定义。 不要在程序中使用goto语句，它会使得程序既难理解又难修改。 try语句块和异常处理（P172，5.6）可以用try\throw和catch联动进行异常处理，形式如下：123456try&#123;待检测块&#125; //待检测块里面包括throw语句来抛出异常catch (异常类型 异常对象的对象名)&#123;异常处理语句 &#125;catch （同上，可以写很多catch）&#123;另一组异常处理语句&#125; throw抛出异常和catch处理异常的头文件都在stdexcept里定义。抛出异常的语句形如：1throw 异常类型（"异常文本"）； 异常类型一般只支持赋值，初始化，调用成员函数.what之类的几种操作。 术语表1.控制流 flow-of-control2.表达式语句 expression statement3.空语句 null statement4.复合语句 compound statement5.悬垂else dangling else6.case标签 case label7.引发（异常） raise8.catch子句 catch clause9.异常处理代码 exception handler10.异常安全（这不是特别安全的意思，而是在异常情况下也能保证程序执行预期的正确行为） exception safe 参考资料 C++ Primer 中文版 第5版 C++Primer第5版学习笔记（四、五） 用Markdown写Hexo博客时如何转义竖杠 | ？]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(三)字符串、向量和数组]]></title>
    <url>%2F2018%2F01%2F04%2FCPP_03%2F</url>
    <content type="text"><![CDATA[第三章主要讲这么五个概念： 1.using声明，我知道挺多同学写代码练手都要在源文件前几句直接加using namespace std;然而using语句并不是什么情况都这么使用的，稍后我们将会看到详细的用法。 2.标准库类型string,和C的字符数组有区别的string，到底是怎么个构造，这章将会讲述。 3.标准库类型vector，vector和数组区别很大，这里将会提到，并引入一个“容器”的重要概念。 4.迭代器，迭代器用来代替下标这种传统方式访问容器或一些支持迭代器的类型。 5.数组和多维数组，经典概念。 命名空间的using声明(P75,3.1)尽管我们可以在各种文件里都使用using namespace std;或者using std::endl;这种语句，但是，在头文件包含命名空间可能产生各种意外。因此，头文件不应包含using声明。 标准库类型string本节介绍最常用的操作，9.5节将介绍另外的。 定义和初始化string对象(P76,3.2.1)12#include &lt;string.h&gt;using std::string; 以下几种初始化语句被string支持： 123456string s1;//创建了一个空的字符串，对象名为s1，类型为string类型。string s2(s1);//是s2的值与s1的值相等。string s2=s1;//同上一句，拷贝初始化。string s3("value");//直接用字符串字面值初始化string类型的对象。string s3="value";//字符串字面值转化为string类型变量并赋值给string。string s4(10,'c');//直接初始化string，操作后s4拥有10个字符，每个字符的值都是'c'。 最后，其实string s5={&quot;value&quot;}和string s3=&quot;value&quot;一样，也是合法的。不过大括号初始化是严格检测匹配的，比如int a={3.5};就是错误的。 string支持的操作(P77,3.2.2)1.输入流中获取字符串首先要强调是cin&gt;&gt;string的操作，这种操作就是从输入流中读字符串，值得注意的是这个过程会忽略掉开头输入的各种空白（我们说空白时是在说 空格，换行符，制表符）,读取输入流直到遇到字符后的第一个空白为止。 另一种getline（cin,string）;的操作(P78) 则可以读一行，也就是读入输入流的数据（包括空格，制表符），直到遇到换行符为止，这里输入流中的换行符本身已经被读过了，但是字符串里不保存这个换行符。下次再从输入流里读什么数据至少也要从这个换行符后面对输入流进行操作了。 2.string::type_size (P79)为了更抽象，脱离机器特性，调用每个string对象的size成员函数，返回值都是一个string::type_size类型，这个类型拥有无符号整形数的一些性质。在string对下标的支持中，[ ]中的数字也会被转换为string::type_size类型。这里要强调的是string::type_size是一个无符号类型。使用这个类型和int型这种有符号的类型一起进行计算可能出现一些错误。1auto len = line.size(); //len的类型是string::size_type 如果一个表达式中已经有了size()函数，就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。 3.string对象与字符串字面值相加 (P80)字符串字面值是字符数组类型，字符串字面值和string类型的对象在一起计算时会被自动转换为string类型。 4.其他支持的操作包括下标运算符[ ]、重载的+、==、！=、&lt;、&gt;、&lt;=、&gt;=。 处理每个字符的头文件cctype（P82, 3.2.3）我们可以通过引用头文件&lt;cctype&gt;的形式处理每一个字符。这个头文件包含很多方便处理字符的函数。列举如下： isalnum(c); //当c是字母或者数字时为真 isalpha(c); //当c是字母时为真 iscntrl(c); //当c是控制字符时为真 isdigit(c); //当c是数字时为真 isgraph(c); //当c不是空格但是可打印时为真 islower(c); //当c是小写字母为真 isprint(c); //当c可打印时为真 isupper(c); //当c是大写字符时为真 isxdigit(c); //当c是16位数字时为真 ispunct(c); //当c是标点符号时为真（一个字符除了控制字符，字母，数字，可打印空白就是标点符号） isspace(c); //当c是空白时为真（空白包括空格，横向/纵向制表符，回车符，换行符，进纸符） tolower(c); //把大写字符转换为小写字符，本来就是小写字符的不变，返回转换后的字符 toupper(c); //把小写字符转换为大写字符，本来就是大写字符的不变，返回转换后的字符 建议：使用C++版本的C标准库头文件。C++标准库兼容了C语言的标准库。C语言的头文件形如name.h，C++则会将这些文件命名为cname。也就是去掉了.h后缀，在文件名前添加了字母c。 范围for（range for）语句(P82，3.2.3)范围for语句用于遍历元素。形如： 123for(一个用于访问序列中基础元素的变量a : 被访问的序列对象b)&#123; statement..... blabla;&#125; 首次初始化，变量a的值会被初始化为对象b序列中的第一个元素，迭代之后每次访问下一个元素，直到序列被完全访问结束。 可以使用auto &amp;a的方式声明变量a,使变量绑定到具体的序列元素上，从而进行更改。如在for(auto a : str){}中，每次把a初始化的行为实质上是使a获得str每个元素的副本（拷贝），而for(auto &amp;a ： str){}这样的语句则使a成为了str对应的每个元素的”别名”,从而可以修改str。 使用范围for循环遍历多维数组，为了不手动打类名，也为了防止外层数组的名被auto类型转化成指针，要在对外层数组的访问上都加上&amp;绑定。 范围for有空补，未详看。 标准库类型vector(P86, 3.3)类模板、容器和实例化(P87, 3.3)当我们在C++里面谈论容器这个概念时，我们应该知道容器是用来存储和组织一类特定对象的集合。下面提到的标准库类型vector，就是一个容器。 类模板一般用于按照模板规定好的规则生成不同的类。我们无需很麻烦的一个一个写类的定义，只需使用模板，给出指定的少量信息，类模板就会帮助我们自动生成一个我们可以直接使用的类。vector也是一个类模板。 通过类模板创建类的过程，或者通过类型创建对象的过程，就叫做实例化。 定义和初始化vector对象(P87,3.3.1)与string的定义和初始化一样，我们也可以使用多种方式定义和初始化一个vector对象。 以下几种初始化语句被vector支持： 12345678910111213vector&lt;Type&gt; v1;//创建了一个空的vector容器，这个容器是Type类型对象的集合，这个集合名字叫做为v1，执行默认初始化。vector&lt;Type&gt; v2(v1);//创建了一个叫做v2的vector容器，这个容器的内容和v1相同。vector&lt;Type&gt; v2=v1;//同上一句，拷贝初始化。vector&lt;Type&gt; v3&#123;a,b,c,...&#125;;//v3包含了初始值个数的元素。vector &lt;Type&gt; v4=&#123;a,b,c,...&#125;;//同上。vector &lt;Type&gt; v5(n,val);//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都是val。vector &lt;Type&gt; v5(n);//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都被默认初始化。 当我们使用圆括号（）初始化对象时，IDE会认为我们在通过语句“构建”(constract)这个对象 ；当我们使用花括号{ }初始化对象时，IDE会认为我们在列表初始化(list initialize)对象。 当我们使用等号=初始化对象时，我们就执行了“拷贝初始化”；当我们不使用=初始化对象时，我们就执行了“直接初始化”。 但是当我们在花括号里面给一个不符合对象类型的值，IDE就会认为我们正在构建而非初始化对象，一个体现就是：1vector&lt;string&gt; v7&#123;10&#125;; 这个语句中，10不能转换为string，因此被系统理解为“这个string容器里有10个元素”。当然，像vector &lt;string&gt;s1={10};这样的语句是错误的，因为=就应该是拷贝初始化了，然而10并不能够被转化为string因此也无法赋值。 向vector对象添加元素(P90, 3.3.2)向vector对象添加元素：push_back。 循环体内部包含向vector对象添加元素时，则不能使用范围for循环。 vector支持的操作(P91, 3.3.3) 向容器的后面添加元素：已存在vector&lt;T&gt; v;，可以使用 v.push_back(vector&lt;T&gt; a)的方式在集合v的尾部添加元素。 empty和size函数成员：已存在vector&lt;T&gt; v;，可以使用 v.empty()的方式判断v是否为空，可以使用v.size()的方式返回v的大小。 重载的运算符：vector支持的运算符包括下标运算符[ ]、重载的+、==、！=、&lt;、&gt;、&lt;=、&gt;=。这一点和string类似。 不能用下标形式添加元素。只能对确知已存在的元素执行下标操作！ 迭代器介绍(3.4)为了访问容器的元素（有些容器可能不支持下标运算符），因此C++提供了迭代器(iterator)这个概念来访问容器中的指定元素。 支持迭代器的类都会提供名为begin和end的函数成员来供我们获取迭代器。如已定义vector&lt;int&gt; i1(10);，这时使用auto ben=i1.begin();这个语句获取指向第一个字符的迭代器，使用auto end=i1.end();获取指向i1容器最后一个元素的下一个元素的迭代器，术语“尾后迭代器”。两个迭代器可以相减，但是两个迭代器相加后的行为是未定义的。 当使用vector &lt;int&gt;创建类时，这个类的命名空间就是vector &lt;int&gt;，命名空间中的迭代器类型写作vector&lt;int&gt;::iterator。因为这个叫做&quot;vector&lt;int&gt;::iterator&quot;的迭代器类型名太长了也不好记，这里我们使用auto推导这个类型。用成员函数cbegin和cend可以推导出底层const迭代器，就是这个迭代器对迭代器指向的内容只读不写。第6章会详细说明。 迭代器 对 迭代器指向的容器内容 可以像 指针 对 指针指向的数组元素一样使用。 虽然数组不是直接支持迭代器的类型，但是可以引入&lt;iterator&gt;头文件，使用begin(数组名)和end(数组名)的方式获得指向数组第一个元素和尾后第一个元素的指针。因为大多数容器不支持下标运算符，所以使用迭代器访问容器等结构中的元素是最好的方法。 数组(3.5, P101)一维数组的定义和初始化(3.5.1,P102)一维数组声明形式：类型名 数组名[一个常量]。比如int a[15];这里这个数组的名字是a，有15个元素，每个元素都是int型的。再比如int *a[15];这里a数组的15个元素都是int *型的，即指向int的指针，这样的指针有15个，构成了一个数组。虽然有指针数组，但是不存在元素都是引用类型的数组。 一维数组的初始化方式就是花括号初始化，形如int a[n]={1,2,3};，大括号里面的内容就是初始化列表，n为数组大小，可以缺省，缺省时数组长度由初始化列表的元素个数决定。当初始化列表的值的个数比数组长度小，数组剩下的元素被初始化为默认的值，比如对于有10个元素的int型数组，如果只给出第一个元素的值，后几个元素将被初始化为0。 当我们声明int a[]的时候代表通过数组名a访问这个数组。我们也可以定义指向数组的指针和指向数组的引用来间接访问这个数组。已有int arr[10];的情况下，int (*ptr) [10]=&amp;arr;这条语句可以使指针ptr指向arr这整个数组。int (&amp;ref)[10]=arr;则会使ref作为整个arr数组的引用。int *(&amp;ref)[10]=arr;这个语句则是说ref是arr的引用，这个被引用的数组的类型是指针数组。 auto a=一个数组名，a的类型将会是这个指针，指针指向的类型就是数组元素的类型。用decltype(一个数组名) a;这样的形式，a将会是和数组名属性一致的数组。在大部分运算中，数组名都会被转化成相应的指针类型。如*(ai+4)中，数组名ai是指向整个数组首元素的指针，这个指针＋4就是向右侧移动4位，指针原来指向第一个元素，移动4位就指向了数组中的第五个元素。然后指向的值就是ai数组第五个元素的值，相当于ai[4]。 用数组初始化vector对象和用string对象赋值字符数组(3.5.5, P111)作为与旧代码的接口，C++提供了方便的把数组转化为vector对象的方法。在声明vector对象时，我们可以通过迭代器用一个数组初始化vector。在已经存在int oldarray[10];的情况下，声明的语句形如：vector&lt;int&gt; arr( begin(oldarray) , end(oldarray) );可以把arr初始化为oldarray。begin和end这两个函数在&lt;iterator&gt;头文件里，作用是返回数组的首元素/尾后指针。这种初始化接受两个参数：拷贝开始部分指针和结束部分的指针。我们也可以写形如int arr[10]={0}; vector &lt;int&gt; newarr( arr+1 , arr+6 );这种方式拷贝数组arr的第2~第5号元素，并用它们初始化newarr。 类似地，我们可以通过string a(&quot;23333333\n&quot;); const char *b=a.c_str();这样的语句使string型的a被赋值给字符数组指针b。返回结果是const是为了确保我们不会通过这个指针改动返回的字符数组的值。 建议： 尽量使用标准库类型而非数组 使用指针和数组容易出错。现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。 术语表1.拷贝初始化 copy initialization2.直接初始化 direct initialization3.范围for range for4.容器 container5.类模板 class template6.实例化 instantiation7.值初始化 value-initialized8.构造 construct9.列表初始化 list initialize10.迭代器 iterator11.迭代器运算 iterator arithmetic12.C风格字符串 C-style character string13.空字符 null terminated14.缓冲区溢出 buffer overflow15.编译器扩展 complier extension 参考资料 C++ Primer 中文版 第5版 https://zhuanlan.zhihu.com/p/23503699]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
        <tag>string</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西瓜书《机器学习》学习笔记(2)：比较检验与偏差方差]]></title>
    <url>%2F2018%2F01%2F04%2FML_chap2_02%2F</url>
    <content type="text"><![CDATA[本篇主要介绍比较检验、偏差与方差。其中，比较检验分为如下四类： 假设检验 交差验证t检验 McNeMar检验 FriedMan检验与Nemenyi后续检验 比较检验(2.4, P37)在比较学习器泛化性能的过程中，统计假设检验（hypothesis test）为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。 假设检验(2.4.1, P38)假设检验(Hypothesis Testing)是数理统计学中根据一定假设条件由样本推断总体的一种方法。 “假设”指的是对学习器泛化错误率分布的某种判断或猜想，如“$\epsilon = \epsilon_0 $”，现实任务中，我们并不知道学习器的泛化错误率$\epsilon$，但是可以通过测试错误率$\hat \epsilon$推算。 在包含了 m 个样本的测试集上，【泛化错误率为 $\epsilon$ 的学习器】被测得测试错误率为$ \hat \epsilon $的概率为：$$P(\hat\epsilon;\epsilon) = \begin{pmatrix} m \\ \hat\epsilon\times m \end{pmatrix} \epsilon^{\hat\epsilon\times m}(1-\epsilon)^{m-\hat\epsilon\times m}$$ 上式中的$\begin{pmatrix} m \\ \hat\epsilon\times m \end{pmatrix} $表示$C_m^{m’}$，即从m个数中任取m’个数。 这个概率，表达了【泛化错误率为 $\epsilon$ 的学习器】被测得【测试错误率】为 $\hat{\epsilon}$ 的可能性。 $\hat{\epsilon} $取0~100%。若以这个【可以测得的测试错误率$ \hat{\epsilon} $】作为自变量，以概率 $P(\hat{\epsilon};\epsilon) $为因变量，建立平面坐标图，则对于不同的测试错误率，有不同的可能性。在某点可能性越高，这个未知的【泛化错误率$ \epsilon $】和这个点代表的测试错误率的关系就越密切。 现在要找其可能性最高的点，就要对概率$ P(\hat{\epsilon};\epsilon)$ 求 $\epsilon$ 的导数，导数为0时，存在极值。 而对此概率函数求导并解出导函数等于0的式子之后，发现存在一个值 $\epsilon_0$ ，使得$P(\hat{\epsilon};\epsilon)$在$\epsilon=\epsilon_0$时最大，$|\epsilon-\epsilon_0|$ 增大时减小。整个图像其实是个山峰形状，符合二项分布。 那么此时也可以反过来讲，如果这个泛化错误率 $\epsilon$ 已知为 $\epsilon_0$ ，则理论上，横坐标为 $\epsilon_0$的概率值$P(\hat{\epsilon};\epsilon)$是最大的。 即：若泛化错误率为$ \epsilon_0$ ，则测试错误率也为 $\epsilon_0$ 的概率最大（可能性最高）。 此时，我们得到了泛化错误率为$ \epsilon_0$，我们可以用这个数值来进行假设，假设这个学习器的泛化错误率不会超过 $\epsilon_0$。 即假设：“$ H_0:\epsilon≤\epsilon_0$ ”。 到底要不要接受这个假设呢？ 我们需要检验一下。 显著度（显著性水平）是估计总体参数落在某一区间内，可能犯错误的概率，用$\alpha$表示。$\alpha$的常用取值很小，如0.05，0.1等。$1-\alpha$则表示置信度(confidence)。 通过二项检验(binomial test)，我们得到结论：在$\alpha$的显著度下，假设$ H_0:\epsilon≤\epsilon_0$ 不能被拒绝，能以$1-\alpha$的置信度认为，学习器的泛化错误率不大于$\epsilon_0$；否则假设被拒绝，即在$\alpha$的显著度下可认为该学习器的泛化错误率大于$\epsilon_0$。 现实中我们并非仅作出一次留出法估计，而是做多次，所以会得到不同的多个测试错误率，假定为k个测试错误率： $\hat \epsilon_1$、$\hat \epsilon_2、\cdots 、\hat \epsilon_k$，则平均错误率$ \mu $和方差$ \sigma^{2}$为：$$\mu = \frac 1k \sum_{i=1}^k\hat \epsilon_i $$$$ \sigma^2 = \frac{1}{k-1} \sum_{i=1}^k (\hat \epsilon_i - \mu)^2$$ 假设X服从标准正态分布N（0,1），Y服从$ \chi^2$分布，那么$ T=X/\sqrt{Y/n}$ 的分布称为自由度为n的t分布,记为$T \sim t(n)$。 t分布这边需要一定的数学基础。默默记住吧。 T 为自由度为 n 的 t 分布，变量 $\tau_{t}=(\sqrt{k}(\mu-\epsilon_0))/\sigma $服从自由度为 k-1 的 t 分布。（ $\mu-\epsilon_{0} $服从正态分布， $\sigma^{2} $服从自由度为 k-1 的$ \chi^2 $分布） 由此图和 t 分布图的性质可知，最高点处就是测试错误率的最大值$\epsilon_0$ 。 现在要重新假设了，“ $H_1:\mu=\epsilon_0 $”。 接下来就是继续确定显著度 $\alpha$ ，确定门槛值（此处用双边假设），最后进行在置信度为 $1-\alpha$ 下的判断了。 交叉验证 t 检验(2.4.2, P40)回顾一下上一篇中的k折交叉验证： “k折交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$ 如果说前一种的假设检验是得到单个学习器的泛化错误率的大致范围假设，那么“交叉验证t检验”方法就是在比较A、B两学习器性能的优劣了（不过偏向于验证A、B性能是否相同）。 现在有两个学习器A和B，使用 k 折交叉验证法得到测试错误率分别为 $\epsilon_{1}^{A},\epsilon_{2}^{A},\epsilon_{3}^{A},…\epsilon_{k}^{A}$ 和$\epsilon_{1}^{B},\epsilon_{2}^{B},\epsilon_{2}^{B},…\epsilon_{k}^{B} $。其中$ \epsilon_{i}^{A} $和 $\epsilon_{i}^{B} $是在相同的第 i 折训练/测试集上得到的结果。 注意，此时的测试错误率和之前的假设检验那一节的测试错误率采用了不同的符号，此时由于没有提到泛化错误率，测试错误率被标记为$ \epsilon $，只不过增加了上下角标，请各位不要将其与上一节的泛化错误率混淆。 基本思想：若两个学习器的性能相同，则它们使用的训练/测试集得到的测试错误率应相同，即 $\epsilon_{i}^{A}=\epsilon_{i}^{B} $。 实际上却不会像理想状态一样，两个学习器的测试错误率并不完全相同，而是存在一定的微小差值。我们想要判断两个学习器的性能是否有显著差别，就要利用这个差值进行假设检验。 若两个学习器性能相同，这个差值均值应该为0。因此可对这k个差值对“学习器A和B性能相同”这个假设做 t 检验。 1、先对每一对结果求差，$ \Delta_i=\epsilon_{i}^{A}-\epsilon_{i}^{B}$ 2、计算出这$k$个差值的均值$ \mu $和方差 $\sigma^2$ 3、根据 t 检验的公式$ T=X/\sqrt{Y/n} $，得 $\tau_t=|\frac{\sqrt{k}\mu}{\sigma}|$ ，满足自由度为 k-1 的 t 分布，故在显著度$ \alpha $，若其小于临界值 $t_{\alpha/2,k-1} $，则假设不能被拒绝，即认为两个学习器性能没有显著的差别。反之则认为平均错误率小的性能更优。 这里$t_{\alpha/2,k-1}$ 是分布上尾部累积分布为$\alpha/2$ 的临界值。 但是这样使用 k 折交叉验证法，通常情况下会因为样本有限，使得不同轮次的训练集产生一定程度的重叠。这样训练出来的学习器，会让得出的这组测试错误率无法做到彼此完全独立。 而进行有效的假设检验的一个重要的前提就是：测试错误率均为泛化错误率的独立采样。（例如 t 分布就需要随机变量X和Y相互独立。） 所以为了缓解这个问题，可采用“5×2交叉验证”法。 5×2交叉验证(2.4.2, P41)待补。 McNemar检验(2.4.3, P41)McNemar检验适用于二分类问题，与成对t检验一样也是用于比较两个学习器的性能大小。通过联列，可以获得学习器A和B的分类结果的差别。下表即为两分类器分类差别列联表， e 为样本数。 主要思想是：若两学习器的性能相同，则A预测正确B预测错误数应等于B预测错误A预测正确数，即$e_{01}=e_{10}$，且$|e_{01}-e_{10}|$符合正态分布。 $| e_{01}-e_{10}|$为什么符合正态分布？ 按理说，实际生活中，凡自然状态下的整体数据分布几乎都符合正态分布，那么当假设两学习器性能相同的时候，如果用大量不同的测试集进行测试，这个差值应该就可能符合正态分布。 McNemar检验考虑变量： 但上式中的“-1”并非因为$ |e_{01}-e_{10}| $的均值 $\mu$ 为1，实际上均值$ \mu $应近似为0，这里的“-1”，是为了连续性校正。 什么是连续性校正？$2*2$列联表资料是分类资料,所以样本量较小时要进行连续性校正。。卡方检验要求：最好是大样本数据。一般每个个案最好出现一次，四分之一的个案至少出现五次。如果数据不符合要求，就要应用校正卡方。参见维基百科 上述变量$\tau_{\chi^2}$ 符合自由度为1 的$ \chi^2 $分布。 $ \chi^2 $分布的定义：若k个独立的随机变量$Z_1,Z_2,⋯,Z_k$，且符合标准正态分布$N(0,1)$，则这k个随机变量的平方和 $X=∑_{i=1}^kZ^2_i$为服从自由度为k的卡方分布，记为： $X\sim \chi^2(k)$。卡方分布的期望与方差分为为：$E(\chi^2)=k，D(\chi^2)=2k$，其中k为卡方分布的自由度。 给定显著度$\alpha $，当上述变量小于临界变量值的时候，不能拒绝假设，即认为两学习器的性能没有显著差别；否则拒绝假设，即认为两者性能有显著差别，平均错误率较小的学习器性能较好。这个过程也是自由度为1 的卡方检验。 $\chi^2 $检验，中文名为卡方检验。卡方检验是一种用途很广的计数资料的假设检验方法。它属于非参数检验的范畴，主要是比较两个及两个以上样本率( 构成比）以及两个分类变量的关联性分析。其根本思想就是在于比较理论频数和实际频数的吻合程度或拟合优度问题。 Friedman检验与Nemenyi后续检验(2.4.4, P42)上述的三种检验（假设检验、交叉验证t检验，McNemar检验）都只能在一组数据集上，Friedman检验则可以在多组数据集进行多个学习器性能的比较，基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予序值1,2,3…，相同则平分序值，如下图所示： 比如：D1数据集上，算法A的性能最好，其次算法B的性能，最差的是算法C的性能。数字越小，代表该算法在该数据集上的表现越好。 Friedman检验：判断算法是否性能都相同。 检验变量$\tau_{\chi^2}$与F检验的临界值进行比较。 若“H0：所有算法的性能相同”这个假设被拒绝，则需要进行后续检验(post-hoc test)，来得到具体的算法之间的差异。常用的就是Nemenyi后续检验。 Nemenyi检验计算出平均序值差别的临界值域，若两个算法的平均序值差超出了临界值域CD，则相应的置信度1-α拒绝“两个算法性能相同”的假设。 总结一下多学习器的比较： Friedman + Nemenyi Friedman 检验(基于序值，F检测，判断“是否都相同”) Nemenyi 后续检验 (基于序值，进一步判断两两差别) 关于读音：（音译，仅供参考）McNemar：mac呢嘛儿（mac:[mæk]，中文名：麦克尼马尔）Friedman：free的们（free:[fri]，中文名：弗里德曼）Nemenyi：呢曼里(y貌似不发音) 偏差与方差(2.5, P44)“偏差-方差分解”(bias-variance decomposition)是解释学习算法泛化性能的重要工具。 测试样本：x 测试样本x在数据集中的标记： $y_D$ 测试样本x的真实标记： y 训练集： D 从训练集 D 上学得的模型f 模型 f 在测试样本x上的预测输出$f(x;D) $ 根据上述变量，推导出学习算法的期望预测：$$\bar f(x) = \mathbb{E}_D [f(x;D)] $$使用样本数相同的不同训练集产生的方差为：度量了同样大小的训练集的变动所导致的学习性能的变化，也就是数据扰动所造成的影响。$$var(x) = \mathbb{E}_D [(f(x;D)- \bar f (x) )^2] $$ 噪声(数据集标记和真实标记的方差)为：当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。$$ \varepsilon^2 = \mathbb{E}_D [(y_D - y)^2]$$ Bias（偏差）：期望输出与真实标记的偏离程度，刻画了学习算法本身的拟合能力。$$bias^2(x) = (\bar f (x) - y)^2 $$ 对回归任务，泛化误差可通过“偏差-方差分解”拆解为：$$E(f;D) = bias^2(x) + var(x) + \varepsilon^2 $$ 也就是说，泛化误差可分解为 偏差、方差与噪声之和。偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。 一般来说，偏差与方差是由冲突的，这称为“偏差-方差窘境”。 随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。换句话说：在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差。因此训练也不要贪杯，适度辄止。 参考 周志华《机器学习》 《机器学习》学习笔记与习题探讨（二）④ 卡方分布与卡方检验 卡方检验（Chi-square test）和费舍尔精确检验（Fisher exact test）]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西瓜书《机器学习》学习笔记(1)：评估方法与度量指标]]></title>
    <url>%2F2018%2F01%2F03%2FML_chap2_01%2F</url>
    <content type="text"><![CDATA[笔记直接跳过了第一章，从第二章开始。 本次笔记主要回顾评估方法与性能度量指标。 经验误差与过拟合(2.1, P23)学习器在训练集上的误差称为训练误差(training error)或经验误差(empirical error)，在新样本上的误差称为泛化误差(generalization error)，我们希望得到泛化误差小的学习器。 过拟合(overfitting)，欠拟合(underfitting)。 多种因素导致过拟合，最常见的就是由于学习能力过于强大，以至于把训练样本不太一般的特性都学到了。欠拟合相反。 欠拟合比较容易克服，如在决策树学习中学习扩展分支，在神经网络学习中增加训练轮数等。 过拟合无法彻底避免。只能“缓解”，减小风险。 评估方法(2.2, P24)测试集(testing set)上的测试误差(testing error) 作为泛化误差的近似。 留出法(2.2.1, P25)“留出法”(hold-out) 将数据集D划分为两个互斥的集合，其中一个集合作为训练集S，另一个作为测试集T，即$D=S\cup T,S\cap T=\oslash $。 常见的划分为：大约2/3-4/5的样本用作训练，剩下的用作测试。 注意： 训练/测试集的划分需要尽可能保持数据分布的一致性。 由于划分的随机性，单次留出法得到的评估结果往往不够稳定可靠，一般采用若干次随机划分、重复进行实验评估后取平均值。 交叉验证法(2.2.2, P26)“交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$ 每次用k-1个子集作为训练集，余下的那个子集作为测试集；这样就可以得到k组训练/测试集。从而可进行k次训练和测试，最终返回k次测试结果的均值。 故通常把交叉验证法称为“k折交叉验证”(k-fold cross validation)。10折交叉验证示意图： 与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为p次k折交叉验证，常见的是10次10折交叉验证，即进行了100次训练/测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。 自助法(2.2.3, P27)“自助法”(bootstrapping)以自助采样法(bootstrapping sampling)为基础。每次随机从包含m个样本的数据集D中挑选一个样本，将其拷贝到$D’$，然后再将该样本放回D中，使得该样本下次采样时仍有可能被采到。重复执行m次后，就得到包含m个样本的数据集$D’$。 我们将$D’$用作训练集，$D-D’$(D中除了$D’$以外的样本)用作测试集。 在m次采样中，样本始终不被采到的概率取极限为： 自助法在数据集较小、难以有效划分训练/测试集时很有用。 调参与最终模型(2.2.4, P28)大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。 当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。 学得模型(训练后的模型)实际使用中遇到的数据称为测试数据，在模型评估选择中用于评估测试的数据集称为“验证集”(calidation set)。【和吴恩达讲得差不多(略有区别？)。吴恩达说，通常将数据分为三类：训练集，验证集与测试集。】 性能度量performance measure(2.3, P28)分类和回归属于监督学习。 【分类】：对是离散值的结果进行预测。 【回归】：对是连续值的结果进行预测。 回归任务和分类任务的常用性能度量如下图所示。 预测任务：学习器预测结果$f(x)$与真实标记$y$进行比较。 回归任务：“均方误差”(mean squared error)$$E(f;D) = \frac 1m \sum_{i=1}^m (f(x_i)-y_i)^2 $$ 下面将依次介绍上图中分类任务的四类性能度量。 错误率与精度(2.3.1, P29)错误率：分类错误的样本占样本总数的比例：$$E(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)\neq y_i) $$精度：分类正确的样本占样本总数的比例：$$acc(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)= y_i) = 1-E(f;D) $$ 错误率+精度=1。 查准率、查全率与F1(2.3.2, P30) 查准率就是准确率，查全率就是召回率。 更具体的，可参考我的这篇文章：准确率、召回率与F1值【重点，单独列出】 ROC 与AUC(2.3.3, P33)ROC：受试者工作特性(Receiver Operating Characteristic)。ROC图的纵坐标为“真正例率”，横坐标为“假正例率”。 真正例率（TPR）：【真正例样本数】与【真实情况是正例的样本数】的比值。（查全率） 假正例率（FPR）：【假正例样本数】与【真实情况是反例的样本数】的比值。 如图，理想模型是真正例率为100%，假正例率为0%的一点。随机猜测模型则是真正例率与假正例率持平的直线。由此可知，在随机猜测模型左上方的曲线和在其右下方的曲线都代表了什么。（右下方的模型，还不如随机猜测准。） 现实中通常是有限个测试样例来绘制ROC图。无法产生光滑的ROC曲线图。 同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则不太好判断。此时，AUC应运而生。 AUC(Area Under ROC Curve)：判断两个ROC曲线的性能，AUC计算的是ROC曲线下的面积。面积越大，性能越好。 代价敏感错误率与代价曲线(2.3.4, P35)上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。 在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”(cost sensitive)的错误率为： 同样对于ROC曲线，在非均等错误代价下，性能度量的方法演变成了“代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。 代价曲线的绘制：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC曲线上的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价，如图所示： 参考 周志华《机器学习》 http://blog.csdn.net/u011826404/article/details/53229609 https://zhuanlan.zhihu.com/p/28482121]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下的部分小技巧整理]]></title>
    <url>%2F2017%2F12%2F29%2Fpractical_tricks%2F</url>
    <content type="text"><![CDATA[本文主要是电脑使用中的一些小技巧的整理。主要包括： 电脑常用的部分快捷键 批处理乱码问题 Photoshop文字添加、删除与旋转 VirtualBox虚拟机问题 电脑操作打开“我的电脑”的快捷键winkey +E :打开我的电脑（资源管理器）。winkey指的是键盘上刻有windows徽标的键，就是左边ctrl 和alt中间那个(window标志)。 其他常用键组合： winkey + d :这是高手最常用的第一快捷组合键。这个快捷键组合可以将桌面上的所有窗口瞬间最小化，无论是聊天的窗口还是游戏的窗口……只要再次按下这个组合键，刚才的所有窗口都回来了，而且激活的也正是你最小化之前在使用的窗口！ winkey + r :在我们的文章中，你经常会看到这样的操作提示:“点击‘开始→运行’，打开‘运行’对话框……”。其实，还有一个更简单的办法，就是按winkey + r！ alt + tab 或者 winkey + tab:如果打开的窗口太多，这个组合键就非常有用了，它可以在一个窗口中显示当前打开的所有窗口的名称和图标，选中自己希望要打开的窗口，松开这个组合键就可以了。而alt+tab+shift键则可以反向显示当前打开的窗口。 ALT + F4 ：关闭当前应用程序 PRINT SCREEN :将当前屏幕以图象方式拷贝到剪贴板 更多快捷键可参考：https://zhidao.baidu.com/question/100107981.html 复制一个当前文件夹窗口的快捷键Ctrl + N 批量查看照片尺寸在空白的地方右击，选择查看——详细信息; 照片就以列表的形式摆放了，但没有尺寸大小的信息~ 再次在空白处右击，选择排列方式——更多， 将滑块往下滑动，找到尺寸，打上勾，按确定~ 照片的尺寸信息就出现了~ 若没有理解清楚，详细图文教程可参考：如何批量查看照片的尺寸 awesomiumProcess是什么进程在Windows任务管理器中的相应进程上右键–打开文件位置，发现是MarkDownPad2自带的程序。 推广一下，就是手动查看进程中是否存在可疑程序。。。 批处理批处理脚本bat中文乱码面对这个情况是编码不同问题，所以在最开始就应该把编码修正，支持中文的编码是ANSI。 我们第一步是新建一个txt文件。用记事本打开，将原来的bat文件内容拷贝过来，然后选择“文件”=&gt;“另存为”。 cmd中的编码方式为ANSI，若中文不是此编码方式则会出现乱码。所以我们在编码的时候选择“ANSI”。 photoshopps修改图片上的文字删去文字先选择图层，再选择一个区域后，按delete删除。 取消当前图层的选区： ctrl + D参考自：ps取消选区快捷键 添加横的文字选择添加文本的按钮输入文字，但是不可以旋转（我要变成竖直的文字）。 按组合键Ctrl + T或者点击编辑菜单下的【自由变换】，进入文字调整。具体参考：ps怎么旋转一个字体 vbox虚拟机无法启动E_FAIL (0x80004005)版本问题。回退到4.3.12之前。新版本问题多多。具体参考：Oracle VM VirtualBox 虚拟机 启动报错代码:E_FAIL (0x80004005) VirtualBox显示模式切换热键初用VirtualBox, 几个显示切换快捷键还是要记一下的: Right Ctrl + F – 切换到全屏模式Right Ctrl + L – 切换到无缝模式Right Ctrl + C – 切换到比例模式Right Ctrl + Home – 显示控制菜单 无缝模式是灰色的，怎么办安装增强模式。相当于VMware里面的”VMware Tools”。]]></content>
      <categories>
        <category>Photoshop</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的部分tricks整理]]></title>
    <url>%2F2017%2F12%2F29%2Fpython_tricks%2F</url>
    <content type="text"><![CDATA[本文整理了本人遇到的一些tricks。主要包括： pycharm快捷键整理 爬虫中的日志记录(logging)、取消SSL警告、字符过滤(re.sub)与查找(find)、文件删除(os)与文件保存(pickle)、词云(wordcloud)的使用 图像处理的部分基本操作(PIL,numpy)。 0 pycharm 快捷键注释/反注释 Ctrl+斜杠，也就是 Ctrl + / 注释与反注释都是这个组合键。 块注释Ctrl+Shift+斜杠 格式化代码ctrl + alt + F: 格式化代码(用了JetBrains的IDE之后就习惯性地格式化一下)，代码规范化。 复制当前行Ctrl + D复制当前行 另起一行shift + enter : 向下另起一行，光标在行内任意位置都能另起一行，且不破坏当行结构ctrl + alt + enter : 向上另起一行 查看注释Ctrl + q: help 查注释，查询documentation 搜索功能ctrl + shift + a : 搜索功能: 搜索IDE功能，比如想看看这个文件的历史，就键入history 可以找到 Local history 万能提示键ctrl + alt + space: 万能提示键(在Keymap中搜索basic可以找到并修改它)PyCharm的会根据上下文提供补全。 run相关的快捷键根据具体设置可能略有差异，笔者采用的是VS风格（可在File-&gt;Settings-&gt;Keymap中设置）的快捷键。ctrl + F9 : run the current file （跑当前页面的程序）F9 : resume the program (中断后)重新开始程序ctrl + F5: run the specific program(直接跑上一个程序)F5： debug（弹出debug目录，自行选择运行的文件）alt + shift + F10 : 运行程序（弹出run目录） 其他技巧ctrl + shift + 数字键 与 ctrl + 数字键 : 书签功能Ctrl + 鼠标点击 ： 查看内置函数啥的alt + 上下箭头 : preview/next method (def/class)debug的时候可以在断点打开Python console然后改变量值Ctrl+ B和shift + →，查看源码时很方便，至少在vim下看库的源码没那么容易。对Python程序员而言，看源码很重要shift + F6 : 重命名，这太重要了，vim没有吧。即使有，那它也没法重构Flask和Django的template下的指令吧。 1 python信息同时输出到控制台与文件1.1 问题python编程中，往往需要将结果用print等输出，如果希望输出既可以显示到IDE的屏幕上，也能存到文件中（如txt）中，该怎么办呢？ 1.2 解决方案可通过日志logging模块输出信息到文件或屏幕。但可能要设置log的level或输出端，对于同时需要记录debug error等信息的较为合适，官方教程推荐学习用更规范的logger来操作。例如,可参考来自官网的这段代码。12345import logging logging.basicConfig(filename='log_examp.log',level=logging.DEBUG) logging.debug('This message should go to the log file') logging.info('So should this') logging.warning('And this, too') 其中的level=logging.DEBUG会显示Debug调试信息，若想显示普通的输出信息，可以换成level=logging.INFO。 程度 使用场景 DEBUG 获得诊断问题是具体的信息 INFO 确认程序是否按正常工作 WARNING 在程序还正常运行时获取发生的意外的信息，这可能会在之后引发异常（例如磁盘空间不足） ERROR 获取程序某些功能无法正常调用这类严重异常的信息 CRITICAL 获取程序无法继续运行的这类最严重异常信息 1.3 改变默认输出信息的格式1234import logging# output format: output time - logging level - log messageslogging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s')logging.warning('This message will appear in python console.') 在python console中直接打印以下输出： 12016-8-2 2:59:11, 510 - WARNING - This message will appear in python console 2 Python中将打印输出导向日志文件利用sys.stdout将print行导向到你定义的日志文件中，例如： 123456789101112131415161718import sys# make a copy of original stdout routestdout_backup = sys.stdout# define the log file that receives your log infolog_file = open("message.log", "w")# redirect print output to log filesys.stdout = log_fileprint "Now all print info will be written to message.log"# any command line that you will execute...log_file.close()# restore the output to initial patternsys.stdout = stdout_backupprint "Now this will be presented on screen" 这样子只会打印到日志文件，而控制台没有输出了，笔者一般不采用这种方法。 3 python3使用requests请求HTTPS取消SSL验证警告3.1 问题描述使用requests库请求HTTPS时,因为忽略证书验证,导致每次运行时都会报错（警告）:12D:\python\Python35\lib\site-packages\urllib3\connectionpool.py:858: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings InsecureRequestWarning) 3.2 解决方法 虽然这并不影响结果的正确，但是这个提示一直存在，看着是真的别扭，尤其需要输出到报告或者是日志的时候。代码加入下面两行，取消这个警告。 添加如下的这两行代码： 123from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) python3也可以的。我的pycharm中会显示找不到该库，不过没问题，依旧可以跑，应该是pycharm本身的问题。 4. python过滤中文、英文标点特殊符号4.1 垃圾邮件过滤实例下面是一封垃圾邮件的过滤实例： 1&quot;想做/ 兼_职/学生_/ 的 、加,我Q： 1 5. 8 0. ！！？？ 8 6 。0. 2。 3 有,惊,喜,哦&quot; 邮件中的“！？。、”都是中文的，而“/.”是英文的 下面是采用re正则项过滤方式： 123456import retemp = "想做/ 兼_职/学生_/ 的 、加,我Q： 1 5. 8 0. ！！？？ 8 6 。0. 2。 3 有,惊,喜,哦"temp = temp.decode("utf8") string = re.sub("[\s+\.\!\/_,$%^*(+\"\']+|[+——！，。？、~@#￥%……&amp;*（）]+", "", temp) # 将temp中若存在的前面的这一长串替换为空的。print(string) 4.2 目录名称过滤实例此外，比如说目录命名时，也需要过滤掉/|等，如下：12dirName = re.sub("[\s+\.\!\/_,$%^*(+\"\'?]+|[+——！，。？、~@#￥%……&amp;*（）]+", "", dirName)os.mkdir(dirName) 5. Markdown之表格table的处理插入表格代码如下：12345678910&lt;table class="table table-bordered table-striped table-condensed"&gt; &lt;tr&gt; &lt;td&gt;北京&lt;/td&gt; &lt;td&gt;雾霾&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;深圳&lt;/td&gt; &lt;td&gt;暴雨&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 发现table加了个class属性，如果只是table标签 将不起作用。 table-bordered：带圆角边框和竖线 table-striped：奇偶行颜色不同 table-condensed：压缩行距 除了以上另外还有其他可供选择： 1、如果需要表头跟内容不一样，可以将&lt;td&gt;表头内容&lt;/td&gt;换成&lt;th&gt;表头内容&lt;/th&gt;。 2、如果表格内文需要换行，可以在要换行的内容后加入&lt;br&gt;，后面的内容就会跑到下一行。 3、如果内文中有代码，需要特别显示，可使用：&lt;code&gt;代码&lt;/code&gt;。 4、如果表格中有需要设为斜体的内容，可使用：&lt;I&gt;要设为斜体的内容&lt;/I&gt;。 5、如果有跨行或者跨列的单元格，可用&lt;th colspan=&quot;跨列数&quot;&gt;内容&lt;/th&gt;或rowspan。 6、如果要调整某一列的宽度，可使用：&lt;th width=&quot;宽度值或百分比&quot;&gt;表头内容&lt;/th&gt;。 6. 用numpy打开图像和保存图像123456789# -*- coding: utf-8 -*- from PIL import Image from pylab import * from PCV.tools import imtools import numpy im = array(Image.open('C:/pic/train2/1.jpg').convert('L')) # 打开图像，并转成灰度图像 img11=Image.fromarray(uint8(im)) img11.save("C:/pic/train2/10.jpg")# 保存灰度图像 补充用opencv打开和保存图像： 12345#coding=utf-8 import cv2 img = cv2.imread("C:/pic/train1/2.jpg", 0) cv2.imwrite('C:/pic/1/5.jpg',img) 7. PIL.Image转换为OpenCV支持的Image格式可参考：http://www.mobibrw.com/2017/7381 后来放弃了。不太方便。 8. 使用pickle把数据保存到文件8.1 实例一使用pickle模块从文件中重构python对象。1234567891011import pprint, picklepkl_file = open('data.pkl', 'rb')data1 = pickle.load(pkl_file)pprint.pprint(data1)data2 = pickle.load(pkl_file)pprint.pprint(data2)pkl_file.close() 8.2 实例二其中，friend是从网页获得的数据，先保存下来，以备后续处理。1234567# 获取好友列表friends = itchat.get_friends(update=True)[0:]output = open('data.pkl', 'wb')# Pickle dictionary using protocol 0.pickle.dump(friends, output)output.close() 读取保存的文件，用于后续处理。 1234import pickle, repkl_file = open('data.pkl', 'rb')friends = pickle.load(pkl_file) 9. 解决Python词云库wordcloud不显示中文的问题9.1 安装安装命令： pip install wordcloud 9.2 解决方案实例代码：123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-from wordcloud import WordCloudimport matplotlib.pyplot as plttext = '''文案 文案The 抱抱 Zen of LOVE 抱抱 Python, 快乐 by Tim Peters公众号 公众号 Python 最好的 语言 语言一辈子 is better LOVE than 一辈子.喵小姐 is 爱你 than implicit.爱你 喵小姐蟹先生 is 爱你 than complex.一辈子 is 蟹先生 than complicated.二中 is 喵小姐 我想你了 than nested. 二中 蟹先生清湖 is 胜于 than 清湖.思旺 counts. 想你Special 喵小姐 我想你了 aren't special enough 思旺 break 思旺 rules.别生气 practicality beats 厨艺好.Errors should 我想你了 never pass 小龙虾 silently. 运营别生气 explicitly 好不好. LOVEIn the face of ambiguity, 程序员 the 厨艺好 to guess.龙华 龙华There 快乐 should be one-- 我想你了 and preferably 红烧肉 only one 小龙虾--obvious way to do it.运营Although 共享单车 way may not 我想你了 be obvious at first unless you're Dutch. 新媒体 地铁Now is better 红烧肉 than never.程序员 Although 共享单车 is often 高铁 than 东莞 now. 高铁 地铁If the implementation 想你 is hard to explain, it's a bad idea. 想你了If 成都 implementation is 想你 easy to explain, it may be a good idea.Namespaces are 端午one 端午 honking great idea -- 成都 do more of those! 想你了深圳 晚安 深圳 新媒体'''# the font from github: https://github.com/adobe-fontsfont = r'C:\Windows\Fonts\simfang.ttf'wc = WordCloud(collocations=False, font_path=font, width=1400, height=1400, margin=2).generate(text.lower())plt.imshow(wc)plt.axis("off")plt.show()wc.to_file('show_Chinese.png') # 把词云保存下来 10. PIL库图片基本操作1.打开图片12import Imageimg=Image.open("code.jpg") 注：有些图片名称是包含中文的，就需要在“”前加上u，例：1img=Image.open(u"阿布.jpg") 2.展示图片 1img.show() 3.保存图片1img.save("img1.png","png") 说明：img为一个图片，存为一个名叫img1的图片，格式为png。后面的png不写也可以，直接按照文件名的后缀.png存为相应格式了。 4.旋转图片rotate fixedIm=img.rotate(90) fixedIm.save(&quot;fixedIm.png&quot;,&quot;png&quot;) 说明：fixedIm=img.rotate(90)，将图片img逆时针旋转90度，存到fixedIm中。 更多操作可参考:http://www.cnblogs.com/meitian/p/3699223.html python删除文件1234567import os # 删除文件： os.remove()#删除空目录： os.rmdir() # 递归删除空目录： os.removedirs() 递归删除目录和文件（类似DOS命令DeleteTree）：12345678910# Delete everything reachable from the directory named in 'top',# assuming there are no symbolic links.# CAUTION: This is dangerous! For example, if top == '/', it# could delete all your disk files.import osfor root, dirs, files in os.walk(top, topdown=False): for name in files: os.remove(os.path.join(root, name)) for name in dirs: os.rmdir(os.path.join(root, name)) 参考自：python 删除文件 Python3 find()方法描述find()方法检测字符串中是否包含子字符串str，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。 语法find()方法语法： str.find(str, beg=0, end=len(string)) 参数str：指定检索的字符串beg：开始索引，默认为0。end：结束索引，默认为字符串的长度。 返回值如果包含子字符串返回开始的索引值，否则返回-1。 实例以下实例展示了find()方法的实例(Python 3.0+)： 12345678#!/usr/bin/python3 str1 = "Runoob example....wow!!!"str2 = "exam"; print (str1.find(str2))print (str1.find(str2, 5))print (str1.find(str2, 10)) 以上实例输出结果如下： 7 7 -1 实例(Python 3.0+)12345678&gt;&gt;&gt;info = 'abca'&gt;&gt;&gt; print(info.find('a')) # 从下标0开始，查找在字符串里第一个出现的子串，返回结果：00&gt;&gt;&gt; print(info.find('a', 1)) # 从下标1开始，查找在字符串里第一个出现的子串：返回结果33&gt;&gt;&gt; print(info.find('3')) # 查找不到返回-1-1&gt;&gt;&gt; 参考资料 python 信息同时输出到控制台与文件 Python中将打印输出导向日志文件 python requests报错InsecureRequestWarning的解决方案 Python requests移除SSL认证，控制台输出InsecureRequestWarning取消方法 python 过滤中文、英文标点特殊符号 Markdown之表格table的处理 用numpy打开图像和保存图像 pickle模块的基本使用 词云库wordcloud显示中文 Python3 find()方法]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于TensorFlow的简单语音识别]]></title>
    <url>%2F2017%2F12%2F28%2FTensorFlow_speech_commands%2F</url>
    <content type="text"><![CDATA[简单语音识别教程虽然真正的语音和音频识别系统要复杂得多，但是像MNIST（入门级的CV数据集）一样，本教程应该会让你对所涉技术有一个基本的了解。 完成本教程后，你将可以尝试创建一个模型，将一秒钟的音频剪辑去噪，并且能识别如下单词： “yes”，“no”，“up”，“down”，&quot;left&quot;，&quot;right&quot;，&quot;on&quot;，&quot;off&quot;，&quot;stop&quot;，or &quot;go&quot;。 你也可以在Android应用程序中运行该模型。 准备你要确保已经安装了TensorFlow，由于该版本下载了超过1GB的训练数据，因此你需要电脑有足够的内存，另外网速要快，训练过程可能需要几个小时。 出错与解决找不到audio_ops123456Traceback (most recent call last): File "train.py", line 79, in &lt;module&gt; import input_data File "/home/philglau/speech_commands/input_data.py", line 35, in &lt;module&gt; from tensorflow.contrib.framework.python.ops import audio_ops as contrib_audioImportError: cannot import name 'audio_ops' 解决方案这个’audio_ops’只在TensorFlow1.4版本中有，所以，如果不是1.4的版本，一般都会有这个错误。 此时的解决方案，一是更新TensorFlow版本，二是使用如下命令安装tf-nightly即可。 1pip install tf-nightly 详见参考连接三。 训练要开始训练过程，请访问TensorFlow源代码树下载并运行： 1python tensorflow/examples/speech_commands/train.py 训练过程将从下载“ 语音命令”数据集开始，该数据集由65000个WAVE音频文件组成，其中有30个不同的单词。 这些数据是由Google收集的，并根据CCBY许可证发布。存档超过1GB，所以下载可能需要一段时间，但你应该能看到进度日志，一旦下载完成，你就不用再次执行此步骤了。 下载完成后，你将看到如下所示的日志记录信息： 123I0730 16:53:44.766740 55030 train.py:176] Training from step: 1I0730 16:53:47.289078 55030 train.py:217] Step #1: rate 0.001000, accuracy 7.0%, cross entropy 2.611571 这表明初始化过程已经完成，循环训练已经开始。你会看到它输出每个训练步骤的信息。 步骤分解： Step #1表明我们正在循环训练的第一步。在这种情况下，总共将有18000个步骤，所以你可以查看步骤号码，了解其完成程度有多接近。 rate 0.001000是控制网络权重更新速度的学习率。早期的这个数字是相对较高的（0.001），但是对于后来的训练周期，它会减少10倍到0.0001。 accuracy 7.0%在这个训练步骤中正确地预测了有多少classes。value函数往往波动很大，但随着训练的进行，平均值会增加。该模型输出一个数字数组，每个标签一个，每个数字是该类输入的预测可能性。 通过选择具有最高分数的条目来选择预测的标签，分数总是在零和一之间。 cross entropy 2.611571是我们用来指导培训过程的损失功能的结果。这是通过比较当前训练运动与正确标签的分数向量获得的分数，这在训练期间应该向下倾斜。 经过一百步，你应该看到这样的一行：1I0730 16:54:41.813438 55030 train.py:252] Saving to &quot;/tmp/speech_commands_train/conv.ckpt-100&quot; 这是将当前训练的权重保存到checkpoint文件中。如果你的训练脚本中断，可以查找最后保存的checkpoint，然后：--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-100使用命令行参数重新启动脚本， 从那里开始。 混淆矩阵四百步后，将记录以下信息：12345678910111213141516171819202122232425I0730 16:57:38.073667 55030 train.py:243] Confusion Matrix:[[258 0 0 0 0 0 0 0 0 0 0 0][ 7 6 26 94 7 49 1 15 40 2 0 11][ 10 1 107 80 13 22 0 13 10 1 0 4][ 1 3 16 163 6 48 0 5 10 1 0 17][ 15 1 17 114 55 13 0 9 22 5 0 9][ 1 1 6 97 3 87 1 12 46 0 0 10][ 8 6 86 84 13 24 1 9 9 1 0 6][ 9 3 32 112 9 26 1 36 19 0 0 9][ 8 2 12 94 9 52 0 6 72 0 0 2][ 16 1 39 74 29 42 0 6 37 9 0 3][ 15 6 17 71 50 37 0 6 32 2 1 9][ 11 1 6 151 5 42 0 8 16 0 0 20]] 第一部分是混淆矩阵。要了解这是什么意思，你首先需要知道正在使用的标签，在这种情况下，它们分别表示为静音、未知yes、no、up、down、left、right、on、off、stop、go。 第一行是所有的静音剪辑，第二个剪辑是未知的单词，第三个“yes”等。 该矩阵可以比单个准确率得分更有用，因为它可以很好地总结出网络发生的错误。在此示例中，你可以看到除了初始条目之外，第一行中的所有条目都为零。 因为第一行实际上都是静音的片段，所以这意味着它们都没有被错误的标注为文字，所以我们没有任何静音的否定。这表明网络已经越来越好地区分了静音与谈话。 一个完美的模型将产生一个混淆矩阵，其中所有的条目都是从对角线穿过中心的零点。一旦你确定了可以通过添加更多数据来解决问题，该模型的方差可以帮助你了解模型怎样最容易混淆。 验证混淆矩阵之后，你会看到如下一行：1I0730 16:57:38.073777 55030 train.py:245] Step 400: Validation accuracy = 26.3% (N=3093) 将数据集分为三类是很好的做法。最大的（大约是数据的80％）用于训练网络，一个较小的集（10％ “validation”）被保留用于评估训练中的准确性，另一组10％，“testing”）用于在训练完成后评估准确度。 通过将数据集分类为训练集、验证集、测试集，你可以确保该模型适用于之前从未见过的数据。测试集是一个额外的保障措施，以确保不仅仅是以适用于训练和验证集拟合调整模型。 训练脚本将数据集自动分成这三个类别，上面的记录行显示了在验证集上运行时的模型准确率。理想情况下，这应该与训练准确性相当接近。如果训练准确性增加但验证不是这样，这表明过度拟合正在发生，你的模型只是学习关于训练剪辑的东西，而不是真正的训练模式。 Tensorboard使用Tensorboard可以看出训练进展。默认情况下，脚本将事件保存到/ tmp / retrain_logs，可以通过运行以下命令来加载它们：1tensorboard --logdir /tmp/retrain_logs 然后在浏览器中导航到http：// localhost：6006，将看到显示模型进度的图表。 完成训练经过几个小时的训练（取决于你的电脑快慢），脚本应该已经完成了所有18000个步骤。它将识别出最终的混淆矩阵，以及准确率分数，全部运行在测试集上。使用默认设置，准确率在85％到90％之间。 因为音频识别在移动设备上特别有用，接下来我们将其导出为，在移动平台上易于使用的格式。要执行此操作，请运行以下命令行：12345python tensorflow/examples/speech_commands/freeze.py--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-18000--output_file=/tmp/my_frozen_graph.pb 创建固定模型后，可以使用label_wav.py脚本进行测试，如下所示：1234567python tensorflow/examples/speech_commands/label_wav.py--graph=/tmp/my_frozen_graph.pb--labels=/tmp/speech_commands_train/conv_labels.txt--wav=/tmp/speech_dataset/left/a5d485dc_nohash_0.wav 可以识别出三个标签： left (score = 0.81477) right (score = 0.14139) _unknown_ (score = 0.03808) 更多内容请查看论文：http://suo.im/3PW89b 在Android应用程序中运行模型查看此模型在真实应用程序中如何工作的最简单的方法是，下载预构建的Android演示应用程序并将其安装在手机上。 你会看到“TF Speech”出现在应用程序列表中，打开它将显示我们刚刚训练过单词列表，从“yes”和“no”开始。 你还可以自己构建此应用程序，因为它是开源的， 并可作为github上TensorFlow存储库的一部分使用。默认情况下，它从tensorflow.org下载一个预先训练的模型，但你可以轻松地用自己训练的模型替换它。 如果你自己创建的话，你需要确保SpeechActivity Java源文件中的 SAMPLE_RATE，SAMPLE_DURATION符合你训练时的默认设置所做的任何更改。 你还会看到一个Java版本的RecognizeCommands模块。 这与本教程中的C++版本非常相似。如果你调整了参数，还可以在SpeechActivity中进行更新，以获得与服务器测试相同的结果。 演示应用程序，根据你在固定模型复制到模型中的标签文本文件，自动更新其用户界面列表，可以轻松地尝试不同的模型，而无需进行任何代码更改。如果你更改路径，需要update LABEL_FILENAME，MODEL_FILENAME添加到文件。 参考资料 TensorFlow官网教程：Simple Audio Recognition 中文翻译参考 Tensorflow missing ‘audio_ops’ from contrib framework]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>TensorFlow</tag>
        <tag>Speech Recognition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow基础篇与搭建深层神经网络]]></title>
    <url>%2F2017%2F12%2F28%2Ftensorflow_base%2F</url>
    <content type="text"><![CDATA[本文是 Tensorflow：实战Google深度学习框架的第三章与第四章。 第3章 TensorFlow入门0.1 查看已安装tensorflow版本由于tensorflow版本不同,可能一些函数的调用也有变换,这时候可能需要查看tensorflow版本,可以在终端输入查询命令如下:123python //windows下cmd进入python环境，linux下终端类似import tensorflow as tftf.__version__ 查询tensorflow安装路径为:1tf.__path__ 参考自：查看已安装tensorflow版本 0.2 Tensorflow：实战Google深度学习框架 源码下载 Tensorflow：实战Google深度学习框架 caicloud/tensorflow-tutorial 3.2 TensorFlow数据模型——张量3.2.1 张量的概念一个张量中主要保存了三个属性：名字（name）、维度（shape）、类型（type）。 3.2.2 张量的使用两大类。 一是对中间结果的引用。 二是用来获得计算的结果。tf.Session().run(result) 3.3 TensorFlow运行模型——会话3.3.1 创建和关闭会话12345678# 创建一个会话。sess = tf.Session()# 使用会话得到之前计算的结果。print(sess.run(result))# 关闭会话使得本次运行中使用到的资源可以被释放。sess.close() 3.3.2 使用with statement 来创建会话1234567with tf.Session() as sess: print(sess.run(result))# 下面的两个命令有相同的功能。print(sess.run(result))print(result.eval(session=sess)) 3.3.3 指定默认会话12345sess = tf.Session()# 下面的两个命令有相同的功能。print(sess.run(result))print(result.eval(session=sess)) 3.3.4 通过ConfigProto配置会话123config=tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)sess1 = tf.InteractiveSession(config=config)sess2 = tf.Session(config=config) 3.4 TensorFlow实现神经网络3.4.2 前向传播算法简介tf.matmul 矩阵乘法 3.4.3 神经网络参数与tensorflow变量1weights = tf.Variable(tf.random_normal([2, 3], stddev=2)) 产生一个[2,3]的矩阵，矩阵中元素是均值为0，方差为2的随机数。 1.TensorFlow随机数生成函数 函数名称 随机数分布 主要参数 tf.random_normal 正态分布 平均值、标准差、取值类型 tf.truncated_normal 正太分布,但如果随机出来的值离平均值超过2个标准差，那么这个数将会被重新随机 平均值、标准差、取值类型 tf.random_uniform 平均分布 最小、最大取值、取值类型 tf.random_gramma Gramma分布 形状参数alpha、尺度参数beta、取值类型 2.TensorFlow常数生成函数 函数名称 功能 样例 tf.zeros 产生全0的数组 tf.zeros([2,3],int32)-&gt;[[0,0,0],[0,0,0]] tf.ones 产生全1的数组 tf.ones([2,3],int32)-&gt;[[1,1,1],[1,1,1]] tf.fill 产生一个全部为给定数字的数组 tf.fill([2,3],9)-&gt;[[9,9,9],[9,9,9]] tf.constant 产生一个给定值的常量 tf.constant([1,2,3])-&gt;[1,2,3] 声明了变量之后，程序的第二步会声明一个会话（session）。并通过会话计算结果。 在真正开始计算之前，必须对变量进行初始化：12init_op = tf.global_variables_initializer() sess.run(init_op) 变量分为需要优化的参数（比如神经网络中的参数）和其他参数。trainable = True，则该变量会加入GraphKeys.TRAINABLE_VARIABLES集合。 维度（shape）和类型（type）是变量最重要的两个属性。 3.4.4 通过tensorflow训练神经网络模型监督学习的思想。 神经网络优化算法中，最常用的是反向传播算法。 x = tf.constant([[0.7, 0.9]]) 常量表示样例导致计算图特变大。使用placeholder机制提供输入数据。 在placeholder定义的时候，这个位置上的数据类型是需要指定的。和其他张量一样，placeholder的类型不可以被改变。12345678910x = tf.placeholder(tf.float32, shape=(1, 2), name="input")a = tf.matmul(x, w1)y = tf.matmul(a, w2)sess = tf.Session()init_op = tf.global_variables_initializer()sess.run(init_op)print(sess.run(y, feed_dict=&#123;x: [[0.7, 0.9]]&#125;)) feed_dict时一个字典（map），在字典中需要给出每个用到的placeholder的取值，否则运行会报错。 输入的数据一般是一个batch，不止一个，placeholder也支持输入多个数据。12345678910x = tf.placeholder(tf.float32, shape=(3, 2), name="input")a = tf.matmul(x, w1)y = tf.matmul(a, w2)sess = tf.Session()#使用tf.global_variables_initializer()来初始化所有的变量init_op = tf.global_variables_initializer() sess.run(init_op)print(sess.run(y, feed_dict=&#123;x: [[0.7,0.9],[0.1,0.4],[0.5,0.8]]&#125;)) 在得到一个batch的前向传播结果之后，需要定义一个损失函数来刻画当前的预测值与真实答案之间的差距。然后通过反向传播算法来调整网络参数之间的取值使得差距可以被缩小。 3.4.5 完整的神经网络样例程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import tensorflow as tffrom numpy.random import RandomState# 1. 定义神经网络的参数，输入和输出节点。batch_size = 8w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))x = tf.placeholder(tf.float32, shape=(None, 2), name="x-input")y_ = tf.placeholder(tf.float32, shape=(None, 1), name='y-input')# 2. 定义前向传播过程，损失函数及反向传播算法。a = tf.matmul(x, w1)y = tf.matmul(a, w2)# tf.clip_by_value(A, min, max)：输入一个张量A，把A中的每一个元素的值都压缩在min和max之间。小于min的让它等于min，大于max的元素的值等于max。cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))train_step = tf.train.AdamOptimizer(0.001).minimize(cross_entropy)# 3. 生成模拟数据集。rdm = RandomState(1)dataset_size = 128X = rdm.rand(dataset_size, 2)Y = [[int(x1 + x2 &lt; 1)] for (x1, x2) in X]# 4. 创建一个会话来运行TensorFlow程序。with tf.Session() as sess: init_op = tf.global_variables_initializer() sess.run(init_op) # 输出目前（未经训练）的参数取值。 print("w1:", sess.run(w1)) print("w2:", sess.run(w2)) print("\n") # 训练模型。 STEPS = 5000 # 设定训练的轮数 for i in range(STEPS): start = (i * batch_size) % 128 end = (i * batch_size) % 128 + batch_size sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y[start:end]&#125;) if i % 1000 == 0: total_cross_entropy = sess.run(cross_entropy, feed_dict=&#123;x: X, y_: Y&#125;) print("After %d training step(s), cross entropy on all data is %g" % (i, total_cross_entropy)) # 输出训练后的参数取值。 print("\n") print("w1:", sess.run(w1)) print("w2:", sess.run(w2)) 输出为： 训练之前的神经网络的参数值： w1: [[-0.81131822 1.48459876 0.06532937] [-2.4427042 0.0992484 0.59122431]] w2: [[-0.81131822] [ 1.48459876] [ 0.06532937]] 可以发现，随着训练的进行，交叉熵是逐渐减小的。交叉熵越小说明预测的结果和真实的结果差距越小。 After 0 training step(s), cross entropy on all data is 0.0674925 After 1000 training step(s), cross entropy on all data is 0.0163385 After 2000 training step(s), cross entropy on all data is 0.00907547 After 3000 training step(s), cross entropy on all data is 0.00714436 After 4000 training step(s), cross entropy on all data is 0.00578471123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109训练之后的神经网络的参数值：&gt; &gt; w1: [[-1.9618274 2.58235407 1.68203783]&gt; [-3.46817183 1.06982327 2.11789012]]&gt; &gt; w2: [[-1.82471502]&gt; [ 2.68546653]&gt; [ 1.41819513]]# 第4章 深层神经网络## 4.1 深度学习与深层神经网络### 4.1.1 线性模型的局限性### 4.1.2 激活函数实现去线性化激活函数：tf.nn.relu、tf.sigmoid和tf.tanh。### 4.1.3 多层网络解决异或运算单层感知机无法模拟异或运算。加入了隐含层之后，就可以解决异或问题。## 4.2损失函数的定义### 4.2.1 经典损失函数交叉熵(cross entropy)。用q来表示p的交叉熵为：$$H(p,q)=-\sum_x p(x)\text&#123;log&#125; q(x)$$p代表的是正确答案，q代表的是预测值。交叉熵刻画的是两个概率分布的距离，也就是说交叉熵越小，两个概率分布越接近。`softmax`回归：将神经网络的输出变成一个概率分布。交叉熵的代码实现： cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))其中，`tf.clip_by_value`的用法`tf.clip_by_value(A, min, max)：`输入一个张量A，把A中的每一个元素的值都压缩在`min`和`max`之间。小于`min`的让它等于`min`，大于`max`的元素的值等于`max`。 import tensorflow as tf; import numpy as np; A = np.array([[1,1,2,4], [3,4,8,5]]) with tf.Session() as sess: print sess.run(tf.clip_by_value(A, 2, 5)) 输出：&gt; [[2 2 2 4]&gt; &gt; [3 4 5 5]]`tf.log`是对张量中所有元素依次求对数。`*`操作是元素之间直接相乘，矩阵乘法是`tf.matmul`。上面三个计算得到的结果是nxm的矩阵。`tf.reduce_mean`的用法。 v = tf.constant([[1.0, 2.0, 3.0, 4.0], [4.0, 5.0, 6.0, 7.0]]) sess = tf.Session() init_op = tf.global_variables_initializer() sess.run(init_op) print(tf.reduce_mean(v).eval(session=sess)) # 程序输出为：4.0 = sum/8### 4.2.2 自定义损失函数当然tensorflow也支持自定义损失函数。## 4.3 神经网络优化算法假设用$\theta$表示神经网络中的参数，$J(\theta)$表示在给定的参数取值下，训练集上损失函数的大小，那么整个优化过程可以抽象为：寻找一个参数$\theta$，使得$J(\theta)$最小。对于参数$\theta$，其梯度为$\frac&#123;\partial&#125;&#123;\partial\theta&#125;J(\theta)$。有了梯度，还需要学习率$\eta $(learning rate)来控制每次参数更新的幅度。因此，参数更新的公式为：$$\theta_&#123;n+1&#125; = \theta_n - \eta \frac&#123;\partial&#125;&#123;\partial\theta&#125;J(\theta)$$需要注意的是梯度下降算法并不能保证达到全局最优解，此外还存在计算时间过长的问题。为了加速训练过程，可以使用随机梯度下降(stochastic gradient descent)算法。每一轮迭代中随机优化某一条训练数据的损失函数。在实际应用中，采用折中的方法：**每次计算一小部分训练数据的损失函数**。这一小部分数据被称为&lt;font color=AA00AA&gt;**batch**&lt;/font&gt;。## 4.4 神经网络进一步优化### 4.4.1 学习率的设置假设我们要最小化函数 $y=x^2$, 选择初始点 $x_0=5$。#### 1. 学习率为1时```pythonimport tensorflow as tfTRAINING_STEPS = 10LEARNING_RATE = 1x = tf.Variable(tf.constant(5, dtype=tf.float32), name=&quot;x&quot;)y = tf.square(x)train_op = tf.train.GradientDescentOptimizer(LEARNING_RATE).minimize(y)with tf.Session() as sess: sess.run(tf.global_variables_initializer()) for i in range(TRAINING_STEPS): sess.run(train_op) x_value = sess.run(x) print &quot;After %s iteration(s): x%s is %f.&quot;% (i+1, i+1, x_value) 结果是：12345678910After 1 iteration(s): x1 is -5.000000.After 2 iteration(s): x2 is 5.000000.After 3 iteration(s): x3 is -5.000000.After 4 iteration(s): x4 is 5.000000.After 5 iteration(s): x5 is -5.000000.After 6 iteration(s): x6 is 5.000000.After 7 iteration(s): x7 is -5.000000.After 8 iteration(s): x8 is 5.000000.After 9 iteration(s): x9 is -5.000000.After 10 iteration(s): x10 is 5.000000. 学习率为1的时候，x在5和-5之间震荡。 2. 学习率为0.001时将上述代码中的学习率设为0.001（很小），如下：1LEARNING_RATE = 0.001 运行结果为：12345678910After 1 iteration(s): x1 is 4.990000.After 101 iteration(s): x101 is 4.084646.After 201 iteration(s): x201 is 3.343555.After 301 iteration(s): x301 is 2.736923.After 401 iteration(s): x401 is 2.240355.After 501 iteration(s): x501 is 1.833880.After 601 iteration(s): x601 is 1.501153.After 701 iteration(s): x701 is 1.228794.After 801 iteration(s): x801 is 1.005850.After 901 iteration(s): x901 is 0.823355. 学习率为0.001的时候，下降速度过慢，在901轮时才收敛到0.823355。 3. 使用指数衰减的学习率将上述代码中的学习率设为指数衰减的方式，如下：1LEARNING_RATE = tf.train.exponential_decay(0.1, global_step, 1, 0.96, staircase=True) 运行结果：12345678910After 1 iteration(s): x1 is 4.000000, learning rate is 0.096000.After 11 iteration(s): x11 is 0.690561, learning rate is 0.063824.After 21 iteration(s): x21 is 0.222583, learning rate is 0.042432.After 31 iteration(s): x31 is 0.106405, learning rate is 0.028210.After 41 iteration(s): x41 is 0.065548, learning rate is 0.018755.After 51 iteration(s): x51 is 0.047625, learning rate is 0.012469.After 61 iteration(s): x61 is 0.038558, learning rate is 0.008290.After 71 iteration(s): x71 is 0.033523, learning rate is 0.005511.After 81 iteration(s): x81 is 0.030553, learning rate is 0.003664.After 91 iteration(s): x91 is 0.028727, learning rate is 0.002436. 使用指数衰减的学习率，在迭代初期得到较高的下降速度，可以在较小的训练轮数下取得不错的收敛程度。 4.4.2 过拟合问题为了避免过拟合，一个非常常用的方法是正则化(regularization)，加入刻画模型复杂程度的指标$R(w)$，优化时优化$J(\theta)+\lambda R(w) $。 常用的正则化方法有：L1正则化和L2正则化。$$R(w) =||w||_1 =\sum_i|w_i|$$$$R(w) =||w||_2^2 =\sum_i|w_i^2|$$ 无论哪一种正则化的方式，其思想都是通过限制权重的大小，使得模型不能任意拟合训练数据中的随机噪声。 区别在于，L1正则化会使得参数变得更加稀疏，而L2正则化则不会；此外，L1正则化的计算公式不可导，而L2正则化公式可导。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS2015 设置调试时不加载符号]]></title>
    <url>%2F2017%2F12%2F27%2FCPP_VS2015_noPDB%2F</url>
    <content type="text"><![CDATA[人生苦短，消除等待！！ 问题描述用VS2015打开代码文件，按下F5进行调试，当电脑接入网络后系统会自动从Microsoft符号服务器加载PDB符号文件，而且是每次都会加载。如下图所示： 此加载符号过程使得调试变得非常慢。 通过查阅得知，此类的pdb调试器在编写代码时对于新手来说，根本用不到。也就是说完全可以不需要加载。 那么如何避免VS2013调试时自动加载符号呢？ 解决方案 打开VS的【工具】-【选项】： 选择其中的【调试】-【符号】，并 取消勾选“Microsoft符号服务器” ： 确定并退出即可，此后再次按F5进行调试。 参考资料 VS2013代码调试：如何避免调试时加载符号 vs2015加载符号慢，请问怎么解决]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>VS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习技法笔记01：最佳分类超平面]]></title>
    <url>%2F2017%2F12%2F26%2FML_taiwan_01%2F</url>
    <content type="text"><![CDATA[Large-Margin Separating Hyperplane题目翻译为中文的意思大体上是 最大余量分类超平面。本节主要讲解如何确定该最佳分类超平面。 首先，我们回顾一下之前讲过的Linear Classfication ：有$\circ$和$\times$，我们用一条直线将$\circ$和$\times$分开，或者在高维空间中使用超平面将其分开。数学上，将资料拿来计算一个加权和，根据和的正负预测$\circ$和$\times$。 现在，给定一个线性可分的资料，则会有很多条线将和分开，但是下图中的那条线会更好呢？ PLA(Perceptron learning algorithm,For binary classification解决是非问题)会选哪一条线与PLA看到的错误有关，因此PLA得到哪一条线不定。从之前的理论来看，三条线似乎也没什么区别，例如从VC Bound来看：$$E_{out}(w)\leqslant E_{in}(w) + \Omega(H) $$ 其中$E_{in}(w)$为训练样本上的错误率，三条线都满足；$\Omega(H)$为复杂度，都是线，因此复杂度都为d+1。但是我们的直觉告诉我们最右边是最好的线。 一种原始的解释：假设我们已经拿到原始资料，即图上的点，但是在测试的时候我们拿到跟原始资料相近的资料(测量误差、资料收集等造成)，下图中灰色的x。所以，测试资料可能会和训练资料有点出入。 假设我们绝对相信我们的训练资料，若果有误差，则我们人为最好的预测为将测试资料预测的与训练资料很接近(不完全一样)。 上图中左边与右边最大的差别就在于对测量误差的容忍度，点距离线越远则容忍度越好(tolerate more noise)，进而可以避免过拟合(more robust to overfitting)。 或者换个角度，看这条线有多胖（能涨出去多少），倾向于选择胖的线。 robustness = fatness: distance to closest xn比较胖的线是比较好的。 goal: find fattest separating hyperplane在分类正确的基础上，找出最胖、最强壮(鲁棒)的线。 目标是：我们要找出一条线，首先这条线可以将$\circ$和$\times$分开(线性可分)，然后取最胖的一条线，即计算所有点到线的距离，取其中最小的距离。也就是下面的公式所描述的： fatness: formally called margin：最胖的线，术语上叫“margin”，余量，留白的多少。 correctness: yn = sign(w^T x_n)算出来的分数是正的还是负的，相乘是同号(分类正确)就可以。 goal: find largest-margin separating hyperplane：寻找边界最宽，能够完全分开的线（超平面）。 参考资料 台大林轩田《机器学习基石》学习笔记5：线性模型一（PLA/pocket、Linearregression ） 机器学习技法(林軒田)笔记之一 机器学习技法(林軒田)视频与讲稿。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer学习笔记：(一/二)从基本类型开始]]></title>
    <url>%2F2017%2F12%2F25%2FCPP_01_02%2F</url>
    <content type="text"><![CDATA[本文介绍了C++的基础知识点。包括但不限于： 顶层const与底层const constexpr auto decltype struct 头文件保护符 第一章 开始include指令(P6,1.2)通常情况下#include指令必须在所有函数之外。include和它想包含的头文件名字必须在同一行里，不然会报错。 一般情况下我们把include指令放在源文件代码内容的最前面，当你在源文件中使用#include声明了一个头文件，效果相当于你把整个头文件黏贴到对应的那一行上。 编译器(P14,1.4)编译器的一部分工作是寻找程序文本中的错误。常见错误类型： 语法错误(syntax error) 类型错误(type error) 声明错误(declaration error) “编辑-编译-调试”（edit-compile-debug）周期。 文件重定向(P19,1.5)1$ addItems &lt;infile &gt;outfile 术语表(P23) 花括号 curly brace 内置类型 built-in type 形参列表 parameter list 字符串字面值常量 string literal 操作符 manipulator 变量 variable 初始化 initialize 注释 comments 集成开发环境 Integrated Developed Environment,IDE 条件 condition 赋值 assignment 表达式 expression 语法错误 syntax error 方法（类方法） method 第二章 变量和基本类型C++语言关于类型的规定(P30,2.1.1)C++语言的基本类型的设定与硬件紧密相关，因此很多类型的内存尺寸也都只是给了一个范围，其实各家IDE（LLVM，GCC，Visaul C++）的实现都是在范围内，具体的实现细节都是不确定的。 其中bool最小尺寸未定义，char最小尺寸是8位，wchar_t和char16_t的最小尺寸都是16位，char32_t的最小尺寸是32位，int的最小尺寸是16位，long和long long的最小尺寸分别是32位和64位，对于浮点型数据的表现尺寸是按照精度计算的，其中float的最小尺寸精度是小数点后6位(通常占内存32bytes)，double（通常占内存 64bytes）和long double(通常占内存 96~128bytes)的最小尺寸精度则是小数点后10位(实际可能比这个精度要大一些，比如float小数点后有效位为7，double为16)。 int不得小于short,long不得小于int,long long不得小于long。float,double,long double也应该是精度递增（或者相同）的关系。 要特别注意的是，扩展的字符类型(char16_t，char32_t，wchar_t)和布尔类型都没有带符号和无符号之分（尽管它们也确实属于算数类型）。 类型转换(P32,2.1.2)程序自动执行的类型转换操作发生在程序里IDE预期我们使用A类型但是实际上我们使用B类型的时候，B类型的对象会自动转换为A类型的，如果没法转换，程序就会报错。赋值操作中就可能发生这样的情况。 我们先看赋值操作里表达式里面发生的自动转换，赋值操作A=B中，等号左边的A被叫做左值，B被叫做右值，程序期待事情是你给定的右值和左值类型完全相同。如果不相同，这里就会发生强制的类型转换，即把B的类型转化为A的类型。如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个无符号类型，比如unsigned char c=-1;这时-1（整型，负的），右值会转化为无符号字符型，初始值对无符号类型表示数值总数取模，然后求余数，这个余数就是转化后的数。 因为C++没有明确规定有符号类型的数应该如何表示，因此如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个有符号类型，这种行为的结果是不一定的，因为C++标准委员会没有规定这样做之后到底会发生什么，因此各个IDE可能会有不同的实现。我们把这种不确定造成结果的行为叫做未定义行为。 建议：避免无法预知和依赖于环境的行为。 提示：切勿混用带符号类型和无符号类型。 转义序列(P36，2.1.3)字符的转义序列可以为\后面加上最多3个8进制数字（如果多于3个不会引发报错，多出的部分会被当成字符），或者\x后面加上最多两个16进制数字（多出会报错）。数字转换成10进制后的大小不得超过字符集的限定范围。一般的字面值转义无此限制，不过，一般的字面值的类型是不确定的。10进制数字类型字面值会被转换为能够容纳这个数的带符号整数类型，其他进制中它们则会被转换为能容纳它们的占内存最小的类型的值。 在最新的C++14标准中，数字字面值里还允许以0b或者0B开头，后面加上二进制数成为二进制字面值。如0B101，代表数字5；0b11，代表数字3。 指定字面值的常量：当使用一个长整型字面值时，请使用大写字母L来标记，因为小写字母l和数字1太容易混淆了。 变量(P38)列表初始化C++11标准：列表初始化(list initialization)，用一组花括号来初始化变量。下面的第三种：1234int units_sold = 0;int units_sold = &#123;0&#125;;int units_sold&#123;0&#125;;int units_sold(0); 变量声明和定义的关系变量能且只能被定义一次，但是可以被多次声明。声明变量：在变量名前添加关键字extern，而且不要显示地初始化。12345extern int i; // 仅仅是声明extern int i = 0; // 声明且定义int v; // 声明且定义int a = 0; // 声明且定义 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 补： extern外部变量声明其实是在IDE进行编译的时候告诉IDE，这有一个外部变量你要去别的地方找。因此我们应该掌握编译链接这套流程才能够更加方便的会用extern。假设有一个头文件a.h，这个头文件里面定义了int aaa=0;还有一个源文件b.cpp。这个b.cpp里面使用了extern int aaa;这样的语句，那么这个b.cpp是编译不了的。因为头文件如果不被别的源文件引用，是不参与被编译为obj的过程的，一旦它不参与这个过程，它里面声明的aaa这个全局变量其实就不存在，因此在b.cpp里面外部生命一个不存在的变量自然就是非法的。另外，使用extern也要和static做区分并考量它在别的文件中会不会造成内存污染等问题。这里应该掌握分离式编译的编译和链接特性再使用extern比较好。 静态类型(P42) 指针与引用初始化所有指针： 初始化为nullptr或0。 void *指针(P50)：特殊的指针类型，可以存放任意对象的地址。我们对该指针中到底是个什么类型的对象并不了解。 1int *p1,p2; 其中，p1是指向int的指针，p2是int。(强调变量具有的复合类型。) 指向指针的指针：通过*的个数可以区分指针的级别，即：**表示指向指针的指针，***表示指向指针的指针的指针。 指向指针的引用(P52)：123456int i = 42;int *p;int *&amp;r = p; //r是对指针p的引用r = &amp;i; //r引用了一个指针，因此给r赋值&amp;i就是令p指向i*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0 面对一条比较复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。 顶层const(P57,2.4.3)顶层const是对const而言的，“顶层”可以用来修饰const状态的形容词。一个const使对象本身的值固定，这个const就被称为顶层const;一个const是对象指向或引用的对象成为固定值，这个const就被称为底层const。 顶层和底层const对拷贝来说密切相关，有相同底层const资格的两个对象才能够互相拷贝，而且顶层const声明变量之后不允许再次改变const的值。int p,const int *a＝&amp;p;这种语句中的const就是底层const。像int v1=9;const int *p=&amp;v1;int *p2=p;这种语句如果能够通过编译，那么我们就可以使用p2的性质改变p1指向的常量的值，但是常量的值是不能够被改变的，因此这种变相改变常量的值的表达式都是错误的。可以通过分析const级别得到表达式中常量是否被更改，从而判断语句的正确性。 说到底，顶层底层说的是对拷贝控制的约束。总的规则就是“不能改变常量的值”。因此“拷入和拷出的对象都要有相同的底层const资格，或者两个对象数据类型必须能转换”，例如，有int *p1,const int *p2;。p1没有底层const,p2有底层const。p1=p2;这时const int*不能转换成int *(如果转换，就违反了“不能改变常量的值这一约束条件”)，因此p1=p2;不合法。p2=p1;``int *能够转换成const int *,因此p2=p1合法。 constexpr(P58,2.4.4)我们在了解constexpr之前，应该先了解常量表达式。所谓常量就是固定的量，那么常量表达式就是值固定不变的表达式，这里“值固定不变”，指的是程序编译阶段，常量表达式的值就能被确定下来之后也不能对其进行任何种方式的修改。因此这个固定，是编译之后固定的。像cout&lt;&lt;1234&lt;&lt;endl;中的1234，就是常量表达式，显然，字面值是常量表达式。 constexpr的作用之一就是帮助程序员在IDE的提示下查看一个赋值语句是不是常量表达式。使用的方式包含在声明语句里面，形如constexpr 变量类型 变量名=右值;如果右值是一个常量，这条语句就是正确的。在所有函数体外声明的全局变量的地址就符合“在编译期间能确定，编译后值不被改变”这两个条件，因此也属于常量。123constexpr int mf = 20; // 20是常量表达式constexpr int limit = mf + 1; // mf+1是常量表达式constexpr int sz = size(); //只有当size是一个constexpr函数时，才是一条正确的语句。 另外，用constexpr声明的指针(比如，constexpr int *p=&amp;v1;中的*p，相当于int *const p=&amp;v1;)都是顶层const，即指针本身值固定。但是指针指向的内容是可以变的。引用也一样。 定义于函数体之外的变量的地址是固定的，可以用来初始化constexpr指针。 当你使用constexpr定义引用变量的时候，这个变量引用的对象只能是全局基本数据类型（引用类型除外的）变量（因为要求的内存地址必须是固定不变的）。constexpr引用的结果和正常的引用的结果是一致的，因为引用本身就是固定不变的，因此相当于顶层const修饰的constexpr对引用类型类说没有特殊的意义。 类型别名(P61,2.4.4)使用typedef int zhengxing;这种对简单的类型名进行替换的方式无疑是非常直观并且好理解的，但是在涉及到复杂的类型名的时候往往会出现各种各样的问题。 比如typedef char *Pstring;这条语句是不是就意味着我们看到Pstring就可以用char *替换呢。其实并不是，实际上类型别名不只是替换的规则，而是要复杂很多。 比如我们遇到const Pstring a;的时候，按照替换的规则，这条语句就相当于const char * a;这里的const这种情况下是底层const，但是结果并不是这样的，这条语句正确的等同语句应该是char *const a;是一个顶层const，即指针本身是一个常量。让我们来分析一下为什么是这个样子，而不是简单的替换就行了。typedef char *Pstring；这条语句就是说Pstring是一个类型别名，它是什么类型的类型别名呢？Pstring是 指向char的指针的类型别名，也就是说，这个类型修饰的对象必须是一个指针，这个指针也必须指向char而不能指向别的什么东西，比如，不能指向const char。我们再看看const Pstring a;这个语句，首先a一定是指向char的指针。所以这个前面的const应该是用来修饰这个指针本身。也就是说，这个指针是常量指针而非指向常量的指针。这一点非常重要。 const char * a这个语句里面，实际上类型是const char，*是声明符的一部分。我们说过，定义一个变量由两部分组成，类型名和声明符，声明符可以是*或者&amp;加上变量名的形式。而类型别名只是给类型一个别名，至于声明符是怎样的，不在它修饰的范围内。因此在有const的情况下，就可以看出来这两者之间的区别还是很明显的。 123typedef char *pstring;const pstring cstr = 0; //cstr是指向char的常量指针const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针。 pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针。1const char *cstr = 0; //是对const pstring的错误理解 数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。cstr是一个指针，指向了常量字符。 auto类型声明符(P61,2.5.2)C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。 auto变量通过初始化语句，计算出右值的类型，并推导出左值的类型。12int i=0, &amp;r = i;auto a = r; // a是一个整数（r是i的别名，而i是一个整数） 这个过程中auto将会忽视顶层const和引用类型，可用const auto &amp;a=i;这种方式显式地指出了：指出要推导的结果是带顶层指针属性的或者是引用属性的。 auto推导多个值时，这些值的类型必须是一样的。因为auto是利用初始化赋值，因此它的行为基本上也和初始化有关。 关于auto的更多用法：【C++11】新特性——auto的使用 decltype类型指示符(P62,2.5.3)有时候会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为此，C++11新标准引入第二种类型说明符decltype。 decltype不通过计算，只通过推算出变量应有的值，表达式本身应有的值和函数的返回值来推导类型。 对于变量类型，decltype保留顶层const和引用的属性。对于表达式，解引用表达式(如:int i=1; int *p=&amp;i; decltype (*p) a=i;中的*p,对p解引用是int &amp;类型的)和带括号的表达式，（如：decltype ((a+1)) c=i;）的结果都将是引用类型。因为decltype通过处理表达式得到结果，因此更详细的内容在第四章将会被提到。有的表达式返回左值，有的表达式返回右值，返回左值的表达式在decltype类型推导下得到的将是引用的结果。12345int i = 42,*p = &amp;i, &amp;r = i;decltype(r + 0) b; //正确，加法结果为int，因此b是一个（未初始化的）intdecltype(*p) c; //错误，c是int&amp;，必须初始化decltype((i)) d; //错误，c是int&amp;，必须初始化decltype(i) e; //正确，e是一个（未初始化的）int decltype((variable)) (注意是双层括号)的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。 补： 一般情况下，出现数组名的表达式时会把数组名转换为指针，而用decltype一个数组名时，其返回类型是该数组的类型，如有int ia[10]，则decltype(ia) da，此时da也为包含10个int元素的数组。用于函数时也一样，不会自动把函数名转换为指针，而是返回该函数类型。 如果作用于一个取地址运算符，则为指向指针的指针，如有int p，则decltype(&amp;p)的结果是int **类型。 用关键字struct自定义数据结构使用struct关键字定义类的形式如struct 类名｛数据成员类型1 数据成员名1；数据成员类型2 数据成员名2;｝;，C++11规定可以给类内成员提供类内初始值用于初始化用我们自定义类创建的对象实例中的成员的值。形式如下：12345struct MyClass&#123; int student=0; float numbers=1;&#125;; 很多新手程序员忘记在类定义的最后加上分号。 头文件保护符123456789#ifndef SALES_DATA_H#define SALES_DATA_H#include &lt;string.h&gt;struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;#endif 头文件保护符依赖于预处理变量。如#define DEBUG，此时DEBUG就是预处理器变量。预处理变量无视C++语言中关于作用域的规则。 头文件保护符很简单， 程序员只要习惯性加上就可以了，没必要太在乎你的程序到底需不需要。 术语表1.算数类型 arithmetic type2.整型 integral type3.转换 convert4.不可打印 nonprintable5.转义序列 escape sequence6.类型说明符 type specifier7.分离式编译 separate compilation8.声明 declaration9.声明符 declarator10.静态类型 statically typed11.类型检查 type checking12.标识符 identifier13.内层作用域 inner scope14.复合类型 compound type15.左值引用 lvalue reference16.预处理 preprocessor17.临时量 temporary18.指向常量的指针 pointer to const19.常量指针 const pointer20.字面值类型 literal type21.类型别名 type alias22.类内初始值 in-class initializer23.预处理器 preprocessor24.头文件保护符 header guard 参考资料 C++ Primer 中文版 第5版 https://zhuanlan.zhihu.com/p/21820756]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photoshop白色背景图片转换为透明背景]]></title>
    <url>%2F2017%2F12%2F21%2Fps_white2transparent%2F</url>
    <content type="text"><![CDATA[1.打开Adobe Photoshop以及待处理的图片，如果图层上有“锁”的标志，就双击进行解锁； 2.在图层上右击，选择最上方的“混合选项”； 3.在混合选项中的本图层中，拖动右侧的白色小三角，向左滑动至适当位置。 4.效果展示。滑动之前的效果：滑动之后的效果： 5.存储。选择“文件”中的“存储为”； 在弹出窗口中选择保存类型为“PNG”格式，保存即可。也可以根据需要，选择合适的格式。 最后附上全文的图片链接。]]></content>
      <categories>
        <category>Photoshop</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万网域名注册、域名解析与备案流程]]></title>
    <url>%2F2017%2F12%2F19%2Fblog_domain_register%2F</url>
    <content type="text"><![CDATA[域名注册简要说一下为什么选择万网。 看到网上的教程一般都是推荐到国外网站注册，如godaddy，Gandi，Namesilo等等。但一般都是比较早期的回答(2011-13)了，目前(2017/12)来说，仅从价格因素考虑，阿里云万网域名是普遍低于国外网站的。 万网域名注册地址：https://wanwang.aliyun.com/domain/ 另外，关于域名后缀选择问题，一般来说，首选com域名，不推荐cn域名（国内监管严格的原因？）。其次，个人博客站点可以考虑其他后缀，如net，top，me(貌似万网不支持了)，xyz等等。 选择了心仪的域名之后，购买。以阿里云为例，购买完成后，点击右上角的控制台；进入控制台后，选择左下角的域名与网站（万网）下的域名，进入域名列表界面。 可以看到，右方出现了三个选项【续费】、【解析】【管理】 域名解析点击解析，按照操作，添加解析即可。主要填写三个参数：记录类型、主机记录和记录值。 记录类型：CNAME是跳转到其他网址，我的是github博客，就直接让他跳转到github博客即可。A是指向IPV4地址。 主机记录是网址的前缀，比如说注册的网址是xxx.com，那么blog.xxx.com的主机记录就是blog，xxx.com的主机记录可以不填，也可以填上一个@ 给出我目前的解析值作为参考。第一个是为了让百度搜索引擎抓取的，每个网址的主机记录都不同，可以忽略。 域名备案我使用的是hexo+Github搭建个人博客，因此，只买了域名（也可以不买，直接使用github.io地址），没有买云服务器、虚拟主机之类的，因此无法备案。 简而言之，备案需要有服务器，然后到服务器提供商处备案即可。 阿里云官方的备案完整流程，可供备案参考：https://help.aliyun.com/knowledge_detail/36895.html]]></content>
      <categories>
        <category>博客搭建系列</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之实现来必力评论功能]]></title>
    <url>%2F2017%2F12%2F18%2Fblog_comment%2F</url>
    <content type="text"><![CDATA[评论功能概述目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。 可用的评论系统大概有： HyperComments：https://www.hypercomments.com （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，） 来必力：https://livere.com （来自韩国，使用邮箱注册。） 畅言： http://changyan.kuaizhan.com （安装需要备案号。不太好用。） Gitment： https://github.com/imsun/gitment （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。） Valine: https://github.com/xCss/Valine (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？） 综上，最终采用了来必力。 注册账号打开来必力官网：https://livere.com 按套路注册（有可能注册上面要花费点功夫）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。 安装点击上方的安装，选择免费的city版本。 并点击现在安装，出现如下界面。 复制其中的uid字段。 打开主题目录下的blog/themes/next/_config.yml配置文件，定位到livere_uid字段，粘贴上刚刚复制的UID。 至此，大功告成。 效果展示测试评论如图所示： 设置提醒当有新评论出现时，通过邮箱提醒。 点击右上角-&gt;管理页面。选择评论提醒，按照下图设置，输入邮箱、选择间隔时间。]]></content>
      <categories>
        <category>博客搭建系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>来必力</tag>
        <tag>评论功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(2) 第三章 函数的增长]]></title>
    <url>%2F2017%2F12%2F13%2Falgorithm_tutorial_chapter_3%2F</url>
    <content type="text"><![CDATA[本文是《算法导论》第三章：函数的增长的学习笔记。没有涉及到具体的算法。主要内容有： 五种渐近记号的表示 常用的函数与标记 3.1 渐近记号$\Theta、 \text{O}和\Omega $三种记号的图示： 先看第一幅图(a)——$\Theta$记号若存在正常量$c_1,c_2,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant c_1g(n)\leqslant f(n) \leqslant c_2g(n)$，则$f(n)$属于集合$\Theta(g(n))$，可以记为$f(n)\in \Theta(g(n))$，我们通常用$f(n)=\Theta(g(n))$表达相同的概念。 上述公式的含义：函数f(n)能“夹入”$c_1g(n)$和$c_2g(n)$之间。换句话说，对所有的$n\geqslant n_0$，函数$f(n)$在一个常量因子内等于$g(n)$，我们称$g(n)$是$f(n)$的一个渐近紧确界(asymptotically tight bound)。 实例：可以用上述的形式化定义来证明：$\frac{1}{2}n^2-3n =\Theta(n^2)$，以及$6n^3 \neq \Theta(n^2)$。 渐近正函数就是对足够大的n均为正的函数。 直觉上，一个渐近正函数的低阶项 在确定渐近确界时可以被忽略，因为对于大的n，它们是无足轻重的。 一般来说，对任意多项式$p(n)=\sum_{i=0}^d a_i n^i$，其中$a_i$为常量且$a_d&gt;0$（最高阶的系数大于零），则有$p(n)=\Theta(n_d)$。 接着看图(b)——$\text{O}$记号$\Theta$记号渐近地给出了一个函数的上界和下届。当只有一个渐近上界时，使用$\text{O}$记号。 $\text{O}(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant f(n) \leqslant cg(n)}$ 我们记$f(n)=\text{O}(g(n))$表示$f(n)$是集合$\text{O}(g(n))$的成员。注意$f(n)=\Theta(g(n))$蕴含了$f(n)=\text{O}(g(n))$，因为$\Theta$记号是一个比$\text{O}$记号更强的概念。 使用$\text{O}$记号，我们常常可以仅仅通过检查算法的总体结构来描述算法的运行时间。$\text{O}$记号描述上界，对插入排序算法的最坏情况运行时间的界$\text{O}(n^2)$也适合于该算法对每个输入的运行时间。该算法对每个输入的运行时间都有一个界，这就是综合性描述。 最后看图(c)——$\Omega$记号正如$\text{O}$记号提供了渐近上界，$\Omega$记号提供了渐进下界。 $\Omega(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant cg(n) \leqslant f(n)}$ 于是，由此引出了定理3.1。 定理 3.1对任意两个函数$f(n)$和$g(n)$，我们有$f(n)=\Theta(g(n))$，当且仅当$f(n)=\text{O}(g(n))$且$f(n)=\Omega(g(n))$。 当一个算法的运行时间为$\Omega(g(n))$时，我们意指不管n是什么规模，只要n足够大，对那个输入的运行时间至少是$g(n)$的常数倍。 等式和不等式中的渐近记号当渐近记号出现在某个公式中时，我们将其解释为代表某个我们不关注名称的匿名函数。 例如：$2n^2+3n+1 = 2n^2 +\Theta(n)$。 按这种方式使用渐记号可以帮助消除一个等式中无关紧要的细节与混乱。 例如：归并排序的最坏情况运行时间：$$T(n) = 2T(n/2)+\Theta(n)$$如果只对T(n)的渐近行为感兴趣，就没必要准确说明所以低阶项，它们都被理解为包含在由项$\Theta(n)$表示的匿名函数中。 在某些例子中，渐近记号出现在等式的左边，如：$$2n^2+\Theta(n) = \Theta(n^2) $$ 无论怎么选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。 $\text{o}$记号$\text{o}$记号，非渐近紧确的上界。 $\text{o}(g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant f(n) &lt; cg(n)}$。 $\text{O}$记号与$\text{o}$记号类似，主要的区别 是在$f(n)=\text{O}(g(n))$中，界$0\leqslant f(n) \leqslant cg(n)$对某个常量$c&gt;0$成立，但在$f(n)=\text{o}(g(n))$中，界$0\leqslant f(n) &lt; cg(n)$对所有常量$c&gt;0$成立。 直观上，在$\text{o}$记号中，当n趋向于无穷时，函数$f(n)$相对于$g(n)$来说变得微不足道了，即：$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = 0$$ $\omega$记号非渐近紧确下界。 $\omega (g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant cg(n) &lt; f(n) }$。 $$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = \infty $$ 渐近运算的运算性质传递性、自反性、对称性与转置对称性：而且：两个函数f和g的渐近比较关系可与实数a与b之间的比较做类比： f(n)=O(g(n)) 类似于a&lt;= b f(n)=Ω(g(n)) 类似于a&gt;= b f(n)=Θ(g(n)) 类似于a= b f(n)=o(g(n)) 类似于a&lt; b f(n)=w(g(n)) 类似于a&gt; b 三分性：虽然实数具有三分性，即对于任意两个实数a、b，下列三种情况必须有一种成立：$ab$。但是不是所有函数都可以渐近比较。 3.2 标准记号与常用函数单调性单调递增/单调递减：包含等号；严格递增/严格递减：不包含等号。 向下取整与向上取整x的向下取整：$\lfloor x \rfloor$；x的向上取整：$\lceil x \rceil$。 模运算对任意整数a和正整数n，$a\ \text{mod}\ n$ 的值就是商a/n的余数。$$a\ \text{mod}\ n = a-n\lfloor a/n\rfloor $$ 若$(a\ \text{mod}\ n)=(b\ \text{mod}\ n)$，则记$a\equiv b(\text{mod}n)$ 多项式给定一个非负整数d，n的d次多项式$p(n)$：$$p(n)=\sum_{i=0}^d a_i n^i$$其中，$a_d \neq 0 $。 多项式为渐近正的当且仅当$a_d &gt; 0 $。对于一个d次渐近正的多项式$p(n)$，有$p(n)=\Theta(n^d)$ 若对于某个常量k，有$f(n)=\text{O}(n^k)$，则称函数$f(n)$是多项式有界的。 指数对所有使得$a&gt;1$的实常量a和b，有$$\lim_{n\rightarrow \infty} \frac{n^b}{a^n} = 0$$据此可得：$$n^b = \text{o}(a^n)$$ 对数以2为底的自然数：$$\text{lg}n = \text{log}_2n$$自然对数：$$\text{ln}n = \text{log}_en$$取幂：$$\text{lg}^kn = (\text{lg}n)^k$$复合：$$\text{lg}\text{lg}n =\text{lg} (\text{lg}n)$$ 一个重要的记号约定：对数函数只适用于公式中的下一项，所以$\text{lg}n+k$意思是指$(\text{lg}n)+k$ 对于$a&gt;0,b&gt;0,c&gt;0$和n，有$$a = b^{\text{log}_ba}$$$$\text{log}_c(ab) = \text{log}_ca +\text{log}_cb$$$$\text{log}_b(a^n) = n\text{log}_ba$$$$\text{log}_ba =\frac{\text{log}_ca}{\text{log}_cb} $$$$\text{log}_b(1/a) =- \text{log}_ba $$$$\text{log}_ba =\frac{1}{\text{log}_ab} $$$$a^{\text{log}_bc} = c^{\text{log}_ba}$$其中，上述等式的对数底不为1。 对任意常量a，有$$\text{log}^bn = \text{o}(n^a)$$表示任意正的多项式函数都比任意多对数函数增长得快。 阶乘$n!$，读作“n的阶乘”。其定义为对整数$n \geqslant 0$：$$n! = \begin{cases}1 &amp; 若n=0\\n\cdot (n-1)! &amp; 若n&gt;0\end{cases}$$ 阶乘函数的一个弱上界是$n! \leqslant n^n$，因为在阶乘中，n项的每项最多为n。 斯特林(Stirling)近似公式$$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n})) $$ 由上述公式可以证明：$$n! = o(n^n)$$$$n! = \omega(2^n)$$$$\text{lg}n! = \Theta(n\text{lg}n)$$ 多重函数记号$f^{(i)}(n)$表示f(n)重复i次作用于一个初值n上。对非负整数i，我们递归地定义：$$f^{(i)}(n)=\begin{cases}n &amp; 若i=0 \\f(f^{(i-1)}(n)) &amp; 若i&gt;0\end{cases}$$ 多重对数函数$\text{lg}^*n$表示多重对数，多重对数增长非常慢。 斐波那契数斐波那契数的递归定义：$$F_0 = 0$$$$F_1 = 1$$$$F_i = F_{i-1}+F_{i-2}, i \geqslant 2$$]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>函数渐近</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论详解(1) 第二章 算法基础]]></title>
    <url>%2F2017%2F12%2F12%2Falgorithm_tutolrial_chapter_2%2F</url>
    <content type="text"><![CDATA[本文是《算法导论》的第二章：算法基础的笔记整理。其中主要包括两个算法： 插入排序 归并排序 第二章 算法基础伪码说明 数组A[1,…,n]长度为n的待排序序列。注意，书中的下标都是从1开始的。python中是从0开始的。 伪码中，A的长度用A.length表示。python中使用len(A)表示。 缩进表示块结构。提高代码清晰度。 while, for, repeat-until 在循环结束后，循环计数器仍然保持其值。 符号“//”后面是注释。 数组元素通过“数组名[下标]”这样的形式来访问。 复合数据通常被组织成对象，对象又由属性组成。 return允许返回多个值 按值把参数传递给过程，被调用过程接收其参数自身的副本。 布尔运算符“and”和“or”都是短路的。 2.1 插入排序插入排序的Python实现：123456789101112def insertion_sort(A): length = len(A) for j in range(1, length): key = A[j] i = j - 1 while i &gt;= 0 and A[i] &gt; key: A[i + 1] = A[i] i = i - 1 A[i + 1] = key return AA = [5, 3, 19, 1, 8, ]print(insertion_sort(A)) 对插入排序的简单理解：从第二个数开始，依次比较前面的数和key的大小，若大于key，则后移。最后将key插入到最前方停下的位置。j是遍历数组每个元素；i是每个元素前面、需要移动的最前方。 形象的解释：插入纸牌：key是当前带插入的牌，找到插入的位置，先把每个大的都往后挪一个位置出来，再把key插入到空出来的位置。 2.2 分析算法RAM（Random-access machine,RAM）模型:单处理器计算模型，指令一条接一条地执行，没有并发操作。 真实计算机如何设计，RAM模型就是如何设计的，RAM模型包含真实计算机的常见指令：算术指令（加减乘除，取余，向下取整，向上取整），数据移动指令（装入、存储和复制）和控制指令（条件与无条件转移、子程序调用与返回）。 灰色区域：真实计算机中未列出的指令。如指数运算算是常量时间的指令吗？ 答案：①一般情况下不是，如$x^y$，当x和y都是实数的时候。②在受限情况下，可以当做一个常量时间的操作。如$2^k$是一个常量的操作。 一个整数的各位左移k位等价于将该整数乘以$2^k$。 插入排序算法的分析算法需要的时间与输入规模同步增长，通常把一个程序的运行时间描述成其输入规模的函数。 输入规模的最佳概念依赖于研究的问题。 一个算法在特定输入上的运行时间是指执行的基本操作数或步数。算法的运行时间是执行每条语句的运行时间之和。 若数组已排好序，则出现最佳情况：$T(n)=an+b$若数组已反向排序（即按递减序排好序），则导致最坏情况：$T(n)=an^2+b$，是n的二次函数。 最坏情况与平均情况分析本书往往集中于只求最坏情况运行时间，即对于规模为n的任何输入，算法的最长时间。 书中给出了三个理由，在此不详述。其中一点是平均情况往往与最坏情况一样差。 增长量级最坏情况运行时间表示为：$T(n)=an^2+b$。 现在我们做出一种更简化的抽象：我们真正感兴趣的运行时间的$增长率$或$增长量级$。 2.3 设计算法2.3.1 分治法许多算法在结构上是递归的，算法依次或多次递归地调用其自身以解决紧密相关的若干子问题。 分治模式在每层递归时都有三个步骤： 分解原问题为若干子问题； 解决这些子问题，递归地求解各子问题。 合并这些子问题的解成原问题的解。 归并排序算法完全遵循分治模式。归并算法的关键在于合并。归并排序的的基本步骤如下： 把待排序的数组分为左数组和右数组 对左数组和右数组进行迭代排序 将左数组和右数组进行合并 显然这些基本步骤符合分治模式在每一层递归上的三个步骤：分解、解决、合并。 2.3.2 归并排序算法（分治算法）MERGE(A,p,q,r)：完成合并。A是一个数组，p,q,r是数组的下标，满足$p\leqslant q&lt;r$。假设A[p..q]与A[q+1..r]都已排好序，MERGE函数的目的就是合并这两个子数组形成单一的已排好序的数组A[p..r]。 形象地描述：同样以插入排序时的扑克牌为例，现在的情况是有两堆牌（两个输入堆），牌面朝上（可见，已排序），每次选取两堆中较小的放入到输出堆，牌面朝下。重复这个步骤，直到一个输入堆为空，则把另一个输入堆直接牌面朝下的放置到输出堆。 MERGE-SORT(A,p,r)排序子数组A[p,r]中的元素。若$p\geqslant r$，则该子数组最多只有一个元素，所以已经排好序，直接返回。否则，分解步骤。计算下表q，将A[p..r]分为A[p..q]和A[q+1..r]。 123456789101112131415161718192021222324252627282930313233343536373839# author: wangwljfrom math import floorMAX = 1 &lt;&lt; 31def merge(A, p, q, r): n1 = q - p + 1 n2 = r - q L = [] R = [] for i in range(0, n1): L.append(A[p + i]) # 因为我初始化为空列表，所以直接赋值的话会报错，只能以append的形式追加值。 for i in range(0, n2): R.append(A[q + i + 1]) L.append(MAX) # 使用无穷大作为哨兵 R.append(MAX) assert len(L) == n1 + 1 and len(R) == n2 + 1 i = 0 # python是从0开始 j = 0 for k in range(p, r + 1): # 需要加1，因为首尾每个都算 if L[i] &lt;= R[j]: A[k] = L[i] i += 1 else: A[k] = R[j] j += 1def merge_sort(A, p, r): if p &lt; r: q = floor((p + r) / 2) merge_sort(A, p, q) merge_sort(A, q + 1, r) # 首尾都包含了，所以要加1 merge(A, p, q, r)if __name__ == "__main__": # test function A = [1, 3, 5, 2, 4, 6, 0, -1, 5] merge_sort(A, 0, len(A) - 1) print(A) 上述代码测试成功。 2.3.2 分析分治算法假设把原问题分解为a个子问题，每个子问题的规模都是原问题的1/b。（对于归并排序，a和b都是2，然而在许多分治算法中，$a\neq b $。） 求解规模为n/b的子问题，需要$T(n/b)$的时间，所以需要花费$aT(n/b)$的时间来求解a个子问题。 下面分析归并排序n个数的最坏情况运行时间$T(n)$的递归式。 分解：分解步骤只计算子数组的中间位置，需要常量时间，因此，$D(n)=\Theta(n)$ 解决：递归地求解两个规模为n/2的子问题，将贡献$2T(n/2)$的运行时间。 合并：n个子元素的数组上的merge需要$\Theta(n)$的时间（线性复杂度），所以$C(n)=\Theta(n)$。 $D(n)$和$C(n)$相加的和，仍然是n的线性复杂度，即$\Theta(n)$。再与“解决”步骤相加，为：$$T(n) = \begin{cases} \Theta(1) &amp; 若n=1 \\ 2T(n/2)+\Theta(n) &amp; 若n&gt;1\\ \end{cases} $$ 在第四章，我们将看到“主定理”，可以用该定理来证明$T(n)$ 为$\Theta(n\text{lg}n)$。（即时间复杂度为nlgn） 运行时间为$\Theta(n\text{lg}n)$的归并排序优于运行时间为$\Theta(n^2)$的插入排序。 $T(n) =\Theta(n\text{lg}n)$的直观理解：由(d)图，每层对n等分，可以展开为lgn层(再加上原来的一层，一共lgn+1层)。每层的复杂度都是cn，所以总的复杂度为$cn\text{lg}n+cn = cn(\text{lg}n+1)$。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法导论</tag>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起开始机器学习吧——知乎live笔记]]></title>
    <url>%2F2017%2F12%2F12%2FStart_Machine_Learning_review%2F</url>
    <content type="text"><![CDATA[本文纯干货，想要入门机器学习的同学可以参考一下。 问答干货①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。 ②教程推荐：公开课（吴恩达、coursera等），coursera上吴恩达的公开课 ③语言推荐：python，MATLAB。很多开源工具（MXNet，Tensorflow，Keras）都有Python接口。 ④python方面，网上有很多博客，比如廖雪峰的博客，感觉只需要了解即可，会用就行；传统算法入门的话，推荐李航的《统计学习方法》,入门最合适。最近出了Bengio的《Deep learning》书，有中文翻译，前面章节全是传统算法。不推荐一上来就看大家都说的《pattern recognition and machine learning》以及《模式分类》,这两本书不适合入门。 ⑤完全零基础的入门性质的资料：视频：https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s机器学习入门： http://www.cnblogs.com/subconscious/p/4107357.html ⑥数学基础课：数学（概率、线代、高数、随机过程，排名分先后） ⑦发论文经验：目前我只是有paper在投，还没有成功发过，哈哈。经验嘛，主要就是一定要敢于否定自己，我在写的paper一共两篇，每一篇都几乎改了七八次，每次都很严格地要求自己。同时，最好要把paper发给同组的人一起看看，不同的角度给你提问题，会帮助你认识到自己容易忽视的问题。视觉方面发paper其实很容易的。通常来说你需要在同一个数据集上跟最好的方法做对比。 ⑧我数学基础不太牢固 想一边看机器学习一边补数学 但有很多数学符号甚至都不认识 百度也没法搜索 你有什么建议吗？答：专业书籍都有符号索引表；学习简单的数学工具，如latex；matrix cookbook 矩阵常用的手册。 PPT干货 机器学习常用分类：监督学习、半监督学习、无监督学习、增强学习 ②无监督才是世界的本质，标注数据往往要花费大量的人力物力。没有标注这么做呢？迁移学习是可以类比无监督学习来做的事情。人是有类比能力的，计算机可以吗？我们想让它有这个能力。（就是迁移学习）通过迁移学习的方式可以部分地接近无监督学习的目标。迁移学习的好处是什么？利用已有的知识，节约新学习的成本。但需要找到两者的相似性。骑自行车-&gt;开汽车？ 不行！ 需要有相似性。深度学习算是对迁移学习的改进（我的总结）？，因为深度学习不像迁移学习需要手动提取特征。 准备工作 理论知识（高数、概率、线性代数、随机过程） 编码能力（Python, Matlab, Java） 基本入门 李航《统计学习方法》 周志华《机器学习》 吴恩达公开课 Kaggle竞赛 进阶提高 《模式分类》、《PRML》 ICML、NIPS等国际会议 做自己的研究工作 书籍资料整理：https://github.com/ty4z2008/Qix/blob/master/dl.md 入门资料：http://www.cnblogs.com/subconscious/p/4107357.html 公开课：http://open.163.com/special/opencourse/machinelearning.html Kaggle竞赛：https://www.kaggle.com/]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫实战--selenium模拟登录并自动点击]]></title>
    <url>%2F2017%2F12%2F09%2FHDHome_clawler_tutorial%2F</url>
    <content type="text"><![CDATA[爬虫实战项目。 爬虫利器：selenium的使用。 python爬虫实战–selenium模拟登录网站HDH并刷魔力值任务介绍最近刚刚注册了某个网站：HDHome，该站有新手考核任务，其中有一项是需要达到魔力值5000。在魔力值获取方式中，我们看到这一项：“说谢谢 = 0.5个魔力值”，而网站存活种子数量达到16000+，也就意味着对每个种子说一下谢谢，轻松达到8000+的魔力值，于是，这个项目应运而生。 实现思路：获取种子的页面，在每个页面中找到说谢谢的按钮，并点击后，关闭。依次进行下去即可。 相似任务： 实现对某论坛的自动回复，实现自动获取所有帖子的信息等等相关操作，无论是否需要模拟登录、模拟鼠标操作还是直接解析网站元素。 selenium 牛刀小试首先导入相关的库： 123456import selenium.webdriver as webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.common.keys import Keys 这是整个程序里面用到的所有内容。其中，webdriver是主浏览器，selenium都是基于整个浏览器的对象；WebDriverWait、EC、By是等待网页元素加载相关的操作；Keys是键值，如Keys.CONTROL，Keys.ENTER等等，ActionChains是用鼠标进行一系列的操作。 webdriver可用的浏览器有：123456789101112webdriver.Firefoxwebdriver.FirefoxProfilewebdriver.Chromewebdriver.ChromeOptionswebdriver.Iewebdriver.Operawebdriver.PhantomJSwebdriver.Remotewebdriver.DesiredCapabilitieswebdriver.ActionChainswebdriver.TouchActionswebdriver.Proxy 一开始我选择的是Chrome浏览器，后来改为了Firefox火狐。Chrome浏览器在执行单个元素（如验证码）截图时有坑（下文有详细说），所以后来才用的Firefox。此外，PhantomJS是匿名浏览器，没有显式的窗口。 那么，开始写程序吧。1234567driver = webdriver.Firefox()login_url = "http://hdhome.org/login.php"login_failed_url = "http://hdhome.org/takelogin.php"driver.get(login_url)while self.driver.current_url == login_url or self.driver.current_url == login_failed_url: time.sleep(10)# do something 首先，实体化浏览器driver，执行driver = webdriver.Firefox()这句的时候，就会有firefox浏览器弹出来了。当执行到driver.get(login_url)时，浏览器转到相应的网址，后面的while语句是用来等待我们手动登录的，当我们手动登录成功后，会进入到&quot;http://hdhome.org/index.php&quot;，与login_url及login_failed_url都不同。接着便可以做自己想做的事情了。 我们发现单个种子的网址是类似这样的：1single_link = "http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1".format(i) i可以从1到30000多。于是，我们可以这样写程序，依次对每个种子执行“说谢谢”操作：1234567891011121314151617def saythanks(link): driver.get(link) try: driver.find_element_by_xpath("//input[@id='saythanks']").click() print(link, " succeed\n") except: print(link, " not succeed\n") finally: time.sleep(1) pass START = 1END = 30000for i in range(START, END): link = "http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1".format(i) saythanks(link)driver.close() 其中，我们使用try、except、finally语句来尝试定位到’saythanks’说谢谢的按钮元素。由于有时候加载较慢就会找不到，或者是这个种子已经被删除了，所以也导致找不到该元素。 其中定位网页元素的方法有一下几种：123456789101112131415161718# locate single element in a page:find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector# To find multiple elements (these methods will return a list):find_elements_by_namefind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector 从上面可以看出，我们也可以用find_element_by_id(&quot;saythanks&quot;)同样可以找到说谢谢的按钮。 附上到目前为止的所有程序：GitHub地址1完整程序中加上了logging模块，将输出日志也导入到了文件，方面以后查阅。 改进一：使用多线程多标签在上述模块中，可以看到，我们按照种子的顺序依次进行相应的操作。在种子数量很多的时候，会显得很慢，于是，有了这个改进：使用多线程。 我们使用multiprocessing库。1from multiprocessing import Pool 先来看一个使用该多线程库的示例程序：123456789101112131415161718192021222324252627import timefrom multiprocessing import Pooldef run(fn): # fn: 函数参数是数据列表的一个元素 time.sleep(1) return fn * fnif __name__ == "__main__": testFL = [1, 2, 3, 4, 5, 6] print('shunxu:') # 顺序执行(也就是串行执行，单进程) s = time.time() for fn in testFL: run(fn) e1 = time.time() print("顺序执行时间：", int(e1 - s)) print('concurrent:') # 创建多个进程，并行执行 pool = Pool(5) # 创建拥有5个进程数量的进程池 # testFL:要处理的数据列表，run：处理testFL列表中数据的函数 rl = pool.map(run, testFL) pool.close() # 关闭进程池，不再接受新的进程 pool.join() # 主进程阻塞等待子进程的退出 e2 = time.time() print("并行执行时间：", int(e2 - e1)) print(rl) 于是，模仿上述程序，我们也使用多线程来执行说谢谢。说谢谢的过程其实有两步：一是打开网页，二是对每个网页定位到每个元素并点击。 如果对一、二两个步骤都执行多线程会出错，可能是由于多窗口的原因。因此我目前只对打开网页的步骤执行了多线程的操作。 上述也提到了，要同时打开多个窗口，则需要使用浏览器的多标签功能。打开一个新的标签的程序需要执行js脚本，如下：123def open_url(url): newwindow = 'window.open("&#123;&#125;")'.format(url) driver.execute_script(newwindow) 于是多线程部分的改进如下：123456789101112131415161718192021222324252627282930313233343536373839START = 25980 END = 30000 Thread_Num = 3 t = 1 for i in range(START, END, Thread_Num): pool = Pool(Thread_Num) all_links = ["http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1".format(i) for i in range(i, i + Thread_Num)] print(all_links) # noinspection PyBroadException try: rl = pool.map(open_url, all_links) pool.close() pool.join() except: print("multi thread start failed, next!!") logging.info("multi thread start failed, next!!") time.sleep(5) continue # 通过移动句柄来说谢谢 saythanks() # sleep more time.sleep(0.5) if t % 3 == 0: time.sleep(0.5) if t % 5 == 0: driver.switch_to.window(driver.window_handles[0]) driver.refresh() mystr = driver.find_elements_by_xpath('//span[@class="medium"]')[0].text bonus = re.search("\s[0-9,.]*\s", mystr).group() usrName = re.search("\s[a-zA-Z0-9]*\s", mystr).group() print(driver.current_url, "normal refresh,&#123;&#125;bonus is&#123;&#125;now...".format(usrName, bonus)) logging.info(driver.current_url + "normal refresh,&#123;&#125;bonus is&#123;&#125;now...".format(usrName, bonus)) time.sleep(1) t = t + 1 driver.quit() logging.info("&#123;&#125;: driver quit, program stop.".format( time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))) 为了不让浏览器检测到，我只是用了三个线程，可以适当的增加。saythanks()下面的部分程序是为了增加更多的延迟并且显示相应的信息。其中if t % 5 == 0:中，我们移动到主页上，进行刷新操作，然后定位到用户信息那一栏：12bonus = re.search(&quot;\s[0-9,.]*\s&quot;, mystr).group()usrName = re.search(&quot;\s[a-zA-Z0-9]*\s&quot;, mystr).group() 这个部分使用了re正则项来找出当前的魔力值以及用户名，并显示出来。 其中，说谢谢的程序也需要对多标签进行相应的改进，程序如下：123456789101112131415161718192021222324def saythanks(): while len(driver.window_handles) &gt; 1: driver.switch_to.window(driver.window_handles[-1]) # noinspection PyBroadException try: WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.ID, "outer"))) except: driver.refresh() time.sleep(1) print(driver.current_url, " refresh ---") # noinspection PyBroadException try: driver.find_element_by_xpath("//input[@id='saythanks']").click() print(driver.current_url, " succeed") logging.info(driver.current_url + " succeed~") except: print(driver.current_url, " not succeed") logging.info(driver.current_url + " not succeed!") finally: time.sleep(1) driver.close() driver.switch_to.window(driver.window_handles[-1]) 通过在不同窗口的句柄之间移动，来依次进行说谢谢的步骤。在每个网页加载的时候，我们执行了等待的操作：1WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.ID, "outer"))) 一直等到最外层的元素出现。我选择的”outer”这个元素，是在无论这个种子是否存在的时候都会出现的。 1driver.switch_to.window(driver.window_handles[-1]) 将窗口转移到最后打开的那个窗口。12driver.close()driver.switch_to.window(driver.window_handles[-1]) 关闭当前的个窗口，并转到当前的最后一个窗口。需要注意的是：窗口虽然关闭了，但是，driver依旧会停在那个已经失效的窗口，并不会自动的转到新的窗口（虽然在浏览器中看上去到了新的窗口），所以，需要我们自己手动的移动窗口的句柄。 这边还存在一个问题，就是多标签的时候，自动切换标签的时候，浏览器会自动弹出来。这样子便有点烦人，毕竟我们只是想让他在后台自己跑， 所以，我加上了一个虚拟窗口，使用的是pyvirtualdisplay库。 以下是pyvirtualdisplay库在ubuntu中的安装步骤：123pip install pyvirtualdisplaysudo apt install xvfbsudo apt install xserver-xephyr 下面是pyvirtualdisplay具体的使用方式：12345from pyvirtualdisplay import Displayif __name__ == &quot;__main__&quot;: display = Display(visible=1, size=(800, 600)) display.start() 把虚拟窗口放在一开始处的位置即可。也可以将visible改为0，浏览器就完全不可见了。 最后附上这个阶段的完整程序：github地址2 改进二：验证码保存+面向对象编程验证码保存：123456code = self.driver.find_element_by_xpath("//img[@alt='CAPTCHA']") img = code.screenshot_as_png img_name = "./code/code&#123;&#125;.png".format(time.strftime('%Y-%m-%d_%H%M%S', time.localtime(time.time()))) with open(img_name, 'wb') as f: f.write(img) rec_code = self.code_recog(img_name) 其中，验证码保存步骤使用了selenium自带的元素截图功能，而不是全屏截图。这边正是我从chrome浏览器改为firefox浏览器的真实原因。chrome浏览器中的元素截图不可用！会报错！故此选用firefox浏览器。 面向对象编程就是对函数使用了类，把多个函数合并到了同一个类中去。 完整程序在最后给出。 改进三：使用pyqt获得验证码图片思路是：从网页中解析到验证码的图片，然后下载到本地；接着使用pyqt弹出一个窗口，窗口中显示获取到的验证码，手动输入验证码后点击关闭。 简化了每次登录的流程，账号、密码记录在程序中自动输入，只需要手动输入验证码。 其中，基于pyqt5图形界面的窗口部分的程序如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# CodeRecognition.pyimport sysfrom PyQt5 import QtWidgets, QtGuifrom PyQt5.QtWidgets import *from PyQt5.QtGui import *class CodeRecognition(QtWidgets.QWidget): def __init__(self, parent=None): QtWidgets.QWidget.__init__(self, parent) self.setWindowTitle("请手动输入验证码") self.resize(250, 150) self.center() # 界面初始化 self.code_edit = QLineEdit() self.label_code = QtWidgets.QLabel() self.init_interface() self.img_path = './image_3.png' self.show_code_img() # 输出的识别码 self.out_code = 'To_be_recognize' def init_interface(self): label1 = QtWidgets.QLabel('请输入验证码：', self) label2 = QtWidgets.QLabel('输入完成后点击关闭按钮即可。', self) self.code_edit.setToolTip('请输入验证码') button2 = QtWidgets.QPushButton('关闭', self) grid = QGridLayout() grid.setSpacing(0) grid.addWidget(self.label_code, 0, 0, 1, 2) grid.addWidget(label1, 1, 0) grid.addWidget(self.code_edit, 2, 0) grid.addWidget(label2, 3, 0) grid.addWidget(button2, 4, 0, 1, 2) # 关闭窗口 button2.clicked.connect(self.close) self.setLayout(grid) def center(self): # 该语句用来计算出显示器的分辨率（screen.width, screen.height） screen = QtWidgets.QDesktopWidget().screenGeometry() size = self.geometry() self.move((screen.width() - size.width()) / 2, (screen.height() - size.height()) / 2) def get_text(self): self.out_code = self.code_edit.text() # print(self.out_code) return self.out_code def show_code_img(self): img = QtGui.QPixmap(self.img_path) self.label_code.setPixmap(img) def closeEvent(self, event): code = self.get_text() if len(code) &lt; 4 or len(code) &gt;= 8: QtWidgets.QMessageBox.about(self, "验证码输入错误", "请注意：\n验证码一般为4-6位，请重新输入!") event.ignore() else: event.accept()if __name__ == "__main__": app = QtWidgets.QApplication(sys.argv) center = CodeRecognition() # 改变输入的图片。 path = "image_2.png" center.img_path = path center.show_code_img() center.show() app.exec_() rec_code = center.get_text() print("识别的验证码为：", rec_code) 之前学过qt的同学看起来应该不困难，没有学过qt的同学想要入门的话建议查看官方文档或者小甲鱼论坛的pyqt连接。 最后附上完整的程序：github地址3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>Selenium</tag>
        <tag>HDHome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-基础篇]]></title>
    <url>%2F2017%2F11%2F27%2Fpython_base_NJU_1%2F</url>
    <content type="text"><![CDATA[本文是学习南京大学Python玩转数据基础篇的笔记整理。内容较为简洁，仅供参考。 python类型基本类型 整型/长整型： 长度与机器有关。长整型：整型值后面加上L。 布尔型：True、False。 浮点型：数学中的实数。可以用科学计数法表示。 float 复数型：虚数部分用j。 x = 2.4+ 5j Out[9]: (2.4+5j) type(x) Out[10]: complex 复数可以对实数和复数部分分离。imag、real。 复数的共轭：conjugate() x.real Out[11]: 2.4 x.imag Out[12]: 5.0 x.conjugate() Out[13]: (2.4-5j) 序列类型字符串，列表[]，元组() 字符串： 三种表示方式：单引号，双引号，三引号。 可以使用索引操作符。 映设类型字典： 大括号{}鉴别； 类似于哈希表的键值对。 python运算算术运算+ - × / 取余 % 乘方 ** 整除 // ----地板除 比较运算数值的比较：按值的大小 字符串的比较：按ASCII码值的大小 逻辑运算not and or 字符运算r / R, ---原始字符串 u / U 位运算&lt;左移 &gt;右移 函数、模块与包函数函数可以看成类似于数学中的函数。完成一个特定功能的一段代码。如绝对值函数abs()，类型函数type()，四舍五入函数round()。 内建函数如何查看python中自带的内建函数1dir(__builtins__) 模块非内建函数如何使用呢？ 如floor()函数，不是内建函数，但包含在math的头文件中，因此只需要导入该模块即可，如下：1import math 什么是模块？模块就是一个完整的python文件。12文件：物理上的组织方式：math.py模块：逻辑上的组织方式：math Python中通常用import 模块的方式将现成模块中的函数、类重用到其他代码块中。 用help(math)打印所有math内部的函数和变量。 可以导入多个模快。可以从模块中导入指定的模块属性（把指定的名称导入）。123import ModuleNameimport ModuleName1,ModuleName2,...from Module1 import ModuleElement 包(package)包是有层次的文件目录结构。 比如说如下的目录结构定义了一个由模块和子包组成的Python应用程序执行环境：123456789101112AAA/ __init__.py bbb.py CCC/ __init__.py c1.py c2.py DDD/ __init__.py d1.py EEE/ ... 因此，我们可以这样使用该包：12import AAA.CCC.c1AAA.CCC.c1.func1(123) 或者：12from AAA.CCC.c1 import func1func1(123) 库（library）库是一组具有相关功能的模块的集合。Python的一大特色就是具有强大的标准库、以及第三方库、以及自定义的模块。 条件、循环与中断语句条件语句if语句else语句elif语句：多分支情况下使用 其中，条件语句可以嵌套使用。 循环语句for循环12for iter_var in interable_object: suite_to_repeat 可以明确循环的次数，一般用在： 遍历一个数据集的成员 在列表解析中使用 1234in[4]: [i for i in range(10)]Out[4]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]in[5]: [i for i in range(10)if i%2==0]Out[5]: [0, 2, 4, 6, 8] 在生成器表达式中使用 12in[6]: (i for i in range(10)if i%2==0)Out[6]: &lt;generator object &lt;genexpr&gt; at 0x7f44af56f570&gt; 可用于迭代的对象（iterable object）有：String、 List、Tuple、Dictionary、File。 range语句一般与for语句配合使用。 while循环语法：12while expression: suitr_to_repeat 其中，expression是条件表达式，当expression的值为 True的时候，执行suitr_to_repeat的代码块。 break语句while循环中的break与for循环中的break。 循环中的else语句循环中的else：如果是正常结束，就执行else中的代码；break处中止，就不执行else。 自定义函数自定义函数的创建：123def function_name([arguments]): &quot;optional documentation string&quot; function_suite 其中，def下一行可以是函数文档。～～～～～要学会使用函数文档！！ 自定义函数的调用函数名加上函数运算符，一对小括号。 括号之间是所有可选的参数，即使没有参数，小括号也不能省略。 参数问题，有参数就必须加上去。除非有默认值的可以不需要。 默认参数函数的参数可以有一个默认值，如果提供有默认值，在函数定义中，默认参数以赋值语句的形式提供。 默认参数的值可以改变。 默认参数一般需要放置在参数列表的最后。默认参数后面不能有非默认参数。 关键字参数关键字参数是让调用者通过使用参数名区分参数。允许你改变参数列表中的参数顺序。 传递函数函数可以像参数一样传递给另外一个参数。1234567def addMe2Me(x): return (x+x)def self(f,y): print f(y)&gt;&gt;&gt; self(addMe2Me,2.2)4.4 lambda函数匿名函数。 12345678# 普通的函数def my_add(x,y): return x+y# 匿名函数lambda x, y : x + ymy_add = lambda x, y : x + y&gt;&gt;&gt; my_add(3,5)8 变量的作用域全局变量和局部变量函数内部就是局部变量。 函数内部可以调用全局变量，使用global语句。 当全局变量和局部变量使用的是同一个名字时，内层会屏蔽外层。 递归递归介绍递归必须有边界条件，即停止递归的条件。 如n==0 或者n==1的情况。 递归的代码更简洁，更符合自然逻辑，更容易理解。 递归的执行方式：逐层递归调用，遇到边界条件停止递归，逐层返回调用至最初层，系统资源的消耗比循环大。 汉诺塔123456789101112# Filename: Hanoi.pydef hanoi(a, b, c, n): if n == 1: print(a, '-&gt;', c) else: hanoi(a, c, b, n - 1) print(a, '-&gt;', c) hanoi(b, a, c, n - 1)hanoi("a", "b", "c", 3) 运行结果：1234567a -&gt; ca -&gt; bc -&gt; ba -&gt; cb -&gt; ab -&gt; ca -&gt; c]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DeepLab简介及其pytorch实现]]></title>
    <url>%2F2017%2F11%2F23%2FTorch_DeepLab%2F</url>
    <content type="text"><![CDATA[本文实现了使用pytorch搭建DeepLab。算是第一批采用Pytorch的吧，到目前为止，网上还没有类似的实现。 DeepLab简介DeepLab文章的下载地址：https://arxiv.org/abs/1606.00915 该文章的主要思想之一：提出了Atrous convolution（带孔卷积）。扩大视野但不增加计算量。 所谓的带孔卷积，就是在卷积核之间加上0。rate参数为2（torch中对应的参数为dilation）的示意图如下 rate = 2就是在原卷积核相邻两个元素之间补上一个0，假设原卷积核为3x3，rate = 2的带孔卷积核的大小就为3+(3-1) × (rate-1)=5。 下图是不同rate的带孔卷积。 以rate = 12 为例，带孔卷积的核的大小为：3+(3-1)x(12-1)=25，即新卷积核的大小为：25*25。 总的来说，对于rate=r的带孔卷积，在连接着的卷积核元素间插入r-1个元素。因此，扩展后的卷积核大小为$k_{new}=k+(k-1)(r-1)$。 pytorch实现deeplab笔者主要目的是实现一下不同视野的concat过程。 在torch中，卷积函数如下：12import torch.nn as nnnn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True) 其中的dilation参数就是带孔卷积的参数（也就是tensorFlow下的rate），默认情况下为1，就是普通的卷积，所以带孔卷积只需要修改这个参数就可以了。 比如说，我们已经写好了不同的视野下的卷积，然后需要将他们的feature map叠加起来，torch中使用torch.cat(inputs, dimension=0)函数来进行叠加。torch的参数一般是四个维度的：[n_batch_size, n_feature_map, height, weight]，所以参数中的dimension = 1就是对feature map叠加。代码如下： 1x = torch.cat([x2, x3, x4, x5], dim=1) 叠加的这一步非常容易出错，原因在于，要求叠加的所有图片大小是一样的。而视野不同导致的卷积核的大小不同，也会导致最终输出的图像大小的变化，因此，需要恰当的调整zero-padding的数目来使得最终输出图像的大小保持一致。 另外稍微提一下，全连接层的输入向量大小的确定方法。全连接层是将上一步所得到的图像reshape为一个一维的向量之后，作为它的输入，因此，输入向量的长度为： in_channels = nFeatureMap * height * weight。 网络整体代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 10, kernel_size=5, padding=1) self.conv2 = nn.Conv2d(10, 10, kernel_size=5, padding=1) self.conv2_drop = nn.Dropout2d() self.fc1 = nn.Linear(40 * 4 * 5 * 5, 50) self.fc2 = nn.Linear(50, 10) self.conv_rate_1 = nn.Conv2d(10, 20, kernel_size=3, dilation=2, padding=2) self.conv_rate_2 = nn.Conv2d(20, 40, kernel_size=3, dilation=3, padding=3) self.conv_rate_3 = nn.Conv2d(20, 40, kernel_size=3, dilation=4, padding=4) self.conv_rate_4 = nn.Conv2d(20, 40, kernel_size=3, dilation=5, padding=5) self.conv_rate_5 = nn.Conv2d(20, 40, kernel_size=1, padding=0) def forward(self, x): x = F.max_pool2d(F.relu(self.conv1(x)), 2) x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2)) x = self.conv_rate_1(x) x2 = self.conv_rate_2(x) x3 = self.conv_rate_3(x) x4 = self.conv_rate_4(x) x5 = self.conv_rate_5(x) # print(x.data.shape) # print(x2.data.shape) # print(x3.data.shape) # print(x4.data.shape) # print(x5.data.shape) x = torch.cat([x2, x3, x4, x5], dim=1) # for FC x = x.view(-1, self.num_flat_features(x)) # origin is 320 x = F.relu(self.fc1(x)) # fc-&gt;relu x = F.dropout(x, training=self.training) # dropout x = self.fc2(x) return F.log_softmax(x) def num_flat_features(self, x): size = x.size()[1:] # all dimensions except the batch dimension num_features = 1 for s in size: num_features *= s return num_features]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习系列：（七）深度学习中的正则化]]></title>
    <url>%2F2017%2F10%2F22%2FDL_chap_7%2F</url>
    <content type="text"><![CDATA[本文是对《深度学习》的第七章，正则化方法的简单学习记录。 本文尚未完成。仅供参考。 7.1 参数范式惩罚对目标模型J添加一个参数范数惩罚$\Omega (\theta)$，限制模型 的学习能力。正则化后的目标函数记为：$$\tilde{J}(\theta ;X,y) = J(\theta ;X,y) +\alpha \Omega (\theta)$$ 我们通常只对权重做惩罚而不对偏置做正则惩罚。 神经网络情况下，有时候希望对网络的每一层使用单独的惩罚，并分配不同的$\alpha$系数。寻找合适的多个超参数的代价很大，因此为了减少搜索空间，我们会在所以层使用相同的权重衰减。 符号约束说明：向量$w$表示所有应受范数惩罚影响的权重，而向量$\theta$表示所有参数（包括w和无须正则化的参数）。 7.1.1 $L^2$参数正则化5.2节中已经见过最简单的、最常见的$L^2$参数范数惩罚。其正则项为：$$\Omega (\theta) = \frac 12 ||w||^2_2$$ 令$w^\ast $为未正则化的目标函数取得最小训练误差时的权重向量，即$w^\ast =\text {argmin}_w J(w)$，并在$w^\ast $的邻域对目标函数做二次近似。 近似的$\hat J (\theta)$如下： $$\hat J (\theta) = J (w^\ast) + \frac 12 (w-w^\ast)^TH(w-w^\ast) $$ 其中，$H$是$J$在$w^\ast $处计算的Hessian矩阵（关于$w$）。因为$w^\ast $被定义为最优，所以该二次近似中没有一阶项。同样地，因为$w^\ast $是$J$的一个最优点，可以得出$H$是半正定。 7.1.2 $L^1$正则化7.2 作为约束的范数惩罚7.3 正则化和欠约束问题7.4 数据集增强使用更多的数据进行训练。 创建假数据并添加到训练集中。 图像：沿着训练图像每个方向平移几个像素。旋转。缩放。 数据集增强对语音识别也是有效的。 网络输入层注入噪声， 算法性能对比时，应确保算法使用同一 人工设计的数据集增强方案。 7.5 噪声鲁棒性7.6 半监督学习在半监督学习的框架下，$P(x)$产生的未标记样本和$P(x,y)$中的标记样本都用于估计$P(y|x)$或者根据x预测y。 半监督学习通常是学习一个表示：$h=f(x)$。学习表示的目的是使相同类的样本有类似的表示。 无监督学习可以为如何在空间聚集样本提供有用的线索。 模型的构建：生成模型$P(x)$或$P(x,y)$与判别模型$P(y|x)$共享参数，而不用分离无监督和监督部分。权衡监督模型准则$-\text{log}P(y|x)$和无监督(或生成)模型准则$-\text{log}P(x)$或$-\text{log}P(x,y)$。 生成模型准则表达了对 监督学习问题的特殊形式的先验知识，即$P(x)$的结构通过某种共享参宿的方式连接到$P(y|x)$。 7.7 多任务学习7.8 提前终止在训练有足够表示能力甚至会过拟合的大模型时，经常会出现：训练误差随着时间推移逐渐降低但验证集的误差会再次上升。 此时，我们只需要返回验证集误差最低的参数设置。 在每次验证集误差有所改善时，我们存储模型参数的副本。当验证集的误差在事先指定的循环次数内没有进一步改善时，算法就会终止。 这就是提前终止（early stopping）。 两个代价：一是训练步数作为超参数，训练期间需要定期评估验证集。而是需要保持最佳的参数副本。 提前终止是一个不显眼的正则化形式。 提前终止需要验证集，意味着一部分训练数据不能馈送到模型。为了更好地利用这部分数据，可以在提前终止的首次训练后，进行额外的训练。在第二轮（额外的）训练中，所有的训练数据都被包括在内。 未完待续。 7.9 参数绑定和参数共享7.10 稀疏表示7.13 Bagging和其他集成方法Bagging(bootstrap aggregating)是通过结合几个模型降低泛化误差的技术。 主要想法是分别训练几个不同的模型，然后让所有模型表决测试样例的输出。 这是机器学习的一项常规策略，被称为：模型平均（model averaging）。采用这种策略的技术被称为：集成方法。 7.12 Dropout7.13 对抗训练7.14 切面距离、正切传播和流形正切分类器]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习系列：（九）卷积网络]]></title>
    <url>%2F2017%2F10%2F20%2FDL_chap_9%2F</url>
    <content type="text"><![CDATA[本文主要简单地介绍一下图像处理中必备的卷积网络。 9.1 卷积运算卷积的第一个参数： 输入，第二个参数： 核函数。输出有时被称为特征映射。 对于二维图像I，二维的核K。卷积可以写为： $$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(m,n)K(i-m,j-n)$$ 卷积是可交换的。可以等价地写为： $$S(i,j) = (K\times I )(i,j) = \sum_m \sum_n I(i-m,j-n)K(m,n)$$ 卷积运算可交换性的出现时因为我们将核相对输入进行了翻转(flip)，从m增大的角度来看，输入的索引在增大，但是核的索引在减小。 互相关函数：和卷积一样，但是没有对核翻转，互相关函数的公式如下： $$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(i+m,j+n)K(m,n)$$ 9.2 动机卷积运算的三个重要思想： 参数共享–绑定的权重。在一个模型的多个函数中使用相同的参数。 平移等变–输入改变，输出也以同样的方式改变。 9.3 池化池化函数：使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。 最大池化函数（Max pooling）：相邻矩形区域内的最大值 其他常用的池化函数：相邻区域内的平均值，L2范数，基于距中心像素位置的加权平均函数。 局部平移不变性。 池化综合了全部邻居的反馈，这使得池化单元少于探测单元成为可能，我们可以通过综合池化区域的k个像素的统计特征而不是单个像素来实现。这种方式提高了网络的计算效率，因为下一层少了约k倍的输入。（downsampling） 9.4 卷积与池化作为一种无限强的先验先验概率分布（第5.2节）。弱先验具有较高的熵值，强先验具有较低的熵值。 一个无限强的先验需要对一些参数的概率置零并且完全禁止对这些参数赋值。 可以把卷机网络类比为全连接网络，但对于这个全连接网络的权重有一个无限强的先验。这个无限强的先验是说一个隐藏单元的权重必须和它邻居的权重相同，但可以在空间上移动。这个先验也要求除了那些处在隐藏单元的小的空间连续的接受域内的权重以外，其余的权重为零。 类似地，使用池化也是一个无限强的先验：每个单元都具有对少量平移的不变性。 卷积和池化可能导致欠拟合。 9.5 基本卷积函数的变体神经网络中的卷积是由多个并行卷积组成的计算：单个核的卷积只能提取一种类型的特征。 卷积的输入输出可以看作3维的张量，其中一个索引用于标明不同的通道，另外两个索引用于标明每一个通道上的空间坐标。 $$Z_{i,j,k}= c(K,V,s)_{i,j,k}= \sum\limits_{l,m,n}[V_{l,(j - 1) \times s + m,(k - 1) \times s + m} K_{i,l,m,n}]$$输入是观测数据V，每个元素是$V_{i,j,k}$，表示通道i中第j行第k列的值。$K_{i,j,k,l}$输出通道i的一个单元和输入通道j中的一个单元的链接强度，并且在输出单元和输入单元之间有k行l列的偏置。 三种零填充方式： 有效(valid)卷积：不适用零填充。输出的大小在每一层都会缩减。 相同(same)卷积：进行足够的零填充，保持输出和输入 全(full)卷积：每个像素咋每个方向上恰好被访问k次，最终输出的图像宽度为m+k-1。 通常零填充的最优数量处于“有效卷积”和“相同卷积”之间的某个位置。 三种卷积方式： 非共享卷积(unsahred convolution)：不横跨位置来共享参数。局部连接层没有参数共享。 平铺卷积(tiled convolution)：学习一组核，当在空间移动时它们可以循环利用。平铺卷积有t个不同的核。 标准卷积(standard convolution)：等效于t=1的平铺卷积。 我们采用的一般就是标准卷积，其他的了解一下即可。 9.6 结构化输出卷积神经网络可以输出高维的结构化对象，通常这个对象只是一个张量，由标准卷积层产生。 假设为$S$，其中$S_{i,j,k}$是网络的输入像素$(j,k)$属于类$i$的概率。这允许模型标记图像中的每个像素，并绘制沿着单个对象轮廓的精确掩膜。 9.7 数据类型卷积网络的优点：可以处理具有可变的空间尺度的输入。 可变尺寸的输入，仅对输入是因为包含对同种事物的不同量的观察（时间上不同长度的记录，空间上不同宽度的观察等）而导致的尺寸变化才有意义。 9.8 高效的卷积算法朴素卷积$O(w^d) $与可分离(seperable)卷积$O(w\times d) $。 9.9 随机或无监督的特征卷积网络训练中最昂贵的部分是学习特征。（输出层计算代价相对不高，池化后特征少）减少训练成本：使用那些不是由监督方式得到的特征。 三种基本策略： 简单地随机初始化它们； 手动设计它们，如设置每个核在一个特定的方向或尺度来检测边缘； 使用无监督的标准来学习核。 9.10 卷积网络的神经科学基础初级视觉皮层(primary visual cortex)。 Gabor函数(Gabor function)。 9.11 卷积网络与深度学习的历史ImageNet]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[import TensorFlow出错解决方案]]></title>
    <url>%2F2017%2F10%2F19%2Ftensorflow_import_error%2F</url>
    <content type="text"><![CDATA[本文纯属折腾TensorFlow时的一个出错记录。 如果你以前import tensorflow还没有问题，突然import出错的时候，可以进来看看。 出错与解决历程先介绍一下我的python环境：3.5.2 一开始是tensorflow找不到cudn的几个库，虽然问题不大。看到有教程说要升级tensorflow（ 请不要尝试升级 ），于是抱着试试看的想法，升级了tensorflow版本： pip install –trusted-host pypi.python.org –upgrade tensorflow-gpu 升级之后是1.3.0的最新版本。 接着import tensorflow的时候，出现错误： Traceback (most recent call last): File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 18, in swig_import_helper return importlib.import_module(mname) File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _gcd_import File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 969, in _find_and_load File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 958, in _find_and_load_unlocked File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 666, in _load_unlocked File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 577, in module_from_spec File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 906, in create_module File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removed ImportError: DLL load failed: The specified module could not be found. During handling of the above exception, another exception occurred: Traceback (most recent call last): File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt; from tensorflow.python.pywrap_tensorflow_internal import * File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 21, in &lt;module&gt; _pywrap_tensorflow_internal = swig_import_helper() File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 20, in swig_import_helper return importlib.import_module(&apos;_pywrap_tensorflow_internal&apos;) File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) ImportError: No module named &apos;_pywrap_tensorflow_internal&apos; During handling of the above exception, another exception occurred: Traceback (most recent call last): File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt; import tensorflow as tf File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\__init__.py&quot;, line 24, in &lt;module&gt; from tensorflow.python import * File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\__init__.py&quot;, line 51, in &lt;module&gt; from tensorflow.python import pywrap_tensorflow File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 52, in &lt;module&gt; raise ImportError(msg) ImportError: Traceback (most recent call last): File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 18, in swig_import_helper return importlib.import_module(mname) File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _gcd_import File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 969, in _find_and_load File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 958, in _find_and_load_unlocked File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 666, in _load_unlocked File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 577, in module_from_spec File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 906, in create_module File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removed ImportError: DLL load failed: The specified module could not be found. During handling of the above exception, another exception occurred: Traceback (most recent call last): File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt; from tensorflow.python.pywrap_tensorflow_internal import * File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 21, in &lt;module&gt; _pywrap_tensorflow_internal = swig_import_helper() File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 20, in swig_import_helper return importlib.import_module(&apos;_pywrap_tensorflow_internal&apos;) File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module return _bootstrap._gcd_import(name[level:], package, level) ImportError: No module named &apos;_pywrap_tensorflow_internal&apos; Failed to load the native TensorFlow runtime. See https://www.tensorflow.org/install/install_sources#common_installation_problems for some common reasons and solutions. Include the entire stack trace above this error message when asking for help. 查找到相关解决方案： https://stackoverflow.com/questions/43942185/failed-to-load-the-native-tensorflow-runtime-python-3-5-2 按照高票回答上面做出来后，依旧无效。其中5.1步骤找“curses”，需要pip install curses (从http://www.lfd.uci.edu/~gohlke/pythonlibs/) 简直气疯了。然后，尝试下载了cuda cudnn 9.0的版本，并且加上了系统环境变量，依旧无效。 之后在贴吧http://tieba.baidu.com/p/5147977587 看到11楼说： 我也是同样的问题 是tensorflow-gpu版本不兼容的问题 之前是1.3 后来安装的的1.0.1 亲测有效 于是回退tensorflow的版本。 http://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载了1.1.0版本。 Traceback (most recent call last): File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt; from tensorflow.python.pywrap_tensorflow_internal import * File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 35, in &lt;module&gt; _pywrap_tensorflow_internal = swig_import_helper() File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 30, in swig_import_helper _mod = imp.load_module(&apos;_pywrap_tensorflow_internal&apos;, fp, pathname, description) File &quot;D:\python\Python35\lib\imp.py&quot;, line 242, in load_module return load_dynamic(name, filename, file) File &quot;D:\python\Python35\lib\imp.py&quot;, line 342, in load_dynamic return _load(spec) ImportError: DLL load failed: 找不到指定的模块。 During handling of the above exception, another exception occurred: Traceback (most recent call last): File &quot;D:/python/py3_prog/TensorFlow/setup_test.py&quot;, line 4, in &lt;module&gt; import tensorflow as tf File &quot;D:\python\Python35\lib\site-packages\tensorflow\__init__.py&quot;, line 24, in &lt;module&gt; from tensorflow.python import * File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\__init__.py&quot;, line 51, in &lt;module&gt; from tensorflow.python import pywrap_tensorflow File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 52, in &lt;module&gt; raise ImportError(msg) ImportError: Traceback (most recent call last): File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt; from tensorflow.python.pywrap_tensorflow_internal import * File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 35, in &lt;module&gt; _pywrap_tensorflow_internal = swig_import_helper() File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 30, in swig_import_helper _mod = imp.load_module(&apos;_pywrap_tensorflow_internal&apos;, fp, pathname, description) File &quot;D:\python\Python35\lib\imp.py&quot;, line 242, in load_module return load_dynamic(name, filename, file) File &quot;D:\python\Python35\lib\imp.py&quot;, line 342, in load_dynamic return _load(spec) ImportError: DLL load failed: 找不到指定的模块。 Failed to load the native TensorFlow runtime. See https://www.tensorflow.org/install/install_sources#common_installation_problems for some common reasons and solutions. Include the entire stack trace above this error message when asking for help. 提示缺少dll。在c/windows/system32中添加了一下msvcp140.dll （680kb的，不是400多kb的）问题终于解决。 dll问题具体方案：https://www.microsoft.com/en-us/download/details.aspx?id=53587下载Microsoft Visual C++ 2015 Redistributable 并安装。 更多解决办法可参考：https://github.com/tensorflow/tensorflow/issues/8385 总结一下 千万不要去更新tensorflow的版本。能用就行，不要用最新的1.3.0版本。 cuda，cudnn也不要用最新的9.0版本，就用8.0版本即可。 import tensorflow出错时，有几个方向检查：cudn/cudaa环境变量，dll库的问题，版本是否匹配：python3.5，回退tensorflow版本，回退cuda/cudnn版本。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习中防止过拟合的方法]]></title>
    <url>%2F2017%2F10%2F18%2FDL_overfitting%2F</url>
    <content type="text"><![CDATA[“什么是过拟合？以及如何预防过拟合？” 上述是机器学习常见面试题之一，本文将对其稍作解答，仅供参考。 0. 什么是过拟合过拟合即在训练误差很小，而泛化误差很大，因为模型可能过于的复杂，使其”记住”了训练样本，然而其泛化误差却很大。 在传统的机器学习方法中有很大防止过拟合的方法，同样这些方法很多也适合用于深度学习中，同时深度学习中又有一些独特的防止过拟合的方法，下面对其进行简单的梳理。 1. 获取更多数据让模型泛化的能力更好的最好办法就是使用更多的训练数据进行训练，但是在实践中，我们拥有的数据是有限的，解决这一问题可以人为的创造一些假数据添加到训练集中。 一个具体的例子:在AlexNet中，将$256\times 256$图像随机的截取$224\times 224$大小，增加了许多的训练样本，同时可以对图像进行左右翻转，增加样本的个数，实验的结果可以可降低1%的误差。 在神经网络中输入噪声也可以看做是数据增强的一种方式。 通俗得讲，数据集扩增即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。一般有以下方法： 从数据源头采集更多数据 复制原有数据并加上随机噪声 重采样 根据当前数据集估计数据分布参数，使用该分布产生更多数据等 2.选用合适的模型2.1 网络结构 Architecture这个很好理解，减少网络的层数、神经元个数等均可以限制网络的拟合能力。 2.2 参数范数惩罚 regularization范数正则化是一种非常普遍的方法，也是最常用的方法，假如优化: $$minObj(\theta)=L(y,f(x))+\alpha G(\theta)$$ 其中L为经验风险，其为在训练样本上的误差，而G为对参数的惩罚，也叫结构风险。α是平衡两者，如果太大则对应的惩罚越大，如过太小，甚至接近与0，则没有惩罚。 最常用的范数惩罚为L1，L2正则化。 L1正则L1又被成为Lasso:$$||w||1=|w1|+|w2|+…$$ 即绝对值相加，其趋向于是一些参数为0。可以起到特征选择的作用。 L2正则L2正则化为: $$||w||_2=w12+w22+…$$ L2范数是指向量各元素的平方和然后求平方根。它有两个美称，在回归里面，有人把有它的回归叫“岭回归”（Ridge Regression），有人也叫它“权值衰减weight decay”。它的强大功效是改善机器学习里面一个非常重要的问题：过拟合。 其趋向与，使权重很小。其又成为ridge。 拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。 这里也一句话总结下：通过L2范数，我们可以实现了对模型空间的限制，从而在一定程度上避免了过拟合。 关于更多正则化的内容可以参考《deep learning》第七章：深度学习中的正则化。 2.3 训练时间 Early stopping当随着模型的能力提升，训练集的误差会先减小再增大，这样可以提前终止算法减缓过拟合现象。 Early stopping方法的具体做法是，在每一个Epoch结束时（一个Epoch集为对所有的训练数据的一轮遍历）计算validation data的accuracy，当accuracy不再提高时，就停止训练。这种做法很符合直观感受，因为accurary都不再提高了，在继续训练也是无益的，只会提高训练的时间。那么该做法的一个重点便是怎样才认为validation accurary不再提高了呢？并不是说validation accuracy一降下来便认为不再提高了，因为可能经过这个Epoch后，accuracy降低了，但是随后的Epoch又让accuracy又上去了，所以不能根据一两次的连续降低就判断不再提高。一般的做法是，在训练的过程中，记录到目前为止最好的validation accuracy，当连续10次Epoch（或者更多次）没达到最佳accuracy时，则可以认为accuracy不再提高了。此时便可以停止迭代了（Early Stopping）。这种策略也称为“No-improvement-in-n”，n即Epoch的次数，可以根据实际情况取，如10、20、30…… 提前终止是一种很常用的缓解过拟合的方法，如在决策树的先剪枝的算法，提前终止算法，使得树的深度降低，防止其过拟合。 添加噪声给网络加噪声也有很多方法： 在输入中加噪声 在权值上加噪声 对网络的响应加噪声 3. 结合多种模型集成学习是一种比较奇特的方法，如果我们训练多个不同的模型，然后将它们的输出汇总，例如平均起来或者投票汇总，那么汇总的结果可以在一定程度上自动克服过拟合，哪怕每个模型都过拟合了。 3.1 bagging boostingBagging 是 Bootstrap Aggregating 的简称。简单理解：就是分段函数的概念：用不同的模型拟合不同部分的训练集。 其实bagging的方法是可以起到正则化的作用，因为正则化就是要减少泛化误差，而bagging的方法可以组合多个模型起到减少泛化误差的作用。在深度学习中同样可以使用此方法，但是其会增加计算和存储的成本。 由于训练网络本身就要耗费较多资源，所以一般不单独使用神经网络做bagging。 类似的还有boosting。 bagging中的模型是强模型，偏差低，方差高。目标是降低方差。在bagging中，每个模型的bias和variance近似相同，但是互相相关性不太高，因此一般不能降低Bias，而一定程度上能降低variance。典型的bagging是random forest。 boosting中每个模型是弱模型，偏差高，方差低。目标是通过平均降低偏差。boosting的基本思想就是用贪心法最小化损失函数，显然能降低偏差，但是通常模型的相关性很强，因此不能显著降低variance。典型的Boosting是adaboost，另外一个常用的并行Boosting算法是GBDT（gradient boosting decision tree）。这一类算法通常不容易出现过拟合。 3.2 Dropout正则是通过在代价函数后面加上正则项来防止模型过拟合的。而在神经网络中，有一种方法是通过修改神经网络本身结构来实现的，其名为Dropout。该方法是在对网络进行训练时用一种技巧（trick），对于如下所示的三层人工神经网络： 对于上图所示的网络，在训练开始时，随机得删除一些（可以设定为一半，也可以为1/3，1/4等）隐藏层神经元，即认为这些神经元不存在，同时保持输入层与输出层神经元的个数不变，这样便得到如下的ANN： 然后按照BP学习算法对ANN中的参数进行学习更新（虚线连接的单元不更新，因为认为这些神经元被临时删除了）。这样一次迭代更新便完成了。下一次迭代中，同样随机删除一些神经元，与上次不一样，做随机选择。这样一直进行下去，直至训练结束。 Dropout提供了一种廉价的Bagging集成近似，能够训练和评估指数级数量的神经网络。dropout可以随机的让一部分神经元失活，这样仿佛是bagging的采样过程，因此可以看做是bagging的廉价的实现。但是它们训练不太一样，因为bagging，所有的模型都是独立的，而dropout下所有模型的参数是共享的。 通常可以这样理解dropout:假设我们要判别一只猫，有一个神经元说看到有毛就是猫，但是如果我让这个神经元失活，它还能判断出来是猫的话，这样就比较具有泛化的能力，减轻了过拟合的风险。 4. Batch Normalization在Google Inception V2中所采用，是一种非常有用的正则化方法，可以让大型的卷积网络训练速度加快很多倍，同事收敛后分类的准确率也可以大幅度的提高。BN在训练某层时，会对每一个mini-batch数据进行标准化(normalization)处理，使输出规范到N(0,1)的正太分布，减少了Internal convariate shift(内部神经元分布的改变)，传统的深度神经网络在训练是，每一层的输入的分布都在改变，因此训练困难，只能选择用一个很小的学习速率，但是每一层用了BN后，可以有效的解决这个问题，学习速率可以增大很多倍。 5. 参数绑定与参数共享在卷积神经网络CNN中(计算机视觉与卷积神经网络 )，卷积层就是其中权值共享的方式，一个卷积核通过在图像上滑动从而实现共享参数，大幅度减少参数的个数，用卷积的形式是合理的，因为对于一副猫的图片来说，右移一个像素同样还是猫，其具有局部的特征。这是一种很好的缓解过拟合现象的方法。 同样在RNN中用到的参数共享，在其整条时间链上可以进行参数的共享，这样才使得其能够被训练。 6. 辅助分类节点(auxiliary classifiers)在Google Inception V1中，采用了辅助分类节点的策略，即将中间某一层的输出用作分类，并按一个较小的权重加到最终的分类结果中，这样相当于做了模型的融合，同时给网络增加了反向传播的梯度信号，提供了额外的正则化的思想。 参考资料 http://blog.csdn.net/taoyanqi8932/article/details/71101699 http://blog.csdn.net/heyongluoyao8/article/details/49429629 https://www.zhihu.com/question/26760839 https://www.zhihu.com/question/59201590 https://www.zhihu.com/question/26898675 正则化 http://blog.csdn.net/jinping_shi/article/details/52433975]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Overfitting</tag>
        <tag>过拟合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[党的十九大报告全文]]></title>
    <url>%2F2017%2F10%2F18%2FOpening_ceremony_19th_CPC%2F</url>
    <content type="text"><![CDATA[中国共产党第十九次全国代表大会开幕会今天上午9点在人民大会堂大礼堂举行。习近平代表第十八届中央委员会向党的十九大作报告。 笔者在当天即对报告全文进行了学习并转载。 本文在博客新增加密功能时，选作加密测试贴。本文密码：123456，想要提高党性的同学可以看看～～否则请跳过。 以下是报告全文： 同志们： 现在，我代表第十八届中央委员会向大会作报告。 中国共产党第十九次全国代表大会，是在全面建成小康社会决胜阶段、中国特色社会主义进入新时代的关键时期召开的一次十分重要的大会。 大会的主题是：不忘初心，牢记使命，高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。 不忘初心，方得始终。中国共产党人的初心和使命，就是为中国人民谋幸福，为中华民族谋复兴。这个初心和使命是激励中国共产党人不断前进的根本动力。全党同志一定要永远与人民同呼吸、共命运、心连心，永远把人民对美好生活的向往作为奋斗目标，以永不懈怠的精神状态和一往无前的奋斗姿态，继续朝着实现中华民族伟大复兴的宏伟目标奋勇前进。 当前，国内外形势正在发生深刻复杂变化，我国发展仍处于重要战略机遇期，前景十分光明，挑战也十分严峻。全党同志一定要登高望远、居安思危，勇于变革、勇于创新，永不僵化、永不停滞，团结带领全国各族人民决胜全面建成小康社会，奋力夺取新时代中国特色社会主义伟大胜利。 一、过去五年的工作和历史性变革 十八大以来的五年，是党和国家发展进程中极不平凡的五年。面对世界经济复苏乏力、局部冲突和动荡频发、全球性问题加剧的外部环境，面对我国经济发展进入新常态等一系列深刻变化，我们坚持稳中求进工作总基调，迎难而上，开拓进取，取得了改革开放和社会主义现代化建设的历史性成就。 为贯彻十八大精神，党中央召开七次全会，分别就政府机构改革和职能转变、全面深化改革、全面推进依法治国、制定“十三五”规划、全面从严治党等重大问题作出决定和部署。五年来，我们统筹推进“五位一体”总体布局、协调推进“四个全面”战略布局，“十二五”规划胜利完成，“十三五”规划顺利实施，党和国家事业全面开创新局面。 经济建设取得重大成就。坚定不移贯彻新发展理念，坚决端正发展观念、转变发展方式，发展质量和效益不断提升。经济保持中高速增长，在世界主要国家中名列前茅，国内生产总值从五十四万亿元增长到八十万亿元，稳居世界第二，对世界经济增长贡献率超过百分之三十。供给侧结构性改革深入推进，经济结构不断优化，数字经济等新兴产业蓬勃发展，高铁、公路、桥梁、港口、机场等基础设施建设快速推进。农业现代化稳步推进，粮食生产能力达到一万二千亿斤。城镇化率年均提高一点二个百分点，八千多万农业转移人口成为城镇居民。区域发展协调性增强，“一带一路”建设、京津冀协同发展、长江经济带发展成效显著。创新驱动发展战略大力实施，创新型国家建设成果丰硕，天宫、蛟龙、天眼、悟空、墨子、大飞机等重大科技成果相继问世。南海岛礁建设积极推进。开放型经济新体制逐步健全，对外贸易、对外投资、外汇储备稳居世界前列。 全面深化改革取得重大突破。蹄疾步稳推进全面深化改革，坚决破除各方面体制机制弊端。改革全面发力、多点突破、纵深推进，着力增强改革系统性、整体性、协同性，压茬拓展改革广度和深度，推出一千五百多项改革举措，重要领域和关键环节改革取得突破性进展，主要领域改革主体框架基本确立。中国特色社会主义制度更加完善，国家治理体系和治理能力现代化水平明显提高，全社会发展活力和创新活力明显增强。 民主法治建设迈出重大步伐。积极发展社会主义民主政治，推进全面依法治国，党的领导、人民当家作主、依法治国有机统一的制度建设全面加强，党的领导体制机制不断完善，社会主义民主不断发展，党内民主更加广泛，社会主义协商民主全面展开，爱国统一战线巩固发展，民族宗教工作创新推进。科学立法、严格执法、公正司法、全民守法深入推进，法治国家、法治政府、法治社会建设相互促进，中国特色社会主义法治体系日益完善，全社会法治观念明显增强。国家监察体制改革试点取得实效，行政体制改革、司法体制改革、权力运行制约和监督体系建设有效实施。 思想文化建设取得重大进展。加强党对意识形态工作的领导，党的理论创新全面推进，马克思主义在意识形态领域的指导地位更加鲜明，中国特色社会主义和中国梦深入人心，社会主义核心价值观和中华优秀传统文化广泛弘扬，群众性精神文明创建活动扎实开展。公共文化服务水平不断提高，文艺创作持续繁荣，文化事业和文化产业蓬勃发展，互联网建设管理运用不断完善，全民健身和竞技体育全面发展。主旋律更加响亮，正能量更加强劲，文化自信得到彰显，国家文化软实力和中华文化影响力大幅提升，全党全社会思想上的团结统一更加巩固。 人民生活不断改善。深入贯彻以人民为中心的发展思想，一大批惠民举措落地实施，人民获得感显著增强。脱贫攻坚战取得决定性进展，六千多万贫困人口稳定脱贫，贫困发生率从百分之十点二下降到百分之四以下。教育事业全面发展，中西部和农村教育明显加强。就业状况持续改善，城镇新增就业年均一千三百万人以上。城乡居民收入增速超过经济增速，中等收入群体持续扩大。覆盖城乡居民的社会保障体系基本建立，人民健康和医疗卫生水平大幅提高，保障性住房建设稳步推进。社会治理体系更加完善，社会大局保持稳定，国家安全全面加强。 生态文明建设成效显著。大力度推进生态文明建设，全党全国贯彻绿色发展理念的自觉性和主动性显著增强，忽视生态环境保护的状况明显改变。生态文明制度体系加快形成，主体功能区制度逐步健全，国家公园体制试点积极推进。全面节约资源有效推进，能源资源消耗强度大幅下降。重大生态保护和修复工程进展顺利，森林覆盖率持续提高。生态环境治理明显加强，环境状况得到改善。引导应对气候变化国际合作，成为全球生态文明建设的重要参与者、贡献者、引领者。 强军兴军开创新局面。着眼于实现中国梦强军梦，制定新形势下军事战略方针，全力推进国防和军队现代化。召开古田全军政治工作会议，恢复和发扬我党我军光荣传统和优良作风，人民军队政治生态得到有效治理。国防和军队改革取得历史性突破，形成军委管总、战区主战、军种主建新格局，人民军队组织架构和力量体系实现革命性重塑。加强练兵备战，有效遂行海上维权、反恐维稳、抢险救灾、国际维和、亚丁湾护航、人道主义救援等重大任务，武器装备加快发展，军事斗争准备取得重大进展。人民军队在中国特色强军之路上迈出坚定步伐。 港澳台工作取得新进展。全面准确贯彻“一国两制”方针，牢牢掌握宪法和基本法赋予的中央对香港、澳门全面管治权，深化内地和港澳地区交流合作，保持香港、澳门繁荣稳定。坚持一个中国原则和“九二共识”，推动两岸关系和平发展，加强两岸经济文化交流合作，实现两岸领导人历史性会晤。妥善应对台湾局势变化，坚决反对和遏制“台独”分裂势力，有力维护台海和平稳定。 全方位外交布局深入展开。全面推进中国特色大国外交，形成全方位、多层次、立体化的外交布局，为我国发展营造了良好外部条件。实施共建“一带一路”倡议，发起创办亚洲基础设施投资银行，设立丝路基金，举办首届“一带一路”国际合作高峰论坛、亚太经合组织领导人非正式会议、二十国集团领导人杭州峰会、金砖国家领导人厦门会晤、亚信峰会。倡导构建人类命运共同体，促进全球治理体系变革。我国国际影响力、感召力、塑造力进一步提高，为世界和平与发展作出新的重大贡献。 全面从严治党成效卓著。全面加强党的领导和党的建设，坚决改变管党治党宽松软状况。推动全党尊崇党章，增强政治意识、大局意识、核心意识、看齐意识，坚决维护党中央权威和集中统一领导，严明党的政治纪律和政治规矩，层层落实管党治党政治责任。坚持照镜子、正衣冠、洗洗澡、治治病的要求，开展党的群众路线教育实践活动和“三严三实”专题教育，推进“两学一做”学习教育常态化制度化，全党理想信念更加坚定、党性更加坚强。贯彻新时期好干部标准，选人用人状况和风气明显好转。党的建设制度改革深入推进，党内法规制度体系不断完善。把纪律挺在前面，着力解决人民群众反映最强烈、对党的执政基础威胁最大的突出问题。出台中央八项规定，严厉整治形式主义、官僚主义、享乐主义和奢靡之风，坚决反对特权。巡视利剑作用彰显，实现中央和省级党委巡视全覆盖。坚持反腐败无禁区、全覆盖、零容忍，坚定不移“打虎”、“拍蝇”、“猎狐”，不敢腐的目标初步实现，不能腐的笼子越扎越牢，不想腐的堤坝正在构筑，反腐败斗争压倒性态势已经形成并巩固发展。 五年来的成就是全方位的、开创性的，五年来的变革是深层次的、根本性的。五年来，我们党以巨大的政治勇气和强烈的责任担当，提出一系列新理念新思想新战略，出台一系列重大方针政策，推出一系列重大举措，推进一系列重大工作，解决了许多长期想解决而没有解决的难题，办成了许多过去想办而没有办成的大事，推动党和国家事业发生历史性变革。这些历史性变革，对党和国家事业发展具有重大而深远的影响。 五年来，我们勇于面对党面临的重大风险考验和党内存在的突出问题，以顽强意志品质正风肃纪、反腐惩恶，消除了党和国家内部存在的严重隐患，党内政治生活气象更新，党内政治生态明显好转，党的创造力、凝聚力、战斗力显著增强，党的团结统一更加巩固，党群关系明显改善，党在革命性锻造中更加坚强，焕发出新的强大生机活力，为党和国家事业发展提供了坚强政治保证。 同时，必须清醒看到，我们的工作还存在许多不足，也面临不少困难和挑战。主要是：发展不平衡不充分的一些突出问题尚未解决，发展质量和效益还不高，创新能力不够强，实体经济水平有待提高，生态环境保护任重道远；民生领域还有不少短板，脱贫攻坚任务艰巨，城乡区域发展和收入分配差距依然较大，群众在就业、教育、医疗、居住、养老等方面面临不少难题；社会文明水平尚需提高；社会矛盾和问题交织叠加，全面依法治国任务依然繁重，国家治理体系和治理能力有待加强；意识形态领域斗争依然复杂，国家安全面临新情况；一些改革部署和重大政策措施需要进一步落实；党的建设方面还存在不少薄弱环节。这些问题，必须着力加以解决。 五年来的成就，是党中央坚强领导的结果，更是全党全国各族人民共同奋斗的结果。我代表中共中央，向全国各族人民，向各民主党派、各人民团体和各界爱国人士，向香港特别行政区同胞、澳门特别行政区同胞和台湾同胞以及广大侨胞，向关心和支持中国现代化建设的各国朋友，表示衷心的感谢！ 同志们！改革开放之初，我们党发出了走自己的路、建设中国特色社会主义的伟大号召。从那时以来，我们党团结带领全国各族人民不懈奋斗，推动我国经济实力、科技实力、国防实力、综合国力进入世界前列，推动我国国际地位实现前所未有的提升，党的面貌、国家的面貌、人民的面貌、军队的面貌、中华民族的面貌发生了前所未有的变化，中华民族正以崭新姿态屹立于世界的东方。 经过长期努力，中国特色社会主义进入了新时代，这是我国发展新的历史方位。 中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景；意味着科学社会主义在二十一世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜；意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。 这个新时代，是承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代，是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代，是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代，是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代，是我国日益走近世界舞台中央、不断为人类作出更大贡献的时代。 中国特色社会主义进入新时代，我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。我国稳定解决了十几亿人的温饱问题，总体上实现小康，不久将全面建成小康社会，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。同时，我国社会生产力水平总体上显著提高，社会生产能力在很多方面进入世界前列，更加突出的问题是发展不平衡不充分，这已经成为满足人民日益增长的美好生活需要的主要制约因素。 我们必须认识到，我国社会主要矛盾的变化没有改变我们所处社会主义历史阶段的判断，我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，我国是世界上最大发展中国家的国际地位没有变。全党要牢牢把握社会主义初级阶段这个基本国情，牢牢立足社会主义初级阶段这个最大实际，牢牢坚持党的基本路线这个党和国家的生命线，人民的幸福线。领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明、和谐、美丽的社会主义现代化强国而奋斗。 同志们！中国特色社会主义进入新时代，在中华人民共和国发展史上、中华民族发展史上具有重大意义，在世界社会主义发展史上、人类社会发展史上也具有重大意义。全党要坚定信心、奋发有为，让中国特色社会主义展现出更加强大的生命力！ 二、新时代中国共产党的历史使命 一百年前，十月革命一声炮响，给中国送来了马克思列宁主义。中国先进分子从马克思列宁主义的科学真理中看到了解决中国问题的出路。在近代以后中国社会的剧烈运动中，在中国人民反抗封建统治和外来侵略的激烈斗争中，在马克思列宁主义同中国工人运动的结合过程中，一九二一年中国共产党应运而生。从此，中国人民谋求民族独立、人民解放和国家富强、人民幸福的斗争就有了主心骨，中国人民就从精神上由被动转为主动。 中华民族有五千多年的文明历史，创造了灿烂的中华文明，为人类作出了卓越贡献，成为世界上伟大的民族。鸦片战争后，中国陷入内忧外患的黑暗境地，中国人民经历了战乱频仍、山河破碎、民不聊生的深重苦难。为了民族复兴，无数仁人志士不屈不挠、前仆后继，进行了可歌可泣的斗争，进行了各式各样的尝试，但终究未能改变旧中国的社会性质和中国人民的悲惨命运。 实现中华民族伟大复兴是近代以来中华民族最伟大的梦想。中国共产党一经成立，就把实现共产主义作为党的最高理想和最终目标，义无反顾肩负起实现中华民族伟大复兴的历史使命，团结带领人民进行了艰苦卓绝的斗争，谱写了气吞山河的壮丽史诗。 我们党深刻认识到，实现中华民族伟大复兴，必须推翻压在中国人民头上的帝国主义、封建主义、官僚资本主义三座大山，实现民族独立、人民解放、国家统一、社会稳定。我们党团结带领人民找到了一条以农村包围城市、武装夺取政权的正确革命道路，进行了二十八年浴血奋战，完成了新民主主义革命，一九四九年建立了中华人民共和国，实现了中国从几千年封建专制政治向人民民主的伟大飞跃。 我们党深刻认识到，实现中华民族伟大复兴，必须建立符合我国实际的先进社会制度。我们党团结带领人民完成社会主义革命，确立社会主义基本制度，推进社会主义建设，完成了中华民族有史以来最为广泛而深刻的社会变革，为当代中国一切发展进步奠定了根本政治前提和制度基础，实现了中华民族由近代不断衰落到根本扭转命运、持续走向繁荣富强的伟大飞跃。 我们党深刻认识到，实现中华民族伟大复兴，必须合乎时代潮流、顺应人民意愿，勇于改革开放，让党和人民事业始终充满奋勇前进的强大动力。我们党团结带领人民进行改革开放新的伟大革命，破除阻碍国家和民族发展的一切思想和体制障碍，开辟了中国特色社会主义道路，使中国大踏步赶上时代。 九十六年来，为了实现中华民族伟大复兴的历史使命，无论是弱小还是强大，无论是顺境还是逆境，我们党都初心不改、矢志不渝，团结带领人民历经千难万险，付出巨大牺牲，敢于面对曲折，勇于修正错误，攻克了一个又一个看似不可攻克的难关，创造了一个又一个彪炳史册的人间奇迹。 同志们！今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标。 行百里者半九十。中华民族伟大复兴，绝不是轻轻松松、敲锣打鼓就能实现的。全党必须准备付出更为艰巨、更为艰苦的努力。 实现伟大梦想，必须进行伟大斗争。社会是在矛盾运动中前进的，有矛盾就会有斗争。我们党要团结带领人民有效应对重大挑战、抵御重大风险、克服重大阻力、解决重大矛盾，必须进行具有许多新的历史特点的伟大斗争，任何贪图享受、消极懈怠、回避矛盾的思想和行为都是错误的。全党要更加自觉地坚持党的领导和我国社会主义制度，坚决反对一切削弱、歪曲、否定党的领导和我国社会主义制度的言行；更加自觉地维护人民利益，坚决反对一切损害人民利益、脱离群众的行为；更加自觉地投身改革创新时代潮流，坚决破除一切顽瘴痼疾；更加自觉地维护我国主权、安全、发展利益，坚决反对一切分裂祖国、破坏民族团结和社会和谐稳定的行为；更加自觉地防范各种风险，坚决战胜一切在政治、经济、文化、社会等领域和自然界出现的困难和挑战。全党要充分认识这场伟大斗争的长期性、复杂性、艰巨性，发扬斗争精神，提高斗争本领，不断夺取伟大斗争新胜利。 实现伟大梦想，必须建设伟大工程。这个伟大工程就是我们党正在深入推进的党的建设新的伟大工程。历史已经并将继续证明，没有中国共产党的领导，民族复兴必然是空想。我们党要始终成为时代先锋、民族脊梁，始终成为马克思主义执政党，自身必须始终过硬。全党要更加自觉地坚定党性原则，勇于直面问题，敢于刮骨疗毒，消除一切损害党的先进性和纯洁性的因素，清除一切侵蚀党的健康肌体的病毒，不断增强党的政治领导力、思想引领力、群众组织力、社会号召力，确保我们党永葆旺盛生命力和强大战斗力。 实现伟大梦想，必须推进伟大事业。中国特色社会主义是改革开放以来党的全部理论和实践的主题，是党和人民历尽千辛万苦、付出巨大代价取得的根本成就。中国特色社会主义道路是实现社会主义现代化、创造人民美好生活的必由之路，中国特色社会主义理论体系是指导党和人民实现中华民族伟大复兴的正确理论，中国特色社会主义制度是当代中国发展进步的根本制度保障，中国特色社会主义文化是激励全党全国各族人民奋勇前进的强大精神力量。全党要更加自觉地增强道路自信、理论自信、制度自信、文化自信，既不走封闭僵化的老路，也不走改旗易帜的邪路，保持政治定力，坚持实干兴邦，始终坚持和发展中国特色社会主义。 伟大斗争，伟大工程，伟大事业，伟大梦想，紧密联系、相互贯通、相互作用，其中起决定性作用的是党的建设新的伟大工程。推进伟大工程，要结合伟大斗争、伟大事业、伟大梦想的实践来进行，确保党在世界形势深刻变化的历史进程中始终走在时代前列，在应对国内外各种风险和考验的历史进程中始终成为全国人民的主心骨，在坚持和发展中国特色社会主义的历史进程中始终成为坚强领导核心。 同志们！使命呼唤担当，使命引领未来。我们要不负人民重托、无愧历史选择，在新时代中国特色社会主义的伟大实践中，以党的坚强领导和顽强奋斗，激励全体中华儿女不断奋进，凝聚起同心共筑中国梦的磅礴力量！ 三、新时代中国特色社会主义思想和基本方略 十八大以来，国内外形势变化和我国各项事业发展都给我们提出了一个重大时代课题，这就是必须从理论和实践结合上系统回答新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，包括新时代坚持和发展中国特色社会主义的总目标、总任务、总体布局、战略布局和发展方向、发展方式、发展动力、战略步骤、外部条件、政治保证等基本问题，并且要根据新的实践对经济、政治、法治、科技、文化、教育、民生、民族、宗教、社会、生态文明、国家安全、国防和军队、“一国两制”和祖国统一、统一战线、外交、党的建设等各方面作出理论分析和政策指导，以利于更好坚持和发展中国特色社会主义。 围绕这个重大时代课题，我们党坚持以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观为指导，坚持解放思想、实事求是、与时俱进、求真务实，坚持辩证唯物主义和历史唯物主义，紧密结合新的时代条件和实践要求，以全新的视野深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，进行艰辛理论探索，取得重大理论创新成果，形成了新时代中国特色社会主义思想。 新时代中国特色社会主义思想，明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国；明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕；明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信；明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化；明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家；明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队；明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体；明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。 新时代中国特色社会主义思想，是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是马克思主义中国化最新成果，是党和人民实践经验和集体智慧的结晶，是中国特色社会主义理论体系的重要组成部分，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南，必须长期坚持并不断发展。全党要深刻领会新时代中国特色社会主义思想的精神实质和丰富内涵，在各项工作中全面准确贯彻落实。 （一）坚持党对一切工作的领导。党政军民学，东西南北中，党是领导一切的。必须增强政治意识、大局意识、核心意识、看齐意识，自觉维护党中央权威和集中统一领导，自觉在思想上政治上行动上同党中央保持高度一致，完善坚持党的领导的体制机制，坚持稳中求进工作总基调，统筹推进“五位一体”总体布局，协调推进“四个全面”战略布局，提高党把方向、谋大局、定政策、促改革的能力和定力，确保党始终总揽全局、协调各方。 （二）坚持以人民为中心。人民是历史的创造者，是决定党和国家前途命运的根本力量。必须坚持人民主体地位，坚持立党为公、执政为民，践行全心全意为人民服务的根本宗旨，把党的群众路线贯彻到治国理政全部活动之中，把人民对美好生活的向往作为奋斗目标，依靠人民创造历史伟业。 （三）坚持全面深化改革。只有社会主义才能救中国，只有改革开放才能发展中国、发展社会主义、发展马克思主义。必须坚持和完善中国特色社会主义制度，不断推进国家治理体系和治理能力现代化，坚决破除一切不合时宜的思想观念和体制机制弊端，突破利益固化的藩篱，吸收人类文明有益成果，构建系统完备、科学规范、运行有效的制度体系，充分发挥我国社会主义制度优越性。 （四）坚持新发展理念。发展是解决我国一切问题的基础和关键，发展必须是科学发展，必须坚定不移贯彻创新、协调、绿色、开放、共享的发展理念。必须坚持和完善我国社会主义基本经济制度和分配制度，毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展，使市场在资源配置中起决定性作用，更好发挥政府作用，推动新型工业化、信息化、城镇化、农业现代化同步发展，主动参与和推动经济全球化进程，发展更高层次的开放型经济，不断壮大我国经济实力和综合国力。 （五）坚持人民当家作主。坚持党的领导、人民当家作主、依法治国有机统一是社会主义政治发展的必然要求。必须坚持中国特色社会主义政治发展道路，坚持和完善人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度、基层群众自治制度，巩固和发展最广泛的爱国统一战线，发展社会主义协商民主，健全民主制度，丰富民主形式，拓宽民主渠道，保证人民当家作主落实到国家政治生活和社会生活之中。 （六）坚持全面依法治国。全面依法治国是中国特色社会主义的本质要求和重要保障。必须把党的领导贯彻落实到依法治国全过程和各方面，坚定不移走中国特色社会主义法治道路，完善以宪法为核心的中国特色社会主义法律体系，建设中国特色社会主义法治体系，建设社会主义法治国家，发展中国特色社会主义法治理论，坚持依法治国、依法执政、依法行政共同推进，坚持法治国家、法治政府、法治社会一体建设，坚持依法治国和以德治国相结合，依法治国和依规治党有机统一，深化司法体制改革，提高全民族法治素养和道德素质。 （七）坚持社会主义核心价值体系。文化自信是一个国家、一个民族发展中更基本、更深沉、更持久的力量。必须坚持马克思主义，牢固树立共产主义远大理想和中国特色社会主义共同理想，培育和践行社会主义核心价值观，不断增强意识形态领域主导权和话语权，推动中华优秀传统文化创造性转化、创新性发展，继承革命文化，发展社会主义先进文化，不忘本来、吸收外来、面向未来，更好构筑中国精神、中国价值、中国力量，为人民提供精神指引。 （八）坚持在发展中保障和改善民生。增进民生福祉是发展的根本目的。必须多谋民生之利、多解民生之忧，在发展中补齐民生短板、促进社会公平正义，在幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶上不断取得新进展，深入开展脱贫攻坚，保证全体人民在共建共享发展中有更多获得感，不断促进人的全面发展、全体人民共同富裕。建设平安中国，加强和创新社会治理，维护社会和谐稳定，确保国家长治久安、人民安居乐业。 （九）坚持人与自然和谐共生。建设生态文明是中华民族永续发展的千年大计。必须树立和践行绿水青山就是金山银山的理念，坚持节约资源和保护环境的基本国策，像对待生命一样对待生态环境，统筹山水林田湖草系统治理，实行最严格的生态环境保护制度，形成绿色发展方式和生活方式，坚定走生产发展、生活富裕、生态良好的文明发展道路，建设美丽中国，为人民创造良好生产生活环境，为全球生态安全作出贡献。 （十）坚持总体国家安全观。统筹发展和安全，增强忧患意识，做到居安思危，是我们党治国理政的一个重大原则。必须坚持国家利益至上，以人民安全为宗旨，以政治安全为根本，统筹外部安全和内部安全、国土安全和国民安全、传统安全和非传统安全、自身安全和共同安全，完善国家安全制度体系，加强国家安全能力建设，坚决维护国家主权、安全、发展利益。 （十一）坚持党对人民军队的绝对领导。建设一支听党指挥、能打胜仗、作风优良的人民军队，是实现“两个一百年”奋斗目标、实现中华民族伟大复兴的战略支撑。必须全面贯彻党领导人民军队的一系列根本原则和制度，确立新时代党的强军思想在国防和军队建设中的指导地位，坚持政治建军、改革强军、科技兴军、依法治军，更加注重聚焦实战，更加注重创新驱动，更加注重体系建设，更加注重集约高效，更加注重军民融合，实现党在新时代的强军目标。 （十二）坚持“一国两制”和推进祖国统一。保持香港、澳门长期繁荣稳定，实现祖国完全统一，是实现中华民族伟大复兴的必然要求。必须把维护中央对香港、澳门特别行政区全面管治权和保障特别行政区高度自治权有机结合起来，确保“一国两制”方针不会变、不动摇，确保“一国两制”实践不变形、不走样。必须坚持一个中国原则，坚持“九二共识”，推动两岸关系和平发展，深化两岸经济合作和文化往来，推动两岸同胞共同反对一切分裂国家的活动，共同为实现中华民族伟大复兴而奋斗。 （十三）坚持推动构建人类命运共同体。中国人民的梦想同各国人民的梦想息息相通，实现中国梦离不开和平的国际环境和稳定的国际秩序。必须统筹国内国际两个大局，始终不渝走和平发展道路、奉行互利共赢的开放战略，坚持正确义利观，树立共同、综合、合作、可持续的新安全观，谋求开放创新、包容互惠的发展前景，促进和而不同、兼收并蓄的文明交流，构筑尊崇自然、绿色发展的生态体系，始终做世界和平的建设者、全球发展的贡献者、国际秩序的维护者。 （十四）坚持全面从严治党。勇于自我革命，从严管党治党，是我们党最鲜明的品格。必须以党章为根本遵循，把党的政治建设摆在首位，思想建党和制度治党同向发力，统筹推进党的各项建设，抓住“关键少数”，坚持“三严三实”，坚持民主集中制，严肃党内政治生活，严明党的纪律，强化党内监督，发展积极健康的党内政治文化，全面净化党内政治生态，坚决纠正各种不正之风，以零容忍态度惩治腐败，不断增强党自我净化、自我完善、自我革新、自我提高的能力，始终保持党同人民群众的血肉联系。 以上十四条，构成新时代坚持和发展中国特色社会主义的基本方略。全党同志必须全面贯彻党的基本理论、基本路线、基本方略，更好引领党和人民事业发展。 实践没有止境，理论创新也没有止境。世界每时每刻都在发生变化，中国也每时每刻都在发生变化，我们必须在理论上跟上时代，不断认识规律，不断推进理论创新、实践创新、制度创新、文化创新以及其他各方面创新。 同志们！时代是思想之母，实践是理论之源。只要我们善于聆听时代声音，勇于坚持真理、修正错误，二十一世纪中国的马克思主义一定能够展现出更强大、更有说服力的真理力量！ 四、决胜全面建成小康社会，开启全面建设社会主义现代化国家新征程 改革开放之后，我们党对我国社会主义现代化建设作出战略安排，提出“三步走”战略目标。解决人民温饱问题、人民生活总体上达到小康水平这两个目标已提前实现。在这个基础上，我们党提出，到建党一百年时建成经济更加发展、民主更加健全、科教更加进步、文化更加繁荣、社会更加和谐、人民生活更加殷实的小康社会，然后再奋斗三十年，到新中国成立一百年时，基本实现现代化，把我国建成社会主义现代化国家。 从现在到二〇二〇年，是全面建成小康社会决胜期。要按照十六大、十七大、十八大提出的全面建成小康社会各项要求，紧扣我国社会主要矛盾变化，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设，坚定实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战略、区域协调发展战略、可持续发展战略、军民融合发展战略，突出抓重点、补短板、强弱项，特别是要坚决打好防范化解重大风险、精准脱贫、污染防治的攻坚战，使全面建成小康社会得到人民认可、经得起历史检验。 从十九大到二十大，是“两个一百年”奋斗目标的历史交汇期。我们既要全面建成小康社会、实现第一个百年奋斗目标，又要乘势而上开启全面建设社会主义现代化国家新征程，向第二个百年奋斗目标进军。 综合分析国际国内形势和我国发展条件，从二〇二〇年到本世纪中叶可以分两个阶段来安排。 第一个阶段，从二〇二〇年到二〇三五年，在全面建成小康社会的基础上，再奋斗十五年，基本实现社会主义现代化。到那时，我国经济实力、科技实力将大幅跃升，跻身创新型国家前列；人民平等参与、平等发展权利得到充分保障，法治国家、法治政府、法治社会基本建成，各方面制度更加完善，国家治理体系和治理能力现代化基本实现；社会文明程度达到新的高度，国家文化软实力显著增强，中华文化影响更加广泛深入；人民生活更为宽裕，中等收入群体比例明显提高，城乡区域发展差距和居民生活水平差距显著缩小，基本公共服务均等化基本实现，全体人民共同富裕迈出坚实步伐；现代社会治理格局基本形成，社会充满活力又和谐有序；生态环境根本好转，美丽中国目标基本实现。 第二个阶段，从二〇三五年到本世纪中叶，在基本实现现代化的基础上，再奋斗十五年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。到那时，我国物质文明、政治文明、精神文明、社会文明、生态文明将全面提升，实现国家治理体系和治理能力现代化，成为综合国力和国际影响力领先的国家，全体人民共同富裕基本实现，我国人民将享有更加幸福安康的生活，中华民族将以更加昂扬的姿态屹立于世界民族之林。 同志们！从全面建成小康社会到基本实现现代化，再到全面建成社会主义现代化强国，是新时代中国特色社会主义发展的战略安排。我们要坚忍不拔、锲而不舍，奋力谱写社会主义现代化新征程的壮丽篇章！ 五、贯彻新发展理念，建设现代化经济体系 实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦，不断提高人民生活水平，必须坚定不移把发展作为党执政兴国的第一要务，坚持解放和发展社会生产力，坚持社会主义市场经济改革方向，推动经济持续健康发展。 我国经济已由高速增长阶段转向高质量发展阶段，正处在转变发展方式、优化经济结构、转换增长动力的攻关期，建设现代化经济体系是跨越关口的迫切要求和我国发展的战略目标。必须坚持质量第一、效益优先，以供给侧结构性改革为主线，推动经济发展质量变革、效率变革、动力变革，提高全要素生产率，着力加快建设实体经济、科技创新、现代金融、人力资源协同发展的产业体系，着力构建市场机制有效、微观主体有活力、宏观调控有度的经济体制，不断增强我国经济创新力和竞争力。 （一）深化供给侧结构性改革。建设现代化经济体系，必须把发展经济的着力点放在实体经济上，把提高供给体系质量作为主攻方向，显著增强我国经济质量优势。加快建设制造强国，加快发展先进制造业，推动互联网、大数据、人工智能和实体经济深度融合，在中高端消费、创新引领、绿色低碳、共享经济、现代供应链、人力资本服务等领域培育新增长点、形成新动能。支持传统产业优化升级，加快发展现代服务业，瞄准国际标准提高水平。促进我国产业迈向全球价值链中高端，培育若干世界级先进制造业集群。加强水利、铁路、公路、水运、航空、管道、电网、信息、物流等基础设施网络建设。坚持去产能、去库存、去杠杆、降成本、补短板，优化存量资源配置，扩大优质增量供给，实现供需动态平衡。激发和保护企业家精神，鼓励更多社会主体投身创新创业。建设知识型、技能型、创新型劳动者大军，弘扬劳模精神和工匠精神，营造劳动光荣的社会风尚和精益求精的敬业风气。 （二）加快建设创新型国家。创新是引领发展的第一动力，是建设现代化经济体系的战略支撑。要瞄准世界科技前沿，强化基础研究，实现前瞻性基础研究、引领性原创成果重大突破。加强应用基础研究，拓展实施国家重大科技项目，突出关键共性技术、前沿引领技术、现代工程技术、颠覆性技术创新，为建设科技强国、质量强国、航天强国、网络强国、交通强国、数字中国、智慧社会提供有力支撑。加强国家创新体系建设，强化战略科技力量。深化科技体制改革，建立以企业为主体、市场为导向、产学研深度融合的技术创新体系，加强对中小企业创新的支持，促进科技成果转化。倡导创新文化，强化知识产权创造、保护、运用。培养造就一大批具有国际水平的战略科技人才、科技领军人才、青年科技人才和高水平创新团队。 （三）实施乡村振兴战略。农业农村农民问题是关系国计民生的根本性问题，必须始终把解决好“三农”问题作为全党工作重中之重。要坚持农业农村优先发展，按照产业兴旺、生态宜居、乡风文明、治理有效、生活富裕的总要求，建立健全城乡融合发展体制机制和政策体系，加快推进农业农村现代化。巩固和完善农村基本经营制度，深化农村土地制度改革，完善承包地“三权”分置制度。保持土地承包关系稳定并长久不变，第二轮土地承包到期后再延长三十年。深化农村集体产权制度改革，保障农民财产权益，壮大集体经济。确保国家粮食安全，把中国人的饭碗牢牢端在自己手中。构建现代农业产业体系、生产体系、经营体系，完善农业支持保护制度，发展多种形式适度规模经营，培育新型农业经营主体，健全农业社会化服务体系，实现小农户和现代农业发展有机衔接。促进农村一二三产业融合发展，支持和鼓励农民就业创业，拓宽增收渠道。加强农村基层基础工作，健全自治、法治、德治相结合的乡村治理体系。培养造就一支懂农业、爱农村、爱农民的“三农”工作队伍。 （四）实施区域协调发展战略。加大力度支持革命老区、民族地区、边疆地区、贫困地区加快发展，强化举措推进西部大开发形成新格局，深化改革加快东北等老工业基地振兴，发挥优势推动中部地区崛起，创新引领率先实现东部地区优化发展，建立更加有效的区域协调发展新机制。以城市群为主体构建大中小城市和小城镇协调发展的城镇格局，加快农业转移人口市民化。以疏解北京非首都功能为“牛鼻子”推动京津冀协同发展，高起点规划、高标准建设雄安新区。以共抓大保护、不搞大开发为导向推动长江经济带发展。支持资源型地区经济转型发展。加快边疆发展，确保边疆巩固、边境安全。坚持陆海统筹，加快建设海洋强国。 （五）加快完善社会主义市场经济体制。经济体制改革必须以完善产权制度和要素市场化配置为重点，实现产权有效激励、要素自由流动、价格反应灵活、竞争公平有序、企业优胜劣汰。要完善各类国有资产管理体制，改革国有资本授权经营体制，加快国有经济布局优化、结构调整、战略性重组，促进国有资产保值增值，推动国有资本做强做优做大，有效防止国有资产流失。深化国有企业改革，发展混合所有制经济，培育具有全球竞争力的世界一流企业。全面实施市场准入负面清单制度，清理废除妨碍统一市场和公平竞争的各种规定和做法，支持民营企业发展，激发各类市场主体活力。深化商事制度改革，打破行政性垄断，防止市场垄断，加快要素价格市场化改革，放宽服务业准入限制，完善市场监管体制。创新和完善宏观调控，发挥国家发展规划的战略导向作用，健全财政、货币、产业、区域等经济政策协调机制。完善促进消费的体制机制，增强消费对经济发展的基础性作用。深化投融资体制改革，发挥投资对优化供给结构的关键性作用。加快建立现代财政制度，建立权责清晰、财力协调、区域均衡的中央和地方财政关系。建立全面规范透明、标准科学、约束有力的预算制度，全面实施绩效管理。深化税收制度改革，健全地方税体系。深化金融体制改革，增强金融服务实体经济能力，提高直接融资比重，促进多层次资本市场健康发展。健全货币政策和宏观审慎政策双支柱调控框架，深化利率和汇率市场化改革。健全金融监管体系，守住不发生系统性金融风险的底线。 （六）推动形成全面开放新格局。开放带来进步，封闭必然落后。中国开放的大门不会关闭，只会越开越大。要以“一带一路”建设为重点，坚持引进来和走出去并重，遵循共商共建共享原则，加强创新能力开放合作，形成陆海内外联动、东西双向互济的开放格局。拓展对外贸易，培育贸易新业态新模式，推进贸易强国建设。实行高水平的贸易和投资自由化便利化政策，全面实行准入前国民待遇加负面清单管理制度，大幅度放宽市场准入，扩大服务业对外开放，保护外商投资合法权益。凡是在我国境内注册的企业，都要一视同仁、平等对待。优化区域开放布局，加大西部开放力度。赋予自由贸易试验区更大改革自主权，探索建设自由贸易港。创新对外投资方式，促进国际产能合作，形成面向全球的贸易、投融资、生产、服务网络，加快培育国际经济合作和竞争新优势。 同志们！解放和发展社会生产力，是社会主义的本质要求。我们要激发全社会创造力和发展活力，努力实现更高质量、更有效率、更加公平、更可持续的发展！ 六、健全人民当家作主制度体系，发展社会主义民主政治 我国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家，国家一切权力属于人民。我国社会主义民主是维护人民根本利益的最广泛、最真实、最管用的民主。发展社会主义民主政治就是要体现人民意志、保障人民权益、激发人民创造活力，用制度体系保证人民当家作主。 中国特色社会主义政治发展道路，是近代以来中国人民长期奋斗历史逻辑、理论逻辑、实践逻辑的必然结果，是坚持党的本质属性、践行党的根本宗旨的必然要求。世界上没有完全相同的政治制度模式，政治制度不能脱离特定社会政治条件和历史文化传统来抽象评判，不能定于一尊，不能生搬硬套外国政治制度模式。要长期坚持、不断发展我国社会主义民主政治，积极稳妥推进政治体制改革，推进社会主义民主政治制度化、规范化、法治化、程序化，保证人民依法通过各种途径和形式管理国家事务，管理经济文化事业，管理社会事务，巩固和发展生动活泼、安定团结的政治局面。 （一）坚持党的领导、人民当家作主、依法治国有机统一。党的领导是人民当家作主和依法治国的根本保证，人民当家作主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式，三者统一于我国社会主义民主政治伟大实践。在我国政治生活中，党是居于领导地位的，加强党的集中统一领导，支持人大、政府、政协和法院、检察院依法依章程履行职能、开展工作、发挥作用，这两个方面是统一的。要改进党的领导方式和执政方式，保证党领导人民有效治理国家；扩大人民有序政治参与，保证人民依法实行民主选举、民主协商、民主决策、民主管理、民主监督；维护国家法制统一、尊严、权威，加强人权法治保障，保证人民依法享有广泛权利和自由。巩固基层政权，完善基层民主制度，保障人民知情权、参与权、表达权、监督权。健全依法决策机制，构建决策科学、执行坚决、监督有力的权力运行机制。各级领导干部要增强民主意识，发扬民主作风，接受人民监督，当好人民公仆。 （二）加强人民当家作主制度保障。人民代表大会制度是坚持党的领导、人民当家作主、依法治国有机统一的根本政治制度安排，必须长期坚持、不断完善。要支持和保证人民通过人民代表大会行使国家权力。发挥人大及其常委会在立法工作中的主导作用，健全人大组织制度和工作制度，支持和保证人大依法行使立法权、监督权、决定权、任免权，更好发挥人大代表作用，使各级人大及其常委会成为全面担负起宪法法律赋予的各项职责的工作机关，成为同人民群众保持密切联系的代表机关。完善人大专门委员会设置，优化人大常委会和专门委员会组成人员结构。 （三）发挥社会主义协商民主重要作用。有事好商量，众人的事情由众人商量，是人民民主的真谛。协商民主是实现党的领导的重要方式，是我国社会主义民主政治的特有形式和独特优势。要推动协商民主广泛、多层、制度化发展，统筹推进政党协商、人大协商、政府协商、政协协商、人民团体协商、基层协商以及社会组织协商。加强协商民主制度建设，形成完整的制度程序和参与实践，保证人民在日常政治生活中有广泛持续深入参与的权利。 人民政协是具有中国特色的制度安排，是社会主义协商民主的重要渠道和专门协商机构。人民政协工作要聚焦党和国家中心任务，围绕团结和民主两大主题，把协商民主贯穿政治协商、民主监督、参政议政全过程，完善协商议政内容和形式，着力增进共识、促进团结。加强人民政协民主监督，重点监督党和国家重大方针政策和重要决策部署的贯彻落实。增强人民政协界别的代表性，加强委员队伍建设。 （四）深化依法治国实践。全面依法治国是国家治理的一场深刻革命，必须坚持厉行法治，推进科学立法、严格执法、公正司法、全民守法。成立中央全面依法治国领导小组，加强对法治中国建设的统一领导。加强宪法实施和监督，推进合宪性审查工作，维护宪法权威。推进科学立法、民主立法、依法立法，以良法促进发展、保障善治。建设法治政府，推进依法行政，严格规范公正文明执法。深化司法体制综合配套改革，全面落实司法责任制，努力让人民群众在每一个司法案件中感受到公平正义。加大全民普法力度，建设社会主义法治文化，树立宪法法律至上、法律面前人人平等的法治理念。各级党组织和全体党员要带头尊法学法守法用法，任何组织和个人都不得有超越宪法法律的特权，绝不允许以言代法、以权压法、逐利违法、徇私枉法。 （五）深化机构和行政体制改革。统筹考虑各类机构设置，科学配置党政部门及内设机构权力、明确职责。统筹使用各类编制资源，形成科学合理的管理体制，完善国家机构组织法。转变政府职能，深化简政放权，创新监管方式，增强政府公信力和执行力，建设人民满意的服务型政府。赋予省级及以下政府更多自主权。在省市县对职能相近的党政机关探索合并设立或合署办公。深化事业单位改革，强化公益属性，推进政事分开、事企分开、管办分离。 （六）巩固和发展爱国统一战线。统一战线是党的事业取得胜利的重要法宝，必须长期坚持。要高举爱国主义、社会主义旗帜，牢牢把握大团结大联合的主题，坚持一致性和多样性统一，找到最大公约数，画出最大同心圆。坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派按照中国特色社会主义参政党要求更好履行职能。深化民族团结进步教育，铸牢中华民族共同体意识，加强各民族交往交流交融，促进各民族像石榴籽一样紧紧抱在一起，共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，坚持我国宗教的中国化方向，积极引导宗教与社会主义社会相适应。加强党外知识分子工作，做好新的社会阶层人士工作，发挥他们在中国特色社会主义事业中的重要作用。构建亲、清新型政商关系，促进非公有制经济健康发展和非公有制经济人士健康成长。广泛团结联系海外侨胞和归侨侨眷，共同致力于中华民族伟大复兴。 同志们！中国特色社会主义政治制度是中国共产党和中国人民的伟大创造。我们完全有信心、有能力把我国社会主义民主政治的优势和特点充分发挥出来，为人类政治文明进步作出充满中国智慧的贡献！ 七、坚定文化自信，推动社会主义文化繁荣兴盛 文化是一个国家、一个民族的灵魂。文化兴国运兴，文化强民族强。没有高度的文化自信，没有文化的繁荣兴盛，就没有中华民族伟大复兴。要坚持中国特色社会主义文化发展道路，激发全民族文化创新创造活力，建设社会主义文化强国。 中国特色社会主义文化，源自于中华民族五千多年文明历史所孕育的中华优秀传统文化，熔铸于党领导人民在革命、建设、改革中创造的革命文化和社会主义先进文化，植根于中国特色社会主义伟大实践。发展中国特色社会主义文化，就是以马克思主义为指导，坚守中华文化立场，立足当代中国现实，结合当今时代条件，发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化，推动社会主义精神文明和物质文明协调发展。要坚持为人民服务、为社会主义服务，坚持百花齐放、百家争鸣，坚持创造性转化、创新性发展，不断铸就中华文化新辉煌。 （一）牢牢掌握意识形态工作领导权。意识形态决定文化前进方向和发展道路。必须推进马克思主义中国化时代化大众化，建设具有强大凝聚力和引领力的社会主义意识形态，使全体人民在理想信念、价值理念、道德观念上紧紧团结在一起。要加强理论武装，推动新时代中国特色社会主义思想深入人心。深化马克思主义理论研究和建设，加快构建中国特色哲学社会科学，加强中国特色新型智库建设。高度重视传播手段建设和创新，提高新闻舆论传播力、引导力、影响力、公信力。加强互联网内容建设，建立网络综合治理体系，营造清朗的网络空间。落实意识形态工作责任制，加强阵地建设和管理，注意区分政治原则问题、思想认识问题、学术观点问题，旗帜鲜明反对和抵制各种错误观点。 （二）培育和践行社会主义核心价值观。社会主义核心价值观是当代中国精神的集中体现，凝结着全体人民共同的价值追求。要以培养担当民族复兴大任的时代新人为着眼点，强化教育引导、实践养成、制度保障，发挥社会主义核心价值观对国民教育、精神文明创建、精神文化产品创作生产传播的引领作用，把社会主义核心价值观融入社会发展各方面，转化为人们的情感认同和行为习惯。坚持全民行动、干部带头，从家庭做起，从娃娃抓起。深入挖掘中华优秀传统文化蕴含的思想观念、人文精神、道德规范，结合时代要求继承创新，让中华文化展现出永久魅力和时代风采。 （三）加强思想道德建设。人民有信仰，国家有力量，民族有希望。要提高人民思想觉悟、道德水准、文明素养，提高全社会文明程度。广泛开展理想信念教育，深化中国特色社会主义和中国梦宣传教育，弘扬民族精神和时代精神，加强爱国主义、集体主义、社会主义教育，引导人们树立正确的历史观、民族观、国家观、文化观。深入实施公民道德建设工程，推进社会公德、职业道德、家庭美德、个人品德建设，激励人们向上向善、孝老爱亲，忠于祖国、忠于人民。加强和改进思想政治工作，深化群众性精神文明创建活动。弘扬科学精神，普及科学知识，开展移风易俗、弘扬时代新风行动，抵制腐朽落后文化侵蚀。推进诚信建设和志愿服务制度化，强化社会责任意识、规则意识、奉献意识。 （四）繁荣发展社会主义文艺。社会主义文艺是人民的文艺，必须坚持以人民为中心的创作导向，在深入生活、扎根人民中进行无愧于时代的文艺创造。要繁荣文艺创作，坚持思想精深、艺术精湛、制作精良相统一，加强现实题材创作，不断推出讴歌党、讴歌祖国、讴歌人民、讴歌英雄的精品力作。发扬学术民主、艺术民主，提升文艺原创力，推动文艺创新。倡导讲品位、讲格调、讲责任，抵制低俗、庸俗、媚俗。加强文艺队伍建设，造就一大批德艺双馨名家大师，培育一大批高水平创作人才。 （五）推动文化事业和文化产业发展。满足人民过上美好生活的新期待，必须提供丰富的精神食粮。要深化文化体制改革，完善文化管理体制，加快构建把社会效益放在首位、社会效益和经济效益相统一的体制机制。完善公共文化服务体系，深入实施文化惠民工程，丰富群众性文化活动。加强文物保护利用和文化遗产保护传承。健全现代文化产业体系和市场体系，创新生产经营机制，完善文化经济政策，培育新型文化业态。广泛开展全民健身活动，加快推进体育强国建设，筹办好北京冬奥会、冬残奥会。加强中外人文交流，以我为主、兼收并蓄。推进国际传播能力建设，讲好中国故事，展现真实、立体、全面的中国，提高国家文化软实力。 同志们！中国共产党从成立之日起，既是中国先进文化的积极引领者和践行者，又是中华优秀传统文化的忠实传承者和弘扬者。当代中国共产党人和中国人民应该而且一定能够担负起新的文化使命，在实践创造中进行文化创造，在历史进步中实现文化进步！ 八、提高保障和改善民生水平，加强和创新社会治理 全党必须牢记，为什么人的问题，是检验一个政党、一个政权性质的试金石。带领人民创造美好生活，是我们党始终不渝的奋斗目标。必须始终把人民利益摆在至高无上的地位，让改革发展成果更多更公平惠及全体人民，朝着实现全体人民共同富裕不断迈进。 保障和改善民生要抓住人民最关心最直接最现实的利益问题，既尽力而为，又量力而行，一件事情接着一件事情办，一年接着一年干。坚持人人尽责、人人享有，坚守底线、突出重点、完善制度、引导预期，完善公共服务体系，保障群众基本生活，不断满足人民日益增长的美好生活需要，不断促进社会公平正义，形成有效的社会治理、良好的社会秩序，使人民获得感、幸福感、安全感更加充实、更有保障、更可持续。 （一）优先发展教育事业。建设教育强国是中华民族伟大复兴的基础工程，必须把教育事业放在优先位置，加快教育现代化，办好人民满意的教育。要全面贯彻党的教育方针，落实立德树人根本任务，发展素质教育，推进教育公平，培养德智体美全面发展的社会主义建设者和接班人。推动城乡义务教育一体化发展，高度重视农村义务教育，办好学前教育、特殊教育和网络教育，普及高中阶段教育，努力让每个孩子都能享有公平而有质量的教育。完善职业教育和培训体系，深化产教融合、校企合作。加快一流大学和一流学科建设，实现高等教育内涵式发展。健全学生资助制度，使绝大多数城乡新增劳动力接受高中阶段教育、更多接受高等教育。支持和规范社会力量兴办教育。加强师德师风建设，培养高素质教师队伍，倡导全社会尊师重教。办好继续教育，加快建设学习型社会，大力提高国民素质。 （二）提高就业质量和人民收入水平。就业是最大的民生。要坚持就业优先战略和积极就业政策，实现更高质量和更充分就业。大规模开展职业技能培训，注重解决结构性就业矛盾，鼓励创业带动就业。提供全方位公共就业服务，促进高校毕业生等青年群体、农民工多渠道就业创业。破除妨碍劳动力、人才社会性流动的体制机制弊端，使人人都有通过辛勤劳动实现自身发展的机会。完善政府、工会、企业共同参与的协商协调机制，构建和谐劳动关系。坚持按劳分配原则，完善按要素分配的体制机制，促进收入分配更合理、更有序。鼓励勤劳守法致富，扩大中等收入群体，增加低收入者收入，调节过高收入，取缔非法收入。坚持在经济增长的同时实现居民收入同步增长、在劳动生产率提高的同时实现劳动报酬同步提高。拓宽居民劳动收入和财产性收入渠道。履行好政府再分配调节职能，加快推进基本公共服务均等化，缩小收入分配差距。 （三）加强社会保障体系建设。按照兜底线、织密网、建机制的要求，全面建成覆盖全民、城乡统筹、权责清晰、保障适度、可持续的多层次社会保障体系。全面实施全民参保计划。完善城镇职工基本养老保险和城乡居民基本养老保险制度，尽快实现养老保险全国统筹。完善统一的城乡居民基本医疗保险制度和大病保险制度。完善失业、工伤保险制度。建立全国统一的社会保险公共服务平台。统筹城乡社会救助体系，完善最低生活保障制度。坚持男女平等基本国策，保障妇女儿童合法权益。完善社会救助、社会福利、慈善事业、优抚安置等制度，健全农村留守儿童和妇女、老年人关爱服务体系。发展残疾人事业，加强残疾康复服务。坚持房子是用来住的、不是用来炒的定位，加快建立多主体供给、多渠道保障、租购并举的住房制度，让全体人民住有所居。 （四）坚决打赢脱贫攻坚战。让贫困人口和贫困地区同全国一道进入全面小康社会是我们党的庄严承诺。要动员全党全国全社会力量，坚持精准扶贫、精准脱贫，坚持中央统筹省负总责市县抓落实的工作机制，强化党政一把手负总责的责任制，坚持大扶贫格局，注重扶贫同扶志、扶智相结合，深入实施东西部扶贫协作，重点攻克深度贫困地区脱贫任务，确保到二〇二〇年我国现行标准下农村贫困人口实现脱贫，贫困县全部摘帽，解决区域性整体贫困，做到脱真贫、真脱贫。 （五）实施健康中国战略。人民健康是民族昌盛和国家富强的重要标志。要完善国民健康政策，为人民群众提供全方位全周期健康服务。深化医药卫生体制改革，全面建立中国特色基本医疗卫生制度、医疗保障制度和优质高效的医疗卫生服务体系，健全现代医院管理制度。加强基层医疗卫生服务体系和全科医生队伍建设。全面取消以药养医，健全药品供应保障制度。坚持预防为主，深入开展爱国卫生运动，倡导健康文明生活方式，预防控制重大疾病。实施食品安全战略，让人民吃得放心。坚持中西医并重，传承发展中医药事业。支持社会办医，发展健康产业。促进生育政策和相关经济社会政策配套衔接，加强人口发展战略研究。积极应对人口老龄化，构建养老、孝老、敬老政策体系和社会环境，推进医养结合，加快老龄事业和产业发展。 （六）打造共建共治共享的社会治理格局。加强社会治理制度建设，完善党委领导、政府负责、社会协同、公众参与、法治保障的社会治理体制，提高社会治理社会化、法治化、智能化、专业化水平。加强预防和化解社会矛盾机制建设，正确处理人民内部矛盾。树立安全发展理念，弘扬生命至上、安全第一的思想，健全公共安全体系，完善安全生产责任制，坚决遏制重特大安全事故，提升防灾减灾救灾能力。加快社会治安防控体系建设，依法打击和惩治黄赌毒黑拐骗等违法犯罪活动，保护人民人身权、财产权、人格权。加强社会心理服务体系建设，培育自尊自信、理性平和、积极向上的社会心态。加强社区治理体系建设，推动社会治理重心向基层下移，发挥社会组织作用，实现政府治理和社会调节、居民自治良性互动。 （七）有效维护国家安全。国家安全是安邦定国的重要基石，维护国家安全是全国各族人民根本利益所在。要完善国家安全战略和国家安全政策，坚决维护国家政治安全，统筹推进各项安全工作。健全国家安全体系，加强国家安全法治保障，提高防范和抵御安全风险能力。严密防范和坚决打击各种渗透颠覆破坏活动、暴力恐怖活动、民族分裂活动、宗教极端活动。加强国家安全教育，增强全党全国人民国家安全意识，推动全社会形成维护国家安全的强大合力。 同志们！党的一切工作必须以最广大人民根本利益为最高标准。我们要坚持把人民群众的小事当作自己的大事，从人民群众关心的事情做起，从让人民群众满意的事情做起，带领人民不断创造美好生活！ 九、加快生态文明体制改革，建设美丽中国 人与自然是生命共同体，人类必须尊重自然、顺应自然、保护自然。人类只有遵循自然规律才能有效防止在开发利用自然上走弯路，人类对大自然的伤害最终会伤及人类自身，这是无法抗拒的规律。 （一）推进绿色发展。加快建立绿色生产和消费的法律制度和政策导向，建立健全绿色低碳循环发展的经济体系。构建市场导向的绿色技术创新体系，发展绿色金融，壮大节能环保产业、清洁生产产业、清洁能源产业。推进能源生产和消费革命，构建清洁低碳、安全高效的能源体系。推进资源全面节约和循环利用，实施国家节水行动，降低能耗、物耗，实现生产系统和生活系统循环链接。倡导简约适度、绿色低碳的生活方式，反对奢侈浪费和不合理消费，开展创建节约型机关、绿色家庭、绿色学校、绿色社区和绿色出行等行动。 （二）着力解决突出环境问题。坚持全民共治、源头防治，持续实施大气污染防治行动，打赢蓝天保卫战。加快水污染防治，实施流域环境和近岸海域综合治理。强化土壤污染管控和修复，加强农业面源污染防治，开展农村人居环境整治行动。加强固体废弃物和垃圾处置。提高污染排放标准，强化排污者责任，健全环保信用评价、信息强制性披露、严惩重罚等制度。构建政府为主导、企业为主体、社会组织和公众共同参与的环境治理体系。积极参与全球环境治理，落实减排承诺。 （三）加大生态系统保护力度。实施重要生态系统保护和修复重大工程，优化生态安全屏障体系，构建生态廊道和生物多样性保护网络，提升生态系统质量和稳定性。完成生态保护红线、永久基本农田、城镇开发边界三条控制线划定工作。开展国土绿化行动，推进荒漠化、石漠化、水土流失综合治理，强化湿地保护和恢复，加强地质灾害防治。完善天然林保护制度，扩大退耕还林还草。严格保护耕地，扩大轮作休耕试点，健全耕地草原森林河流湖泊休养生息制度，建立市场化、多元化生态补偿机制。 （四）改革生态环境监管体制。加强对生态文明建设的总体设计和组织领导，设立国有自然资源资产管理和自然生态监管机构，完善生态环境管理制度，统一行使全民所有自然资源资产所有者职责，统一行使所有国土空间用途管制和生态保护修复职责，统一行使监管城乡各类污染排放和行政执法职责。构建国土空间开发保护制度，完善主体功能区配套政策，建立以国家公园为主体的自然保护地体系。坚决制止和惩处破坏生态环境行为。 同志们！生态文明建设功在当代、利在千秋。我们要牢固树立社会主义生态文明观，推动形成人与自然和谐发展现代化建设新格局，为保护生态环境作出我们这代人的努力！ 十、坚持走中国特色强军之路，全面推进国防和军队现代化 国防和军队建设正站在新的历史起点上。面对国家安全环境的深刻变化，面对强国强军的时代要求，必须全面贯彻新时代党的强军思想，贯彻新形势下军事战略方针，建设强大的现代化陆军、海军、空军、火箭军和战略支援部队，打造坚强高效的战区联合作战指挥机构，构建中国特色现代作战体系，担当起党和人民赋予的新时代使命任务。 适应世界新军事革命发展趋势和国家安全需求，提高建设质量和效益，确保到二〇二〇年基本实现机械化，信息化建设取得重大进展，战略能力有大的提升。同国家现代化进程相一致，全面推进军事理论现代化、军队组织形态现代化、军事人员现代化、武器装备现代化，力争到二〇三五年基本实现国防和军队现代化，到本世纪中叶把人民军队全面建成世界一流军队。 加强军队党的建设，开展“传承红色基因、担当强军重任”主题教育，推进军人荣誉体系建设，培养有灵魂、有本事、有血性、有品德的新时代革命军人，永葆人民军队性质、宗旨、本色。继续深化国防和军队改革，深化军官职业化制度、文职人员制度等重大政策制度改革，推进军事管理革命，完善和发展中国特色社会主义军事制度。树立科技是核心战斗力的思想，推进重大技术创新、自主创新，加强军事人才培养体系建设，建设创新型人民军队。全面从严治军，推动治军方式根本性转变，提高国防和军队建设法治化水平。 军队是要准备打仗的，一切工作都必须坚持战斗力标准，向能打仗、打胜仗聚焦。扎实做好各战略方向军事斗争准备，统筹推进传统安全领域和新型安全领域军事斗争准备，发展新型作战力量和保障力量，开展实战化军事训练，加强军事力量运用，加快军事智能化发展，提高基于网络信息体系的联合作战能力、全域作战能力，有效塑造态势、管控危机、遏制战争、打赢战争。 坚持富国和强军相统一，强化统一领导、顶层设计、改革创新和重大项目落实，深化国防科技工业改革，形成军民融合深度发展格局，构建一体化的国家战略体系和能力。完善国防动员体系，建设强大稳固的现代边海空防。组建退役军人管理保障机构，维护军人军属合法权益，让军人成为全社会尊崇的职业。深化武警部队改革，建设现代化武装警察部队。 同志们！我们的军队是人民军队，我们的国防是全民国防。我们要加强全民国防教育，巩固军政军民团结，为实现中国梦强军梦凝聚强大力量！ 十一、坚持“一国两制”，推进祖国统一 香港、澳门回归祖国以来，“一国两制”实践取得举世公认的成功。事实证明，“一国两制”是解决历史遗留的香港、澳门问题的最佳方案，也是香港、澳门回归后保持长期繁荣稳定的最佳制度。 保持香港、澳门长期繁荣稳定，必须全面准确贯彻“一国两制”、“港人治港”、“澳人治澳”、高度自治的方针，严格依照宪法和基本法办事，完善与基本法实施相关的制度和机制。要支持特别行政区政府和行政长官依法施政、积极作为，团结带领香港、澳门各界人士齐心协力谋发展、促和谐，保障和改善民生，有序推进民主，维护社会稳定，履行维护国家主权、安全、发展利益的宪制责任。 香港、澳门发展同内地发展紧密相连。要支持香港、澳门融入国家发展大局，以粤港澳大湾区建设、粤港澳合作、泛珠三角区域合作等为重点，全面推进内地同香港、澳门互利合作，制定完善便利香港、澳门居民在内地发展的政策措施。 我们坚持爱国者为主体的“港人治港”、“澳人治澳”，发展壮大爱国爱港爱澳力量，增强香港、澳门同胞的国家意识和爱国精神，让香港、澳门同胞同祖国人民共担民族复兴的历史责任、共享祖国繁荣富强的伟大荣光。 解决台湾问题、实现祖国完全统一，是全体中华儿女共同愿望，是中华民族根本利益所在。必须继续坚持“和平统一、一国两制”方针，推动两岸关系和平发展，推进祖国和平统一进程。“一个中国”原则是两岸关系的政治基础，体现一个中国原则的九二共识明确鉴定了两岸关系的根本性质，是确保两岸关系和平发展的关键。承认九二共识的历史事实、认同两岸同属一个中国，两岸双方就能开展对话协商解决两岸同胞关心的问题。台湾任何政党和团体同大陆交往也不会存在障碍。(add) 两岸同胞是命运与共的骨肉兄弟，是血浓于水的一家人。我们秉持“两岸一家亲”理念，尊重台湾现有的社会制度和台湾同胞生活方式，愿意率先同台湾同胞分享大陆发展的机遇。我们将扩大两岸经济文化交流合作，实现互利互惠，逐步为台湾同胞在大陆学习、创业、就业、生活提供与大陆同胞同等的待遇，增进台湾同胞福祉。我们将推动两岸同胞共同弘扬中华文化，促进心灵契合。 我们坚决维护国家主权和领土完整，绝不容忍国家分裂的历史悲剧重演（鼓掌）。一切分裂祖国的活动都必将遭到全体中国人坚决反对（鼓掌）。我们有坚定的意志、充分的信心、足够的能力挫败任何形式的“台独”分裂图谋（鼓掌）。我们绝不允许任何人、任何组织、任何政党、在任何时候、以任何形式、把任何一块中国领土从中国分裂出去！（鼓掌） 同志们！实现中华民族伟大复兴，是全体中国人共同的梦想。我们坚信，只要包括港澳台同胞在内的全体中华儿女顺应历史大势、共担民族大义，把民族命运牢牢掌握在自己手中，就一定能够共创中华民族伟大复兴的美好未来！ 十二、坚持和平发展道路，推动构建人类命运共同体 中国共产党是为中国人民谋幸福的政党，也是为人类进步事业而奋斗的政党。中国共产党始终把为人类作出新的更大的贡献作为自己的使命。 中国将高举和平、发展、合作、共赢的旗帜，恪守维护世界和平、促进共同发展的外交政策宗旨，坚定不移在和平共处五项原则基础上发展同各国的友好合作，推动建设相互尊重、公平正义、合作共赢的新型国际关系。 世界正处于大发展大变革大调整时期，和平与发展仍然是时代主题。世界多极化、经济全球化、社会信息化、文化多样化深入发展，全球治理体系和国际秩序变革加速推进，各国相互联系和依存日益加深，国际力量对比更趋平衡，和平发展大势不可逆转。同时，世界面临的不稳定性不确定性突出，世界经济增长动能不足，贫富分化日益严重，地区热点问题此起彼伏，恐怖主义、网络安全、重大传染性疾病、气候变化等非传统安全威胁持续蔓延，人类面临许多共同挑战。 我们生活的世界充满希望，也充满挑战。我们不能因现实复杂而放弃梦想，不能因理想遥远而放弃追求。没有哪个国家能够独自应对人类面临的各种挑战，也没有哪个国家能够退回到自我封闭的孤岛。 我们呼吁，各国人民同心协力，构建人类命运共同体，建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往新路。要坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义。要同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展。要尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越。要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园。 中国坚定奉行独立自主的和平外交政策，尊重各国人民自主选择发展道路的权利，维护国际公平正义，反对把自己的意志强加于人，反对干涉别国内政，反对以强凌弱。中国决不会以牺牲别国利益为代价来发展自己，也决不放弃自己的正当权益，任何人不要幻想让中国吞下损害自身利益的苦果。中国奉行防御性的国防政策。中国发展不对任何国家构成威胁。中国无论发展到什么程度，永远不称霸，永远不搞扩张。 中国积极发展全球伙伴关系，扩大同各国的利益交汇点，推进大国协调和合作，构建总体稳定、均衡发展的大国关系框架，按照亲诚惠容理念和与邻为善、以邻为伴周边外交方针深化同周边国家关系，秉持正确义利观和真实亲诚理念加强同发展中国家团结合作。加强同各国政党和政治组织的交流合作，推进人大、政协、军队、地方、人民团体等的对外交往。 中国坚持对外开放的基本国策，坚持打开国门搞建设，积极促进“一带一路”国际合作，努力实现政策沟通、设施联通、贸易畅通、资金融通、民心相通，打造国际合作新平台，增添共同发展新动力。加大对发展中国家特别是最不发达国家援助力度，促进缩小南北发展差距。中国支持多边贸易体制，促进自由贸易区建设，推动建设开放型世界经济。 中国秉持共商共建共享的全球治理观，倡导国际关系民主化，坚持国家不分大小、强弱、贫富一律平等，支持联合国发挥积极作用，支持扩大发展中国家在国际事务中的代表性和发言权。中国将继续发挥负责任大国作用，积极参与全球治理体系改革和建设，不断贡献中国智慧和力量。 同志们！世界命运握在各国人民手中，人类前途系于各国人民的抉择。中国人民愿同各国人民一道，推动人类命运共同体建设，共同创造人类的美好未来！ 十三、坚定不移全面从严治党，不断提高党的执政能力和领导水平 中国特色社会主义进入新时代，我们党一定要有新气象新作为。打铁必须自身硬。党要团结带领人民进行伟大斗争、推进伟大事业、实现伟大梦想，必须毫不动摇坚持和完善党的领导，毫不动摇把党建设得更加坚强有力。 全面从严治党永远在路上。一个政党，一个政权，其前途命运取决于人心向背。人民群众反对什么、痛恨什么，我们就要坚决防范和纠正什么。全党要清醒认识到，我们党面临的执政环境是复杂的，影响党的先进性、弱化党的纯洁性的因素也是复杂的，党内存在的思想不纯、组织不纯、作风不纯等突出问题尚未得到根本解决。要深刻认识党面临的执政考验、改革开放考验、市场经济考验、外部环境考验的长期性和复杂性，深刻认识党面临的精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险的尖锐性和严峻性，坚持问题导向，保持战略定力，推动全面从严治党向纵深发展。 新时代党的建设总要求是：坚持和加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提高党的建设质量，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。 (一)把党的政治建设摆在首位。旗帜鲜明讲政治是我们党作为马克思主义政党的根本要求。党的政治建设是党的根本性建设，决定党的建设方向和效果。保证全党服从中央，坚持党中央权威和集中统一领导，是党的政治建设的首要任务。全党要坚定执行党的政治路线，严格遵守政治纪律和政治规矩，在政治立场、政治方向、政治原则、政治道路上同党中央保持高度一致。要尊崇党章，严格执行新形势下党内政治生活若干准则，增强党内政治生活的政治性、时代性、原则性、战斗性，自觉抵制商品交换原则对党内生活的侵蚀，营造风清气正的良好政治生态。完善和落实民主集中制的各项制度，坚持民主基础上的集中和集中指导下的民主相结合，既充分发扬民主，又善于集中统一。弘扬忠诚老实、公道正派、实事求是、清正廉洁等价值观，坚决防止和反对个人主义、分散主义、自由主义、本位主义、好人主义，坚决防止和反对宗派主义、圈子文化、码头文化，坚决反对搞两面派、做两面人。全党同志特别是高级干部要加强党性锻炼，不断提高政治觉悟和政治能力，把对党忠诚、为党分忧、为党尽职、为民造福作为根本政治担当，永葆共产党人政治本色。 (二)用新时代中国特色社会主义思想武装全党。思想建设是党的基础性建设。革命理想高于天。共产主义远大理想和中国特色社会主义共同理想，是中国共产党人的精神支柱和政治灵魂，也是保持党的团结统一的思想基础。要把坚定理想信念作为党的思想建设的首要任务，教育引导全党牢记党的宗旨，挺起共产党人的精神脊梁，解决好世界观、人生观、价值观这个“总开关”问题，自觉做共产主义远大理想和中国特色社会主义共同理想的坚定信仰者和忠实实践者。弘扬马克思主义学风，推进“两学一做”学习教育常态化制度化，以县处级以上领导干部为重点，在全党开展“不忘初心、牢记使命”主题教育，用党的创新理论武装头脑，推动全党更加自觉地为实现新时代党的历史使命不懈奋斗。 (三)建设高素质专业化干部队伍。党的干部是党和国家事业的中坚力量。要坚持党管干部原则，坚持德才兼备、以德为先，坚持五湖四海、任人唯贤，坚持事业为上、公道正派，把好干部标准落到实处。坚持正确选人用人导向，匡正选人用人风气，突出政治标准，提拔重用牢固树立“四个意识”和“四个自信”、坚决维护党中央权威、全面贯彻执行党的理论和路线方针政策、忠诚干净担当的干部，选优配强各级领导班子。注重培养专业能力、专业精神，增强干部队伍适应新时代中国特色社会主义发展要求的能力。大力发现储备年轻干部，注重在基层一线和困难艰苦的地方培养锻炼年轻干部，源源不断选拔使用经过实践考验的优秀年轻干部。统筹做好培养选拔女干部、少数民族干部和党外干部工作。认真做好离退体干部工作。坚持严管和厚爱结合、激励和约束并重，完善干部考核评价机制，建立激励机制和容错纠错机制，旗帜鲜明为那些敢于担当、踏实做事、不谋私利的干部撑腰鼓劲。各级党组织要关心爱护基层干部，主动为他们排忧解难。 人才是实现民族振兴、赢得国际竞争主动的战略资源。要坚持党管人才原则，聚天下英才而用之，加快建设人才强国。实行更加积极、更加开放、更加有效的人才政策，以识才的慧眼、爱才的诚意、用才的胆识、容才的雅量、聚才的良方，把党内和党外、国内和国外各方面优秀人才集聚到党和人民的伟大奋斗中来，鼓励引导人才向边远贫困地区、边疆民族地区、革命老区和基层一线流动，努力形成人人渴望成才、人人努力成才、人人皆可成才、人人尽展其才的良好局面，让各类人才的创造活力竞相进发、聪明才智充分涌流。 (四)加强基层组织建设。党的基层组织是确保党的路线方针政策和决策部署贯彻落实的基础。要以提升组织力为重点，突出政治功能，把企业、农村、机关、学校、科研院所、街道社区、社会组织等基层党组织建设成为宣传党的主张、贯彻党的决定、领导基层治理、团结动员群众、推动改革发展的坚强战斗堡垒。党支部要担负好直接教育党员、管理党员、监督党员和组织群众、宣传群众、凝聚群众、服务群众的职责，引导广大党员发挥先锋模范作用。坚持“三会一课”制度，推进党的基层组织设置和活动方式创新，加强基层党组织带头人队伍建设，扩大基层党组织覆盖面，着力解决一些基层党组织弱化、虚化、边缘化问题。扩大党内基层民主，推进党务公开，畅通党员参与党内事务、监督党的组织和干部、向上级党组织提出意见和建议的渠道。注重从产业工人、青年农民、高知识群体中和在非公有制经济组织、社会组织中发展党员。加强党内激励关怀帮扶。增强党员教育管理针对性和有效性，稳妥有序开展不合格党员组织处置工作。 (五)持之以恒正风肃纪。我们党来自人民、植根人民、服务人民，一旦脱离群众，就会失去生命力。加强作风建设，必须紧紧围绕保持党同人民群众的血肉联系，增强群众观念和群众感情，不断厚植党执政的群众基础。凡是群众反映强烈的问题都要严肃认真对待，凡是损害群众利益的行为都要坚决纠正。坚持以上率下，巩固拓展落实中央八项规定精神成果，继续整治“四风”问题，坚决反对特权思想和特权现象。重点强化政治纪律和组织纪律，带动廉洁纪律、群众纪律、工作纪律、生活纪律严起来。坚持开展批评和自我批评，坚持惩前毖后、治病救人，运用监督执纪“四种形态”，抓早抓小、防微杜渐。赋予有干部管理权限的党组相应纪律处分权限，强化监督执纪问责。加强纪律教育，强化纪律执行，让党员、干部知敬畏、存戒惧、守底线，习惯在受监督和约束的环境中工作生活。 (六)夺取反腐败斗争压倒性胜利。人民群众最痛恨腐败现象，腐败是我们党面临的最大威胁。只有以反腐败永远在路上的坚韧和执着，深化标本兼治，保证干部清正、政府清廉、政治清明，才能跳出历史周期率，确保党和国家长治久安。当前，反腐败斗争形势依然严峻复杂，巩固压倒性态势、夺取压倒性胜利的决心必须坚如磐石。要坚持无禁区、全覆盖、零容忍，坚持重遏制、强高压、长震慑，坚持受贿行贿一起查，坚决防止党内形成利益集团。在市县党委建立巡察制度，加大整治群众身边腐败问题力度。不管腐败分子逃到哪里，都要缉拿归案、绳之以法。推进反腐败国家立法，建设覆盖纪检监察系统的检举举报平台。强化不敢腐的震慑，扎牢不能腐的笼子，增强不想腐的自觉，通过不懈努力换来海晏河清、朗朗乾坤。 (七)健全党和国家监督体系。增强党自我净化能力，根本靠强化党的自我监督和群众监督。要加强对权力运行的制约和监督，让人民监督权力，让权力在阳光下运行，把权力关进制度的笼子。强化自上而下的组织监督，改进自下而上的民主监督，发挥同级相互监督作用，加强对党员领导干部的日常管理监督。深化政治巡视，坚持发现问题、形成震慑不动摇，建立巡视巡察上下联动的监督网。深化国家监察体制改革，将试点工作在全国推开，组建国家、省、市、县监察委员会，同党的纪律检查机关合署办公，实现对所有行使公权力的公职人员监察全覆盖。制定国家监察法，依法赋予监察委员会职责权限和调查手段，用留置取代“两规”措施。改革审计管理体制，完善统计体制。构建党统一指挥、全面覆盖、权威高效的监督体系，把党内监督同国家机关监督、民主监督、司法监督、群众监督、舆论监督贯通起来，增强监督合力。 (八)全面增强执政本领。领导十三亿多人的社会主义大国，我们党既要政治过硬，也要本领高强。要增强学习本领，在全党营造善于学习、勇于实践的浓厚氛围，建设马克思主义学习型政党，推动建设学习大国。增强政治领导本领，坚持战略思维、创新思维、辩证思维、法治思维、底线思维，科学制定和坚决执行党的路线方针政策，把党总揽全局、协调各方落到实处。增强改革创新本领，保持锐意进取的精神风貌，善于结合实际创造性推动工作，善于运用互联网技术和信息化手段开展工作。增强科学发展本领，善于贯彻新发展理念，不断开创发展新局面。增强依法执政本领，加快形成覆盖党的领导和党的建设各方面的党内法规制度体系，加强和改善对国家政权机关的领导。增强群众工作本领，创新群众工作体制机制和方式方法，推动工会、共青团、妇联等群团组织增强政治性、先进性、群众性，发挥联系群众的桥梁纽带作用，组织动员广大人民群众坚定不移跟党走。增强狠抓落实本领，坚持说实话、谋实事、出实招、求实效，把雷厉风行和久久为功有机结合起来，勇于攻坚克难，以钉钉子精神做实做细做好各项工作。增强驾驭风险本领，健全各方面风险防控机制，善于处理各种复杂矛盾，勇于战胜前进道路上的各种艰难险阻，牢牢把握工作主动权。 同志们！伟大的事业必须有坚强的党来领导。只要我们党把自身建设好、建设强，确保党始终同人民想在一起、干在一起，就一定能够引领承载看中国人民伟大梦想的航船破浪前进，胜利驶向光辉的彼岸！ 同志们！中华民族是历经磨难、不屈不挠的伟大民族，中国人民是勤劳勇敢、自强不息的伟大人民，中国共产党是敢于斗争、敢于胜利的伟大政党。历史车轮滚滚向前，时代潮流浩浩荡荡。历史只会眷顾坚定者、奋进者、搏击者，而不会等待犹豫者、懈怠者、畏难者。全党一定要保持艰苦奋斗、戒骄戒躁的作风，以时不我待、只争朝夕的精神，奋力走好新时代的长征路。全党一定要自觉维护党的团结统一，保持党同人民群众的血肉联系，巩固全国各族人民大团结，加强海内外中华儿女大团结，团结一切可以团结的力量，齐心协力走向中华民族伟大复兴的光明前景。 青年兴则国家兴，青年强则国家强。青年一代有理想、有本领、有担当，国家就有前途，民族就有希望。中国梦是历史的、现实的，也是未来的；是我们这一代的，更是青年一代的。中华民族伟大复兴的中国梦终将在一代代青年的接力奋斗中变为现实。全党要关心和爱护青年，为他们实现人生出彩搭建舞台。广大青年要坚定理想信念，志存高远，脚踏实地，勇做时代的弄潮儿，在实现中国梦的生动实践中放飞青春梦想，在为人民利益的不懈奋斗中书写人生华章！ 大道之行，天下为公。站立在九百六十多万平方公里的广裹土地上，吸吮着五千多年中华民族漫长奋斗积累的文化养分，拥有十三亿多中国人民聚合的磅礴之力，我们走中国特色社会主义道路，具有无比广阔的时代舞台，具有无比深厚的历史底蕴，具有无比强大的前进定力。全党全国各族人民要紧密团结在党中央周围，高举中国特色社会主义伟大旗帜，锐意进取，埋头苦干，为实现推进现代化建设、完成祖国统一、维护世界和平与促进共同发展三大历史任务，为决胜全面建成小康社会、夺取新时代中国特色社会主义伟大胜利、实现中华民族伟大复兴的中国梦、实现人民对美好生活的向往继续奋斗！ 参考自： https://mp.weixin.qq.com/s/e6quFK5Ct4hDHRZ6Hv8j7g 根据开幕式现场视频做出了增加。并将最后的图片识别为文字。 http://tv.cctv.com/live/cctv13/]]></content>
      <tags>
        <tag>十九大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度下降及其优化算法]]></title>
    <url>%2F2017%2F10%2F17%2FDL_gradient_descent%2F</url>
    <content type="text"><![CDATA[“请简述梯度下降算法以及如何优化梯度下降算法？” 上述是机器学习中常见面试题之一，本文将稍作阐述，仅供参考。 梯度下降法梯度下降是一个最优化算法，通俗的来讲也就是沿着梯度下降的方向来求出一个函数的极小值。 那么我们在高等数学中学过，对于一些我们了解的函数方程，我们可以对其求一阶导和二阶导，比如说二次函数。可是我们在处理问题的时候遇到的并不都是我们熟悉的函数，并且既然是机器学习就应该让机器自己去学习如何对其进行求解，显然我们需要换一个思路。因此我们采用梯度下降，不断迭代，沿着梯度下降的方向来移动，求出极小值。 批量梯度下降（Batch gradient descent）现在我们就要求出J(θ)取到极小值时的θT向量。之前已经说过了，沿着函数梯度的方向下降就能最快的找到极小值。 $$\theta=\theta-\eta \nabla_\theta{J(\theta)}$$ 计算J(θ)关于θT的偏导数,也就得到了向量中每一个θ的梯度。 沿着梯度的方向更新参数θ的值 迭代直到收敛。 批量梯度下降算法使用整个训练集计算目标函数的梯度并更新参数。代码如下： for i in range(nb_epochs): params_grad = evaluate_gradient(loss_function, data, params) params = params - learning_rate * params_grad 可以看到，批量梯度下降是用了训练集中的所有样本。因此在数据量很大的时候，每次迭代都要遍历训练集一遍，开销会很大，所以在数据量大的时候，可以采用随机梯度下降法。 随机梯度下降（Stochastic gradient descent）和批量梯度有所不同的地方在于，每次迭代只选取一个样本的数据，一旦到达最大的迭代次数或是满足预期的精度，就停止。 可以得出随机梯度下降法的θ更新表达式。 $$\theta=\theta-\eta\nabla_\theta{J(\theta;x^{(i)},y^{(i)})}$$ 因为每次只计算一个样本，所以SGD计算非常快并且适合线上更新模型。但是，频繁地更新参数也使得目标函数抖动非常厉害。 SGD频繁地参数更新可以使算法跳出局部最优点，更可能寻找到接近全局最优的解。SGD代码如下： for i in range(nb_epochs): np.random.shuffle(data) for example in data: params_grad = evaluate_gradient(loss_function, example, params) patams = params - learning_rate * params_grad 注意，上面的代码在每个epoch都对训练数据进行了打乱操作，这样可以保证不同epoch学习到的特征和训练样本的出现顺序没有关系。 使用情况如果仅从测试误差出发，标准梯度下降的效果会比随机梯度下降要好。但是标准梯度下降的训练时间会比随机梯度下降要长。 像线性回归这种简单的模型，训练时间的优先级不高，所以用标准梯度下降会比随机梯度下降要好。像神经网络这种复杂的模型，训练时间的优先级比较高，所以用随机梯度下降比较好。 如果模型的损失函数是凸函数，那么使用标准梯度下降一定能达到全局最优。如果模型比较复杂，容易进入局部最优，那么使用随机梯度下降会发生震荡，容易从局部最优中跳出，进入全局最优。 另外，神经网络模型使用标准梯度下降最重要的原因是神经网络容易过拟合，而不是训练时间。 小批量梯度下降(mini-batch gradient descent)小批量梯度下降结合了批量梯度下降和随机梯度下降的优点，它一次以小批量的训练数据计算目标函数的权重并更新参数。公式如下： $$\theta=\theta-\eta\nabla_\theta{J(\theta;x^{(i:i+n)};y^{(i:i+n)})}$$ 其中，n为每批训练集的数量，一般设为50到256。 for i in range(nb_epochs): np.random.shuffle(data) for batch in get_batches(data, batch_size=50): params_grad = evaluate_gradient(loss_function, batch, params) params = params - learning_rate * params_grad 这个算法有下面几个方面的优点： 相比较SGD增加了一次更新使用的训练数据量，使得目标函数收敛得更加平稳； 可以使用矩阵操作对每批数据进行计算，大大提升了算法的效率。 梯度下降的优缺点mini-batch gradient descent虽然相较于批量梯度下降和随机梯度下降方法效果有所改善但是任然存在许多挑战： 难以选择合适的学习速率：如果学习速率选择过小会造成网络收敛太慢，但是设得太大可能使得损失函数在最小点周围不断摇摆而永远达不到最小点； 可以在训练开始时设置一个较大地学习率然后每训练若干个周期后按比例降低学习率，虽然这个方法有一些作用，但是由于降低学习率的周期是人为事先设定的，所以它不能很好地适应数据内在的规律； 另一方面，我们对特征向量中的所有的特征都采用了相同的学习率，如果训练数据十分稀疏并且不同特征的变化频率差别很大，这时候对变化频率慢得特征采用大的学习率而对变化频率快的特征采用小的学习率是更好的选择。 这些梯度下降方法难以逃脱”鞍点”, 如下图所示，鞍点既不是最大点也不是最小点，在这个点附近，所有方向上的梯度都接近于0，这些梯度下降算法很难逃离它。 梯度下降算法的改进冲量(Momentum)实际中，我们遇到的目标函数往往在不同的维度上梯度相差很大，比如在下面的函数等高线图中可以看出函数在纵向上要比横向陡峭得多。 然而SGD等基本梯度下降算法并不知道这些，因为y方向梯度大x方向梯度小所以它们会在y方向上不断摇摆而沿x方向缓慢移动，但是我们知道在y方向的震荡是无用的只有x方向的才在不断接近最优点。 冲量方法在SGD的基础上，加上了上一步的梯度： 其中γ通常设为0.9。 由于目标函数在y方向上摇摆，所以前后两次计算的梯度在y方向上相反，所以相加后相互抵消，而x方向上梯度方向不变，所以x方向的梯度是累加的，其效果就是损失函数在y方向上的震荡减小了，而更加迅速地从x方向接近最优点。 也可以把这个过程和在斜坡放一个球让其滚下类比：当从斜坡顶端释放一个小球时，由于重力的作用小球滚下的速度会越来越快；与此类似，冲量的作用会使相同方向的梯度不断累加，不同方向的梯度相互抵消，其效果就是逼近最优点的速度不断加快。 Nesterov accelerated gradient想象小球从山坡上滑落，它的速度沿着山坡不断加快，然而这并不是令我们满意的结果，当小球接近山谷(最优点)时，它已经有了很大的速度，很可能会再次冲向山谷的另一边，而错过了最优点。我们需要一颗更加“聪明”的小球，它能够感知坡度的变化，从而在它再次冲上山坡之前减速而避免错过山谷。 Nesterov accelerated gradient(NAG)就是一种让小球变“聪明”的方法。NAG不但增加了动量项，并且计算参数的梯度时，在损失函数中减去了梯度项将其作为下一次参数所在位置的预估： 同样，上式中的γ 一般设为0.9。 如下图所示，蓝色的是动量方法的更新路径，首先计算一次梯度更新一小步，然后在下一次累加上一次计算的梯度从而更新一大步。而NAG算法每一步更新过程由两个步骤组成：第一步($\gamma v_{t−1}$, 图中棕色)使用之前计算的梯度移动一大步，第二步在移动后的位置计算的梯度方向移动一小步(图中红色线)进行修正，经过这样的两步合成了最终的绿线部分。 分析上面的原理可知，当“小球”将要冲上山坡的另一面时，红色线表示的预测梯度方向发生改变，从而将棕色向量往回拉达到了“减速”的效果。 通过NAG方法，我们使参数更新速率能够自适应“坡度”的变化，另一方面，我们希望每个单独的参数能够自适应各自的变化频率，比如，稀疏特征采用高的更新速率，其他特征采用相对较低的更新速率。下面介绍几种常用的方法。 详细介绍可以参见Ilya Sutskever的PhD论文Sutskever, I. (2013). Training Recurrent neural Networks. PhD Thesis. AdagradAdadeltaRMSpropAdamAdam的全称是Adaptive Moment Estimation, 它也是一种自适应学习率方法，与Adadelta和RMSprop类似，它将每个参数的历史梯度平方均值存于$v_t$中，不同的是，Adam还使用了类似冲量的衰减项$m_t$: 效果图a中，所有方法都从相同位置出发，经历不同的路径到达了最小点，其中Adagrad、Adadelta和RMSprop一开始就朝向正确的方向并且迅速收敛，而冲量、NAG则会冲向错误的方向，但是由于NAG会向前多“看”一步所以能很快找到正确的方向。 图b显示了这些方法逃离鞍点的能力，鞍点有部分方向有正梯度另一些方向有负梯度，SGD方法逃离能力最差，冲量和NAG方法也不尽如人意，而Adagrad、RMSprop、Adadelta很快就能从鞍点逃离出来。 参考资料 http://www.cnblogs.com/Sinte-Beuve/p/6164689.html http://blog.csdn.net/ortyijing/article/details/54984058 http://blog.csdn.net/bupt_wx/article/details/52761751 http://blog.csdn.net/heyongluoyao8/article/details/52478715 http://cs231n.github.io/neural-networks-3/ http://www.360doc.com/content/16/1010/08/36492363_597225745.shtml其中，第四个文章写得不错。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Gradient Descent</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BAT批处理中的字符串处理(字符串截取等)]]></title>
    <url>%2F2017%2F10%2F10%2Fbatch_string_process%2F</url>
    <content type="text"><![CDATA[什么是批处理？在windows下，以cmd或者bat结尾的文件就是批处理文件；linux下，也有以sh结尾的shell脚本文件。 本文主要介绍了批处理在字符串处理中的一些方法： 字符串截取 字符串替换 字符串合并 字符串扩充 1、截取字符串截取字符串可以说是字符串处理功能中最常用的一个子功能了，能够实现截取字符串中的特定位置的一个或多个字符。举例说明其基本功能： @echo off set ifo=abcdefghijklmnopqrstuvwxyz0123456789 echo 原字符串（第二行为各字符的序号）： echo %ifo% echo 123456789012345678901234567890123456 echo 截取前5个字符： echo %ifo:~0,5% echo 截取最后5个字符： echo %ifo:~-5% echo 截取第一个到倒数第6个字符： echo %ifo:~0,-5% echo 从第4个字符开始，截取5个字符： echo %ifo:~3,5% echo 从倒数第14个字符开始，截取5个字符： echo %ifo:~-14,5% pause 当然，上面的例子只是将字符串处理的基本功能展示出来了，还看不出字符串处理具体有什么用处。下面这个例子是对时间进行处理。 @echo off echo 当前时间是：%time% 即 %time:~0,2%点%time:~3,2%分%time:~6,2%秒%time:~9,2%厘秒 pause 2、替换字符串替换字符串，即将某一字符串中的特定字符或字符串替换为给定的字符串。举例说明其功能： @echo off set aa=伟大的中国！我为你自豪！ echo 替换前：%aa% echo 替换后：%aa:中国=中华人民共和国% echo aa = %aa% set &quot;aa=%aa:中国=中华人民共和国%&quot; echo aa = %aa% pause 对于上面的例子有一点说明，对比两个echo aa = %aa%可以发现，如果要修改变量aa的内容的话，就需要将修改结果“%aa:中国=中华人民共和国%”赋值给变量aa。上面的字符串截取也有着同样的特点。 3、字符串合并其实，合并字符串就是将两个字符串放在一起就可以了。举例说明： @echo off set aa=伟大的中国！ set bb=我为你自豪！ echo %aa%%bb% echo aa=%aa% echo bb=%bb% set &quot;aa=%aa%%bb%&quot; echo aa=%aa% pause 同样，如果要改变变量aa的内容的话，就需要将合并结果“%aa%%bb%”赋值给变量aa。 4、扩充字符串 “扩充”这个词汇来自于微软自己的翻译，意思就是对表示文件路径的字符串进行特殊的处理，具体功能罗列如下： ========================================= ~I - 删除任何引号(&quot;)，扩充 %I %~fI - 将 %I 扩充到一个完全合格的路径名 %~dI - 仅将 %I 扩充到一个驱动器号 %~pI - 仅将 %I 扩充到一个路径 %~nI - 仅将 %I 扩充到一个文件名 %~xI - 仅将 %I 扩充到一个文件扩展名 %~sI - 扩充的路径只含有短名 %~aI - 将 %I 扩充到文件的文件属性 %~tI - 将 %I 扩充到文件的日期/时间 %~zI - 将 %I 扩充到文件的大小 %~$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串可以组合修饰符来得到多重结果: %~dpI - 仅将 %I 扩充到一个驱动器号和路径 %~nxI - 仅将 %I 扩充到一个文件名和扩展名 %~fsI - 仅将 %I 扩充到一个带有短名的完整路径名 %~dp$PATH:i - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个驱动器号和路径。 %~ftzaI - 将 %I 扩充到类似输出线路的 DIR ========================================= 以上内容引用于for /?帮助信息。其中的I代表变量I，不过需要说明的是，不是所有的变量都能够进行扩充的，有两个条件：1、该字符串代表一个文件路径；2、变量要用%x来表示，x可取a-z A-Z 0-9共62个字符中的任意一个。举例说明： @echo off echo 正在运行的这个批处理： echo 完全路径：%0 echo 去掉引号：%~0 echo 所在分区：%~d0 echo 所处路径：%~p0 echo 文件名：%~n0 echo 扩展名：%~x0 echo 文件属性：%~a0 echo 修改时间：%~t0 echo 文件大小：%~z0 pause 其中的%0是批处理里面的参数，代表当前运行的批处理的完全路径。类似的还有%1-%9，分别代表传递来的第1-9个参数。例子如下： @echo off set aa=C:\Windows\PPP\a.btx call :deal aaa %aa% &quot;c c&quot; ddd eee pause&gt;nul exit :deal echo %%0 = %0 echo %%1 = %1 echo %%2 = %2 echo %%3 = %3 echo %%4 = %4 echo %%5 = %5 其中，变量aa在之前是不可以扩充的，通过call命令并将aa作为参数传递给子函数:deal，将aa变量转换成了变量%1，即符合%x格式，从而可以进行字符串扩充。 至于%x中x取a-z A-Z的形式，可以复习一下for语句，for语句里面的变量就是用%x来表示的，因而可以直接进行扩充。 补充C语中的strcpy函数C语中的strcpy函数，将一个字符串复制到另一个字符型指针或字符数组，覆盖原来的字符串。 C语言中的调用方法：strcpy(目标字符串,源字符串) 在批处理中的实现方法： set 目标字符串=%源字符串% 示例： @echo off ::关闭屏幕回显（可选） set str1=This is old string ::设置str1中存储的字符串，注意没有双引号，这点与C语言等不同！ set str2=This is new string ::设置str2中存储的字符串 echo 执行字符串拷贝以前： echo str1=%str1% echo str2=%str2% ::先输出一次原有的字符串 set str1=%str2% ::字符串拷贝 echo 执行字符串拷贝以后： echo str1=%str1% echo str2=%str2% ::输出执行完字符串拷贝后的字符串 echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit ::输出信息，当用户按任意键时，结束该批处理。 2.C语中的strcat函数C语中的strcat函数，将一个字符串连接到另一个字符型指针或字符数组的末尾。 C语言中的调用方法：strcat(目标字符串,源字符串) 在批处理中的实现方法： set 目标字符串=%目标字符串%%源字符串% 示例： @echo off set str1=This is string1 set str2=This is string2 ::设置str1和str2中存储的字符串 echo 连接字符串以前： echo str1=%str1% echo str2=%str2% ::先输出一次原有的字符串 set str1=%str1%%str2% ::字符串连接 echo 连接字符串以后： echo str1=%str1% echo str2=%str2% ::输出执行完字符串连接后的两个字符串 echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit 3、字符串截取C中没有这种函数，不过可以通过语句实现，不再介绍，直接说批处理的。 set 目标字符串=%源字符串:~起始值,截取长度% 注意，起始值从0开始！ 截取长度是可选的，如果省略逗号和截取长度，将会从起始值一直截取到字符串的结尾。 示例： @echo off set str1=This is string1 ::设置str1中存储的字符串 set str2=%str1:~8,6% set str3=%str1:~0,4% set str4=%str1:~5% ::字符串截取 echo 原字符串： echo str1=%str1% echo 截取得到的字符串： echo str2=%str2% echo str3=%str3% echo str4=%str4% ::输出执行结果 echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit 4、C语中的strlen函数，取得字符串的长度。C语言中的调用方法：strlen(字符串) 在批处理中的实现方法是利用goto和标签，形成循环结构，不断将字符串截短1字符，并用变量记录截短的次数，直到字符串变成空串。 示例： @echo off set str1=This is a test string set str2=Hello World ::设置两个字符串 set str=%str1% ::将str1复制到str :next1 ::标签，用于goto跳转 ::注意与注释语句的区别，注释用两个冒号开头，标签则为一个冒号 if not &quot;%str%&quot;==&quot;&quot; ( ::判断str是不是空串，如果不是则执行下边的语句 set /a num+=1 ::算术运算，使num的值自增1，相当于num++或者++num语句 set &quot;str=%str:~1%&quot; ::截取字符串，赋给自身 goto next1 ::跳转到next1标签 ::这里利用goto和标签，构成循环结构 ) ::当以上循环结构执行完毕时，会执行下边的语句 echo str1=%str1% echo str1的长度为：%num% ::输出结果 set num=0 ::将记和用的环境变量num置0，以便开始下一次运算。 set str=%str2% ::将str2复制到str :next2 ::定义一个新的标签 ::注意不能与已有的标签同名，否则会出错！ if not &quot;%str%&quot;==&quot;&quot; ( set /a num+=1 set &quot;str=%str:~1%&quot; goto next2 ) ::和上一个循环相似，不再介绍 echo str2=%str2% echo str2的长度为：%num% ::输出结果 echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit 5、C语中的strchr函数，在一个字符串中查找一个字符的首次出现位置，找到时返回所在位置，找不到时返回0值。 批处理中的思路：不断截短字符串，并取截短后字符串中的首字符，和要求的字符比较，如果相同就利用goto语句跳出循环，输出结果，如果没有相同的字符，执行到最后就输出0值。 示例： @echo off Setlocal ENABLEDELAYEDEXPANSION ::启用命令扩展，参加setlocal /?命令 set str1=This is a test string set ch1=t ::注意，这里是区分大小写的！ set str=%str1% ::复制字符串，用来截短，而不影响源字符串 :next if not &quot;%str%&quot;==&quot;&quot; ( set /a num+=1 if &quot;!str:~0,1!&quot;==&quot;%ch1%&quot; goto last ::比较首字符是否为要求的字符，如果是则跳出循环 set &quot;str=%str:~1%&quot; goto next ) set /a num=0 ::没有找到字符时，将num置零 :last echo 字符&apos;%ch1%&apos;在字符串&quot;%str1%&quot;中的首次出现位置为%num% echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit 参考自：http://www.jb51.net/article/52744.htm]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习系列：（五）机器学习基础]]></title>
    <url>%2F2017%2F10%2F08%2FDL_chap_5%2F</url>
    <content type="text"><![CDATA[本文尚未全部完成。 待补充。 5.8 无监督学习从不需要人为注释的样本中抽取信息。 通常与密度估计有关。 学习从分布中采样，学习从分布中去噪，寻找数据分布的流形 或是 将数据中相关的样本聚类。 一个经典的无监督学习任务：找到数据的“最佳”表示。 较简单表示主要有三种：低维表示、稀疏表示和独立表示。 表示的概念是深度学习的核心主题之一，也是本书的核心主题之一。 5.8.1 主成分分析通过线性变换W将数据从x投影到z时，得到的数据表示的协方差矩阵为对角的。即：z中的元素是彼此无关的。 5.8.2 k-均值聚类k均值聚类的算法提供了k维的one-hot编码向量h以表示输入x。当x属于聚类i时，有$h_i=1$，h的其他项为零。 one-hot编码是稀疏表示的极端示例，丢失了很多分布式表示的优点。 k-均值聚类初始化k个不同的中心点$\mu^{(1)},\cdots ,\mu^{(k)}$，然后迭代交换两个不同的步骤直到收敛。 步骤一，每个训练样本分配到最近的中心点$\mu^{(i)}$所代表的聚类$i\ $。步骤二，每个中心点更新为聚类$i\ $中所有训练样本$x^{(i)}$的均值。 聚类问题的本身是病态的。没有单一的标准去度量聚类的数据在真实世界中效果如何。 因此，我们可能更偏好于分布式表示。分布式表示可以对每个车辆赋予两个属性——一个表示它的颜色，一个表示它是汽车还是卡车。 5.9 随机梯度下降随机梯度下降：stochastic gradient descent,SGD。 机器学习中的代价函数通常可以分解为每个样本的代价函数的总和。 训练数据的负条件对数似然 $\;$可以写为： $$J(\theta) = E_{x,\; y \sim \hat P_{data}}L(x,y,\theta ) = \frac 1m \sum_{i=1}^m L(x^{(i)},y^{(i)},\theta ) $$ 其中，L是每个样本的损失函数。 随机梯度下降的核心是，梯度是期望。期望可使用小规模的样本近似估计。 5.10 构建机器学习算法组合模型、代价和优化算法 来构建机器学习算法的配方。适用于监督学习以及非监督学习。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习系列：（六）前馈神经网络]]></title>
    <url>%2F2017%2F10%2F08%2FDL_chap_6%2F</url>
    <content type="text"><![CDATA[本文是《深度学习》第六章的学习笔记. 本章是对前馈网络的整体内容进行详细地论述。 6.1 实例：学习XOR采用一个简单的前馈神经网络，一个隐含层，隐含层包含两个单元。 整个网络为： $$f(x;W,c,w,b) = w^T\text{max}(0,W^Tx+c)+b$$ 隐含层激活函数采用的是ReLU。 给出一个解：$$W= \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \\ \end{bmatrix}$$$$c= \begin{bmatrix} 0 \\ -1 \\ \end{bmatrix}$$$$w= \begin{bmatrix} 1 \\ -2 \\ \end{bmatrix}$$以及：$$ b = 0 $$ 6.2 基于梯度的学习对于前馈神经网络，将所有权重初始化为小的值是很重要的。偏置可以初始化为0或者小的正值(如0.1)。 第8章介绍迭代的基于梯度的优化算法，8.4节为参数初始化，4.3节介绍了一些特别的算法，是对梯度下降思想的改进和提纯。随机梯度下降将算法的改进在5.9节。 6.2.1 代价函数大多数情况下，参数模型定义了一个分布$p(y|x;\theta)$，并且简单地使用最大似然原理。使用训练数据和模型预测间的交叉熵作为代价函数。 完整的代价函数 = 基本代价函数 + 正则项。 最流行的正则化策略：权重衰减（weight decay）。 第7章介绍更高级的正则化策略。 6.2.1.1 使用最大似然学习条件分布使用最大似然训练意味着代价函数就是负的对数似然。 负的对数似然 = 训练数据和模型分布间的交叉熵 。 代价函数为： $$J(\theta) = E_{x,\; y \sim \hat P_{data}} logP_{model}(y|x) $$ 代价函数的具体形式取决于模型$logP_{model}$的具体形式。展开后的代价函数，可以舍去其中不依赖于模型的参数。 如果有：$$P_{model}(y|x) = N(y;f(x;\theta),I) $$ 就可以得到均方误差代价： $$J(\theta) = \frac{1}{2} E_{x,\; y \sim \hat P_{data}} || y-f(x;\theta )||^2 +\text{const} $$ 代价函数的梯度必须足够大和具有足够的预测性，来为学习算法提供一个好的指引。 饱和（变得非常平）的函数破坏了这一目标，梯度非常小。该情况很常见是因为隐藏单元或输出单元的激活函数会饱和。 6.2.1.2 学习条件统计量预测器$f(x;\theta)$，预测y的均值。 代价泛函(可以表示一大类函数中的任何一个函数，仅仅被一些特征所限制，而不是具有特殊的参数形式)。 泛函是指函数到实数的映射。 对函数求解问题需要用到变分法(19.4.2节)。 变分法导出的第一个结果是解优化问题：$$f^* =\underset{f}{\mathrm{argmin}} E_{x,\; y \sim P_{data}}|| y-f(x)||^2$$ 得到：$$f^*(x) = E_{ y \sim P_{data}(y|x)}[y]$$ 最小化均方误差代价函数将得到一个函数，可以用来对每个x的值预测出y的均值。 第二个使用变分法得到的结果是： $$f^* = \underset{f}{\mathrm{argmin}} E_{x,\; y \sim P_{data}}|| y-f(x)||_1$$ 将得到一个函数可以对每个x预测y取值的中位数，只要这个函数在我们要优化的函数族里。这个函数通常被称为平均绝对误差(mean absolute error)。最小化平均绝对误差代价函数。 交叉熵代价函数 比均方误差或者平均绝对误差更受欢迎的原因也在此，饱和的输出单元当结合后两个代价函数时会产生非常小的梯度。 6.2.2 输出单元代价函数的选择：大多数情况下，简单使用数据分布和模型分布间的交叉熵。 本节中，假设前馈网络提供了一组定义为$h=f(x;\theta )$的隐藏特征。输出层的作用则是随后对这些特征进行额外的变换完成整个网络必须完成的任务。 6.2.2.1 用于Bernoulli输出分布的sigmoid单元两个类的分类问题，即预测二值型变量y。 最大似然定义$y\ $在$x\ $条件下的Bernoulli分布。 6.2.2.2 用于Multinoulli输出分布的softmax单元任何时候，当我们想要表示一个具有n个可能取值的离散型随机变量的分布时，都可以使用softmax函数。 softmax函数最常用作分类器的输出，来表示$n\ $个不同类上的概率分布。 首先，线性层预测了未归一化的对数概率：$$ z = W^Th+b$$其中，$z_i = log \hat P (y=i|x)$，softmax函数然后对$z\ $指数化和归一化来获得需要的$\hat y$。最终，softmax函数的形式为：$$ \text{softmax}(z)_i = \frac{\text{exp}(z_i)}{\sum_j \text{exp}(z_j)}$$ 当使用最大化对数似然训练softmax来输出目标值$y\ $时，这时，我们想要最大化$logP(y=i;z)=\log \text{softmax}(z)_i$。将softmax定义为指数的形式是因为对数似然中的log可以抵消softmax中的exp： $$\log \text{softmax(z)}_i = z_i -\log \sum_j \text{exp}(z_j)$$ 关于softmax的解释：这个函数更接近argmax函数而不是max函数。“soft”术语来源于softmax函数是连续可微的。“argmax”函数的结果表示为一个one-hot向量（只有一个元素为1，其余元素都为0的向量），不是连续可微的。softmax函数因此提供了argmax的“软化”版本，max函数相应的软化版本是$\text{softmax}(z)^Tz$。可能最好是把softmax函数称为“softargmax”，但当前名字已经是一个根深蒂固的习惯了。 6.2.2.4 其他的输出类型6.3 隐藏单元整流线性单元是隐藏单元极好的默认选择。 大多数隐藏单元的区别仅仅在于激活函数$g(z)$的形式。 隐藏单元少数点不可微的解释。 可微的定义是：只有函数在$z\ $处的左导数与右导数都有定义并且相等时，函数在$z\ $处才是可微的。 $g(z) = \text{max}(0,z)$，在$z=0$处的左导数为0，右导数为1。软件中实现通常是返回左导数或者右导数的其中一个，而不是报告导数未定义或者产生一个错误。 6.3.1 整流线性单元及其扩展整流线性单元的激活函数：$g(z) = \text{max}(0,z)$ 整流线性单元通常作用于仿射变换之上： $$h = g(W^Tx+b)$$ 6.3.2 logistic sigmoid与双曲正切函数双曲正切函数通常要比logistic sigmoid函数表现更好。 6.3.3 其他隐藏单元其中一种是完全没有隐藏单元$g(z)$。也可以说是用单位函数作为激活函数。 softmax单元是一种经常用作输出的单元，但有时候也可以用作隐藏单元。softmax单元很自然地表示具有k个可能值的离散型随机变量的概率分布，所以它们可以作为一种开关。将在10.12节介绍。 其他的一些隐藏单元包括： 径向基函数(radial basis function, RBF) softplus函数 硬双曲正切函数(hard tanh) 6.4 架构设计架构（architecture）一词指网络的整体结构：它应该具有多少单元，以及这些单元应该如何连接。 链式结构：每一层都是前一层的函数。主要的考虑因素是网络的深度和每层的宽度。 6.4.1 万能近似性质和深度万能近似定理(universal approximation theorem)：一个前馈神经网络如果具有线性输出层和至少一层具有任何一种“挤压”性质的激活函数（例如sigmoid函数）的隐含层，只要给予网络足够数量的隐藏单元，它可以以任意的精度近似任何从一个有限维空间到另一个有限维空间的Borel可测函数。 单层的前馈网络虽然足以表示任何函数，但是网络层可能大得不可实现。所以需要深度网络。 Montufar et al(2014):一些用深度整流网络表示的函数可能需要浅层网络（一个隐含层）指数级的隐藏单元才能表示。 根据经验，更深的模型确实在广泛的任务中泛化得更好。 6.4.2 其他架构上的考虑上述考虑的是简单的链式结构。在实践中，神经网络具有多样性。 用于计算机视觉的卷积神经网络的特殊架构在 第9章 中介绍。前馈网络也可以推广到序列处理的循环神经网络，但有它们自己的架构考虑，将在第10章中介绍。 架构设计考虑的另一个关键点是如何将层与层之间连接起来。 6.5 反向传播和其他的微分算法6.5.1 计算图图中每个节点表示一个变量。 6.5.2 微积分中的链式法则从标量扩展到向量的链式法则。 假设$x\in \mathbb R^m,\ y\in \mathbb R^n$，$g\ $是从$\mathbb R^m$到$\mathbb R^n$的映射，$f\ $是从$\mathbb R^n$到$\mathbb R\ $的映射。如果$y=g(x)$ 并且$z =f(y)$。那么：$$\frac{\partial z}{\partial x_i} = \sum_j \frac{\partial z}{\partial y_j} \frac{\partial y_j}{\partial x_i}$$ 使用向量记法，可以等价地写成：$$\triangledown_xz = (\frac {\partial y}{\partial x})^T \triangledown_yz$$这里的$\frac {\partial y}{\partial x}$是$g\ $的$n\times m $的Jacobian矩阵。 还可以从向量扩展到张量。 6.5.3 递归地使用链式法则来实现反向传播6.5.4 全连接MLP中的反向传播计算算法6.2反向传播时，偏导数的计算。 算法6.3是前向传播和代价函数的计算。 6.5.5 符号到符号的导数符号表示 反向传播的方法。 1 符号到数值的微分：计算图和一组用于图的输入的数值 2 符号到符号的方法：采用计算图和添加额外的节点到计算图中，这些额外的节点提供了我们所需导数的符号描述。 6.5.6 一般化的反向传播6.5.7 实例：用于MLP训练的反向传播训练多层感知机 交叉熵代价函数 6.5.8 复杂化操作返回多个张量。反向传播的内存消耗、现实实现。 6.5.9 深度学习界外的微分自动微分领域关系如何以算法方式计算微分。 这里描述的反向传播算法只是自动微分算法的一种方法。 反向模式累加和前向模式累加。 Theano和TensorFlow的实现使用基于匹配已知简化模式的试探法，以便重复地尝试去简化图。 在机器学习以外的社区，更常见的 是使用传统的编程语言来直接实现微分软件。例如用Python或者C来编程 6.5.10 高阶微分一些软件框架支持高阶导数。在深度学习软件框架中，这至少包括Theano和TensorFlow。 在深度学习的相关领域，很少会计算标量函数的单个二阶导数。相反，我们通常对Hessian矩阵的性质比较感兴趣。如果有函数$f:\mathbb{R}^n \to R$，那么Hessian矩阵的大小为$n\times n$。在典型的深度学习应用中，n将是模型的参数数量，可能很容易达到数十亿。因此，完整的Hessian矩阵甚至不能表示。 典型的深度学习方法是使用Krylov方法，而不是显式地计算Hessian矩阵。 Hessian矩阵上使用Krylov方法，只需要计算Hessian矩阵$H$和一个任意向量$v$间的乘积即可。 6.6 历史小记线性 -&gt; 非线性 反向传播 现代前馈网络的核心思想 交叉熵损失函数 分段线性隐藏单元（整流线性单元ReLU）]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准确率、召回率与F1值]]></title>
    <url>%2F2017%2F10%2F08%2FDL_Precision_and_Recall%2F</url>
    <content type="text"><![CDATA[“什么是准确率和召回率？”“什么是查准率和查全率？” 机器学习常见面试题之一，本文将对上述问题进行解答。 问题下面有关分类算法的准确率，召回率，F1 值的描述，错误的是？A.准确率是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率B.召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率C.正确率、召回率和 F 值取值都在0和1之间，数值越接近0，查准率或查全率就越高D.为了解决准确率和召回率冲突问题，引入了F1分数 正确答案将在本文最后揭晓。 TP——将正类预测为正类数 FN——将正类预测为负类数 FP——将负类预测为正类数 TN——将负类预测为负类数 准确率（Precision）P = TP/(TP+FP)反映了被分类器判定的正例中真正的正例样本的比重。 准确率是针对我们预测结果而言的，它表示的是预测为正的样本中有多少是真正的正样本。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)。 召回率（Recall）：R = TP/（TP+FN）= 1-[FN/（TP+FN）]反映了被正确判定的正例占总的正例的比重。 而召回率是针对我们原来的样本而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。 所有正例中被分对的比例，衡量了分类器对正例的识别能力。 准确率和召回率，两者取值在0和1之间，数值越接近1，查准率或查全率就越高。 F1值F1 = 2（Recall Precision）/（Recall + Precision） 精准率和召回率和F1取值都在0和1之间，精准率和召回率高，F1值也会高，不存在数值越接近0越高的说法，应该是数值越接近1越高。 总结一句话概括：精确率Precision是预测的正例里有多少是预测正确的，召回率Recall是真正的正例里有多少预测正确的。 精确是预测，召回是原本。 所以开始的问题的正确答案为“C”，三者都是越接近于1越好。 参考资料 西瓜书《机器学习》第二章 https://www.zhihu.com/question/19645541/answer/12502751 https://www.nowcoder.com/test/question/done?tid=11555865&amp;qid=14638#summary]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>准确率</tag>
        <tag>召回率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax(Markdown中的公式)的基本使用语法]]></title>
    <url>%2F2017%2F10%2F08%2Fmathjax_basic%2F</url>
    <content type="text"><![CDATA[本文主要介绍MathJax公式的基本语法。 插入公式如果是在文本中插入公式，则用$...$。 如果公式自成段落，则使用$$...$$。 字体 使用\mathbb或\Bbb来显示黑板粗体字，$\mathbb{NQRZ}$ 使用\mathbf来显示粗体字，$\mathbf {ABCDabcd}$ 使用\mathtt来显示打印式字体，$\mathtt{ABCDabcd}$ 使用\mathrm来显示罗马字体，$\mathrm{ABCDabcd}$ 使用\mathcal来显示手写字体，$\mathcal{ABCDabcd}$ 使用\mathscr来显示剧本字体，$\mathscr{ABCDabcd}$ 使用\mathfrak来显示Fraktur字母(一种旧的德国字体)，$\mathfrak{ABCDabcd}$ 多行公式如果要写出多行公式，就使用 \begin{equation}\begin{split} end{split}\end{equation} \\ 符号表示换行，再使用&amp;符号表示要对齐的位置，例子如下 \begin{equation}\begin{split} H(Y|X)&amp;=\sum_{x\in X} p(x)H(Y|X)\\ &amp;=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\ &amp;=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x) \end{split}\end{equation} 当然，再加上$$...$$之后，显示如下：$$\begin{equation}\begin{split}H(Y|X)&amp;=\sum_{x\in X} p(x)H(Y|X)\\&amp;=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\&amp;=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x)\end{split}\end{equation}$$ 分组通过大括号{}将操作数与符号分割开，消除二义性。 例如，若使用x^10，其效果为$x^10$，这里就要用到大括号，x^{10}，最终效果为$x^{10}$。 空间MathJax通常用自己的一套复杂策略来决定公式的空间距离。直接在两个元素之间加入空格是毫无用处的。 因此为了增加空间距离，使用\,可以增加稍许空间；使用\;可以增加更多的空间；\quad和\qquad分别对应更大的空间。 数学符号上标与下标上标或下标只需在后面加上^或_。另外需要注意的是，如果上下标不止一个字符，就需要用大括号括起来，表示是一个整体{...}。 分式有两种方式做到这个效果。 使用\frac ab。如\frac {1+a}{4+b}，效果为$\frac{1+a}{4+b}$; 使用a \over b。如{1+a} \over {4+b}，效果为${1+a}\over {4+b}$。 一般推荐使用第二种。个人倾向于使用第一种。 根式平方根： \sqrt{x^3}，效果为 $\sqrt{x^3} $。 其余： \sqrt[4]{\frac xy}，效果为 $\sqrt[4]{\frac xy}$。 关系比较符号&lt; \lt &gt; \gt ≤ \le ≥ \ge ≠ \neq $$\begin{array}{c|lcr}\text{符号} &amp; \text{\表示} \\\hline&lt; &amp; lt \\> &amp; gt \\≤ &amp; le \\≥ &amp; ge \\≠ &amp; neq \\\end{array}$$ argmax\underset{f}{\mathrm{argmin}} 效果如下：$$\underset{f}{\mathrm{argmin}}$$ 不显示斜体对于常量部分，有时候我们不想让他显示成斜体，而是正常的竖直显示，可加上\text{...}，就可以正常显示。 矩阵使用$$\begin{matrix}…\end{matrix}$$，每一行末用\\结束表示换行，用&amp;分隔矩阵元素。 $$ \begin{matrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \\ \end{matrix} $$ 效果：$$\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}$$ 如果要加括号，可以使用上面的括号符号。除此之外，还可以直接将matrix替换为pmatrix(小括号)，或者bmatrix(中括号)，或者Bmatrix(大括号)，或者vmatrix(竖线)，或者Vmatrix(是双竖线) 如果你想省略一些项，可以使用\cdots⋯，\ddots⋱，\vdots⋮。如： $$ \begin{pmatrix} 1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n\\ 1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; a_n &amp; a_n^2 &amp; \cdots &amp; a_n^n \\ \end{pmatrix} $$ 效果：$$ \begin{pmatrix} 1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n\\ 1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; a_n &amp; a_n^2 &amp; \cdots &amp; a_n^n \\ \end{pmatrix}$$ 代码块不同语言的代码块，可以用不同的标识符。如python语言，则代码块表示为 1//下一行写具体代码 就是用三个反引号（英文状态下、键盘左上角、ESC下面的那个键）包围的部分就是代码块，上面的三个点号之后，可以标识一下具体的语言，如c,c++,python,java,javascript,yml,html等等。 测试： JavaScript代码块效果如下： 123if (condition)&#123; return true&#125; Python代码块效果如下： 123def func(A): '''intresting document.''' return len(A)]]></content>
      <categories>
        <category>博客搭建系列</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理的常用命令及用法]]></title>
    <url>%2F2017%2F10%2F05%2Fbatch_basic_usage%2F</url>
    <content type="text"><![CDATA[什么是批处理？在windows下，以cmd或者bat结尾的文件就是批处理文件；linux下，也有以sh结尾的shell脚本文件。 本文主要介绍了批处理的一些常用命令。 前言在这里，先解释什么是DOS？ DOS，即Disk Operation System，磁盘操作系统。 命令行就是在Windows操作系统中打开DOS窗口，以字符串的形式执行Windows管理程序。 那么，我们如何进入命令行窗口？ 开始–&gt;运行–&gt;键入”cmd”，回车即可。 阅读本文需要一定的dos基础概念，例如：盘符、文件、目录(文件夹)、子目录、根目录、当前目录 每个命令的完整说明请加 /? 参数参考微软的帮助文档可以看到。 注：如果对某一命令还不是很熟悉，可以在命令行窗口下输入：命令名/?的方式来获得帮助。 例如：对dir命令的应用不熟悉，可以在命令行窗口下输入： dir /? 批处理定义：顾名思义，批处理文件是将一系列命令按一定的顺序集合为一个可执行的文本文件，其扩展名为BAT或者CMD。这些命令统称批处理命令。 小知识：可以在键盘上按下Ctrl+C组合键来强行终止一个批处理的执行过程。 1 echo 和 @回显控制命令1234567@ #关闭单行回显echo off #从下一行开始关闭回显@echo off #从本行开始关闭回显。一般批处理第一行都是这个echo on #从下一行开始打开回显echo #显示当前是 echo off 状态还是 echo on 状态echo. #输出一个"回车换行"，一般就是指空白行echo hello world #输出hello world “关闭回显”是指运行批处理文件时，不显示文件里的每条命令，只显示运行结果。批处理开始和结束时，系统都会自动打开回显 2 errorlevel程序返回码1echo %errorlevel% 每个命令运行结束，可以用这个命令行格式查看返回码用于判断刚才的命令是否执行成功默认值为0， 一般命令执行出错会设 errorlevel 为1 3 dir显示目录中的文件和子目录列表1234567dir #显示当前目录中的文件和子目录dir /a #显示当前目录中的文件和子目录，包括隐藏文件和系统文件dir c: /a:d #显示 C 盘当前目录中的目录dir c:\ /a:-d #显示 C 盘根目录中的文件dir d:\mp3 /b/p #逐屏显示 d:\mp3 目录里的文件，只显示文件名，不显示时间和大小dir *.exe /s #显示当前目录和子目录里所有的.exe文件。 其中 是通配符，代表所有的文件名，还有一个通配符 ? 代表一个任意字母或汉字。如 `c.*代表以 c 开头的所有文件。?.exe` 代表所有文件名是一个字母的.exe文件。 如果指定的目录或文件不存在，将返回 errorlevel 为1;每个文件夹的 dir 输出都会有2个子目录.和..。. 代表当前目录， .. 代表当前目录的上级目录。 12dir . #显示当前目录中的文件和子目录dir .. #显示当前目录的上级目录中的文件和子目录 其它参数可参考dir /? 4 cd更改当前目录123456cd mp3 #进入当前目录中的mp3 目录cd .. #进入当前目录中的上级目录cd\ #进入根目录cd #显示当前目录cd /d d:\mp3 #可以同时更改盘符和目录cd &quot;Documents and Settings&quot;\All users 文件名带空格，路径前需要加上引号！！如果更改到的目录不存在，则出错返回 errorlevel=1 cd /d d: 更改盘符需要加上/d参数。 5 md创建目录12md abc #在当前目录里建立子目录 abcmd d:\a\b\c #如果 d:\a 不存在，将会自动创建 6 rd删除目录12rd abc #删除当前目录里的 abc 子目录，要求为空目录rd /s/q d:\temp #删除 d:\temp 文件夹及其子文件夹和文件，不需要按 Y 确认 7 del删除文件1234del d:\test.txt #删除指定文件，不能是隐藏、系统、只读文件del *.* #删除当前目录里的所有文件，不包括隐藏、系统、只读文件，要求按 Y 确认del /q/a/f d:\temp\*.* #删除 d:\temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录del /q/a/f/s d:\temp\*.* #删除 d:\temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录 8 ren文件重命名123ren 1.txt 2.bak #把 1.txt 更名为 2.bakren *.txt *.ini #把当前目录里所有.txt文件改成.ini文件ren d:\temp tmp #支持对文件夹的重命名 9 cls清屏10 type显示文件内容12type c:\boot.ini #显示指定文件的内容，程序文件一般会显示乱码type *.txt #显示当前目录里所有.txt文件的内容 11 copy拷贝文件123456copy c:\test.txt d:\ #复制 c:\test.txt 文件到 d:\copy c:\test.txt d:\test.bak #复制 c:\test.txt 文件到 d:\ ，并重命名为 test.bakcopy c:\*.* #复制 c:\ 所有文件到当前目录，不包括隐藏文件和系统文件不指定目标路径，则默认目标路径为当前目录copy con test.txt #从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件con代表屏幕，prn代表打印机，nul代表空设备copy 1.txt + 2.txt 3.txt #合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件如果不指定 3.txt ，则保存到 1.txtcopy test.txt + #复制文件到自己，实际上是修改了文件日期 12 title设置cmd窗口的标题1title 新标题 #可以看到cmd窗口的标题栏变了 13 ver显示系统版本14 label 和 vol设置卷标123vol #显示卷标label #显示卷标，同时提示输入新卷标label c:system #设置C盘的卷标为 system 15 pause暂停命令运行该命令时，将显示下面的消息：请按任意键继续 . . .一般用于看清楚屏幕上显示的内容 16 rem 和 ::注释命令注释行，不执行操作 17 date 和 time日期和时间1234date #显示当前日期，并提示输入新日期，按"回车"略过输入date /t #只显示当前日期，不提示输入新日期time #显示当前时间，并提示输入新时间，按"回车"略过输入time /t #只显示当前时间，不提示输入新时间 18 goto 和 :跳转命令12:label #行首为:表示该行是标签行，标签行不执行操作goto label #跳转到指定的标签那一行 19 find (外部命令)查找命令123find "abc" c:\test.txt在 c:\test.txt 文件里查找含 abc 字符串的行如果找不到，将设 errorlevel 返回码为1find /i "abc" c:\test.txt查找含 abc 的行，忽略大小写find /c "abc" c:\test.txt显示含 abc 的行的行数 20 more (外部命令)逐屏显示1more c:\test.txt #逐屏显示 c:\test.txt 的文件内容 21 tree显示目录结构1tree d:\ #显示D盘的文件目录结构 22 &amp;顺序执行多条命令，而不管命令是否执行成功1c: &amp; cd\ &amp; dir /w #相当于把下面3行命令写到1行去了c:cd\dir /w 23 &amp;&amp;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令12f: &amp;&amp; cd\ &amp;&amp; dir &gt;c:\test.txt #注意如果f盘不存在，那么后面2条命令将不会执行find "ok" c:\test.txt &amp;&amp; echo 成功 #如果找到了"ok"字样，就显示"成功"，找不到就不显示 24 ||顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令1find "ok" c:\test.txt || echo 不成功 #如果找不到"ok"字样，就显示"不成功"，找到了就不显示 25 |管道命令前一个命令的执行结果输出到后一个命令 1dir *.* /s/a | find /c &quot;.exe&quot; 管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数 1type c:\test.txt|more 这个和 more c:\test.txt 的效果是一样的 26 &gt; 和 &gt;&gt;输出重定向命令1234567891011&gt; 清除文件中原有的内容后再写入&gt;&gt; 追加内容到文件末尾，而不会清除原有的内容主要将本来显示在屏幕上的内容输出到指定文件中指定文件如果不存在，则自动生成该文件echo hello world&gt;c:\test.txt生成c:\test.txt文件，内容为hello world这个格式在批处理文件里用得很多，可以成 .reg .bat .vbs 等临时文件type c:\test.txt &gt;prn屏幕上不显示文件内容，转向输出到打印机echo hello world&gt;con在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的copy c:\test.txt f: &gt;nul拷贝文件，并且不显示&quot;文件复制成功&quot;的提示信息，但如果f盘不存在，还是会显示出错信息copy c:\test.txt f: &gt;nul 2&gt;nul不显示&quot;文件复制成功&quot;的提示信息，并且f盘不存在的话，也不显示错误提示信息echo ^^W ^&gt; ^W&gt;c:\test.txt生成的文件内容为 ^W &gt; W^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号 27 &lt;从文件中获得输入信息，而不是从屏幕上一般用于 date time label 等需要等待输入的命令1@echo offecho 2005-05-01&gt;temp.txtdate &lt;temp.txtdel temp.txt这样就可以不等待输入直接修改当前日期 28 命令行传递给批处理参数%0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*命令行传递给批处理的参数%0 批处理文件本身%1 第一个参数%9 第九个参数%*从第一个参数开始的所有参数在C盘根目录新建test.bat，内容如下： 12345@echo offecho %0echo %1echo %2echo %* 运行cmd，输入 c:\test.bat &quot;/a&quot; /b /c /d可以看出每个参数的含意 修改test.bat内容如下 12345678910111213@echo offecho %1echo %~1echo %0echo %~f0echo %~d0echo %~p0echo %~n0echo %~x0echo %~s0echo %~a0echo %~t0echo %~z0 再运行cmd，输入 c:\test.bat “/a” /b /c /d可以参照 call/? 或 for/? 看出每个参数的含意。注意这里可以对文件进行日期比较和大小比较 1echo load "%%1" "%%2"&gt;c:\test.txt 生成的文件内容为 load “%1” “%2”批处理文件里，用这个格式把命令行参数输出到文件 31 set设置变量引用变量可在变量名前后加 % ，即 %变量名% 1234567891011121314151617181920set #显示目前所有可用的变量，包括系统变量和自定义的变量echo %SystemDrive% #显示系统盘盘符。系统变量可以直接引用set p #显示所有以p开头的变量，要是一个也没有就设errorlevel=1set p=aa1bb1aa2bb2 #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2echo %p% #显示变量p代表的字符串，即aa1bb1aa2bb2echo %p:~6% #显示变量p中第6个字符以后的所有字符，即aa2bb2echo %p:~6,3% #显示第6个字符以后的3个字符，即aa2echo %p:~0,3% #显示前3个字符，即aa1echo %p:~-2% #显示最后面的2个字符，即b2echo %p:~0,-2% #显示除了最后2个字符以外的其它字符，即aa1bb1aa2becho %p:aa=c% #用c替换变量p中所有的aa，即显示c1bb1c2bb2echo %p:aa=% #将变量p中的所有aa字符串置换为空，即显示1bb12bb2echo %p:*bb=c% #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2set p=%p:*bb=c% #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2set /a p=39 #设置p为数值型变量，值为39set /a p=39/10 #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3set /a p=p/10 #用 /a 参数时，在 = 后面的变量可以不加%直接引用set /a p="1&amp;0" #"与"运算，要加引号。其它支持的运算符参见set/?set p= #取消p变量set /p p=请输入 #屏幕上显示"请输入"，并会将输入的字符串赋值给变量p注意这条可以用来取代 choice 命令 注意变量在 if 和 for 的复合语句里是一次性全部替换的，如123456@echo offset p=aaaif %p%==aaa ( echo %p% set p=bbb echo %p% ) 结果将显示aaaaaa因为在读取 if 语句时已经将所有 %p% 替换为aaa这里的”替换”，在 /? 帮助里就是指”扩充”、”环境 变量扩充”可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!1234567@echo offSETLOCAL ENABLEDELAYEDEXPANSIONset p=aaaif %p%==aaa ( echo %p% set p=bbb echo !p! )ENDLOCAL 结果将显示aaabbb还有几个动态变量，运行 set 看不到1234567%CD% #代表当前目录的字符串%DATE% #当前日期%TIME% #当前时间%RANDOM% #随机整数，介于0~32767%ERRORLEVEL% #当前ERRORLEVEL 值%CMDEXTVERSION% #当前命令处理器扩展名版本号%CMDCMDLINE% #调用命令处理器的原始命令行可以用echo命令查看每个变量值，如 echo %time%注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到 32 start调用外部程序批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令12start explorer d:\调用图形界面打开D盘@echo off cd /d %~dp0regedit /s 劲舞团.regstart patcher.exe 不加 start 命令的话，”劲舞团”运行时，后面会有个黑乎乎的cmd窗口 33 call调用另外一个批处理批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行有时有的应用程序用start调用出错的，也可以call调用 34 choice (外部命令)选择命令让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……win98里 是choice.com win2000pro里没有，可以从win98里拷过来win2003里是choice.exechoice /N /C y /T 5 /D y&gt;nul延时5秒 下面是个 choice 语句的例子123456@echo offrem 以下在win2000pro运行通过，从win98里拷的chioce.com文件choice /c:abc aaa,bbb,cccif errorlevel 3 goto cccif %errorlevel%==2 goto bbbif errorlevel==1 goto aaa rem 必须先判断数值高的返回码rem 可以看到 errorlevel 值的判断有3种写法，有时某种写法不好用，可以用另外的写法 rem 直接运行chioce相当于运行 12345678910choice /c:yn:aaaecho aaagoto end:bbbecho bbbgoto end:cccecho cccgoto end:end 35 assoc 和 ftype文件关联assoc 设置’文件扩展名’关联，关联到’文件类型’ftype 设置’文件类型’关联，关联到’执行程序和参数’ 当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开而是先判断.txt属于 txtfile ‘文件类型’再调用 txtfile 关联的命令行 txtfile=%SystemRoot%\system32\NOTEPAD.EXE %1 可以在”文件夹选项”→”文件类型”里修改这2种关联 1234567assoc #显示所有&apos;文件扩展名&apos;关联assoc .txt #显示.txt代表的&apos;文件类型&apos;，结果显示 .txt=txtfileassoc .doc #显示.doc代表的&apos;文件类型&apos;，结果显示 .doc=Word.Document.8assoc .exe #显示.exe代表的&apos;文件类型&apos;，结果显示 .exe=exefileftype #显示所有&apos;文件类型&apos;关联ftype exefile #显示exefile类型关联的命令行，结果显示 exefile=&quot;%1&quot; %* assoc .txt=Word.Document.8设置.txt为word类型的文档，可以看到.txt文件的图标都变了assoc .txt=txtfile恢复.txt的正确关联 ftype exefile=&quot;%1&quot; %*恢复 exefile 的正确关联 如果该关联已经被破坏，可以运行 command.com ，再输入这条命令 36 pushd 和 popd切换当前目录1234567891011 @echo off c: &amp; cd\ &amp; md mp3 #在 C:\ 建立 mp3 文件夹 md d:\mp4 #在 D:\ 建立 mp4 文件夹 cd /d d:\mp4 #更改当前目录为 d:\mp4 pushd c:\mp3 #保存当前目录，并切换当前目录为 c:\mp3 popd #恢复当前目录为刚才保存的 d:\mp4一般用处不大，在当前目录名不确定时，会有点帮助## 37 subst (外部命令)映射磁盘。 subst z: \\server\d #这样输入z:就可以访问\\server\d了 subst z: /d #取消该映射 subst #显示目前所有的映射 38 xcopy (外部命令)文件拷贝1xcopy d:\mp3 e:\mp3 /s/e/i/y #复制 d:\mp3 文件夹、所有子文件夹和文件到 e:\ ，覆盖已有文件。加 /i 表示如果 e:\ 没有 mp3 文件夹就自动新建一个，否则会有询问 39 一些不常用的内部命令123&gt;&amp; 将一个句柄的输出写入到另一个句柄的输入中&lt;&amp; 从一个句柄读取输入并将其写入到另一个句柄输出中shift 命令行传递给批处理的参数不止9个时，用以切换参数color 设置cmd窗口的显示颜色pormpt 更改命令提示符号，默认都是 盘符:\路径\&gt; ，如 c:\&gt; 40 format (外部命令)格式化硬盘123format c: /q/u/autotest/q表示快速格式化，/autotest表示自动格式化，不需要按 Y 确认/u表示每字节用 F6 覆盖硬盘数据，使其不可用软件恢复format c: /c格式化C盘，并检测坏道 41 fdisk (外部命令)硬盘分区win2000不带该命令win98里的fdisk不支持80G以上大硬盘，winme里的支持fdisk/mbr重建硬盘分区表，一般用于清除引导区病毒、还原精灵注意使用该命令不能从硬盘启动，必须软驱或光驱启动后直接运行 42 ping (外部命令)12ping -l 65500 -t 192.168.1.200 不停的向192.168.1.200计算机发送大小为65500byte的数据包ping -n 10 127.0.0.1&gt;nulping自己10次，可用于批处理延时10秒 43 SC (外部命令)服务控制命令1234567sc create aaa displayname= bbb start= auto binpath= &quot;C:\WINDOWS\System32\alg.exe&quot;创建服务，服务名称aaa，显示名称bbb，启动类型:自动可执行文件的路径&quot;C:\WINDOWS\System32\alg.exe&quot;sc description aaa &quot;ccc&quot;更改aaa的描述为cccsc config aaa start= disabled binpath= &quot;C:\WINDOWS\System32\svchost.exe -k netsvcs&quot;更改aaa的启动类型:已禁用更改aaa的可执行文件的路径&quot;C:\WINDOWS\System32\svchost.exe -k netsvcs&quot;sc config aaa start= demand displayname= ddd更改aaa的启动类型:手动更改aaa的显示名称dddsc start aaa启动aaa服务sc stop aaa停止aaa服务sc delete aaa删除aaa服务 参考资料 http://bbs.bathome.net/thread-39-1-1.html http://www.cnblogs.com/DswCnblog/p/5436245.html]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪录片《轮回》观后记录]]></title>
    <url>%2F2017%2F09%2F25%2Fsamsara_documentary%2F</url>
    <content type="text"><![CDATA[多图预警，流量慎点。GIF较大，可能加载会比较慢。 001300 - 001640 延时摄影，日月星辰，风景变换。 001804 海啸后两幢平房中间翻斜挤压变形的汽车。 00:21:06 巴西圣保罗的教堂中，儿童们在接受洗礼。 与此对比的是，00:25:15处一个夭折的小男孩躺在棺材里。 00:34:50车灯比较有意思。车道右侧是向上前进的车，尾灯是红色的，前灯有白色的，还有蓝青色的。 追踪汽车尾灯的效果实在是太赞了。 00:39:49法国行为艺术家Olivier de Sagazan震撼人心的表演。此人以往自己脸上身上涂粘土和颜料著称，展现人类内在的兽性。 当这个诡异的类似伏地魔的表演结束之后，用一个机器人表现出震惊的样子，实在是笑死。 前面的表演的确震惊，表面斯文的人，作出如此疯狂的动作。 00:41:00 人跌倒时候的配乐是亮点，第一次看的时候忍不住笑了，这么正经的片子，居然还有这种效果，哈哈。 00:41:11 迪拜的一系列人工奇迹：号称世界上唯一的七星级酒店——阿联酋迪拜的阿拉伯塔酒店（Burj Al Arab）。（阿拉伯塔酒店因外形酷似船帆，又称迪拜帆船酒店） 第一张图的右侧是其外观，左侧为清真寺。 大型的填海工程令人叹为观止。 迪拜的一系列人工奇迹: 迪拜购物中心，全球第一大购物中心。 室内瀑布也是迪拜购物中心的标志景观，位于中庭处，24米高的瀑布至今还保持着一个世界纪录，即世界上第一高的室内喷泉。瀑布中还设置了一排排跳水运动员塑像，动作整齐划一，栩栩如生。 迪拜的一系列人工奇迹: 世界第一高楼——哈里发塔（Burj Khalifa），也可译为哈利法塔。 这座全球第一高塔位于Downtown，与迪拜音乐喷泉（The Dubai Fountain）、迪拜购物中心（The Dubai Mall）相距不远。 00:44:35两名时尚女郎走在意大利米兰的埃马努埃莱二世拱廊（Galleria Vittorio Emanuele II）中。拱廊一端的斯卡拉大剧院（La Scala）。 左边这妹子的裤子看来需要我帮她提一下哈哈哈。 ……中间省略一些，主要是繁忙的交通、生产（销毁）流水线、超市疯狂采购以及疯狂吃的人越来越胖具体内容如下： 日本东京繁忙的地铁。一些另类的奇装异服者。 厦门灿坤集团在福建漳州的小家电工厂城。工人们在流水线上如机器人般的劳作。马上跟着回收站中各种电器被压扁、绞碎、封存、筛选。同样是流水作业，一个制造，一个销毁。郑州三全食品股份有限公司的速冻食品生产基地。一个个饺子就这样高效的产出。 在高度机械化的丹麦，一台神奇的机器把一只只活鸡收入囊中。在中国长春，身着粉红色防护服的工人们在把整鸡大卸八块。在美国加州，奶牛们头朝内尾朝外肩并肩的被放在大转盘上转啊转的被挤奶。 超市里，人们在疯狂购物。餐厅里，三个胖子在饕餮着垃圾食品。 最后，讽刺地是，吃胖了的人也得像鸡、猪一样，被画线切开、动手术。 同样需要画线的还有充气娃娃。。。 00:57:30 日本生产充气娃娃的工厂。后面的就不截了。 00:58:35 泰国人妖俱乐部里，人妖们身着比基尼搔首弄姿的跳着钢管舞。 01:00:20 伏见稻荷大社，日本京都市伏见区的稻荷神社（Fushimi Inari-taisha）。竖立的鸟居（Torii）排列成一条长长的甬道，即闻名于世的千本鸟居。 稻荷神是农业与商业的神明，香客前来祭拜求取农作丰收、生意兴隆、交通安全。它是京都地区香火最盛的神社之一。（摘自百科） 01:01:31 上海黄浦江畔高楼林立。 01:03:50 菲律宾宿务市（Cebu City）的一个监狱~ 比起让犯人做什么手工活，大概每个月都教他们一个新的舞蹈，还要在家属面前表演… 男人们卖力的跳着，女人们轻柔的和着，典狱长漠然的看着。 01:06:59 这种房子的结构不错。 一边住人，一边养花草。很赞，第一次见到。 01:10:00 印尼的（卡瓦）伊真（Ijen）（活）火山上，赤膊的工人们在极具腐蚀性的硫酸雾气中把成筐的硫磺矿挑走。 01:17:40 中国国庆大阅兵。 01:18:16 少林寺塔沟武校。 小时候，看了少年包青天之类的电视剧，就好想去武校学习的啊，可惜。 01:19:31 韩国的条子。不要问我怎么知道的（看字）。 01:20:00 柏林墙是是这种大块的条状建筑组成，上面有很多涂鸦。 耶路撒冷哭墙（Western/Wailing Wall）。哭墙是由砖块石头组成。 之前两个没有区分开，所以特此说明一下。 01:33:00千手观音是最美的。 由21位聋哑人表演的千手观音舞蹈。领舞是自幼失聪的邰丽华。 首尾呼应。此处有表演，开头的时候没有。 01:25:29影片接近尾声，镜头来到沙特麦加，记录下几百万汇聚在清真寺周围的虔诚信徒，如沙，如画。 沙特麦加的禁寺（Masjid al-Haram）朝拜。镜头越来越高，那如沙砾般的白点点啊，围着克尔白（Kaaba）不停的转啊转。 (让我想起了刚做的数模中动目标检测的那个素材。。17年全国研究生数模D题) 01:30:47转眼间，镜头又回到了华美绚烂而又精密有序的坛城沙画。 然而，讶异的观众们此时看见，这个刚刚用沙子堆砌起来的世界，历经了积年累月呕心沥的创作，却在完成之后被毫不犹豫地全盘抹去。 一件拥有无上艺术价值的作品，顷刻之间，便化为乌有。 对于修行者来说，他们和它们的使命都已完成。于是那些色泽明艳的细沙将被装入瓶中，倾倒入河，顺流而去。 繁华世界，不过一掬细沙。 部分文字参考自豆瓣影评一沙一世界，无声引导沉思。]]></content>
      <categories>
        <category>观影指南</category>
      </categories>
      <tags>
        <tag>轮回</tag>
        <tag>纪录片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DeepLearnToolBox之BP算法]]></title>
    <url>%2F2017%2F09%2F23%2FDeepLearnToolBox_BP%2F</url>
    <content type="text"><![CDATA[这篇文章只要是基于BP网络代码的简单分析，基于公式推导的文章请参阅：BP神经网络部分具体的推导。 工具箱下载下载地址：https://github.com/rasmusbergpalm/DeepLearnToolbox 总体测试代码\tests\test_example_NN.m nn = nnsetup([784 100 10]); opts.numepochs = 1; // Number of full sweeps through data opts.batchsize = 100; // Take a mean gradient step over this many samples [nn, L] = nntrain(nn, train_x, train_y, opts); [er, bad] = nntest(nn, test_x, test_y); 很简单的几步就训练了一个NN，我们发现其中最重要的几个函数就是nnsetup,nntrain和nntest了。 nnsetupNNSETUP创建前向反馈神经网络。 代码解释详细代码如下： function nn = nnsetup(architecture) %NNSETUP creates a Feedforward Backpropagate Neural Network % nn = nnsetup(architecture) returns an neural network structure with n=numel(architecture) % layers, architecture being a n x 1 vector of layer sizes e.g. [784 100 10] nn.size = architecture; nn.n = numel(nn.size); nn.activation_function = &apos;tanh_opt&apos;; % Activation functions of hidden layers: &apos;sigm&apos; (sigmoid) or &apos;tanh_opt&apos; (optimal tanh). nn.learningRate = 1; % learning rate Note: typically needs to be lower when using &apos;sigm&apos; activation function and non-normalized inputs. nn.momentum = 0.5; % Momentum 权值动量因子 nn.scaling_learningRate = 1; % Scaling factor for the learning rate (each epoch) 学习率变化因子 (each epoch) nn.weightPenaltyL2 = 0; % L2 regularization nn.nonSparsityPenalty = 0; % Non sparsity penalty 非稀疏惩罚 nn.sparsityTarget = 0.05; % Sparsity target 稀疏目标值 nn.inputZeroMaskedFraction = 0; % Used for Denoising AutoEncoders 自动编码的去噪作用 nn.dropoutFraction = 0; % Dropout level (http://www.cs.toronto.edu/~hinton/absps/dropout.pdf) nn.testing = 0; % Internal variable. nntest sets this to one. 一个标志参数--在nntest.m这个函数中会用到 nn.output = &apos;softmax&apos;; % output unit &apos;sigm&apos; (=logistic), &apos;softmax&apos; and &apos;linear&apos; for i = 2 : nn.n % weights and weight momentum nn.W{i - 1} = (rand(nn.size(i), nn.size(i - 1)+1) - 0.5) * 2 * 4 * sqrt(6 / (nn.size(i) + nn.size(i - 1))); nn.vW{i - 1} = zeros(size(nn.W{i - 1})); % average activations (for use with sparsity) nn.p{i} = zeros(1, nn.size(i)); end end nnsetup初始化网络结构以及一系列参数。对照着代码，看一下具体含义。 nn = nnsetup(architecture)返回一个神经网络结构，architecture为结构参数。architecture是一个n x 1 向量，表示每一层神经元的个数。 比如architecture=[784 100 10]，表示输入层为784维输入，100个隐含层，10个输出层 为什么是输入为784：因为每一个手写体大小为28*28的，也就是784维度 隐含层为什么是100：随便设置的，可以随意修改，需要设计 输出为什么是10：手写体有0-9这10种结果，所以为10 //对每一层的网络结构进行初始化，一共三个参数W,vW，p，其中W是主要的参数//vW是更新参数时的临时参数，p是所谓的sparsity，(等看到代码了再细讲) ##使用实例 nn=nnsetup([size(feature,2) 200 200 length(azimuth)]); nntrain截取出的主要框架为： for i = 1 : numepochs for l = 1 : numbatches nn = nnff(nn, batch_x, batch_y); nn = nnbp(nn); nn = nnapplygrads(nn); L(n) = nn.L; n = n + 1; end end 第一层for循环为迭代次数。第二次为遍历所有的batch。其中，先计算前向传播（ff），在计算反向传播（bp），接着更新参数（nnapplygrads），最后计算损失函数（代价函数）L。 下面分析三个函数nnff,nnbp和nnapplygrads。 nnffnnff就是进行feedforward pass，其实非常简单，就是整个网络正向跑一次就可以了 当然其中有dropout和sparsity的计算,具体的参见论文“Improving Neural Networks with Dropout“和Autoencoders and Sparsity 提取出主要框架为： for i = 2 : n-1 （遍历隐含层） //根据激活函数计算隐层输出 //隐层的dropout计算，舍弃部分输出 //计算sparsity，nonSparsityPenalty 是对没达到sparsitytarget的参数的惩罚系数 //Add the bias term end //根据输出层的结构计算输出层的输出。 //计算误差以及损失函数 nnbp代码：\NN\nnbp.mnnbp呢是进行back propagation的过程。值得注意的还是dropout和sparsity的部分。 提取出主要框架为： ①计算输出层的输出 ②依次反向计算隐层输出 for i = (n - 1) : -1 : 2 （反向遍历隐层） d_act为隐层 激活函数的导数 d{i}为隐层输出函数的导数。 计算中用到非稀疏惩罚项，以及dropout end ③计算权值的导数nn.dW{i} dW{i}基本就是计算的gradient(梯度)了，只是后面还要加入一些东西，进行一些修改。 nnapplygrads代码文件：\NN\nnapplygrads.m for i = 1 : (nn.n - 1) //应用weightPenaltyL2，learningRate ，momentum修正dW nn.W{i} = nn.W{i} - dW; //权值W更新 end 这个内容就简单了，nn.weightPenaltyL2是weight decay的部分，也是nnsetup时可以设置的一个参数 有的话就加入weight Penalty，防止过拟合，然后再根据momentum的大小调整一下，最后改变nn.W{i}即可 nntestfunction [er, bad] = nntest(nn, x, y) labels = nnpredict(nn, x); [~, expected] = max(y,[],2); bad = find(labels ~= expected); er = numel(bad) / size(x, 1); end nntest再简单不过了，就是调用一下nnpredict，在和test的集合进行比较 nnpredict代码文件：\NN\nnpredict.m function labels = nnpredict(nn, x) nn.testing = 1; nn = nnff(nn, x, zeros(size(x,1), nn.size(end))); nn.testing = 0; [~, i] = max(nn.a{end},[],2); labels = i; end 继续非常简单，predict不过是nnff一次，得到最后的output~~ max(nn.a{end},[],2); 是返回每一行的最大值以及所在的列数，所以labels返回的就是标号啦(这个test好像是专门用来test分类问题的，我们知道nnff得到最后的值即可) 总结这篇文章只要是基于代码的简单分析，基于公式推导的文章请参阅：BP神经网络部分具体的推导。 参考资料 http://blog.sina.com.cn/s/blog_4a1853330102vupc.html]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017“华为杯”第十四届中国研究生数学建模竞赛回顾]]></title>
    <url>%2F2017%2F09%2F22%2Freview_of_MathModel%2F</url>
    <content type="text"><![CDATA[试题下载地址中国研究生数模竞赛官网：http://gmcm.seu.edu.cn/01/49/c12a329/page.htm 我们组选择了D题。 D题题目基于监控视频的前景目标提取视频监控是中国安防产业中最为重要的信息获取手段。随着“平安城市”建设的顺利开展，各地普遍安装监控摄像头，利用大范围监控视频的信息，应对安防等领域存在的问题。近年来，中国各省市县乡的摄像头数目呈现井喷式增长，大量企业、部门甚至实现了监控视频的全方位覆盖。如北京、上海、杭州监控摄像头分布密度约分别为71、158、130个/平方公里，摄像头数量分别达到115万、100万、40万，为我们提供了丰富、海量的监控视频信息。 目前，监控视频信息的自动处理与预测在信息科学、计算机视觉、机器学习、模式识别等多个领域中受到极大的关注。而如何有效、快速抽取出监控视频中的前景目标信息，是其中非常重要而基础的问题[1-6]。这一问题的难度在于，需要有效分离出移动前景目标的视频往往具有复杂、多变、动态的背景[7，8]。这一技术往往能够对一般的视频处理任务提供有效的辅助。以筛选与跟踪夜晚时罪犯这一应用为例：若能够预先提取视频前景目标，判断出哪些视频并未包含移动前景目标，并事先从公安人员的辨识范围中排除；而对于剩下包含了移动目标的视频，只需辨识排除了背景干扰的纯粹前景，对比度显著，肉眼更易辨识。因此，这一技术已被广泛应用于视频目标追踪，城市交通检测，长时场景监测，视频动作捕捉，视频压缩等应用中。 下面简单介绍一下视频的存储格式与基本操作方法。一个视频由很多帧的图片构成，当逐帧播放这些图片时，类似放电影形成连续动态的视频效果。从数学表达上来看，存储于计算机中的视频，可理解为一个3维数据，其中代表视频帧的长，宽，代表视频帧的帧数。视频也可等价理解为逐帧图片的集合，即，其中为一张长宽分别为的图片。3维矩阵的每个元素（代表各帧灰度图上每个像素的明暗程度）为0到255之间的某一个值，越接近0，像素越黑暗；越接近255，像素越明亮。通常对灰度值预先进行归一化处理（即将矩阵所有元素除以255），可将其近似认为[0,1]区间的某一实数取值，从而方便数据处理。一张彩色图片由R（红），G（绿），B（蓝）三个通道信息构成，每个通道均为同样长宽的一张灰度图。由彩色图片构成的视频即为彩色视频。本问题中，可仅考虑黑白图片构成的视频。在Matlab环境下，视频的读取、播放及相应基本操作程序见附件1。如采用其他编程环境，也可查阅相关资料获得相应操作程序。 题目的监控视频主要由固定位置监控摄像头拍摄，要解决的问题为提取视频前景目标。请研究生通过设计有效的模型与方法，自动从视频中分离前景目标。注意此类视频的特点是相对于前景目标，背景结构较稳定，变化幅度较小，可充分利用该信息实现模型与算法设计。 请你们查阅相关资料和数据，结合视频数据特点，回答下列问题： 问题1对一个不包含动态背景、摄像头稳定拍摄时间大约5秒的监控视频，构造提取前景目标（如人、车、动物等）的数学模型，并对该模型设计有效的求解方法，从而实现类似图1的应用效果。（附件2提供了一些符合此类特征的监控视频） 问题2对包含动态背景信息的监控视频（如图2所示），设计有效的前景目标提取方案。（附件2中提供了一些符合此类特征的典型监控视频） 问题3在监控视频中，当监控摄像头发生晃动或偏移时，视频也会发生短暂的抖动现象（该类视频变换在短时间内可近似视为一种线性仿射变换，如旋转、平移、尺度变化等）。对这种类型的视频，如何有效地提取前景目标？（附件2中提供了一些符合此类特征的典型监控视频，其它一些典型视频可从 http://wordpress-jodoin.dmi.usherb.ca/dataset2014/ 下载） 问题4在附件3中提供了8组视频（avi文件与mat文件内容相同）。请利用你们所构造的建模方法，从每组视频中选出包含显著前景目标的视频帧标号，并将其在建模论文正文中独立成段表示。务须注明前景目标是出现于哪一个视频（如Campus视频）的哪些帧（如241-250，421-432帧）。 问题5如何通过从不同角度同时拍摄的近似同一地点的多个监控视频中（如图3所示）有效检测和提取视频前景目标？请充分考虑并利用多个角度视频的前景之间（或背景之间）相关性信息（一些典型视频可从http://cvlab.epfl.ch/research/surv/multi-people-tracking 下载） 问题6利用所获取前景目标信息，能否自动判断监控视频中有无人群短时聚集、人群惊慌逃散、群体规律性变化（如跳舞、列队排练等）、物体爆炸、建筑物倒塌等异常事件？可考虑的特征信息包括前景目标奔跑的线性变化形态特征、前景规律性变化的周期性特征等。尝试对更多的异常事件类型，设计相应的事件检测方案。（请从网络下载包含各种事件的监控视频进行算法验证） 注：强烈建议深刻考虑问题内涵，建造合理、高效的数学模型和求解方法，鼓励进行具有开放思路与创新思维的探索性尝试。 参考文献[1] Andrews Sobral &amp; Antoine Vacavant, A comprehensive review of background subtraction algorithms evaluated with synthetic and real videos, Computer Vision and Image Understanding, Volume 122, May 2014, Pages 4-21 [2] B. Lee and M. Hedley, “Background estimation for video surveillance,” IVCNZ02, pp. 315–320, 2002. [3] C. Stauffer and W. E. L. Grimson, “Adaptive background mixture models for real-time tracking,” in Computer Vision and Pattern Recognition, 1999. IEEE Computer Society Conference on., vol. 2. IEEE, 1999. [4] E. J. Candes, X. Li, Y. Ma, and J. Wright, “Robust principal component analysis?” Journal of the ACM (JACM), vol. 58, no. 3, p. 11, 2011. [5] D. Meng and F. De la Torre, “Robust matrix factorization with unknown noise,” in IEEE International Conference on Computer Vision, 2013, pp. 1337–1344. [6] Q. Zhao, D. Meng, Z. Xu,W. Zuo, and L. Zhang, “Robust principal component analysis with complex noise,” in Proceedings of the 31st International Conference on Machine Learning (ICML-14), 2014, pp. 55–63. [7] Y. Peng, A. Ganesh, J. Wright, W. Xu, and Y. Ma, “RASL: Robust alignment by sparse and low-rank decomposition for linearly correlated images,” Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 34, no. 11, pp. 2233–2246, 2012. [8] M. Babaee, D. T. Dinh, and G. Rigoll, “A deep convolutional neural network for background subtraction,” arXiv preprint arXiv: 1702.01731, 2017. 思路流程本文只记录下我所做的工作历程。 BGSLibrary编译安装与BGSlibrary GUI的下载与使用这部分详情可参考我的博客：https://qwerty200696.github.io/2017/09/20/BGSlibrary/ ViBe算法一种像素级视频背景建模或前景检测的算法。 详细地可参考ViBe算法官网主页：ViBe官网链接 该官网包含ViBe源码以及可在Windows和Linux中运行的程序。想了解该算法的童鞋可以详细探索该网站。 这篇CSDN博客介绍的也比较全面，可作参考。 光流法LK光流法分析及其源码请参考我的这篇文章：https://qwerty200696.github.io/2017/09/21/optical_flow/ 视频抗抖动算法参考链接：SIMPLE VIDEO STABILIZATION USING OPENCV 采用的方法是基于optical flow 光流法。 算法流程： &emsp;1 使用所有帧中的光流信息来查找从前一帧到当前帧的转换 &emsp;2 累积变换以获得每个帧的x，y，a 的轨迹 &emsp;3 使用滑动平均窗口对轨迹平滑处理 &emsp;4 创建一个新的变换，使得$F_{new}$ = $F_{old}$ + ( $T_{smoothed}$ - $T_{before}$ ) &emsp;5 将新的转换应用到视频中，得到去抖后的视频 其中 dx、dy 为x 和y 方向的流向，da 为抖动中旋转角度的变化量; $F_{new}$、$F_{old}$分别为新的变换与原先的变换，$T_{smoothed}$、$T_{before}$分别为平滑前后的轨迹。 Camera Jitter 相机抖动 数据集下载：http://wordpress-jodoin.dmi.usherb.ca/dataset2014/ opencv视频保存方法视频保存方法请参考这篇博文：https://qwerty200696.github.io/2017/09/21/opencv_SaveVideo/ opencv_contrib安装opencv_contrib的安装说明可以参考这篇博文https://qwerty200696.github.io/2017/09/21/opencv_contrib/ 杂七杂八动目标检测dataset 2014 里面的视频分类详细，很好的数据集。 目标跟踪Object Tracking using OpenCV (C++/Python) 这个算是做的比较好的了，很有参考价值。 D题问题五给出的网址：http://cvlab.epfl.ch/research/surv/multi-people-tracking 视频流跟踪目标OpenTLD Real-Time Tracking 多角度多目标跟踪Deep Occlusion Reasoning for Multi-Camera Multi-Target Detection DeepOcclusion 人群异常行为检测BEHAVE Interactions Test Case Scenarios Detection of Events UCF数据集：Crowd Segmentation Data Set 这是正常行为的，没找到不正常行为的。据说有的。 UMN数据集：Detection of Unusual Crowd Activity 总结至此，花了两天时间稍微记录了一下我自己做的工作吧，算是opencv小白入门记。（之后暂时应该不会研究了，毕竟不是学这个的） 最后附上一个收录计算机视觉题材的地址：百炼成金，计算机视觉修炼之道，想要从事相关研究的童鞋不容错过。]]></content>
  </entry>
  <entry>
    <title><![CDATA[opencv_contrib安装说明与错误解决方案]]></title>
    <url>%2F2017%2F09%2F21%2Fopencv_contrib%2F</url>
    <content type="text"><![CDATA[在数模的时候，需要实现目标跟踪，因此需要安装opencv附加库，即opencv_contrib。 没有安装该附加库的时候，会提示如下错误： opencv_contrib下载opencv_contrib的项目地址为：https://github.com/opencv/opencv_contrib 先将opencv_contrib下载下来，为后续安装做准备。 此外还需要的是opencv以及cmake。 opencv_contrib安装步骤概述windows控制台依次输入如下命令： $ cd &lt;opencv_build_directory&gt; $ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules &lt;opencv_source_directory&gt; $ make -j5 之后会在&lt;opencv_build_directory&gt;目录下生成opencv_contrib库的所有模块。如果不想安装所有的模块，则使用cmake命令的BUILD_opencv_*选项。示例程序如下： $ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules -DBUILD_opencv_legacy=OFF &lt;opencv_source_directory&gt; GUI图形界面安装 打开cmake-gui； 选择源码文件夹以及build文件夹； 点击configue按钮。可以看到opencv build时的一系列参数； 浏览参数并找到OPENCV_EXTRA_MODULES_PATH，将其路径设为&lt;opencv_contrib&gt;/modules； 点击configue按钮，完成后再点击generate按钮。（第一次会询问Makefile的类型） 点击open project，使用你选择的方法来生成opencv core。(上一步是Unix makfile，则相应的make，make install) 在自己的代码/IDE中添加相应模块的连接器标志（linker flags）。比如想使用aruco模块，则需要加上&quot;-lopencv_aruco&quot;。 上述步骤为该项目英文安装指南对应的翻译。 图形界面的安装可参考这篇文章：http://blog.csdn.net/cv_jason/article/details/70037545 opencv_contrib安装错误解决方案cmake出错Failed to downloadCmd下输入 wang@wang-PC MINGW64 /d/Program Files/opencv3/build $ cmake -DOPENCV_EXTRA_MODULES_PATH=&quot;D:\opencv_contrib-master\modules&quot; &quot;D:\Program Files\opencv3\sources&quot; 时出现下载错误，如下图所示： CMake Error at D:/Program Files/opencv3/sources/cmake/OpenCVUtils.cmake:1047 (message): Failed to download . Status= Call Stack (most recent call first): D:/opencv_contrib-master/modules/dnn_modern/CMakeLists.txt:18 (ocv_download) 即：无法下载对应的模块。 遇到此错误的解决方案为：将以下三处的filename改为PACKAGE。（代码中的PACKAGE原为filename） D:\opencv\opencv_contrib\modules\dnn_modern\CMakeLists.txt 20行改为 ocv_download(PACKAGE &quot;v1.0.0a3.tar.gz&quot; D:\opencv\opencv_contrib\modules\xfeatures2d\cmake\download_boostdesc.cmake 22行改为 ocv_download(PACKAGE ${name_${id}} D:\opencv\opencv_contrib\modules\xfeatures2d\cmake\download_vgg.cmake 16行改为 ocv_download(PACKAGE ${name_${id}} 修改后安装成功，可以在输出中查看具体的安装信息： 从图中可以发现，我所需要的tracking库也已经安装成功了。 没有make指令在使用命令行界面安装时，没有最后一步的make指令。 那么只能自己安装了。或者直接用cmake GUI安装。 打开之前opencv_contrib的build文件夹，找到已经生成的opencv项目并打开。 打开VS之后，可以看到完整的OpenCV项目。然后直接编译即可（看个人情况，可自行选择Release或者Debug）。时间相当长。。。 编译成功后，在CMakeTargets中找到INSTALL，然后生成INSTALL，得到我们想要的最终文件。 半永久配置上述步骤的确很麻烦，并且非常容易出错。 有热心网友给出了自己配置好的文件，可以半永久配置。读者感兴趣的可以自己尝试下：http://www.cnblogs.com/wjy-lulu/p/6605306.html 参考文献 https://stackoverflow.com/questions/28619037/opencv-where-is-tracking-hpp http://blog.csdn.net/qsy2000/article/details/70158537 http://blog.csdn.net/cv_jason/article/details/70037545 其实这篇教程写的并不算太详细，cmake GUI可以对照着第三个博客安装。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客使用MathJax并解决Markdown渲染冲突问题]]></title>
    <url>%2F2017%2F09%2F21%2Fmarkdown_mathjax%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何在Hexo博客中使用Mathjax公式的基本配置方法，Mathjax的基本语法可参见：Mathjax基本语法。 并且解决了Hexo博客在使用过程中，Markdown语法默认渲染效果与Mathjax语法互相冲突的问题。 利用MathJax来渲染LaTeX数学公式hexo主题Next中已经集成了对mathjax的支持。在主题配置文件，blog\themes\next\_config.yml中定位到如下片段: # MathJax Support mathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 将enable中的false改为true即可。 另外，再安装一个自动部署MathJax的hexo插件 。安装方式也很简单，在你的博客文件夹下执行： npm install hexo-math --save hexo math install 然后在新建的博文中写上一个麦克斯韦方程组查看LaTeX效果： $$ \begin{eqnarray} \nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\ \nabla\cdot\vec{B} &amp;=&amp; 0 \\ \nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\ \nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right) \end{eqnarray} $$ $$\begin{eqnarray}\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\\nabla\cdot\vec{B} &amp;=&amp; 0 \\\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{eqnarray}$$ 这时如果你会发现出了一些问题，原因是hexo先用marked.js渲染，然后再交给MathJax渲染。在marked.js渲染的时候下划线_是被escape掉并且换成了&lt;em&gt;标签，即斜体字，另外LaTeX中的\\也会被转义成一个\，这样会导致MathJax渲染时不认为它是一个换行符了。 mathjax与markdown默认渲染冲突的解决方案解决方案为：修改Hexo渲染源码。 这个方法是我目前使用的，相对来说，通用性较高的一种方式。思路就是修改hexo的渲染源码: nodes_modules/lib/marked/lib/marked.js: 去掉\的额外转义 将em标签对应的符号中，去掉_,因为markdown中有*可以表示斜体，——完全可以去掉。 具体思路参考了使Marked.js与MathJax共存, 打开nodes_modules/marked/lib/marked.js:第一步: 找到下面的代码: escape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/, 改为: escape: /^\\([`*{}\[\]()# +\-.!_&gt;])/, 这样就会去掉\的转义了。第二步: 找到em的符号: em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 改为: em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 去掉_的斜体含义，这样就解决了。为什么说通用性很高，因为我们没有修改文章的内容，可以放到别的引擎下也会顺利渲染。 这个困扰我许久的问题终于这么解决了。之前一直按照标准mathjax语法写公式，但是有的时候就会无法显示公式。 按照上述修改后，markdown不再处理(公式中的)_以及\。mathjax语法畅行无阻。 参考资料： https://segmentfault.com/a/1190000007261752]]></content>
      <categories>
        <category>博客搭建系列</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LK光流法分析及其源码]]></title>
    <url>%2F2017%2F09%2F21%2Foptical_flow%2F</url>
    <content type="text"><![CDATA[光流法简介光流的概念是Gibson在1950年首先提出来的。它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。 光流法，是利用目标物体在监控场景中的空间运动，体现在视频图像序列中为不同图像颜色分布变化。导致目标物在监控场景中的空间运动场，在图像中转化为光流场，体现图像中每一个像素点的变化趋势。光流场可视为监控场景中的瞬时速度场。 研究光流场的目的就是为了从图片序列中近似得到不能直接得到的运动场。运动场，其实就是物体在三维真实世界中的运动；光流场，是运动场在二维图像平面上（人的眼睛或者摄像头）的投影。 算法原理光流法的三种计算方法：LK，HS，最常用的还是LK。 Lucas–Kanade算法这个算法是最常见，最流行的。它计算两帧在时间t到t+δt之间每个每个像素点位置的移动。由于它是基于图像信号的泰勒级数，这种方法称为差分，这就是对于空间和时间坐标使用偏导数。 图像约束方程，也是光流法的基本方程，可以写为$I(x,y,z,t)=I(x +δx,y+δy,z+δz,t+δt)$ $I(x,y,z,t)$ 为在$(x,y,z)$位置的体素。 我们假设移动足够的小，那么对图像约束方程使用泰勒公式，我们可以得到： H.O.T.指更高阶，在移动足够小的情况下可以忽略。从这个方程中我们可以得到： 或者 我们得到： Vx ,Vy ,Vz 分别是$I(x,y,z,t)$的光流向量中x，y，z的组成。 $\frac{∂I}{∂x}$, $\frac{∂I}{∂y}$, $\frac{∂I}{∂z}$和 $\frac{∂I}{∂t}$则是图像在$(x,y,z,t)$这一点向相应方向的差分。所以$$I_x V_x + I_y V_y + I_z V_z = −I_t$$写做： 这个方程有三个未知量，尚不能被解决，这也就是所谓光流算法的光圈问题。那么要找到光流向量则需要另一套解决的方案。而Lucas-Kanade算法是一个非迭代的算法：假设流(Vx,Vy,Vz)在一个大小为$m*m*m$(m&gt;1)的小窗中是一个常数，那么从像素 $1,2,…,n,n =m^3$ 中可以得到下列一组方程： $$I_{x1} V_x + I_{y1} V_y + I_{z1} V_z = -I_{t_1} $$ $$I_{x2} V_x + I_{y2} V_y + I_{z2} V_z = -I_{t_2} $$ $$ \vdots $$ $$I_{xn} V_x + I_{yn} V_y + I_{zn} V_z = -I_{t_n} $$ 三个未知数但是有多于三个的方程，这个方程组自然是个超定方程，也就是说方程组内有冗余，方程组可以表示为： 记作： $$A \vec{v} = -b $$ 为了解决这个超定问题，我们采用最小二乘法： $$A^T A \vec{v} = A^T (-b) $$ or $$ \vec{v} = (A^T A)^{-1} A^T (-b) $$ 得到： 其中的求和是从1到n。 另外，由于LK算法假设是小位移，为了解决大位移问题，需要在多层图像缩放金字塔上求解，每一层的求解结果乘以2后加到下一层： 代码示例C++代码来自于： http://download.csdn.net/download/crzy_sparrow/4183674 有两点修改的地方： ①void handleTrackedPoint(Mat &frame;,Mat &output;)声明过程中循环条件points[i]要改为points[1]； ②新建项目时加上预编译头。 如果出现这个：warning:opening fiile(../../modules/highgui/src/cap_ffmpeg_impl.hpp:545)注意要把avi格式的视频文件放在debug下，可以用格式工厂转，注意视频编码那里要换成avc 效果：可以检测到运动目标。 参考资料： http://blog.csdn.net/crzy_sparrow/article/details/7407604http://blog.csdn.net/u014568921/article/details/46638557http://www.cnblogs.com/gnuhpc/archive/2012/12/04/2802124.html]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Opencv</tag>
        <tag>光流法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opencv视频保存方法详解]]></title>
    <url>%2F2017%2F09%2F21%2Fopencv_SaveVideo%2F</url>
    <content type="text"><![CDATA[本文主要介绍Opencv视频保存的详细方法。 视频保存流程与示例视频保存三步走： 一开始（循环外） VideoWriter outputVideo; outputVideo.open(&quot;E:\\modeling\\视频\\compare3.avi&quot;, -1, 30, cvSize(cur.rows, cur.cols * 2 + 10),true); 接着（循环中） outputVideo &lt;&lt; canvas; //保存每帧图片到视频 最后释放（循环外） outputVideo.release(); //可以不要 视频保存详解第一步中： 先定义VideoWriter对象，并指定输出文件。其中，open函数的定义为： open ( const char* filename, int fourcc, double fps, CvSize frame_size, int is_color=1 ); 第一个参数filename为输出视频文件名。输出目录要存在，输出文件不存在时会自动创建。目录中注意使用转义字符。 第二个参数fourcc为编码格式。四个字符来表示压缩帧的codec。例如： CV_FOURCC(‘P’,’I’,’M’,’1’) = MPEG-1 codec CV_FOURCC(‘M’,’J’,’P’,’G’) = motion-jpeg codec CV_FOURCC(‘M’, ‘P’, ‘4’, ‘2’) = MPEG-4.2 codec CV_FOURCC(‘D’, ‘I’, ‘V’, ‘3’) = MPEG-4.3 codec CV_FOURCC(‘D’, ‘I’, ‘V’, ‘X’) = MPEG-4 codec CV_FOURCC(‘U’, ‘2’, ‘6’, ‘3’) = H263 codec CV_FOURCC(‘I’, ‘2’, ‘6’, ‘3’) = H263I codec CV_FOURCC(‘F’, ‘L’, ‘V’, ‘1’) = FLV1 codec 若编码器代号为 -1，则运行时会弹出一个编码器选择框。 详细的视频编解码格式可参考：Video Codecs by FOURCC 第三个参数fps 被创建视频流的帧率。 第四个参数frame_size 视频流的大小。 第五个参数is_color 如果非零(true)，编码器将希望得到彩色帧并进行编码；否则，是灰度帧（只有在Windows下支持这个标志）。 出错详解输出路径不对肯定就没有视频了。此外，容易出现的问题有保存的视频大小为0，保存的视频乱码或打不开。 保存的视频大小为0可能的原因有： 编码格式不对在open函数中第二个参数是编码格式，一定按照提供的编码格式进行填写，在应用中最好的解决方法是为-1。当为-1时，程序对弹出如下对话框供你选择： 本人电脑上只有选择全帧（非压缩的）才能正常打开。 帧速率不匹配该项会导致视频时间不同。 后缀名不对 选择.avi格式没有问题，其它待定。 保存的视频乱码或打不开这个情况一般就是编码格式不对造成的，也就是open函数中第二个参数。最好的解决方法是设为-1，然后手动选择编解码器。 参考资料http://www.cnblogs.com/polly333/p/5165290.html]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BGSLibrary编译安装与BGSlibrary GUI的下载与使用]]></title>
    <url>%2F2017%2F09%2F20%2FBGSlibrary%2F</url>
    <content type="text"><![CDATA[本文主要介绍BGSLibrary编译安装与BGSlibrary GUI的下载与使用 安装前提：需要安装了opencv以及VS，可以参考这篇博文，写的很详细。 BGSLibrary简介BGSLibrary由Andrews Sobral开发，并提供了一个执行背景减除（BGS）的C++框架。该代码可以在Windows或Linux上运行。 目前，该库提供了35种BGS算法（PBAS算法从BGSLibrary中删除，因为它基于专利算法ViBE）。 几位作者提供了大量的算法。 源代码可以在GNU GPL v3许可证下获得，图书馆免费，学术目的开源。 任何用户都可以使用SVN客户端下载最新的项目源代码。 BGSLibrary地址该项目的github主页地址为：github地址 详细安装指南（官方修正版）在该项目的github主页上可以看到安装指导。本人的电脑配置为VS2015，Opencv3.2.0，所以在github主页上依次点击： Installation instructions 中的Windows installation -&gt; BGSLibrary with OpenCV 3.2.0 and Visual Studio 2015 from CMAKE (Recommended) 该界面下，详细的安装步骤（及修正）为： 打开windows控制台（cmd） 克隆BGSLibrary库到本地 克隆指令为： git clone https://github.com/andrewssobral/bgslibrary.git 切换到bgslibrary/build目录 设置opencv路径 特别注意：windows环境下没有`setlocal`命令。 所以跳过该步骤，直接进行下一步。 调用cmake命令安装 安装命令为： cmake -DOpenCV_DIR=%OpenCV_DIR% -G &quot;Visual Studio 14 Win64&quot; .. 注意：由于我们没有设置上一步的opencv路径，因此，上述cmake命令中的%OpenCV_DIR%需要用详细路径的形式替换，即直接指定opencv目录。笔者所用的命令为： cmake -D OpenCV_DIR=&quot;D:\Program Files\opencv3\build&quot; -G &quot;Visual Studio 14 Win64&quot; .. 命令中最后的两个点也是需要的。-D与OpenCV_DIR分开或者合在一起都可以。 上述两步骤的变化是笔者花了不少时间尝试出来的。 将opencv可执行文件目录添加到系统环境变量PATH中 计算机上右键 – 属性 – 高级系统设置 – 环境变量 – 系统变量中的PATH –添加opencv目录。 D:\Program Files\opencv3\build\x64\vc14\bin; 最后的是英文状态下的分号，表示不同路径间的分隔符。 VS中打开bgs.sln解决方案文件，切换到“RELEASE”模式（并且要注意选择x64而不是x86模式）下，点击“ALL_BUILD”项目开始生成。 安装完成，可以开始跑demo，跑BGSLibrary了。 主要有两种方式运行BGSLibrary，第一种是在cmd命令行下，第二种是运行写好的脚本文件。 运行方法一：windows控制台在windows控制台（cmd）下运行： ①用摄像头跑BGSLibrary C:\bgslibrary&gt; build\bgslibrary.exe --use_cam --camera=0 ②运行dome程序 C:\bgslibrary&gt; build\bgs_demo.exe dataset/video.avi ③运行demo2程序 C:\bgslibrary&gt; build\bgs_demo2.exe 注意：此时的目录为bgslibrary根目录。 运行方法二：直接运行脚本文件经过上述的成功生成过程后，可在bgslibrary根目录下找到写好的脚本文件（bat或者sh），直接双击运行即可。如下图所示： BGSlibrary GUI的下载与使用BGSlibrary GUI简介是否还在为上述繁琐的安装过程而苦恼，那么就快来下载BGSlibrary GUI吧。 BGSlibrary GUI是BGSLibrary的可执行版本，可用于Windows 32位和64位。 对于Linux和Mac用户，可以使用Makefile来编译所有文件并生成可执行示例。 该GUI中集成了37种背景建模算法，可以显示输入视频/图像、基于背景建模得到的前景和背景建模得到的背景图像，还可以显示出每种算法的计算复杂度等等。并且，测试的可以是视频、图片序列以及摄像头输入视频。 下载方式一文件名：bgslibrary_x86_v1.9.2_with_mfc_gui_v1.4.2.7z 下载地址：CSDN (找的网上的，亲测可用) 上传者设置了积分，没有积分的童鞋可以联系我，我私下发给你，或者我看情况可以上传百度云啥的。 下载方式二最新版本：BGSLibrary v1.9.1 with MFC GUI v1.4.1 (x86/x64) 下载地址：GITHUB（bgslibrary/binaries/） BGSlibrary GUI的使用已经是GUI界面了，所以使用非常简单，在此不再赘述。基本上和编译完成后能实现的功能相同。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BP神经网络部分具体的推导]]></title>
    <url>%2F2017%2F09%2F12%2FBP_derivation%2F</url>
    <content type="text"><![CDATA[本文介绍了BP网络中的前向传播和反向传播过程的公式与推导，读者可自行揣摩。 mathjax公式中不能有多余的{}，否则hexo deploy的时候会出现错误。 网络结构参数说明BP神经网络示意图 注意，上述层与层之间是全连接的，示意图并没有画全。 网络结构一个输入层，两个隐含层，一个输出层。 参数标记 输入层神经元个数n、输出层神经元个数m 两个隐含层神经元个数均为100 权值：输入层与第一个隐含层之间的权值为$w_{ij}$，两个隐含层之间的权值为$w_{jk}$，第二个隐含层与输出层之间的权值为$w_{kl}$ 阈值：两个隐含层$a^1_j,a^2_k$，输出层$b_l$ 其中，$i=1,2,…,n$，$j,k=1,2,…,100$，$l=1,2,…,m$凡是下标含有$i,j,k,l$的，均表示单个神经元。 BP网络推导前向传播两个隐含层及输出层的输出： $$H_j^1 = f(\sum_{i=1}^n w_{ij} x_i - a_{j}^1 )\ \ \ j=1,2,…,100$$ $$H_{k}^2 = f(\sum^{100}_{j=1} w_{jk} H^1_{j} - a^2_{k} )\ \ \ k = 1,2, \cdots ,100$$ $$O_l = \sum_{k = 1}^{100} w_{kl}H_{k}^2 - {b_l} \ \ \ l = 1,2, \cdots ,m$$ 误差此处仅仅是简单相减，可以使用MSE均方误差，有空改。 $$e_l = y_l - O_l\ \ \ l = 1,2, \cdots ,m$$ 其中，$y_l$是真实的样本输出。 反向传播的权值更新$$\begin{equation}\begin{split}w_{kl} &amp;= w_{kl} - dw_{kl} \\&amp;= w_{kl} - \eta \frac{\partial e_l}{\partial w_{kl}}\\&amp;= w_{kl} + \eta H_k^2 e_l \ \ \ \ \ \ k = 1,2, \cdots ,100 \\\end{split}\end{equation}$$ $$\begin{equation}\begin{split}{w_{jk}} &amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial w_{jk}} \\&amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial O_l} \frac{\partial O_l}{\partial H_{k}^2} \frac{\partial H_{k}^2}{\partial w_{jk}} \\&amp;= {w_{jk}} - \eta (-e_l)(\sum_{l = 1}^m w_{kl}) (f’_{H_k^2} H_j^1) \\&amp;= {w_{jk}} + \eta f’_{H_k^2} H_j^1 \sum_{l = 1}^m w_{kl}e_l \ \ \ \ \ j = 1,2, \cdots ,100 \\\end{split}\end{equation}$$ $$\begin{equation}\begin{split}{w_{ij}} &amp;= {w_{ij}} - \eta \frac{\partial e_l}{\partial w_{ij}} \\&amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial O_l} \frac{\partial O_l}{\partial H_{k}^2} \frac{\partial H_{k}^2}{\partial H_{j}^1} \frac{\partial H_{j}^1}{\partial w_{ij}} \\&amp;= {w_{jk}} - \eta (-e_l)(\sum_{l = 1}^m w_{kl}) (f’_{H_k^2} \sum_{k = 1}^{100} w_{jk}) (f’_{H_j^1} x_i) \\&amp;= {w_{ij}} + \eta f’_{H_j^1}{x_i}\sum_{k = 1}^{100} [(\sum_{l = 1}^m w_{kl}e_l)w_{jk}f’_{H_k^2}] \\\ \ \ \ &amp;其中 i = 1,2, \cdots ,n;j = 1,2, \cdots ,100 \\\end{split}\end{equation}$$ 这边公式需要自己推一推啦，详细地说明暂时就不多说。还可以简写。有空补。 关于激活函数的说明上述公式中，$f’_{H_k^2}$, $f’_{H_j^1}$ 之所以没有代入具体值，是因为这取决与所采用的激活函数。DeepLearnToolBox之BP算法中可采用的激活函数有两种，一是sigmoid函数，二是双曲正切函数。 sigmoid函数当激活函数为sigmoid函数$f(x) = \frac{1} { 1 + e^{-x} }$时，sigmoid函数的导数具有下面的一个性质： 其导数为： $$\begin{equation}\begin{split}f’(x) &amp;= \frac{e^{ - x}}{(1 + e^{ - x})^2} \\&amp;= \frac{e^{ - x}}{(1 + e^{ - x})}\frac{1}{(1 + e^{ - x})}\\&amp;= (1 - \frac{1}{(1 + e^{-x})})(\frac{1}{(1 + e^{ - x})}) \\&amp;= (1-f(x))f(x)\\\end{split}\end{equation}$$ 因此，比如说，在$H^2_K$中对$f$求导，结果为$f’_{H_k^2} = H_k^2(1-H_k^2)$，同理$f’_{H_k^1} = H_k^1(1-H_k^1)$ tanh函数激活函数也可以是双曲正切函数$tanhx= \frac{sinhx}{coshx} = \frac{e^x-e^{-x}}{e^x+e^{-x}}$。 双曲正切函数的图形夹在水平直线y=1及y=-1之间，且当x的绝对值很大时，它的图形在第一象限内接近于直线y=1，而在第三象限内接近于直线y=-1。[1]即双曲正切函数的值域是(-1,1)。 tanh(4) = (exp(4)-exp(-4))/(exp(4)+exp(-4)) = 0.9993 超过[-4,4]的范围已经可以看为1了。 双曲正切函数的标准导数公式： $$ tanh(x) = \frac{1}{cosh(x)^2} = 1- tanh(x)^2 $$ 用如下命令作图，并画出导数图像： plot(x,1-tanh(x).^2) plot(x,1./cosh(x).^2) 代码中给出的导数公式为： $$f’_{tanhx} = 1.7159 * \frac{2}{3} (1 -\frac{1}{1.7159^2}tanhx^2) $$ 用如下命令plot(x,1.7159*2/3*(1-1/1.7159^2*tanh(x).^2))作图，画出导数图像： 可以看到，总体形状是类似的，但是幅度上还是存在着较大差异。具体缩放的原因还不太清楚。 总结这篇文章只要是基于公式推导BP网络的整体流程。基于代码的实现请参阅： DeepLearnToolBox之BP算法。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建的GitHub博客之优化]]></title>
    <url>%2F2017%2F09%2F09%2Fblog-opti%2F</url>
    <content type="text"><![CDATA[本篇教程基于NexT主题的博客配置，实现更换主题、评论、打赏等36项功能，接下来根据这些功能进行分点描述，附上个人博客以供比对参考：个人博客链接。 搭建基本Hexo博客Hexo博客基本搭建参考：《hexo+GitHub博客搭建实战》一文，，笔者按照教程的顺序一步一步来，是没有出现错误的，如果读者们在搭建的时候遇到了问题不知如何解决，笔者会尽自己所能帮助读者，并将遇到的问题及解决方法附在文章下方。 Hexo博客绑定域名关于Hexo博客如何绑定自己的域名，详情可参阅《hexo搭建的Github博客绑定域名》一文。 博主按照上述教程，已经成功地绑定域名wangwlj.com。 更换Hexo主题笔者更换后的主题为NexT，其Github网址为：https://github.com/iissnan/hexo-theme-next 。首先将NexT的主题源文件下载到本地，使用Git克隆指令如下： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 下载后，将压缩包解压缩(文件位于指令运行的当前目录)，复制其中名称为next的文件夹到Hexo的主题目录下，主题目录的路径为： Hexo博客根目录/themes/ 在Hexo根目录下有一个以_config.yml命名的文件（下称站点配置文件 ），用Sublime/NotePad++等文本编辑器打开，在其中找到theme属性，将其由landscape改为next。 然后在Hexo根目录执行部署Hexo指令： 123456// 清理缓存hexo clean// 生成文件hexo generate// 部署hexo deploy 便可以在远程的博客上看到修改主题后的样式了。 设置Hexo主题模式看到上图，读者可能会产生疑问，为什么自己的主题样式和笔者的不一样，这是因为在Hexo主题中，有四种不同的模式，通过切换模式，让NexT主题显示不一样的样式。 在NexT根目录下有一个同样名称为_config.yml，为了区分hexo根目录下的_config.yml，将前者称为主题配置文件 ，在其中找到scheme属性，如下图所示： 12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini NexT主题默认使用Muse模式，笔者采用的是Pisces模式，读者可根据自己的喜好，选择其中一种模式。 修正图片显示问题经过上面的配置后，发现上传的博客文章里面的本地图片居然显示不来（没有同步上传）。 于是，找到解决方案： 1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 2 在你的hexo目录下执行这样一句话npm install hexo-asset-image --save，这是下载安装一个可以上传本地图片的插件 3 等待一小段时间后，再运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：1![你想输入的替代文字](xxxx/图片名.jpg) 注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。 5.hexo s，运行本地服务器，打开http://localhost:4000/，可实时查看修改情况。 6.hexo d，同步到github。 参考自：hexo生成博文插入图片 设置预览摘要设置完模式后，读者们会发现，尽管首页显示的是所有文章的列表，但是每一篇文章都显示了所有内容，这样感觉看起来不舒服，这时候可以启用预览摘要模式，在主题配置文件 中找到auto_excerpt属性，将enable设置为true ，将length设置为想要预览到的字数，如下图所示： 123auto_excerpt:enable: true #将原有的false改为truelength: 300 #设置预览的字数 这里说明一下：上述的部署指令中hexo deploy可以换成hexo server，两者的区别在于，前者是将博客部署到远程的Github上，而后者是运行在本地，通过http://localhost:4000在浏览器中访问。后者是为了调试配置方便而使用，但是最终本地博客还是需要hexo deploy指令将其部署至Github上。 添加评论功能更新目前的评论系统，友言，网易云跟帖都挂了。所以，我最终采用的是来必力。 我新写一篇文章详细介绍了来必力评论系统的实现方法：hexo博客优化之实现来必力评论功能 以下是原文NexT目前出到5.1.0版本，功能模块已经相当的丰富。NexT主题集成了评论系统，只需要设置相关的属性即可实现功能，其目前支持多说、Disqus、Facebook评论、Hyper评论、网页云跟帖等，其中“多说”是NexT推荐的评论系统，但是多说评论系统不稳定，经常会出现服务异常的问题。 笔者采用的是一款名为友言的评论系统，它也是NexT已经集成好的，可以直接拿来用的。下面对其操作进行讲解： - 注册友言账号 打开友言官网，单击“注册”按钮后，按照套路可完成账号注册。 - 获取uid 注册完登录后，在首页单击“后台管理”按钮进入后台界面便可看到自己的用户ID，将其复制下来。 - 设置uid 打开主题配置文件 ，在其中找到属性youyan_uid，然后在: 后添加之前复制的uid。 &gt; 提醒一下，: 冒号后面一定要有一个空格 然后部署一下Hexo，可以在本地或远程看到实现的评论功能，如下图所示： &gt; 在笔者配置评论功能的时候，笔者遇到了一个问题：本地博客有评论功能，而远程博客却没有 。折腾了一下午，始终不知道其原因所在。后来，当笔者对博客绑定自己的域名后，发现远程的博客自动出现了评论功能。在此推测为域名的缘故。若没有绑定域名的读者们遇到这个情况，可以放放，先配置其他功能。 设置侧边栏显示效果在主题配置文件 中，找到sidebar的display属性，display属性有四种显示模式：分别为： 1234post // 默认显示方式always // 一直显示hide // 初始隐藏remove // 移除侧边栏 笔者将其设置为hide模式，读者们可根据个人喜好进行设置。 添加菜单选项默认情况下，菜单导航栏有首页、归档、关于三个选项，除此之外笔者还添加了分类、标签和关于。在主题配置文件 中，找到menu属性，并去掉categories、 tags、about的的注释，如下图所示： 然后在Hexo根目录执行指令如下： 123456// 添加分类页面hexo new page "categories"// 添加标签页面hexo new page "tags"// 添加关于页面hexo new page "about" 执行完上述指令后，在Hexo根目录/source/文件夹下创建三个文件夹，命名分别为：categories、tags、about文件夹，在这些文件夹中分别会创建一个以index命名的Markdown文件，对这三个Markdown文件内容进行修改，使之分别为： 1234567891011121314151617---title: categoriesdate: 2017-03-12 22:06:24type: "categories"------title: 标签date: 2017-03-12 17:27:16type: "tags"------title: aboutdate: 2017-03-12 22:07:26type: "about"--- 完成文件的修改，然后部署Hexo即可完成菜单选项的添加。 添加阅读次数统计注册LeanCloud账号，完成激活；点击左上角的”应用”-“创建新应用”-点击“数据”右边的齿轮–点击创建类class，类名字叫做Counter。 然后，修改主题配置文件 ，找到leancloud_visitors，添加修改： 1234leancloud_visitors: enable: true #将原来的false改为true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 从设置中找到相应的id和key： 然后预览，如图： 添加社交链接笔者希望在个人博客中加入自己的微博、知乎和Github链接以提高访问量，接下来了解一下社交链接如何添加： 添加链接及图标 在主题配置文件 中找到social属性，在其下方添加社交链接及图标，其格式为： 社交平台名称：链接 || 图标 链接的图标全部来自于Font Awesome 个人配置 笔者社交链接添加情况如以下代码所示： 123456789101112social: GitHub: https://github.com/qwerty200696 || github E-Mail: mailto:yourname@gmail.com || envelope 知乎: https://www.zhihu.com/people/LijieWang || gratipay 微博: https://weibo.com/3280603012 || weibo Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow YouTube: https://youtube.com/yourname || youtube Instagram: https://instagram.com/yourname || instagram 其中，微博有其对应的图标，而知乎在图标库中却没有找到，笔者找了一款gratipay的图标来代替知乎图标。 如果没有找到指定的图标，将会启用默认的图标。 效果展示 配置完成后，具体效果显示如下： 添加友情链接功能在主题配置文件 中找到links属性，修改links_title属性的值为“友情链接”（也可以是其他文案），取消注释links:，然后添加上好友的博客名称和博客地址，其格式如下： 1234567# Blog rollslinks_title: 友情链接 #修改名称#links_layout: block#links_layout: inlinelinks: #该行取消注释 小草莓: http://my.csdn.net/qq_31196849 qingkong: http://my.csdn.net/qingkong1994 笔者友情链接出现位置在社交链接的下方，效果如下图所示： 设置博文内链接为蓝色 修改原因 链接的默认颜色是白色的，和普通字体颜色相同，不容易区分，如下图所示： 修改方法 通过路径： F:Hexo\themes\next\source\css\_common\components\post\ 打开post.styl文件，在文件中添加，如下字段： 12345678.post-body p a&#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 最好将新添加的内容放在原文件内容的底部，便于查看。 效果预览 设置完成后部署一下，预览效果如图： 图中Git的链接出现的下划线是鼠标悬停时的效果。 设置文章末尾”本文结束”标记实现方法 在路径F:\Hexo\themes\next\layout\_macro下，新建一个文件passage-end-tag.swig,文件内容中添加以下代码： 1234&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt; ------ 本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读 ------&lt;/div&gt;&#123;% endif %&#125; 代码截图如下(在网站中看到的div标签生效消失了，故此截图)： 这里可以更改字体显示的颜色，大小，以及内容，例如可将本文结束用The Happy Ending代替，并将字体颜色设置为了自己喜欢的#CDBA96，你可以去这里选择自己喜欢的颜色对应的RGB值。 然后在路径\themes\next\layout\_macro\下找到并打开post.swig文件，在 post-body 之后， post-footer 之前添加如下代码（post-footer之前两个DIV）： 12345&#123;% if not is_index %&#125; &lt;div&gt; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &lt;/div&gt;&#123;% endif %&#125; 具体位置如下图所示： 最后在主题配置文件 中，在末尾添加如下语句： 12passage_end_tag: enabled: true 实现效果图 最终实现效果如下： 显示每篇文章字数实现方法 首先安装插件，执行以下命令： 1npm install hexo-wordcount --save 然后修改主题配置文件 ，定位到post_wordcount，将wordcount由false改为true即可。 实现效果图 在每篇文章标题下会有如下效果： 显示站点文章总字数实现方法 首先安装插件，插件安装同上（已经“显示每篇文章字数”则忽略这步）。 然后修改主题配置文件 ，定位到post_wordcount，将totalcount由false改为true即可。 实现效果图 在页面最底部会有如下效果： 文章末尾添加版权说明直接修改主题配置文件 ，定位到post_copyright，将enable由false改为true即可。 该字段如下： 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 实现效果如图所示： 设置个人头像通过上面切换到Pisces发现，自己的头像还是属于匿名状态，因此，我们有必要设置一下自己的头像。 实现方法 在主题配置文件 中找到avatar字段,进行修改: 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/head_icon.jpg 先将avatar字段前的#删除，然后粘贴上头像的目录位置或者链接。 笔者将头像图片保存在了主题目录下的source/images文件夹，也可以存放在站点目录下的source/uploads文件夹。也可以将自己的头像图片，保存在百度网盘或者新浪微盘的某个地方，然后将对应的url地址复制过来，添加在avatar字段后即可。 实现效果图 其效果如下图所示： 达到效果后即可部署至远程。 设置头像动态特效在路径F:\Hexo\themes\next\layout\_partials找到head.swig文件并打开，在其末尾添加，如下字段： 1&lt;link href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" rel="stylesheet"&gt; 并在路径themes\next\source\css\_common\components\sidebar\下找到sidebar-author.styl文件并打开，添加如下语句： 1234.site-author-image:hover &#123; -webkit-animation: jello 1s; animation: jello 1s;&#125;; 其中jello是我选择的动态效果，你可以在这里找到你喜欢的特效;然后更换上述代码中的jello字段，达到预期效果后，即可部署至远程。 设置网站图标实现方法 打开主题配置文件 ，找到以下字段，进行相应的修改： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /web_icon.jpg 其中，图片web_icon.jpg存放在hexo-site/source/目录下。 然后预览，在自己的博客网站上有这样的图标： 因为我使用了与头像一样的图片，所以图标与头像一样。达到效果后即可部署至远程。 添加留言版块我们还可以在菜单栏增加一个”留言板”,让他人可以通过留言板直接给我们留言。 实现方法 在博客目录中，执行以下命令，新建一个页面： 1hexo n page guestbook 然后通过路径F:\Hexo\source\guestbook找到并打开guestbook文件夹下的index.md文件，然后再文件中添加以下代码: 1&lt;div class="ds-recent-visitors" data-num-items="28" data-avatar-size="42" id="ds-recent-visitors"&gt;&lt;/div&gt; 然后打开主题配置文件 ，在menu字段下，添加如下字段： 1234567menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 留言板: /guestbook || newspaper-o #自己添加的字段 newspaper-o是留言板的图标，可以在这里找到自己喜欢的图标。 笔者采用的youyan评论系统，默认在新建页面上会产生评论板块。效果如下： 这个效果暂时不稳定，可能是由于笔者暂时还没有绑定域名的关系。 项目主页添加README在建立Github上建立自己的博客仓库的时候，没有生成README文件，这样使得其他人无法知道我们这个仓库是做什么，即我们的这个仓库缺少一个说明文件；但是如果直接使用命令hexo n README，再部署至远程的时候，hexo会将它解析为html文件，这不是我们想要的。 实现方法 因此，解决方式是在路径F:\Hexo\source下手动新建README.mdown注意这里的后缀是.mdown，Mardownpad可以将文件保存为.mdown后缀文件；然后再在这个新建文件中写README即可。再之后hexo g会把它复制到public文件夹，而不会被解析成html文件，发布在博客中。 实现效果图 预览效果，如图： 实现fork me on github在右上角或者左上角实现fork me on github。 实现方法 点击这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码： 然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href标签改为你的github地址： 实现效果图 实现效果图如下（右上角）： 实现点击出现桃心效果实现方法 打开浏览器，输入如下网址 http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 实现效果图 修改文章底部的#号标签实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将其中的 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 实现效果图 添加动态背景实现方法 在主题配置文件 中，定位到如下部分： 123456789101112131415# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribboncanvas_ribbon: false 这是已经集成好的几个动态效果，笔者采用的是canvas_nest，读者可依次体验(将false改为true)，选择最喜欢的动态背景。 实现效果图 代码块样式自定义实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义)123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 实现效果图 文章加密访问实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下：12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 实现效果图 添加jiathis分享实现方法 在主题配置文件 中，jiathis为true，就行了，代码如下： 1234567# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.jiathis: true ##uid: Get this uid from http://www.jiathis.com/#add_this_id: 实现效果图 自定义鼠标样式实现方法 打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码1234567// 鼠标样式 * &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword2.ico"),auto!important &#125; :active &#123; cursor: url("http://om8u46rmb.bkt.clouddn.com/sword1.ico"),auto!important &#125; 其中 url 里面必须是 ico 图片，ico图片可以上传到网上，然后获取外链，复制到 url 里就行了 支持mathjax公式看到网上说明安装hexo-math工具，或者其他的一系列教程，如这个。 其实在目前的hexo/NexT主题已经集成了mathjax，所以不需要那么麻烦的设置了。 实现方法 在主题配置文件 中，定位到mathjax，将后面的选项为true，就行了。 另外，虽然这样设置了，但是在编写的时候还会出现mathjax与markdown默认渲染不兼容的问题，导致有时候公式一复杂就显示不出来。 解决上述问题的方法请参照我写的另一片博客：https://qwerty200696.github.io/2017/09/21/markdown_mathjax/ 修改字体颜色/大小/背景色比如说，想在文章中对某一部分的文字进行强调（改变大小，颜色），该操作具体说明如下： 如果想自定义字体大小以及颜色，可以直接在 Markdown 文档中使用 html 语法：12345&lt;font size=4 &gt; 这里输入文字，自定义字体大小 &lt;/font&gt;&lt;font color="#FF0000"&gt; 这里输入文字，自定义字体颜色&lt;/font&gt; &lt;span style="background-color: #ff6600;"&gt;这里输入文字，自定义字体背景色&lt;/span&gt;&lt;font color="#000000" size=4&gt;&lt;span style="background-color: #ADFF2F;"&gt;这是综合起来的效果 &lt;/span&gt;&lt;/font&gt;&lt;font color="#FFFFFF" size=4&gt;&lt;span style="background-color: #68228B;"&gt;这是综合起来的效果2 &lt;/span&gt;&lt;/font&gt; 其中#FF0000为RGB颜色代码，读者可去RGB颜色查询对照表网站查找自己喜欢的颜色。 若想在RGB颜色值与十六进制颜色码之间相互转化，可查看该网站。 效果如下： 这里输入文字，自定义字体大小 这里输入文字，自定义字体颜色这里输入文字，自定义字体背景色 这是综合起来的效果 这是综合起来的效果2 实现首行缩进由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，因此想要实现行缩进需要加上相应的代码，如下。 在需要缩进行的开头处，先输入下面的代码，然后紧跟着输入文本即可。分号也不要漏掉。 直接写:123半方大的空白`&amp;ensp;`或`&amp;#8194`;全方大的空白`&amp;emsp;`或`&amp;#8195`;不断行的空白格`&amp;nbsp;`或`&amp;#160`; 亲测可行。 插入表格方法1：html代码插入表格的代码是：12345678910&lt;table class="table table-bordered table-striped table-condensed"&gt; &lt;tr&gt; &lt;td&gt;北京&lt;/td&gt; &lt;td&gt;雾霾&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;深圳&lt;/td&gt; &lt;td&gt;暴雨&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 效果为： 北京 雾霾 深圳 暴雨 可以看到上面多出了很多空行，所以我一般采用第二种方法，如下： 方法二：markdown代码1234|函数名|功能||----|----||max|求最大值||min|求最小值| 效果如下： 函数名 功能 max 求最大值 min 求最小值 添加RSS安装 hexo-generator-feed 插件RSS需要有一个Feed链接，而这个链接需要靠hexo-generator-feed插件来生成，所以第一步需要添加插件，在Hexo根目录执行安装指令：1npm install hexo-generator-feed --save 配置feed信息在站点配置文件 中追加如下代码：123456feed: type: rss2 path: rss2.xml limit: 10 hub: content: &apos;true&apos; feed属性下的各个子属性的含义借用feed官方英文解释如下：12345type - Feed type. (atom/rss2)path - Feed path. (Default: atom.xml/rss2.xml)limit - Maximum number of posts in the feed (Use 0 or false to show all posts)hub - URL of the PubSubHubbub hubs (Leave it empty if you don&apos;t use it)content - (optional) set to &apos;true&apos; to include the contents of the entire post in the feed. 至此RSS功能大功告成，部署至远程后，会发现RSS已经自动出现，效果图如下： 手机端订阅图手机端订阅效果展示： 添加搜索功能笔者采用的是local search。安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件 （站点根目录下），新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件 （主题目录下），启用本地搜索功能：123# Local searchlocal_search: enable: true 之后部署到远程即可。 Hexo博客提交百度和Google收录这篇文章写得很详细，我就不详细说了：Hexo博客收录百度和谷歌-基于Next主题 添加打赏功能参考这篇文章：hexo的next主题打赏 博文置顶链接：Hexo博客彻底解决置顶问题 目前按照上述方法，安装新工具之后，只需要在需要置顶文章上面加上top: true字段即可。 比如说置顶这篇文章： 12345678---title: hexo搭建的Github博客之优化date: 2017-09-09 10:27:20categories: 博客搭建系列tags: - 博客top: true--- 参考资料 【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能 GitHub+Hexo+NexT搭建个人博客 hexo博客的背景设置 html设置字体背景色的标签或代码]]></content>
      <categories>
        <category>博客搭建系列</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub博客搭建实战]]></title>
    <url>%2F2017%2F09%2F08%2Fblog_setup%2F</url>
    <content type="text"><![CDATA[我的个人博客链接：wangwlj.com 想要搭建类似的博客吗？ 如果是，那就赶快点进来吧～～ 手把手教学，现在开始！！ 说在前面为什么自己搭建博客，知乎不行吗？有自己的博客自由，自在。可以看看这篇文章：刘未鹏 | Mind Hacks。更多请看为什么要自建博客？ 搭建环境1、安装 Node.js: https://nodejs.org/en/ windows下点击链接，下载安装即可;Linux下更加简单，在终端下输入sudo apt-get install nodejs即可。 2、安装 Git: https://github.com/waylau/git-for-win windows下点击上述链接安装即可；Linux在终端输入sudo apt-get install git即可。 详细教程可参考廖雪峰老师的Git教程： https://github.com/waylau/git-for-win。我也写了个Git的简易入门教程，链接：Git入门使用指南。 本篇教程中不涉及太多Git的操作，因此无须观看Git相关教程也可轻松完成搭建。 3、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，按下图设置，名称和邮箱是Github上的。 4、安装Hexo。所有必备的应用程序安装完成后，即可使用 npm安装Hexo。1$ npm install -g hexo-cli 这一步如果出错，可到文末的“出错汇总”查看解决方法。 至此，本地环境已经搭建完成。 配置Github首先注册、登录 https://github.com/ ，其中自己的Username很重要（之后的创建仓库以及博客github.io域名会用到）。 然后右上角选择 Create a new repository： https://github.com/new如下图所示： 其中仓库名称Repository name一项填写格式为：yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 仓库创建完成后，开始生成添加秘钥。 在终端(Windows:cmd/Linux:Terminal)下输入： 1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用任意文本编辑器打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入https://github.com/settings/ssh 将复制的内容粘贴到Key的输入框，Title的内容可以随意（比如ubuntu home），点击Add SSH key按钮即可。 若没有配置GitHub，就执行第三步（初始化博客），会出现如下错误： 初始化博客在电脑F盘（自己随意）目录下新建文件夹test，进入test，按住Shift键点击鼠标右键，点击“在此处打开命令窗口”： 输入：1hexo init blog 稍微等待下，速度有点慢。成功提示： INFO Start blogging with Hexo! 因为你初始化hexo之后source目录下自带一篇hello world文章, 所以直接执行如下命令:123456$ hexo generate# 启动本地服务器$ hexo server# 在浏览器输入 http://localhost:4000/就可以看见网页和模板了INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器中输入localhost:4000，便可以看到网站初步的模样。不要激动，我们还要把网页发布到Github上去。 配置博客在blog目录下，用sublime/notepad++等文本编辑器打开_config.yml文件，修改参数信息 特别提醒，在每个参数的:后都需要有一个空格 修改网站相关信息123456title: wangwlj的博客subtitle: 积跬步以至千里！description: 网页描述author: wangwljlanguage: zh-CNtimezone: Asia/Shanghai language和timezone都是有输入规范的，详细可参考 语言规范和时区规范。 配置部署代码中的qwerty200696，修改成自己的。 1234deploy: type: git repo: https://github.com/qwerty200696/qwerty200696.github.io branch: master 其中repo项是之前Github上创建好的仓库的地址，可以通过如下图所示的方式得到： branch是项目的分支，我们默认用主分支master。 此外，可将_config.yml中的repo修改为如下标准格式：1repo: https://用户名:密码@github.com/用户名/用户名.github.io.git 这样做的好处就是每次hexo deploy提交时不需要输入账号密码。 配置统一资源定位符如果有个人域名的话可以设置，否则跳过即可。如果是github.io的网址，也是可以填上的。 1url: https://qwerty200696.github.io 对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。 发表文章1.新建一篇博文，在CMD中输入: 123$ hexo new "我的测试文章"INFO Created: F:\test\blog\source\_posts\我的测试文章.md 2.根据上述提示路径找到该文章，打开，使用Markdown语法编辑文章。 该语法介绍可以查看：Markdown 语法说明 (简体中文版) 在文章的一开始处，可以按如下格式添加文章标题，日期，分类、标签以及描述等。 123456789---title: title #文章标题date: 2017-09-08 23:47:44 #文章生成时间categories: "Hexo教程" #文章分类目录 可以省略tags: #文章标签 可以省略 - 标签1 - 标签2 description: #你对本页的描述 可以省略--- 3.接着在blog目录下，输入如下的一系列(三个)命令：1234567891011121314F:\test\blog$ hexo cleanINFO Deleted database.INFO Deleted public folder.$ hexo generateINFO Start processingINFO Files loaded in 1.48 s#省略INFO 29 files generated in 4.27 s$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开http://localhost:4000/，可以在本地预览网站的初步样子。 最后一步，发布到远程，执行hexo deploy：123456F:\test\blog$ hexo deployINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...#省略 执行hexo deploy时如果出现错误，请到文末查看具体解决方案。 正常情况下，会跳出Github登录，直接登录；如果没有问题，在浏览器输入博客地址： qwerty200696.github.io。 然后就可以看到已经有内容了。（有可能稍有延迟） 总结发布文章的步骤： 1、hexo new 创建文章(当然也可以通过其他方式创建Markdown文件) 2、Markdown语法编辑文章 3、部署（所有打开CMD都是在blog目录下）1234hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo generate #生成hexo server #启动服务预览，非必要，可本地浏览网页hexo deploy #部署发布 其中的部分命令可以简写： hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo g == hexo generate # 生成 hexo s == hexo server # 启动服务预览 hexo d == hexo deploy # 部署 到此为止，相信你已经对博客的整体流程有了一定的把握，想要对博客进一步优化吗？ 请进入博客优化篇：hexo搭建的Github博客之优化 出错汇总安装hexo时出错 unable to verify the first certificate（无法验证第一证书） 查找到解决方案： 参考网址：npm报错 依据解决方案所述，在命令行输入如下命令，来取消ssl验证： 1npm config set strict-ssl false 之后安装就会成功了，显示如下： hexo deploy出错之一1deploy not found： git 解决方案：执行如下语句后， 再部署即可： 1npm install hexo-deployer-git --save 参考自：https://www.v2ex.com/t/175940 hexo deploy出错之二安装完成之后的第x天，同步文章到github时，即运行如下命令： 1hexo deploy 居然出现了如下的错误：12345678910fatal: unable to access 'https://username:password@github.com/username/username.github.io.git/': SSL certificate problem: unable to get local issuer certificateFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: unable to access 'https://username:password@github.com/username/username.github.io.git/': SSL certificate problem: unable to get local issuer certificate at ChildProcess.&lt;anonymous&gt; (D:\test\blog2\node_modules\hexo-util\lib\spawn.js:37:17) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at ChildProcess.cp.emit (D:\test\blog2\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:920:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:230:5) 解决方法：执行如下语句： 1$ git config --global http.sslVerify false 参考自：git获取代码提示SSL certificate problem: unable to get local issuer certificate 参考自： hexo提交报错 unable to access 之后再次运行发布指令，终于成功： 1hexo deploy 参考文献 教你免费搭建个人博客，Hexo&amp;Github hexo生成博文插入图片]]></content>
      <categories>
        <category>博客搭建系列</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下TensorFlow完整安装流程及出错解决方案]]></title>
    <url>%2F2017%2F09%2F07%2FTensorFlow_setup%2F</url>
    <content type="text"><![CDATA[本文分为如下几大步骤： 安装python及环境变量配置 安装cuda/cndnn 安装TensorFlow 测试是否成功 安装python通过Pip在Windows上安装PythonTensorFlow在Windows上只支持64位Python3.5，可以通过Python 3.5 from python.org 下载并安装Python3.5.2（注意选择正确的操作系统）。 或者通过https://www.python.org/downloads/选择3.5的任意版本。 设置环境变量上一步安装时，如果勾选了“自动配置环境变量”操作，即：在cmd中输入pip，如果找到了该命令，则可省去该步骤。 若在cmd中输入pip找不到该命令，则需要将Python安装路径下“%安装路径%\Scripts”添加到Path下；再到cmd中输入pip看到若干命令提示，则代表python安装成功（Python安装包自带pip）。“开始”-&gt;“所有程序”，也可以找到Python终端。 参考自：http://blog.csdn.net/include1224/article/details/53452824 cuda以及cudnn的安装TensorFlow分为CPU版和GPU版，如果你打算安装GPU版，请先安装如下两个驱动： 1、CUDA安装：https://developer.nvidia.com/cuda-downloads 2、CuDNN安装：https://developer.nvidia.com/cudnn（要注册Nvidia用户，并加入CuDNN开发组，填若干问卷就可以下载了）选择下载版本时要注意和Cuda版本匹配。 我的账户是qq邮箱。 解压后（三个目录，分别是：bin、include、lib），覆盖至CUDA的安装目录下。例如： C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\ 安装tensorflow我安装的是GPU版本。 windows不支持pip在线安装。即不支持：pip install tensorflow-gpu该命令。 两种方法安装tensorflow： 手动下载tensorflow gpu版本文件：tensorflow_gpu-0.12.0rc0-cp35-cp35m-win_amd64.whl下载网址：https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl 下载完成后，打开cmd，切换到安装文件目录，输入: pip install tensorflow_gpu-0.12.0rc0-cp35-cp35m-win_amd64.whl 即可成功安装。 输入pip命令pip install --upgrade https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl 参考自tensorflow官网：https://www.tensorflow.org/versions/r0.12/get_started/os_setup#pip_installation_on_windows mac和linux可另行参考网上教程。 测试测试是否安装成功。 问题一import tensorflow as tf 导入tensorflow时出现错误： “Couldn&apos;t open CUDA library cudnn64_5.dll” 找到解决方案：安装时没有注意cudnn版本要求，下载安装了cudnnv6.0，安装完后自己查找文件，只有cudnn64_6.dll，没有cudnn64_5.dll。 解决方案为将cudnnV6.0替换为cudnnV5.1即可。 即重新下载cudnn5.1版本。 https://developer.nvidia.com/rdp/cudnn-download 解决方案来自：http://blog.csdn.net/suo_ivy/article/details/70445103 替换完成后，该错误消失。 问题二 执行tf.Session()的时候，出现如下提示： Could not identify NUMA node of /job:localhost/replica:0/task:0/gpu:0, defaulting to 0. Your kernel may not have been built with NUMA support.` 不过这并不影响最终结果的执行。（只是个警告） 网上找到相关说明： http://blog.csdn.net/baixiaozhe/article/details/54598346可供参考一下。大体上的意思是：只要我们不是使用多GPU，这个警告应该是可以忽略的，所以我们目前也不需要担心了。 至此，tensorflow 测试完成，并成功运行了测试样例。 (optional) 测试程序源码 哈哈，是不是迫不及待想用TensorFlow来实现具体的神经网络算法呢？ 那就请查看TensorFlow系列的下一篇文章：TensorFlow基础篇与搭建深层神经网络。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
</search>
