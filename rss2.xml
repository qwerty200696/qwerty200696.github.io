<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Thu, 05 Apr 2018 08:55:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>实现全排列 —— Leetcode(46)</title>
      <link>http://wangwlj.com/2018/04/05/leetcode_46_permutation/</link>
      <guid>http://wangwlj.com/2018/04/05/leetcode_46_permutation/</guid>
      <pubDate>Thu, 05 Apr 2018 08:36:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fq1vmy0ymbj23gw2bce82.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fq1vmy0ymbj23gw2bce82.jpg" alt=""><br><a id="more"></a><br>Vinales, Cuba, by Sam Bark.</p><h3 id="题目：全排列"><a href="#题目：全排列" class="headerlink" title="题目：全排列"></a>题目：全排列</h3><p>Given a collection of distinct numbers, return all possible permutations.</p><p>For example,<br>[1,2,3] have the following permutations:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [1,3,2],</div><div class="line">  [2,1,3],</div><div class="line">  [2,3,1],</div><div class="line">  [3,1,2],</div><div class="line">  [3,2,1]</div><div class="line">]</div></pre></td></tr></table></figure></p><p>来源： <a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="external">https://leetcode.com/problems/permutations/description/</a></p><h3 id="解法一：C-STL"><a href="#解法一：C-STL" class="headerlink" title="解法一：C++ STL"></a>解法一：C++ STL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            ans.push_back(nums);</div><div class="line">        &#125; <span class="keyword">while</span>(next_permutation(nums.begin(), nums.end()));</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="解法二：backtracking"><a href="#解法二：backtracking" class="headerlink" title="解法二：backtracking"></a>解法二：backtracking</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</div><div class="line">        permutation(nums, <span class="number">0</span>, ans);</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;ans)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (begin &gt;= nums.size()) &#123;</div><div class="line">            ans.push_back(nums);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; nums.size(); ++i) &#123;</div><div class="line">            swap(nums[i], nums[begin]);</div><div class="line">            permutation(nums, begin + <span class="number">1</span>, ans); <span class="comment">// </span></div><div class="line">            swap(nums[i], nums[begin]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/04/05/leetcode_46_permutation/#disqus_thread</comments>
    </item>
    
    <item>
      <title>笔试题：区域染色问题</title>
      <link>http://wangwlj.com/2018/04/05/coding_dye_problem_2/</link>
      <guid>http://wangwlj.com/2018/04/05/coding_dye_problem_2/</guid>
      <pubDate>Thu, 05 Apr 2018 07:51:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fq1vgacphjj23v92kyu0z.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fq1vgacphjj23v92kyu0z.jpg" alt=""><br><a id="more"></a><br>New York, United States, by Matt Lamers</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定五种不同颜色，求使得相邻区域颜色不重复的画法有多少种？ 不要求使用所有颜色。<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpx8sbsch9j20ci0b3jrd.jpg" alt=""></p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>按照字母顺序依次填充。<br>A：5选1<br>B：4选1<br>C：3选1<br>D：2选1<br>A/B/C/D两两相邻，所以共计占用了四种不同的颜色。</p><p>现在看E，只与A/C相关，即E可填充的颜色有三种：B的颜色，D的颜色，以及暂未出现的颜色，记为X。<br>当E填充颜色为B的颜色时，F则不能填充ABD的颜色，即可选颜色为CX两种；<br>当E填充颜色为D的颜色时，F则不能填充AD的颜色，即可选颜色为BCX三种；<br>当E填充颜色为X的颜色时，F则不能填充ADX的颜色，即可选颜色为BC两种；</p><p>综上，共有 5x4x3x2x(2+3+2) = 840种。</p><h3 id="假设此时需要使用全部五种颜色，则有多少种方法呢？"><a href="#假设此时需要使用全部五种颜色，则有多少种方法呢？" class="headerlink" title="假设此时需要使用全部五种颜色，则有多少种方法呢？"></a>假设此时需要使用全部五种颜色，则有多少种方法呢？</h3><p>重复上面的思路：<br>现在看E，只与A/C相关，即E可填充的颜色有三种：B的颜色，D的颜色，以及暂未出现的颜色，记为X。<br>当E填充颜色为B的颜色时，F则不能填充ABD的颜色，即可选颜色为CX两种，由于需要使用全部颜色，则只能选X一种；<br>当E填充颜色为D的颜色时，F则不能填充AD的颜色，即可选颜色为BCX三种，由于需要使用全部颜色，则只能选X一种；<br>当E填充颜色为X的颜色时，F则不能填充ADX的颜色，即可选颜色为BC两种；</p><p>综上，共有 5x4x3x2x(1+1+2) = 480种。</p><h3 id="如果扩展到N中颜色呢？不要求使用所有颜色。"><a href="#如果扩展到N中颜色呢？不要求使用所有颜色。" class="headerlink" title="如果扩展到N中颜色呢？不要求使用所有颜色。"></a>如果扩展到N中颜色呢？不要求使用所有颜色。</h3><p>重复上面的思路：</p><p>按照字母顺序依次填充。<br>A：n选1<br>B：(n-1)选1<br>C：(n-2)选1<br>D：(n-3)选1<br>A/B/C/D两两相邻，所以共计占用了四种不同的颜色。</p><p>现在看E，只与A/C相关，即E可填充的颜色有三种：B的颜色，D的颜色，以及暂未出现的颜色，记为X。<br>当E填充颜色为B的颜色时，F则不能填充ABD的颜色，即可选颜色为CX 共(n-3)种；<br>当E填充颜色为D的颜色时，F则不能填充AD的颜色，即可选颜色为BCX共(n-2)种；<br>当E填充颜色为（n-4）种X中任一颜色时，F则不能填充ADX(特定的一种)的颜色，即可选颜色为BCX(n-4-1)共(n-3)种；</p><p>综上，共有 nx(n-1)x(n-2)x(n-3)x((n-3)+(n-2)+(n-4)x(n-3)) = n(n-1)(n-2)(n-3)((n-3)x(n-3)+(n-2))种。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/04/05/coding_dye_problem_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络常考面试题十则</title>
      <link>http://wangwlj.com/2018/03/21/network_top_ten_questions/</link>
      <guid>http://wangwlj.com/2018/03/21/network_top_ten_questions/</guid>
      <pubDate>Wed, 21 Mar 2018 07:43:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fpkhjgxr8hj23vc2kwqv9.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fpkhjgxr8hj23vc2kwqv9.jpg" alt=""><br><a id="more"></a></p><h3 id="1-OSI，TCP-IP，五层协议的体系结构，以及各层协议"><a href="#1-OSI，TCP-IP，五层协议的体系结构，以及各层协议" class="headerlink" title="1. OSI，TCP/IP，五层协议的体系结构，以及各层协议"></a>1. OSI，TCP/IP，五层协议的体系结构，以及各层协议</h3><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。</p><p>每一层的协议如下：</p><ul><li>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）</li><li>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）</li><li>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</li><li>传输层：TCP、UDP、SPX</li><li>会话层：NFS、SQL、NETBIOS、RPC</li><li>表示层：JPEG、MPEG、ASII</li><li>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</li></ul><p>每一层的作用如下：</p><ul><li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li><li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li><li>网络层：负责数据包从源到宿的传递和网际互连（包Packet）</li><li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li><li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li><li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li><li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li></ul><h3 id="2-IP地址的分类"><a href="#2-IP地址的分类" class="headerlink" title="2. IP地址的分类"></a>2. IP地址的分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A类地址：以0开头，   第一个字节范围：1~127（1.0.0.0 - 127.255.255.255）；</div><div class="line">B类地址：以10开头，  第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</div><div class="line">C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</div><div class="line">D类地址：以1110开头，第一个字节范围：224~239（224.0.0.0 - 239.255.255.255）；（作为多播使用）</div><div class="line">E类地址：保留</div></pre></td></tr></table></figure><p>其中A、B、C是基本类，D、E类作为多播和保留使用。</p><p>以下是留用的内部私有地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A类 10.0.0.0--10.255.255.255</div><div class="line">B类 172.16.0.0--172.31.255.255</div><div class="line">C类 192.168.0.0--192.168.255.255</div></pre></td></tr></table></figure></p><p>IP地址与子网掩码相与得到网络号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ip       : 192.168.2.110</div><div class="line">&amp;</div><div class="line">Submask : 255.255.255.0</div><div class="line">----------------------------</div><div class="line">网络号   ：192.168.2.0</div></pre></td></tr></table></figure></p><p>注:</p><p>主机号，全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255）</p><h3 id="3-ARP是地址解析协议，简单语言解释一下工作原理。"><a href="#3-ARP是地址解析协议，简单语言解释一下工作原理。" class="headerlink" title="3. ARP是地址解析协议，简单语言解释一下工作原理。"></a>3. ARP是地址解析协议，简单语言解释一下工作原理。</h3><p>答:</p><ol><li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li><li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的<code>MAC</code>地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送<code>ARP</code>数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</li><li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li><li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ol><p>广播发送ARP请求，单播发送ARP响应。</p><h3 id="4-各种协议的介绍"><a href="#4-各种协议的介绍" class="headerlink" title="4. 各种协议的介绍"></a>4. 各种协议的介绍</h3><p>答:<code>ICMP</code>协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br><code>TFTP</code>协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br><code>HTTP</code>协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br><code>NAT</code>协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，<br><code>DHCP</code>协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用<code>UDP</code>协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><h3 id="5-描述RARP协议"><a href="#5-描述RARP协议" class="headerlink" title="5. 描述RARP协议"></a>5. 描述RARP协议</h3><p>答:RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。<br>工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。</p><h3 id="6-TCP三次握手和四次挥手的全过程"><a href="#6-TCP三次握手和四次挥手的全过程" class="headerlink" title="6. TCP三次握手和四次挥手的全过程"></a>6. TCP三次握手和四次挥手的全过程</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</p><ul><li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li><li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li><li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li></ul><h3 id="7-在浏览器中输入www-baidu-com-后执行的全部过程"><a href="#7-在浏览器中输入www-baidu-com-后执行的全部过程" class="headerlink" title="7. 在浏览器中输入www.baidu.com 后执行的全部过程"></a>7. 在浏览器中输入www.baidu.com 后执行的全部过程</h3><ul><li>1、客户端浏览器通过DNS解析到www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。</li><li>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</li><li>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</li><li>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</li></ul><p>事件顺序：<br>(1) 浏览器获取输入的域名www.baidu.com<br>(2) 浏览器向DNS请求解析www.baidu.com的IP地址<br>(3) 域名系统DNS解析出百度服务器的IP地址<br>(4) 浏览器与该服务器建立TCP连接(默认端口号80)<br>(5) 浏览器发出HTTP请求，请求百度首页<br>(6) 服务器通过HTTP响应把首页文件发送给浏览器<br>(7) TCP连接释放<br>(8) 浏览器将首页文件进行解析，并将Web页显示给用户。</p><p>涉及到的协议：<br>(1) 应用层：HTTP(WWW访问协议)，DNS(域名解析服务)<br>(2) 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)<br>(3) 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)</p><h3 id="8-TCP和UDP的区别？"><a href="#8-TCP和UDP的区别？" class="headerlink" title="8. TCP和UDP的区别？"></a>8. TCP和UDP的区别？</h3><p>答:TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</p><h4 id="TCP对应的协议和UDP对应的协议"><a href="#TCP对应的协议和UDP对应的协议" class="headerlink" title="TCP对应的协议和UDP对应的协议"></a>TCP对应的协议和UDP对应的协议</h4><p>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。<br>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p><h3 id="DNS域名系统，简单描述其工作原理。"><a href="#DNS域名系统，简单描述其工作原理。" class="headerlink" title="DNS域名系统，简单描述其工作原理。"></a>DNS域名系统，简单描述其工作原理。</h3><p>答:当DNS客户机需要在程序中使用名称时，它会查询<code>DNS</code>服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的<code>DNS</code>域名，指定的查询类型，<code>DNS</code>域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如<code>HTTP</code>，<code>SMTP</code>等在其中需要完成主机名到IP地址的转换。</p><p>当一个应用进程需要把某个域名解析为IP地址时，该应用进程就会调用解析程序，并成为一个DNS用户，把待解析的域名放在DNS请求报文中，以UDP数据报的形式发送给本地域名服务器，本地域名服务器查找到相应域名的IP地址后，就将该域名的IP地址信息放入应答报文中返回给客户进程，如果本地域名服务器没有直接查找到对应的IP地址，则向根域名服务器发出迭代查询，再将查询到的IP地址信息回传给客户程序。</p><h3 id="9-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"><a href="#9-TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？" class="headerlink" title="9. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？"></a>9. TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</h3><p>答:建立连接的过程是利用客户服务器模式，假设主机<code>A</code>为客户端，主机<code>B</code>为服务器端。<br>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<br>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</p><h3 id="10-交换机、路由器、网关的概念，各自的用途"><a href="#10-交换机、路由器、网关的概念，各自的用途" class="headerlink" title="10. 交换机、路由器、网关的概念，各自的用途"></a>10. 交换机、路由器、网关的概念，各自的用途</h3><h4 id="1）交换机"><a href="#1）交换机" class="headerlink" title="1）交换机"></a>1）交换机</h4><p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。<br>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。<br>交换机被广泛应用于二层网络交换，俗称“二层交换机”。<br>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。</p><h4 id="2）路由器"><a href="#2）路由器" class="headerlink" title="2）路由器"></a>2）路由器</h4><p>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。<br>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p><h4 id="3）网关"><a href="#3）网关" class="headerlink" title="3）网关"></a>3）网关</h4><p>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。<br>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。<br>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。<br>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。<br>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/21/network_top_ten_questions/#disqus_thread</comments>
    </item>
    
    <item>
      <title>西瓜书《机器学习》学习笔记(6)：支持向量机</title>
      <link>http://wangwlj.com/2018/03/21/ML_chap06_SVM/</link>
      <guid>http://wangwlj.com/2018/03/21/ML_chap06_SVM/</guid>
      <pubDate>Wed, 21 Mar 2018 07:18:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fpki32ijh9j22i11j3b2a.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fpki32ijh9j22i11j3b2a.jpg" alt=""><br><a id="more"></a></p><h2 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h2><ul><li>间隔与支持向量</li><li>对偶问题</li><li>核函数</li><li>软间隔与正则化</li><li>支持向量回归</li><li>核方法</li></ul><p>支持向量机，因其英文名为<code>support vector machine</code>，故一般简称<code>SVM</code>，通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><h2 id="（一）间隔与支持向量"><a href="#（一）间隔与支持向量" class="headerlink" title="（一）间隔与支持向量"></a>（一）间隔与支持向量</h2><p>给定训练样本D={(x1, y1), (x2, y2), …,(xm, ym)}, yi∈{-1, +1}，分类学习最基本的想法就是基于训练集D在样本空间找到一个划分超平面：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkm9sl7q6j20fw0cm0ur.jpg" alt=""></p><p>在样本空间中，划分超平面可通过如下线性方程来描述，</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmavsnhrj2056022q2u.jpg" alt=""></p><p>假设超平面（w，b）能将训练样本正确分类，即对于(xi, yi)∈D，令，</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmbgw89gj20b203c0t6.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmbz01z2j20j60csdik.jpg" alt=""></p><p>距离超平面最近的这几个训练样本点称为“支持向量”（support vector），两个异类支持向量到超平面的距离之和为，<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmcprsbnj203y02oa9y.jpg" alt=""></p><p>称为“间隔”（<code>margin</code>）。<br>找到“最大间隔”（<code>maximum margin</code>）的划分超平面，就是支持向量机（<code>Support Vector Machine</code>，简称<code>SVM</code>）的基本型。</p><p>目标函数：</p><p><img src="http://img.my.csdn.net/uploads/201210/25/1351141837_7366.jpg" alt="7"></p><p>由于求$||w||^{-1}$的最大值相当于求$||w||^2$的最小值，所以上述目标函数等价于（w由分母变成分子，从而也有原来的max问题变为min问题，很明显，两者问题等价）：</p><p><img src="http://img.my.csdn.net/uploads/201210/25/1351141994_1802.jpg" alt="8"></p><p>因为现在的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题。</p><h3 id="补充：函数间隔与几何间隔"><a href="#补充：函数间隔与几何间隔" class="headerlink" title="补充：函数间隔与几何间隔"></a>补充：函数间隔与几何间隔</h3><p>在超平面<code>w*x+b=0</code>确定的情况下，<code>|w*x+b|</code>能够表示点x到距离超平面的远近，而<strong><font color="0CAA00">通过观察<code>w*x+b</code>的符号与类标记y的符号是否一致可判断分类是否正确</font></strong>，所以，可以用<code>(y*(w*x+b))</code>的正负性来判定或表示分类的正确性。于此，我们便引出了函数间隔（<code>functional margin</code>）的概念。</p><p>定义函数间隔为：<br><img src="http://img.blog.csdn.net/20131107201248921" alt="1"></p><p>而超平面<code>(w，b)</code>关于T中所有样本点<code>(xi，yi)</code>的函数间隔最小值（其中，x是特征，y是结果标签，i表示第i个样本），便为超平面<code>(w, b)</code>关于训练数据集T的函数间隔：<br>$$\hat\gamma= \text{min} \hat\gamma_i\;  (i=1，…n)$$</p><p>但这样定义的函数间隔有问题，即如果成比例的改变w和b（如将它们改成2w和2b），则函数间隔的值<code>f(x)</code>却变成了原来的2倍（虽然此时超平面没有改变），所以只有函数间隔还远远不够。</p><p>事实上，我们可以对法向量w加些约束条件，从而引出真正定义点到超平面的距离–几何间隔（<code>geometrical margin</code>）的概念。</p><p>假定对于一个点<code>x</code> ，令其垂直投影到超平面上的对应点为 $x_0$ ，$w$ 是垂直于超平面的一个向量，为样本x到超平面的距离，如下图所示：</p><p><img src="http://blog.pluskid.org/wp-content/uploads/2010/09/geometric_margin.png" alt="2"></p><p>根据平面几何知识，有:<br>$$x=x_0 +\gamma \frac w{||w||} $$</p><p>其中<code>||w||</code>为w的二阶范数（范数是一个类似于模的表示长度的概念），$\frac w{||w||}$是单位向量（一个向量除以它的模称之为单位向量）。</p><p>又由于$w_0$是超平面上的点，满足$w^Tx+b=0 $  ，代入超平面的方程，可得$w^Tx_0+b=0 $ ，即$w^Tx_0=-b $ 。</p><p>随即让此式$x=x_0 +\gamma \frac w{||w||} $的两边同时乘以$w^T$，再根据$w^Tx_0=-b $和$w^Tw=||w||^2$，即可算出：<br>$$\gamma = \frac {$w^Tx+b}{||w||} = \frac {f(x)}{||w||} $$</p><p>为了得到$\gamma$的绝对值，令$\gamma$乘上对应的类别<code>y</code>，即可得出几何间隔（用$\hat\gamma$表示）的定义：</p><p>$$\hat\gamma = y \gamma = \frac {\hat\gamma}{||w||} $$</p><p>从上述函数间隔和几何间隔的定义可以看出：几何间隔就是函数间隔除以<code>||w||</code>，而且函数间隔<code>y*(wx+b) = y*f(x)</code>实际上就是<code>|f(x)|</code>，只是人为定义的一个间隔度量，而几何间隔<code>|f(x)|/||w||</code>才是直观上的点到超平面的距离。</p><h2 id="（二）对偶问题"><a href="#（二）对偶问题" class="headerlink" title="（二）对偶问题"></a>（二）对偶问题</h2><p>我们对<code>SVM</code>基本型求解是一个凸二次规划（<code>convex quadratic programming</code>）问题，能直接用现成的优化计算包求解，但我们可以有更高效的办法。即对SVM的基本型使用拉格朗日算子法得到其“对偶问题”（<code>dual problem</code>）。</p><p>支持向量机的一个重要性质：训练完成后，大部分的训练样本都不需要保留，最终模型仅与支持向量有关。</p><h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p>一般地，一个最优化数学模型能够表示成下列标准形式：<br><img src="http://my.csdn.net/uploads/201206/08/1339126493_9056.jpg" alt="9"></p><p>其中，f(x)是需要最小化的函数，h(x)是等式约束，g(x)是不等式约束，p和q分别为等式约束和不等式约束的数量。</p><p>同时，得明白以下两点： </p><ul><li><p>凸优化的概念：$\mathcal{X} \subset \mathbb{R}^n$ 为一凸集， $f:\mathcal{X}\to \mathbb{R}$ 为一凸函数。凸优化就是要找出一点 $x^\ast \in \mathcal{X}$ ，使得每一 $x \in \mathcal{X} $满足$ f(x^\ast)\le f(x)$ 。</p></li><li><p>KKT条件的意义：它是一个非线性规划（<code>Nonlinear Programming</code>）问题能有最优化解法的必要和充分条件。</p></li></ul><p>经过论证，我们这里的问题是满足 KKT 条件的（首先已经满足Slater条件，再者f和gi也都是可微的，即L对w和b都可导），因此现在我们便转化为求解第二个问题。</p><p>也就是说，原始问题通过满足KKT条件，已经转化成了对偶问题。而求解这个对偶学习问题，分为3个步骤：首先要让L(w，b，a) 关于 w 和 b 最小化，然后求对的极大，最后利用SMO算法求解对偶问题中的拉格朗日乘子。</p><h2 id="（三）核函数"><a href="#（三）核函数" class="headerlink" title="（三）核函数"></a>（三）核函数</h2><p>在现实任务中，原始样本空间内也许并不存在一个能正确划分两类样本的超平面。<br>对这样的问题，可以<strong>将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分</strong>。如下图：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmdb4smxj20k008vq4c.jpg" alt=""></p><p>幸运的是，如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分。<br>令Φ(x)表示将x映射后的特征向量，于是，在特征空间中划分超平面所对应的模型可表示为，</p><p>$$f(x) = w^T \phi(x) +b $$</p><p>其对偶问题是，</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmf74efrj20hq03kdgi.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmfruicvj20bi04wwew.jpg" alt=""></p><p>求解设计到计算：<br>$$\phi(x_i)^T \phi(x_j) $$</p><p>，这是样本xi与xj映射到特征空间之后的内积。由于特征空间的维数可能很高，甚至可能到无穷维，因此直接计算通常是困难的。为了避开这个障碍，可以假设这样一个函数:</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmh8sa81j20f4022gm1.jpg" alt=""></p><p>即xi与xj在特征空间的内积等于他们原始样本空间通过函数<code>k(. , .)</code>计算的结果。有了这样的函数，我们就不必直接计算高维甚至无穷维特征空间中的内积。这里的函数k(. , .)就是“核函数”（<code>kernel function</code>）。</p><p>“核函数选择”是支持向量机的最大变数。常用的核函数有:</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmhpayvdj20k0063tb4.jpg" alt=""></p><p>此外，还可以通过函数的组合得到。</p><blockquote><p>核函数的选择是支持向量机的最大变数。这方面有一些基本的经验。如文本分类通常采用线性核，情况不明时可先尝试高斯核。</p></blockquote><h3 id="补充：核函数的本质"><a href="#补充：核函数的本质" class="headerlink" title="补充：核函数的本质"></a>补充：核函数的本质</h3><p>简要概括下，即以下三点：</p><ul><li>实际中，我们会经常遇到线性不可分的样例，此时，我们的常用做法是把样例特征映射到高维空间中去(映射到高维空间后，相关特征便被分开了，也就达到了分类的目的)；</li><li>但进一步，如果凡是遇到线性不可分的样例，一律映射到高维空间，那么这个维度大小是会高到可怕的(如19维乃至无穷维的例子)。那咋办呢？</li><li>此时，核函数就隆重登场了，核函数的价值在于它虽然也是将特征进行从低维到高维的转换，但核函数绝就绝在它事先在低维上进行计算，而将实质上的分类效果表现在了高维上，也就<strong>避免了直接在高维空间中的复杂计算</strong>。</li></ul><p>举例说明下核函数解决非线性问题的直观效果$ ^{<a href="http://img.blog.csdn.net/20131121105410546" target="_blank" rel="external">3</a>}$。</p><p>假设现在你是一个农场主，圈养了一批羊群，但为预防狼群袭击羊群，你需要搭建一个篱笆来把羊群围起来。但是篱笆应该建在哪里呢？你很可能需要依据牛群和狼群的位置建立一个“分类器”，比较下图这几种不同的分类器，我们可以看到SVM完成了一个很完美的解决方案。</p><p><img src="http://img.blog.csdn.net/20131121105410546" alt="3"></p><h2 id="（四）软间隔与正则化"><a href="#（四）软间隔与正则化" class="headerlink" title="（四）软间隔与正则化"></a>（四）软间隔与正则化</h2><p>在前面的讨论中，我们一直假定训练样本在训练空间或特征空间中是线性可分的，即存在一个超平面将不同类的样本完全划分开。然而，在现实任务中往往很难确定合适的核函数使得训练样本在特征空间中线性可分。</p><p>缓解该问题的一个办法是允许支持向量机在一些样本上出错。为此引入了“软间隔”（<code>soft margin</code>）的概念，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmi732fuj20ig0c6goc.jpg" alt=""></p><p>具体来说，前面介绍的支持向量机形式是要求所有样本均满足约束，即所有样本必须划分正确，这称为“硬间隔”（<code>hard margin</code>），而<strong>软间隔则是允许这样的样本不满足约束</strong>。</p><p>原来的约束条件为：</p><p><img src="http://img.my.csdn.net/uploads/201304/03/1364959415_3450.jpg" alt="4"></p><p>现在考虑到outlier（偏离正常位置很远的数据点）问题，约束条件变成了：</p><p><img src="http://img.my.csdn.net/uploads/201304/03/1364959452_3595.jpg" alt="5"></p><p>其中$\xi_i \geq 0$ 称为松弛变量 (<code>slack variable</code>) ，对应数据点$x_i$允许偏离的 <code>functional margin</code> 的量。</p><p>所以，我们在原来的目标函数$\text{min} \frac 12 ||w||^2 $后面加上一项，使得这些$\xi_i $的总和也要最小：</p><p>$$\text{min} \frac 12 ||w||^2+ C \sum^{n}_{i=1} \xi_i $$</p><p>其中C是一个参数，用于控制目标函数中两项（“寻找 margin 最大的超平面”和“保证数据点偏差量最小”）之间的权重。</p><p>完整的目标函数为：<br><img src="http://img.my.csdn.net/uploads/201304/03/1364959576_9747.jpg" alt="6"></p><p>三种常用的替代损失函数(<code>surrogate loss</code>)：</p><ul><li>hinge损失: $l_{hinge}(z) = max(1, 1-z)$</li><li>指数损失(exponential loss)：$l_{exp}(z) = exp(-z)$</li><li>对率损失(logistic losss)：$l_{log}(z) = log(1+exp(-z))$</li></ul><p>至此可以做个小结，不准确的说，SVM它本质上即是一个分类方法，用<code>w^T+b</code>定义分类函数，于是求w、b，为寻最大间隔，引出<code>1/2||w||^2</code>，继而引入拉格朗日因子，化为对拉格朗日乘子a的求解（求解过程中会涉及到一系列最优化或凸二次规划等问题），如此，求w.b与求a等价，而a的求解可以用一种快速学习算法SMO，至于核函数，是为处理非线性情况，若直接映射到高维计算恐维度爆炸，故在低维计算，等效高维表现。</p><h2 id="（五）支持向量回归"><a href="#（五）支持向量回归" class="headerlink" title="（五）支持向量回归"></a>（五）支持向量回归</h2><p>对样本（x，y），传统回归模型通常直接基于模型输出f(x)与真实输出y之间的差别来计算损失，当切仅当f(x)与y完全相同时，损失才为零。于此不同，支持向量回归（Support Vector Regression，简称SVR）假设我们能容忍f(x)与y之间最多有ε的偏差，即仅当f(x)与y之间的差别绝对值大于ε时才计算损失。如下图所示，</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpkmj2951lj20i80ca76x.jpg" alt=""></p><h2 id="（六）核方法"><a href="#（六）核方法" class="headerlink" title="（六）核方法"></a>（六）核方法</h2><p>根据“表示定理”，对于一般的损失函数和正则化项（不要求是凸函数），优化问题的最优解都可表示为核函数的线性组合。这显示出核函数的巨大威力。<br>人们发展出一系列基于核函数的学习方法，统称为“核方法”（<code>kernel methods</code>）。最常见的，是通过“核化”（即引入核函数）来将线性学习器拓展为非线性学习器。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>西瓜书《机器学习》</li><li><a href="https://zhuanlan.zhihu.com/p/33488981" target="_blank" rel="external">《机器学习》笔记-支持向量机（6）</a></li><li><a href="http://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="external">支持向量机通俗导论（理解SVM的三层境界）【很详细，推荐阅读】</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/21/ML_chap06_SVM/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(11) 第十三章 红黑树</title>
      <link>http://wangwlj.com/2018/03/20/algorithm_tutorial_chapter_13/</link>
      <guid>http://wangwlj.com/2018/03/20/algorithm_tutorial_chapter_13/</guid>
      <pubDate>Tue, 20 Mar 2018 14:39:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fpkhl7oiv3j23vc2kw1l1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fpkhl7oiv3j23vc2kw1l1.jpg" alt=""><br><a id="more"></a></p><h3 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h3><p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是<code>Red</code>或<code>Black</code>。</p><p>通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p><p>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为<code>O(log n)</code>。</p><p>在<code>C++ STL</code>中，很多部分(目前包括set, multiset, map, multimap)应用了红黑树的变体(<code>SGI STL</code>中的红黑树有一些变化，这些修改提供了更好的性能，以及对set操作的支持)。</p><h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><p><font color="CC00AA">红黑树的5个性质</font>：</p><ul><li>每个结点要么是红的要么是黑的。  </li><li>根结点是黑的。  </li><li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  </li><li>如果一个结点是红的，那么它的两个儿子都是黑的。  </li><li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 </li></ul><p><img src="http://img.my.csdn.net/uploads/201212/12/1355319681_6107.png" alt=""></p><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>当在对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即通过修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后继续保持它的性质或平衡的目的。</p><p>树的旋转分为左旋和右旋，下面借助图来介绍一下左旋和右旋这两种操作。</p><p><img src="http://img.my.csdn.net/uploads/201012/29/8394323_1293614183gD0H.jpg" alt=""></p><p>如上图所示，当在某个结点<code>pivot</code>上，做左旋操作时，我们假设它的右孩子y不是<code>NIL[T]</code>，pivot可以为任何不是NIL[T]的左子结点。左旋以pivot到Y之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的左孩子b则成为pivot的右孩子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">LeftRoate(T, x)  </div><div class="line">y ← x.right                    <span class="comment">//定义y：y是x的右孩子  </span></div><div class="line">x.right ← y.left                <span class="comment">//y的左孩子成为x的右孩子  </span></div><div class="line"><span class="keyword">if</span> y.left ≠ T.nil  </div><div class="line">    y.left.p ← x      </div><div class="line">y.p ← x.p                      <span class="comment">//x的父结点成为y的父结点  </span></div><div class="line"><span class="keyword">if</span> x.p = T.nil  </div><div class="line">    then T.root ← y  </div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> x = x.p.left  </div><div class="line">    then x.p.left ← y  </div><div class="line"><span class="keyword">else</span> x.p.right ← y   </div><div class="line">y.left ← x                       <span class="comment">//x作为y的左孩子  </span></div><div class="line">x.p ← y</div></pre></td></tr></table></figure><p>左旋之后，privot变成了y的左节点。右旋之后，y变成privot的右节点。【互逆的过程】</p><p>2.右旋<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RIGHT-ROTATE(T,x)</div><div class="line">    y &lt;- left[x]  </div><div class="line">    left[x] &lt;- right[y]  </div><div class="line">    if right[y] != nil[T]  </div><div class="line">        then p[right[y]] &lt;- x  </div><div class="line">    p[y] &lt;- p[x]  </div><div class="line">    if p[x] = nil[T]  </div><div class="line">        then root[T] &lt;- y  </div><div class="line">        else if x = right[p[x]]  </div><div class="line">            then right[p[x]] &lt;- y  </div><div class="line">            else left[p[x]] &lt;- y  </div><div class="line">    right[y] &lt;- x  </div><div class="line">    p[x] &lt;- y</div></pre></td></tr></table></figure></p><p>右旋中的x，对应于上图右侧的Y。</p><p>右旋与左旋差不多，再此不做详细介绍。左右旋也是相互对称的，只要理解其中一种旋转就可以了。</p><p>树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>首先以二叉查找树的方法增加结点并标记它为红色。（如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑结点，这个是很难调整的。但是设为红色结点后，可能会导致出现两个连续红色结点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。）下面要进行什么操作取决于其他临近结点的颜色。</p><p>设要插入的结点为N，N的父结点标为P，N的叔父结点标为U，N的祖父结点标为G。（即P和U是G的孩子结点）。图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含（imply）的。</p><p><code>情形1</code>. <strong>新结点N位于树的根上，没有父结点</strong>。（插入树的第一个结点）</p><p>在这种情形下，我们把它重绘为黑色以满足性质2。因为它在每个路径上对黑结点数目增加一，性质5符合。</p><p><code>情形2</code>. <strong>父结点P是黑色</strong>，则整棵树不必调整便是红黑树。新结点是红色的，所以性质4没有失效。尽管新结点N有两个黑色叶子子结点；但由于新结点N是红色，通过它的每个子结点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色结点，性质5也未受到威胁。</p><p><code>情形3</code>. <strong>父结点P是红色（祖父结点G一定为黑色），叔父结点U也是红色</strong>。则我们可以将P，U重绘为黑色并重绘祖父结点G为红色（用来保持性质5）。但是，红色的祖父结点G可能是根结点，这就违反了性质2，也有可能祖父结点G的父结点是红色的，这就违反了性质4。为了解决这个问题，在祖父结点G上递归调整颜色。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_2.png" alt=""></p><p>（此时新插入结点N做为P的左子结点或右子结点都属于情形3，这里仅显示N做为P左子的情形）</p><p><code>情形4</code>. <strong>父结点P是红色（祖父结点G一定为黑色），叔父结点U是黑色或缺少，并且新结点N是左孩子</strong>。则针对祖父结点G进行一次右旋转；在旋转产生的树中，以前的父结点P现在是新结点N和以前的祖父结点G的父结点。以前的祖父结点G是黑色，切换以前的父结点P和祖父结点G的颜色，结果的树满足性质4，5。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_3.png" alt=""></p><p>（此时P为祖父结点G的左子结点或右子结点都属于情形4，这里仅显示P为G左子的情形）</p><p><code>情形5</code>. <strong>父结点P是红色（祖父结点G一定为黑色），叔父结点U是黑色或缺少，并且新结点N是右孩子</strong>。则针对父结点P进行一次左旋转调换新结点N和P的角色，接着按情形4进行处理。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_4.png" alt=""></p><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>首先以二叉查找树的方法找到要删除的结点，如果需要删除的结点有两个非叶子的孩子结点，那么问题可以转化成删除的结点最多有一个非叶子的孩子结点。（对于二叉查找树，在删除带有两个非叶子儿子的结点的时候，要么找到它的前驱（左子树中的最大元素）、要么找到后继（右子树中的最小元素），并把它的值拷贝到要删除的结点中。接着删除前驱（或后继），注意前驱（后继）的非叶子孩子结点数必定少于2。因为拷贝前驱（后继）值时不违反任何性质，所以上面的问题转化成立）。</p><p>如果被删除的结点没有非叶子的孩子，那么直接删除，然后用一个叶子结点代替它的位置，不用作其它树调整。</p><p>下面只讨论删除的结点只有一个非叶子结点孩子的情况。如果<strong>删除的是一个红色节点</strong>，它的父亲和孩子一定是黑色的，所以我们可以简单的用它的黑色儿子替换它，并不会破坏红黑树的性质。另一种简单情况是在<strong>被删除节点是黑色而它的儿子是红色的时候</strong>。我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。</p><p>需要进一步讨论的是在要<strong>删除的节点和它的儿子二者都是黑色的时候</strong>，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为S。在下面的示意图中，我们使用P称呼N的父亲，S<sub>L</sub> 称呼S的左儿子，S<sub>R</sub> 称呼S的右儿子。</p><p><code>情形1</code>. <strong>N是新的根</strong>。在这种情形下，从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。</p><p><code>情形2</code>. <strong>S是红色（N的父亲P是黑色）</strong>。在N的父亲P上做左旋转，把 S 转换成N的祖父，接着对调新的父亲P和新的祖父S的颜色。完成这两个操作后，N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），接下去按情形4、情形5或情形6来处理。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_5.png" alt=""></p><p><code>情形3</code>. <strong>S和S的儿子都是黑色，N的父亲P是黑色</strong>。简单的重绘S为红色。结果是通过S的所有路径，都少了一个黑色节点，因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_6.png" alt=""></p><p><code>情形4</code>. <strong>S和S的儿子都是黑色，N的父亲P是红色</strong>。简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_7.png" alt=""></p><p><code>情形5</code>. <strong>S是黑色，S的左儿子是红色，S的右儿子是黑色</strong>。在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。接着交换S和它的新父亲的颜色，所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，它的右儿子是红色的，所以我们进入了情形4。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_8.png" alt=""></p><p><code>情形6</code>. <strong>S是黑色，S的右儿子是红色</strong>。在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。</p><p><img src="http://7xrlu9.com1.z0.glb.clouddn.com/DataStructure_RB_9.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>算法导论</li><li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">红黑树</a></li><li><a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">教你初步了解红黑树</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/20/algorithm_tutorial_chapter_13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：不用加减乘除做加法</title>
      <link>http://wangwlj.com/2018/03/16/coding_offer46_sum1toN/</link>
      <guid>http://wangwlj.com/2018/03/16/coding_offer46_sum1toN/</guid>
      <pubDate>Fri, 16 Mar 2018 14:29:50 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyy7l1ldj23nd2qj1l1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;四种解法，只有想不到，没有做不到！！&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyy7l1ldj23nd2qj1l1.jpg" alt=""></p><blockquote><p>四种解法，只有想不到，没有做不到！！</p></blockquote><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><blockquote><p>四种解法，只有想不到，没有做不到！！</p></blockquote><h3 id="解法一：短路求值"><a href="#解法一：短路求值" class="headerlink" title="解法一：短路求值"></a>解法一：短路求值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> ans = n;</div><div class="line">        ans &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>));</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="解法二：利用异常"><a href="#解法二：利用异常" class="headerlink" title="解法二：利用异常"></a>解法二：利用异常</h3><p>用异常退出递归。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//用异常退出递归</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sum(n);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">1</span>%n;</div><div class="line">            <span class="keyword">return</span> n+sum(n<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="解法三：乘法-gt-sizeof"><a href="#解法三：乘法-gt-sizeof" class="headerlink" title="解法三：乘法-&gt;sizeof"></a>解法三：乘法-&gt;sizeof</h3><p>用公式是不可以的，公式里有乘法！！实现乘法可以用sizeof多维数组，两行代码就可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">bool</span> a[n][n+<span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a)&gt;&gt;<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="解法四：乘法-gt-快速模乘"><a href="#解法四：乘法-gt-快速模乘" class="headerlink" title="解法四：乘法-&gt;快速模乘"></a>解法四：乘法-&gt;快速模乘</h3><p>马客(Mark)：<br>我就猜到大家都是用 <code>&amp;&amp;</code> 的短路原则的，这样复杂是O(n)的。<br>我来一个复杂度32的，可以说O(logM)吧，M是数值大小，对于int也可以说是O(1)吧虽然常数有点大。</p><p>原理就是，类似快速幂，俗称快速模乘。</p><p><code>a * b</code>可以这样算：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">res = <span class="number">0</span></div><div class="line"><span class="keyword">while</span>(a)&#123;</div><div class="line">    <span class="keyword">if</span>(a &amp; <span class="number">1</span>) res += b;</div><div class="line">    a &gt;&gt;= <span class="number">1</span>;</div><div class="line">    b &lt;&lt;= <span class="number">1</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原理是把a拆成2的幂的和，<code>a = 2^e0 + 2^e1 + 2^e2....</code><br>那么 <code>a * b = (2^e0 + 2^e1 + 2^e2+...) * b = b * 2^e0 + b * 2^e1 + b * 2^e2 + ...= (b &lt;&lt; e0) + (b &lt;&lt; e1) + ....</code></p><p>也就是看成了二进制的相乘。可以写成如下代码【然而用了while】<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// res = (n+1)xn/2</span></div><div class="line">        <span class="keyword">int</span> a = n, b = n + <span class="number">1</span>, ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(a) &#123;</div><div class="line">            <span class="keyword">if</span>(a &amp; <span class="number">1</span>) &#123;</div><div class="line">                ans += b;</div><div class="line">            &#125;</div><div class="line">            a &gt;&gt;= <span class="number">1</span>;</div><div class="line">            b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>由于不能使用while语句，所以符合题意的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//奇数返回0xffffffff，否则0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) ((((x) &amp; 1) <span class="meta-string">&lt;&lt; 31) &gt;&gt; 31)</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = n, b = n + <span class="number">1</span>, s = <span class="number">0</span>;</div><div class="line">        <span class="comment">//复制32次。。</span></div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">         </div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">         </div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">         </div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> s &gt;&gt; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/16/coding_offer46_sum1toN/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++常见面试题整理</title>
      <link>http://wangwlj.com/2018/03/16/CPP_review_reproduce/</link>
      <guid>http://wangwlj.com/2018/03/16/CPP_review_reproduce/</guid>
      <pubDate>Fri, 16 Mar 2018 13:09:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyqoz2cgj23vc2kwkjm.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyqoz2cgj23vc2kwkjm.jpg" alt=""><br><a id="more"></a><br>有那么一些零碎的小知识点，偶尔很迷惑，偶尔被忽略，偶然却发现它们很重要，这段时间正好在温习这些，就整理在这里，一起学习一起提高！后面还会继续补充。</p><p>本文转载自：<a href="http://www.cnblogs.com/webary/p/4754522.html" target="_blank" rel="external">http://www.cnblogs.com/webary/p/4754522.html</a> </p><p>我自己也有整理，不过是思维导图的形式，有机会再一起放出来吧。</p><h3 id="1-面向对象的特性"><a href="#1-面向对象的特性" class="headerlink" title="1.面向对象的特性"></a>1.面向对象的特性</h3><p>　　封装、继承、多态。</p><p>　　封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。（优点：可以隐藏实现细节，使得代码模块化）</p><p>　　继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。（优点：可以扩展已存在的代码模块（类））</p><p>　　多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。虽然针对不同对象的具体操作不同，但通过一个公共的类，这些操作可以通过相同的方式被调用。</p><p>　　多态实现的两种方式：父类指针指向子类对象 或 将一个基类的引用类型赋值为它的派生类实例。（重要：虚函数 + 指针或引用）</p><p>构造函数、复制构造函数、析构函数、赋值运算符不能被继承。</p><h3 id="2-堆和栈"><a href="#2-堆和栈" class="headerlink" title="2.堆和栈"></a>2.堆和栈</h3><p>　　从内存角度来说：栈区（<code>stack</code>）由编译器自动分配释放，存放函数的参数值，局部变变量的值等，其操作方式类似于数据结构中的栈，可静态亦可动态分配。</p><p>　　堆区（<code>heap</code>）一般由程序员分配释放，若程序员不释放，可能造成内存泄漏，程序结束时可能由<code>OS</code>回收。只可动态分配，分配方式类似于链表。</p><p>　　从数据结构角度来说：堆可以被看成是一棵树，如：堆排序。</p><p>　　而栈是一种先进后出的数据结构。</p><h3 id="3-malloc和new"><a href="#3-malloc和new" class="headerlink" title="3.malloc和new"></a>3.malloc和new</h3><p>　　1.<code>malloc</code>与<code>free</code>是<code>C++/C</code>语言的标准库函数，<code>new/delete</code>是<code>C++</code>的运算符。但它们都可用于申请动态内存和释放内存。</p><p>　　2.对于非内部数据类型的对象而言，用<code>malloc/free</code>无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由<code>malloc/free</code>是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于<code>malloc/free</code>，因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，和一个能完成清理与释放内存工作的运算符delete。</p><p>　　3.<code>new</code>可以认为是<code>malloc</code>加构造函数的执行。<code>new</code>出来的指针是直接带类型信息的。而<code>malloc</code>返回的都是<code>void*</code>指针。<code>new delete</code>在实现上其实调用了<code>malloc,free</code>函数。</p><p>　　4.new 建立的是一个对象；malloc分配的是一块内存。</p><h3 id="4-虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数"><a href="#4-虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数" class="headerlink" title="4.虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数"></a>4.虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数</h3><p>　　虚函数表：类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。</p><p>　　编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的每个虚函数占据虚函数表中的一块。如果类中有N个虚函数，那么其虚函数表将有<code>N*4</code>字节的大小。</p><p>　　在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p><p>　　编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88" target="_blank" rel="external">函数指针</a>，并调用相应的函数。</p><p>　　-&gt;有虚函数或虚继承的类实例化后的对象大小至少为4字节（确切的说是一个指针的字节数；说至少是因为还要加上其他非静态数据成员，还要考虑对齐问题）；没有虚函数和虚继承的类实例化后的对象大小至少为1字节（没有非静态数据成员的情况下也要有1个字节来记录它的地址）。</p><p>　　有纯虚函数的类为抽象类，不能定义抽象类的对象，它的子类要么实现它所有的纯虚函数变为一个普通类，要么还是一个抽象类。</p><p>　　特别的：</p><p>　　（1）当存在类继承并且析构函数中有必须要进行的操作时（如需要释放某些资源，或执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄露或达不到预期结果；</p><p>　　（2）内联函数不能为虚函数：内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开；</p><p>　　（3）构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数；</p><p>　　（4）静态成员函数不能为虚函数：静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的。</p><p>　　更多关于虚函数的细节，请移步博文：<a href="http://www.cnblogs.com/webary/p/4731457.html" target="_blank" rel="external">关于C++虚函数表的那些事儿</a></p><h3 id="5-面向对象的多态、多态的实现机制，多态的例子"><a href="#5-面向对象的多态、多态的实现机制，多态的例子" class="headerlink" title="5.面向对象的多态、多态的实现机制，多态的例子"></a>5.面向对象的多态、多态的实现机制，多态的例子</h3><p> 　　见知识点4</p><h3 id="6-对一个类求sizeof需要考虑的内容"><a href="#6-对一个类求sizeof需要考虑的内容" class="headerlink" title="6.对一个类求sizeof需要考虑的内容"></a>6.对一个类求sizeof需要考虑的内容</h3><p> 　　见知识点4。同时，对于一个结构体和一个类执行<code>sizeof()</code>运算时情况比较复杂，详细分析请移步另一篇博文<a href="http://www.cnblogs.com/webary/p/4721017.html" target="_blank" rel="external">struct/class等内存字节对齐问题详解</a></p><h3 id="7-重载和重写（覆盖）"><a href="#7-重载和重写（覆盖）" class="headerlink" title="7.重载和重写（覆盖）"></a>7.重载和重写（覆盖）</h3><p>　　方法的重写<code>Overriding</code>和重载<code>Overloading</code>是多态性的不同表现。</p><p>　　重写<code>Overriding</code>是父类与子类之间多态性的一种表现，重载<code>Overloading</code>是一个类中多态性的一种表现。</p><p>　　如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (<code>Overriding</code>)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同；如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同。</p><h3 id="8-“引用”与多态的关系"><a href="#8-“引用”与多态的关系" class="headerlink" title="8.“引用”与多态的关系?"></a>8.“引用”与多态的关系?</h3><p>　　引用是除指针外另一个实现多态的方式。这意味着，一个基类的引用可以指向它的派生类实例。例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　Class A; Class B : Class A&#123;…&#125;;</div><div class="line"></div><div class="line">　　B b; A&amp; ref = b;</div></pre></td></tr></table></figure></p><h3 id="9-计算机加载程序包括哪几个区？"><a href="#9-计算机加载程序包括哪几个区？" class="headerlink" title="9.计算机加载程序包括哪几个区？"></a>9.计算机加载程序包括哪几个区？</h3><p>　　一个由<code>C/C++</code>编译的程序占用的内存分为以下几个部分：</p><p>　　（1）栈区（<code>stack</code>）:—由编译器自动分配释放，存放函数的参数值，局部变量的值等。可静态也可动态分配。其操作方式类似于数据结构中的栈。 </p><p>　　（2）堆区（<code>heap</code>）:一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。动态分配。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 </p><p>　　（3）全局区（静态区）:—程序结束后由系统释放，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域；未初始化的全局变量和静态变量在相邻的另一块区域(BSS，Block Started by Symbol)，在程序执行之前BSS段会自动清0。 </p><p>　　（4）文字常量区:—程序结束后由系统释放，常量字符串就是放在这里的。  </p><p>　　（5）程序代码区:—存放函数体的二进制代码。</p><p>10.派生类中构造函数与析构函数，调用顺序</p><p>　　构造函数的调用顺序总是如下：</p><p>　　1.基类构造函数。如果有多个基类，则构造函数的调用顺序是某类<strong><font color="3FAA00">在类派生表中出现的顺序</font></strong>，而不是它们在成员初始化表中的顺序。</p><p>　　2.成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象<strong><font color="3FAA00">在类中被声明的顺序</font></strong>，而不是它们出现在成员初始化表中的顺序。如果有的成员不是类对象，而是基本类型，则初始化顺序按照声明的顺序来确定，而不是在初始化列表中的顺序。</p><p>　　3.派生类构造函数。</p><p>　　析构函数正好和构造函数相反。</p><h3 id="11-extern-“C”的作用"><a href="#11-extern-“C”的作用" class="headerlink" title="11.extern “C”的作用"></a>11.extern “C”的作用</h3><p>　　<code>extern &quot;C&quot;</code>实现C++与C及其它语言的混合编程，是用在C和C++之间的桥梁。之所以需要这个桥梁是因为C编译器编译函数时不带函数的类型信息，只包含函数符号名字；而C++编译器为了实现函数重载，编译时会带上函数的类型信息，如他把上面的a函数可能编译成<code>_a_float</code>这样的符号为了实现重载。</p><p>　　<code>extern &quot;C&quot;</code>的惯用法：</p><p>　　在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为<code>cExample.h</code>）时，需进行下列处理：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">extern</span> <span class="string">"C"</span>&#123;</div><div class="line">　　　　<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cExample.h"</span></span></div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p><p>　　而在C语言的头文件中，对其外部函数只能指定为<code>extern</code>类型，C语言中不支持<code>extern &quot;C&quot;</code>声明，在<code>.c</code>文件中包含了<code>extern &quot;C&quot;</code>时会出现编译语法错误。</p><p>　　<code>extern</code>本身作为关键字修饰变量（函数）时声明该变量（函数）是外部变量（函数），通常全局变量在头文件中用这种方式声明，在对应源文件中定义，来防止重定义的错误。</p><h3 id="12-析构函数、构造函数能不能被继承"><a href="#12-析构函数、构造函数能不能被继承" class="headerlink" title="12.析构函数、构造函数能不能被继承"></a>12.析构函数、构造函数能不能被继承</h3><p>　　见知识点1</p><h3 id="13-C-为什么用模板类，为什么用泛型"><a href="#13-C-为什么用模板类，为什么用泛型" class="headerlink" title="13.C++为什么用模板类，为什么用泛型"></a>13.C++为什么用模板类，为什么用泛型</h3><p>　　通过泛型可以定义类型安全的数据结构（类型安全），而无须使用实际的数据类型（可扩展）。这能够显著提高性能并得到更高质量的代码（高性能），因为您可以重用数据处理算法，而无须复制类型特定的代码（可重用）。</p><h3 id="14-结构体内存对齐，与什么有关（CPU）"><a href="#14-结构体内存对齐，与什么有关（CPU）" class="headerlink" title="14.结构体内存对齐，与什么有关（CPU）"></a>14.结构体内存对齐，与什么有关（CPU）</h3><p>　　在系统默认的对齐方式下：每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，且最终占用字节数为成员类型中最大占用字节数的整数倍。</p><p>　　详细分析见博客：<a href="http://www.cnblogs.com/webary/p/4721017.html" target="_blank" rel="external">struct/class等内存字节对齐问题详解</a></p><p>　　为什么要对齐？当CPU访问正确对齐的数据时，它的运行效率最高，当数据大小的数据模数的内存地址是0时，数据是对齐的。例如：WORD值应该是总是从被2除尽的地址开始，而DWORD值应该总是从被4除尽的地址开始，数据对齐不是内存结构的一部分，而是CPU结构的一部分。当CPU试图读取的数值没有正确的对齐时，CPU可以执行两种操作之一：产生一个异常条件；执行多次对齐的内存访问，以便读取完整的未对齐数据，若多次执行内存访问，应用程序的运行速度就会慢。</p><h3 id="15-指针和引用"><a href="#15-指针和引用" class="headerlink" title="15.指针和引用"></a>15.指针和引用</h3><p>　　1.指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。</p><p>　　2.指针可以有多级，但是引用只能是一级；</p><p>　　3.指针的值可以为空，也可能指向一个不确定的内存空间，但是引用的值不能为空，并且引用在定义的时候必须初始化为特定对象；（因此引用更安全）</p><p>　　4.指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变引用对象了；</p><p>　　5.sizeof引用得到的是所指向的变量(对象)的大小，而sizeof指针得到的是指针本身的大小；</p><p>　　6.指针和引用的自增(++)运算意义不一样；</p><h3 id="16-static关键字作用"><a href="#16-static关键字作用" class="headerlink" title="16.static关键字作用"></a>16.static关键字作用</h3><p>　　在C语言中，关键字static有三个明显的作用：</p><p>　　1)在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持上一次的值不变，即只初始化一次（该变量存放在静态变量区，而不是栈区）。</p><p>　　2)在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外访问。（注：模块可以理解为文件）</p><p>　　3)在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</p><pre><code>【补充】《C和指针》中说static有两层含义：指明存储属性；改变链接属性。 具体解释：（1）全局变量（包括函数）加上static关键字后，链接属性变为internal，也就是将他们限定在了本作用域内；（2）局部变量加上static关键字后，存储属性变为静态存储，不存储在栈区，下一次将保持上一次的尾值。</code></pre><p>　　除此之外，C++中还有新用法：</p><p>　　4)在类中的static成员变量意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；</p><p>　　5)在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量(当然，可以通过传递一个对象来访问其成员)。</p><h3 id="17-虚表，基类的虚表是什么样的，派生类虚表"><a href="#17-虚表，基类的虚表是什么样的，派生类虚表" class="headerlink" title="17.虚表，基类的虚表是什么样的，派生类虚表"></a>17.虚表，基类的虚表是什么样的，派生类虚表</h3><p>　　（1）单继承情况</p><p>　　（2）多重继承（无虚函数覆盖）</p><p>　　（3）多重继承（有虚函数覆盖）</p><p>　　 详细的内容参考博文：关于C++虚函数表的那些事儿</p><h3 id="18-volatile"><a href="#18-volatile" class="headerlink" title="18.volatile"></a>18.volatile</h3><p>　　volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p>　　当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p><p>　　volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样一来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。</p><h3 id="19-define与const的区别"><a href="#19-define与const的区别" class="headerlink" title="19.#define与const的区别"></a>19.#define与const的区别</h3><p>　　• define不会做类型检查（容易出错），const拥有类型，会执行相应的类型检查<br>　　• define仅仅是宏替换，不占用内存，而const会占用内存<br>　　• const内存效率更高，编译器可能将const变量保存在符号表中，而不会分配存储空间，这使得它成 为一个编译期间的常量，没有存储和读取的操作</p><p>　　当使用#define定义一个简单的函数时，强烈建议使用内联函数替换！</p><h3 id="20-C-中的强制类型转换"><a href="#20-C-中的强制类型转换" class="headerlink" title="20.C++中的强制类型转换"></a>20.C++中的强制类型转换</h3><p>　　• reinterpret_cast: 转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型,反之亦 然. 这个操作符能够在非相关的类型之间转换. 操作结果只是简单的从一个指针到别的指针的值的 二进制拷贝. 在类型之间指向的内容不做任何类型的检查和转换?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;; </div><div class="line">class B&#123;&#125;; </div><div class="line">A* a = new A;</div><div class="line">B* b = reinterpret_cast(a);</div></pre></td></tr></table></figure></p><p>　　• static_cast: 允许执行任意的隐式转换和相反转换动作（即使它是不允许隐式的）,例如：应用到类 的指针上, 意思是说它允许子类类型的指针转换为父类类型的指针(这是一个有效的隐式转换), 同 时, 也能够执行相反动作: 转换父类为它的子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Base &#123;&#125;; </div><div class="line">class Derive:public Base&#123;&#125;; </div><div class="line">Base* a = new Base; </div><div class="line">Derive *b = static_cast(a);</div></pre></td></tr></table></figure></p><p>　　• dynamic_cast: 只用于对象的指针和引用. 当用于多态类型时，它允许任意的隐式类型转换以及相 反过程. 不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程）,dynamic_cast 会检查操作是否有效. 也就是说, 它会检查转换是否会返回一个被请求的有效的完整对象。检测在 运行时进行. 如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL. 对于引用 类型，会抛出bad_cast异常。<br>　　• const_cast: 这个转换类型操纵传递对象的const属性，或者是设置或者是移除,例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span>&#125;; </div><div class="line"><span class="keyword">const</span> C* a = <span class="keyword">new</span> C; </div><div class="line">C *b = <span class="keyword">const_cast</span>(a);</div></pre></td></tr></table></figure></p><p>21.析构函数中抛出异常时概括性总结<br>　　（1） C++中析构函数的执行不应该抛出异常；<br>　　（2） 假如析构函数中抛出了异常，那么系统将变得非常危险，也许很长时间什么错误也不会发生；但也许系统有时就会莫名奇妙地崩溃而退出了，而且什么迹象也没有；<br>　　（3） 当在某一个析构函数中会有一些可能（哪怕是一点点可能）发生异常时，那么就必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外，即在析构函数内部写出完整的throw…catch()块。</p><h3 id="22-C-11新特性"><a href="#22-C-11新特性" class="headerlink" title="22.C++11新特性"></a>22.C++11新特性</h3><p>　　Lambda、变参模板、auto、decltype、constexpr、智能指针、列表初始化、正则表达式、线程库、静态断言、委托构造。</p><p>　　weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>　　使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</p><p>　　weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr.</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/16/CPP_review_reproduce/#disqus_thread</comments>
    </item>
    
    <item>
      <title>操作系统常见面试题整理</title>
      <link>http://wangwlj.com/2018/03/16/operating_system_review_reproduce/</link>
      <guid>http://wangwlj.com/2018/03/16/operating_system_review_reproduce/</guid>
      <pubDate>Fri, 16 Mar 2018 12:59:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fpeyf3zq50j21m012o1e2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpeyf3zq50j21m012o1e2.jpg" alt=""><br><a id="more"></a></p><p>有那么一些零碎的小知识点，偶尔很迷惑，偶尔被忽略，偶然却发现它们很重要，也是各大笔试和面试高频出现考点。这段时间正好在温习这些，就整理在这里，一起学习一起提高！后面还会继续补充。</p><p>本文转载自一个很不错的博客：<a href="http://www.cnblogs.com/webary/p/4782903.html" target="_blank" rel="external">http://www.cnblogs.com/webary/p/4782903.html</a></p><p>我自己也有整理，不过是思维导图的形式，有机会再一起放出来吧。</p><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><p>　　线程是指进程内的一个执行单元,也是进程内的可调度实体.</p><p>　　与进程的区别:</p><p>　　(1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间(也有少量自己的地址空间);而进程有自己独立的地址空间(多个进程之间一般不会共享地址空间);</p><p>　　(2)资源拥有:进程是资源拥有的单位,同一个进程内的线程共享进程的资源</p><p>　　(3)线程是处理器调度和分派的基本单位.</p><p>　　(4)二者均可并发执行.多线程程序的并发性高。</p><p>　　(5)进程的切换代价远高于线程，同步和通信的实现也比线程复杂。</p><p>　　进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，需要用多线程。</p><h3 id="2-Unix和windows进程间通信的主要方式"><a href="#2-Unix和windows进程间通信的主要方式" class="headerlink" title="2.Unix和windows进程间通信的主要方式"></a>2.Unix和windows进程间通信的主要方式</h3><h4 id="linux系统IPC："><a href="#linux系统IPC：" class="headerlink" title="　　linux系统IPC："></a>　　linux系统IPC：</h4><p>　　<strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>　　<strong>命名管道 (named pipe)</strong> ： 命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>　　<strong>信号量( semophore )</strong>： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>　　<strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>　　<strong>信号 ( sinal )</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>　　<strong>共享内存( shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>　　<strong>套接字( socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><h4 id="windows系统IPC："><a href="#windows系统IPC：" class="headerlink" title="　　windows系统IPC："></a>　　windows系统IPC：</h4><p>　　<strong>剪贴板(Clipboard)</strong>：当用户在应用程序中执行剪切或复制操作时，应用程序将选定的数据以一个或多个标准或应用程序定义的格式放在剪贴板中。</p><p>　　<strong>WM_COPYDATA消息</strong>：当一个应用向另一个应用传送数据时，发送方只需使用调用SendMessage函数， 接收方只需像处理其它消息那样处理WM_COPYDATA消息，这样收发双方就实现了数据共享，它在底层实际上是通过文件映射来实现的。</p><p>　　<strong>文件映射(File Mapping )</strong>：使进程把文件内容当作进程地址区间一块内存那样来对待。只需简单的指针操作就可读取和修改文件的内容。 允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针，通过使用这些指针，不同进程就可以读写文件的内容，实现了对文件中数据的共享。</p><p>　　<strong>共享内存(Shared Memory)</strong>是文件映射的一种特殊情况进程在创建文件映射对象时用0xFFFFFFFF来代替文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。由于共享内存是用 文件映射实现的， 所以它也有较好的安全性，也只能运行于同一计算机上的进程之间。</p><p>　　<strong>动态数据交换(DDE)</strong>：是使用共享内存在应用程序之间进行数据交换的一种进程间通信形式。应用程序可以使用DDE进行一次性数据传输，也可以当出现新数据时， 通过发送更新值在应用程序间动态交换数据。DDE和剪贴板一样既支持标准数据格式(如文本、位图等)，又可以支持自己定义的数据格式。但它们的数据传输机制却不同，一个明显区别是剪贴板操作几乎总是用作对用户指定操作的一次性应答，如从菜单中选择Paste命令。尽管DDE也可以由用户启动，但它继续发挥作用一般不必用户进一步干预。可以发生在单机或网络中不同计算机的应用程序之间。</p><p>　　<strong>邮件槽(Mailslot)</strong>：提供进程间单向通信能力，任何进程都能建立邮件槽成为邮件槽服务器。其它进程称为邮件槽客户，可以通过邮件槽的名字给邮件槽服务器进程发送消息。进来的消息一直放在邮件槽中，直到服务器进程读取它为止。一个进程既可以是邮件槽服务器也可以是邮件槽客户，因此可建立多个 邮件槽实现进程间的双向通信。</p><p>　　<strong>管道( pipe )</strong>：同上linux系统 &amp; 命名管道</p><p>　　<strong>套接字（Sockets  ）</strong>：同上linux系统</p><h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h3><p>　　死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的僵局，若无外力作用，它们都将无法推进下去。</p><p>　　产生死锁的四个<strong>必要条件</strong>：</p><p>　　1.互斥条件：一段时间内某资源只由一个进程占有。<br>　　2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>　　3.不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。<br>　　4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>　　预防死锁：需要打破必要条件的2，3，4中之一，由于施加的限制条件较严格，可能导致系统资源利用率和系统吞吐量降低。</p><p>　　避免死锁：施加的限制条件较弱，使系统一直处于安全状态。比如银行家算法。</p><p>　　检测死锁：资源分配图、死锁定理。</p><p>　　解除死锁：剥夺起源、撤销进程。</p><h3 id="4-windows下什么线程优先级最高"><a href="#4-windows下什么线程优先级最高" class="headerlink" title="4.windows下什么线程优先级最高"></a>4.windows下什么线程优先级最高</h3><p>　　<code>SetThreadPriority</code>  设置指定线程的优先级：</p><p>　　<code>BOOL SetThreadPriority(HANDLE hThread, int nPriority);</code></p><p>　　参数说明：</p><p>　　<code>hThread</code>  要设置的线程句柄<br>　　<code>nPriority</code> 优先级别参数 可设置为一下参数</p><p>　　<code>THREAD_PRIORITY_ABOVE_NORMAL</code>  比一般优先级高一个等级<br>　　<code>THREAD_PRIORITY_BELOW_NORMAL</code> 比一般低一个等级<br>　　<code>THREAD_PRIORITY_HIGHEST</code>               比一般高2个等级（最高）<br>　　<code>THREAD_PRIORITY_IDLE</code>                      空闲<br>　　<code>THREAD_PRIORITY_LOWEST</code>                比一般低2个等级（最低）<br>　　<code>THREAD_PRIORITY_NORMAL</code>                一般等级<br>　　<code>THREAD_PRIORITY_TIME_CRITICAL</code>    实时</p><h3 id="5-linux下fork函数"><a href="#5-linux下fork函数" class="headerlink" title="5.linux下fork函数"></a>5.linux下fork函数</h3><p>　　在<code>fork()</code>的调用处，创建一个子进程，并将整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区等。<code>fork</code>调用仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p><p>　　（1）在父进程中，fork返回新创建子进程的进程ID；<br>　　（2）在子进程中，fork返回0；<br>　　（3）如果出现错误，fork返回一个负值；</p><p>　　在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p><p>　　fork出错可能有两种原因：</p><p>　　1）当前的进程数已经达到了系统规定的上限，这时<code>errno</code>的值被设置为<code>EAGAIN</code>。<br>　　2）系统内存不足，这时<code>errno</code>的值被设置为<code>ENOMEM</code>。</p><p>　　创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</div><div class="line">        <span class="keyword">pid_t</span> fpid = fork();</div><div class="line">        <span class="keyword">if</span>(fpid==<span class="number">0</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"son\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"father\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　对于这种N次循环的情况，执行printf函数的次数为<code>2*（2^N-1）</code>次，创建的子进程数为<code>2^N-1</code>个。输出中没有换行时缓冲区也会被复制，参见：<a href="http://www.oschina.net/question/195301_62902" target="_blank" rel="external">http://www.oschina.net/question/195301_62902</a> </p><h3 id="6-程序什么时候使用多线程好，什么时候单线程效率高"><a href="#6-程序什么时候使用多线程好，什么时候单线程效率高" class="headerlink" title="6.程序什么时候使用多线程好，什么时候单线程效率高"></a>6.程序什么时候使用多线程好，什么时候单线程效率高</h3><p>　　1．耗时的操作使用线程，提高应用程序响应速度<br>　　2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求<br>　　3．多CPU系统中，使用线程提高CPU利用率<br>　　4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。其他情况都使用单线程。</p><h3 id="7-线程间通信"><a href="#7-线程间通信" class="headerlink" title="7.线程间通信"></a>7.线程间通信</h3><p>　　互锁函数、临界段、内核对象（事件对象、互斥对象、信号量）</p><h3 id="8-进程状态转换"><a href="#8-进程状态转换" class="headerlink" title="8.进程状态转换"></a>8.进程状态转换</h3><p>　　在操作系统中，进程一般有三种基本状态：运行状态，就绪状态和等待状态。</p><p>　　1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p><p>　　2）执行——等待：正在执行的进程因发生某等待事件而无法执行，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； </p><p>　　3）等待——就绪：处于等待状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p><p>　　4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p><h3 id="9-内存地址：虚拟地址-线性地址-物理地址的区别与联系"><a href="#9-内存地址：虚拟地址-线性地址-物理地址的区别与联系" class="headerlink" title="9.内存地址：虚拟地址-线性地址-物理地址的区别与联系"></a>9.内存地址：虚拟地址-线性地址-物理地址的区别与联系</h3><p>　　<code>x86</code>平台下的系统采用分段机制与分页机制对地址进行转换，其中分段机制把一个虚拟地址转换成线性地址；分页机制把一个线性地址转换成物理地址。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>《计算机操作系统（第三版）》，西安电子科技大学出版社，汤小丹等</p><p><a href="http://blog.csdn.net/jason314/article/details/5640969" target="_blank" rel="external">linux中fork（）函数详解（原创！！实例讲解）</a></p><p><a href="http://www.oschina.net/question/195301_62902" target="_blank" rel="external">一个fork的面试题</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/16/operating_system_review_reproduce/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：旋转数组的最小数字</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/</guid>
      <pubDate>Tue, 06 Mar 2018 11:57:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3d1c9f1wj22bc1jke81.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3d1c9f1wj22bc1jke81.jpg" alt=""><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个非递减排序的数组(如{1,2,3,4,5})的一个旋转(如{3,4,5,1,2})，输出旋转数组的最小元素。 </p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>简而言之，输入的是旋转后的数组，输出数组的最小数字。</p><p>最简单的方法当然是从头到尾查找一遍就知道最小数字了，复杂度为$O(n)$，不过这并不是能让面试官满意的答案。</p><p>需要结合旋转数组的特性来分析。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道二分查找的变形的题目。</p><p>旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素</p><p>注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。</p><p>思路：</p><p>（1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。</p><p>但是如果不是旋转，第一个元素肯定小于最后一个元素。</p><p>（2）找到数组的中间元素。</p><p>中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。</p><p>移动之后，第一个指针仍然位于前面的递增数组中。</p><p>中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。</p><p>移动之后，第二个指针仍然位于后面的递增数组中。</p><p>这样可以缩小寻找的范围。</p><p>（3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。</p><p>最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。</p><p>也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。</p><p>此时的解法答案如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(<span class="number">0</span> == size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = size - <span class="number">1</span>, mid;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>((high - low) &gt; <span class="number">1</span>) &#123;</div><div class="line">            mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[<span class="number">0</span>]) <span class="comment">//位于左半递增数组上</span></div><div class="line">                low = mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[size - <span class="number">1</span>]) &#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> rotateArray[high];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>到目前为止以上思路很好的解决了没有重复数字的情况，这一道题目添加上了这一要求，<strong>有了重复数字</strong>。</p><p>因此这一道题目比上一道题目多了些特殊情况：</p><p>我们看一组例子：<code>｛1，0，1，1，1｝</code> 和 <code>｛1，1， 1，0，1｝</code> 都可以看成是递增排序数组<code>｛0，1，1，1，1｝</code>的旋转。</p><p>这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。</p><p>第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。</p><p>因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。</p><p>也就无法移动指针来缩小查找的范围。</p><p>因此只能按照正常的顺序来遍历查找最小的元素。</p><p>再次放上最终版本的代码。基本上考虑了所有的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = rotateArray.size();</div><div class="line"><span class="keyword">int</span> min = <span class="number">0x7fffffff</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = rotateArray.begin(); i != rotateArray.end(); ++i) &#123;</div><div class="line"><span class="keyword">if</span>(min &gt; *i) &#123;</div><div class="line">min = *i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(<span class="number">0</span> == size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = size - <span class="number">1</span>, mid;</div><div class="line">        <span class="keyword">if</span>(rotateArray[low] &lt; rotateArray[high]) &#123; <span class="comment">//翻转了0个或者翻转全部</span></div><div class="line">            <span class="keyword">return</span> rotateArray[low];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>((high - low) &gt; <span class="number">1</span>) &#123;</div><div class="line">            mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</div><div class="line"><span class="keyword">if</span>(rotateArray[mid] == rotateArray[<span class="number">0</span>] &amp;&amp; rotateArray[mid] == rotateArray[size - <span class="number">1</span>]) <span class="comment">//三个数字都相同，这一种情况比较特殊。</span></div><div class="line">                <span class="keyword">return</span> MinInOrder(rotateArray);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[<span class="number">0</span>]) <span class="comment">//位于左半递增数组上</span></div><div class="line">                low = mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt;= rotateArray[size - <span class="number">1</span>]) &#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> rotateArray[high];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Solution *s = <span class="keyword">new</span> Solution();</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：斐波那契数列</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/</guid>
      <pubDate>Tue, 06 Mar 2018 11:57:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp4ae6zmdtj22gg2gkkj7.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp4ae6zmdtj22gg2gkkj7.jpg" alt=""><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p><p>题目链接：<a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>给出解法，详细分析见后面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">            方法一：时间花费950ms，接近一秒了。。。</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        <span class="comment">//if(n &lt;= 0 )</span></div><div class="line">        <span class="comment">//    return 0;</span></div><div class="line">        <span class="comment">//else if (n == 1)</span></div><div class="line">        <span class="comment">//    return 1;</span></div><div class="line">        <span class="comment">//return Fibonacci(n - 1) + Fibonacci(n -2);</span></div><div class="line">        </div><div class="line">        <span class="comment">//方法二：</span></div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span> )</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> ans_i = <span class="number">0</span>, ans_i_1 = <span class="number">1</span>, ans_i_2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(n &gt;= i)&#123;</div><div class="line">            ans_i = ans_i_1 + ans_i_2;</div><div class="line">            ans_i_2 = ans_i_1;</div><div class="line">            ans_i_1 = ans_i;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans_i;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这个题可以说是迭代（Iteration） VS 递归（Recursion），<br>f(n) = f(n-1) + f(n-2)，第一眼看就是递归啊，简直完美的递归环境，递归肯定很爽，这样想着关键代码两三行就搞定了，注意这题的n是从0开始的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</div></pre></td></tr></table></figure></p><p>然而并没有什么用，测试用例里肯定准备着一个超大的n来让Stack Overflow，为什么会溢出？因为重复计算，而且重复的情况还很严重，举个小点的例子，n=4，看看程序怎么跑的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Fibonacci(<span class="number">4</span>) = Fibonacci(<span class="number">3</span>) + Fibonacci(<span class="number">2</span>);</div><div class="line">             = Fibonacci(<span class="number">2</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>);</div><div class="line">             = Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。</p><p>那么如何求解呢，动态规划似乎不错，关于动态规划三个条件：最优子结构、无后效性、子问题重叠这些就不谈了，因为理(wo)论(ye)性(bu)太(tai)强(dong)了。</p><p>下例是一个简单的动态规划，以一定的空间代价避免代价更大的重复计算的栈空间浪费：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">record[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">record[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</div><div class="line">    record[i] = record[i<span class="number">-1</span>] + record[i<span class="number">-2</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> record[n];</div></pre></td></tr></table></figure></p><p>虽然看起来很蠢，空间浪费了<code>sizeof(int)*(n-1)</code>，但是对于那个超大n的测试用例应该是可以通过了，时间复杂度也达到了O(n)。<br>那能不能把“优雅”的递归和动态规划结合起来呢？递归的优点在于便于理解和编码，而重复计算的关键原因在于代码里直接就“递”进去然后等着“归”了，所以避免重复的关键在于对子问题是否已经得出解的判断，即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] record = null;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(null == record)&#123;</div><div class="line">        record = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="number">0</span>!=record[n<span class="number">-2</span>] &amp;&amp; <span class="number">0</span>!=record[n<span class="number">-1</span>])&#123;</div><div class="line">        record[n] = record[n<span class="number">-2</span>] + record[n<span class="number">-1</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-2</span>) + Fibonacci(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
